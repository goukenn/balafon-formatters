{"version":3,"file":"bformatter/1.0.52/bformatter.umd.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAoB,WAAID,IAExBD,EAAiB,WAAIC,GACtB,CATD,CASGK,MAAM,I,4BCTT,IAAIC,EAAM,CACT,yCAA0C,KAC1C,wCAAyC,KACzC,yBAA0B,KAC1B,gCAAiC,KACjC,0BAA2B,IAC3B,0BAA2B,IAC3B,2BAA4B,KAC5B,kCAAmC,KACnC,6BAA8B,IAC9B,4BAA6B,KAC7B,6BAA8B,KAC9B,gCAAiC,KACjC,uBAAwB,KACxB,6BAA8B,IAC9B,2BAA4B,KAC5B,yBAA0B,IAC1B,wBAAyB,KACzB,2BAA4B,IAC5B,6BAA8B,MAI/B,SAASC,EAAeC,GACvB,IAAIC,EAAKC,EAAsBF,GAC/B,OAAOG,EAAoBF,EAC5B,CACA,SAASC,EAAsBF,GAC9B,IAAIG,EAAoBC,EAAEN,EAAKE,GAAM,CACpC,IAAIK,EAAI,IAAIC,MAAM,uBAAyBN,EAAM,KAEjD,MADAK,EAAEE,KAAO,mBACHF,CACP,CACA,OAAOP,EAAIE,EACZ,CACAD,EAAeS,KAAO,WACrB,OAAOC,OAAOD,KAAKV,EACpB,EACAC,EAAeW,QAAUR,EACzBR,EAAOD,QAAUM,EACjBA,EAAeE,GAAK,I,eCvCpBQ,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAapDnB,EAAQoB,UAPR,MAIIC,K,8BCVJL,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IACpD,MAAM,MAAEG,GAAU,EAAQ,MAqG1BtB,EAAQuB,YApGR,MAKIC,KAKAC,QAKAC,SAMAC,UAIAC,QAIAC,YAMAC,mBAKAC,SAMAC,OAMAC,WAEA,WAAAC,CAAYC,GAERnB,OAAOE,eAAekB,KAAM,SAAU,CAACC,IAAG,IAAUF,GACxD,CAEA,UAAAG,CAAWC,EAAQC,EAAWC,EAAMC,EAAQC,GACxC,MAAMC,EAAIR,MACJ,SAAES,EAAQ,YAAEC,GAAgBxB,EAAMyB,QAClCrB,EAAWJ,EAAM0B,wBAAwBT,EAAQM,EAAUC,GAE3DG,EAAiBC,GACZ5B,EAAM6B,WAAWD,EAAG,KAGzBE,EAAQ,CACV,QAAA1B,CAAS2B,EAAEd,EAAQG,EAAQC,GACvB,IAAIW,EAAI5B,EAAS6B,MAAMX,EAAG,CAACS,EAAEd,EAAQG,EAAQC,IAK7C,OAJAW,EAAEE,SAASN,IAEPA,EAAEf,OAASS,EAAET,MAAM,IAEhBmB,CACX,EACAG,MAAOR,EACPS,IAAKT,EACLU,MAAOV,EACPpB,YAAaoB,EACb,oBAAAW,CAAqBP,EAAGd,GACpB,IAAIsB,EAAI,IAAIC,qBAEZ,OADAC,WAAWC,UAAUzB,EAAQsB,EAAGR,EAAGV,GAC5BkB,CACX,EACAlC,UAvBcL,EAAM2C,4BAwBpBlC,SApBaT,EAAM4C,qBAAqBtB,GAqBxC,cAAAuB,GACI,MAAM,IAAItD,MAAM,8BACpB,GAEJ,IAAIuD,EAAKhB,EAAMZ,GACf,OAAI4B,EACOA,EAAGb,MAAMX,EAAG,CAACH,EAAMF,EAAQG,EAAQC,IAEvCF,CACX,E,8BCnGJzB,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAEpD,MAAM,wBAAEkD,GAA4B,EAAQ,OACtC,iBAAEC,GAAqB,EAAQ,OAC/B,yBAAEC,GAA6B,EAAQ,OACvC,MAAEjD,GAAU,EAAQ,MAC1B,MAAMkD,EACFC,QACAC,MACAC,YACAC,MAOA,sBAAOC,CAAgBJ,EAASG,EAAM,YAqFlC,MAAME,EApFN,SAA+BL,EAASG,EAAM,YAC1C,IAAKH,EACD,MAAM,IAAI5D,MAAM,mBAEpB,IAAIkE,EAAKN,EAAQ,GACjB,GAAIA,EAAQO,OAAO,EACf,MAAO,CAAC7D,MAAM4D,EAAIH,MAAOA,GAE7B,MAAM,QAACK,GAAWR,EAClB,QAAuB,IAAb,EAEN,OADAS,QAAQC,IAAI,oBACL,KAEX,IAsBIC,EACAC,EAvBAC,EAAcL,EAAQ,GAAG,GACzBM,EAAY,CAAC,EACbZ,EAAc,CAAC,EACfa,EAAS,KACTC,EAAU,EACVX,EAAQ,KACRY,EAAa,SAASF,EAAQG,GAC9BhB,EAAYgB,GAAKH,EACjBD,EAAUI,GAAKH,CACnB,EACII,EAAa,SAASC,EAAKC,EAAGT,EAAOM,GACrCF,EAAUI,EAAIC,EAAEd,OAChBQ,EAASO,EAASV,EAAOS,EAAG,KAAMH,GAClCD,EAAWF,EAAQG,GACnBb,EAAQ,IACZ,EACIkB,EAAgB,SAAU9C,EAAGI,GAC7B,OAASJ,EAAE+C,OAAO3C,EAAE2C,OAAS/C,EAAEQ,KAAKJ,EAAEI,GAC1C,EACIqC,EAAW,SAASV,EAAOS,EAAG3D,EAAQ3B,GACtC,MAAO,IAAI6E,EAAOlE,MAAM2E,EAAEtF,KAAI,SAAI0F,GAAS,OAAO9D,KAAK6D,MAAQxB,EAAQyB,KAAO,EAAG/D,OAAQA,EAAQgE,OAAO,GAC5G,EAIA,IAAI,IAAIR,EAAI,EAAGA,EAAIlB,EAAQO,OAAQW,IAAI,CAEnC,GADAP,EAAKH,EAAQU,QACG,IAAN,EAAkB,CACxBhB,EAAYgB,GAAK,CAACxE,WAAOiF,GACzB,QACJ,CACA,IAAIN,EAAIrB,EAAQkB,GAChBN,EAAQ,CAACY,MAAMb,EAAG,GAAKE,EAAY5B,IAAI0B,EAAG,GAAKE,GAC/C,IAAIO,EAAMd,EAAGsB,QAAQP,EAAGL,GACxB,GAAY,MAARD,EAEAI,EAAWC,EAAIC,EAAGT,EAAOM,QAIzB,GAAIH,EAAOS,OAASZ,EAAMY,OAAWT,EAAO9B,KAAK2B,EAAM3B,IAGnDiB,EAAYgB,GAAKH,OAEjB,GAAKA,EAAOS,OAAQZ,EAAMY,OAAWT,EAAO9B,KAAK2B,EAAM3B,IAAK,CACxD,GAAIoB,GAASkB,EAAclB,EAAOO,GAAO,CAErC,IAAIiB,EAASP,EAASV,EAAOS,EAAGhB,EAAOa,GACvCb,EAAQwB,CACZ,MACIxB,EAAQiB,EAASV,EAAOS,EAAGN,EAAQG,GACnCH,EAAOW,OAAOI,KAAKzB,GAGvBH,EAAYgB,GAAKb,CACrB,MAEIc,EAAWC,EAAIC,EAAGT,EAAOM,EAIzC,CAOA,OALIZ,EAAGC,OAAO,IACVI,EAAKH,EAAQ,GACbI,EAAQ,CAACY,MAAMb,EAAG,GAAKE,EAAY5B,IAAI0B,EAAG,GAAKE,GAC/CI,EAAYK,EAASV,EAAOZ,EAAQ,GAAI,KAAM,GAAI,IAE/C,CAACA,UAASC,MAAOa,EAAWZ,YAAaA,EACpD,CACc6B,CAAsB/B,EAASG,GAC7C,IAAIE,EACA,OAAO,KAEX,MAAM,MAAEJ,EAAM,YAAEC,GAAgBG,EAChC,IAAI2B,EAAK,IAAIjC,EAKb,OAJAiC,EAAG/B,MAAQA,EACX+B,EAAGhC,QAAUK,EAAML,QACnBgC,EAAG9B,YAAcA,EACjB8B,EAAG7B,MAAQA,EACJ6B,CACX,CAWA,MAAAC,CAAOC,EAAU5E,EAAU2B,EAAKkD,EAAQC,EAAQC,EAAWC,GAAM,GAC7D,IAAKhF,EACD,MAAM,IAAIlB,MAAM,yBAEpB,IAAKiG,EACD,MAAM,IAAIjG,MAAM,0BAEpB,MAAMT,EAAOgC,MACP,QAAEqC,EAAO,MAAEC,GAAUtE,GACrB,MAAE4G,EAAK,OAAEC,GAAUJ,EACzB,IAAIK,EAASzC,EAAQ,GACjB0C,EAAS,EACTC,EAAU,GACVC,EAAaR,EAAOS,UACpBC,EAAa,SAAUL,EAAQpH,EAAM6G,EAAU5E,EAAU6E,EAAQY,GAEjE,IAAIC,EAAK3H,EAAKqB,MACVuG,EAAKD,EACLE,EAAY,CAAC,CAAC7H,OAAM8H,OAAO,GAAIb,OAAM,EAAOc,KAAI,IAChDC,GAAO,EACX,KAAMH,EAAU3C,OAAO,GAAE,CACrB,IAAIpC,EAAI+E,EAAUI,SACd,GAACvH,GAAKoC,EAAE9C,KACZ,IAAI8C,EAAEmE,MAIN,GADAe,GAAO,GACFlF,EAAEiF,KAAOjF,EAAE9C,KAAKqG,OAAOnB,OAAO,EAAE,CACjC,MAAMgD,EAAYpF,EAAE9C,KAAKqG,OAAO8B,MAAM,GAGtC,IAFArF,EAAEiF,KAAM,EACRF,EAAUO,QAAQtF,GACZoF,EAAUhD,OAAO,GAAE,CACrB,IAAImD,EAAQH,EAAUI,MACtBT,EAAUO,QAAQ,CAAC/F,OAAQS,EAAGmE,OAAM,EAAOjH,KAAMqI,EAAON,KAAI,GAChE,CACJ,KAAK,CACDJ,EAAK7E,EAAEiF,IAAMjF,EAAEgF,OAAShF,EAAE9C,KAAKqB,MAC/ByF,EAASA,EAASA,EAAOqB,MAAM,GAAK,GACpC,IAAIxG,EAAU,KACV4G,EAAM,KAEV,GAAIC,MAAMC,QAAQd,GAAI,CAElB,MAAMe,EAAK5F,EAAE9C,KAAKqB,MAClB,IAAIsH,EAAS,EACTC,EAAO,GACPC,EAAI,GAERlB,EAAGjE,SAAQN,IAEPyF,EAAIH,EAAGI,UAAUH,EAAQvF,EAAEmC,MAAM,IACjC,IAAIwD,EAAKF,EAAEzF,EAAEuE,GACbgB,EAASvF,EAAEmC,MAAM,GAAGnC,EAAEmC,MAAM,GAC5BqD,GAAOG,CAAE,IAGbH,GAAOF,EAAGI,UAAUH,GACpBhB,EAAKiB,CACT,CACA,IAAII,GAAiB,EACrB,MAAMC,EAAM1E,EAAwB2E,KAAKvB,GACzC,GAAIjH,KAAMuB,EAAS,CAEf,GADAsG,EAAMtG,EAASvB,GACX6H,EAAIpG,WAAW,CAEf,IAAIgH,EAAQzE,EAAgB0E,WAAWb,EAAIpG,WAAYwF,EAAIZ,GAC3D,GAAIoC,EACA,MAAMA,CAEd,CAQA,GAPIZ,EAAI7G,MACJF,EAAM6H,YAAYd,EAAI7G,KAAMoF,GAE5ByB,EAAI5G,UACJA,EAAU4G,EAAI5G,SAGdiC,EAEAgE,EAAKD,EACLA,EAAK/D,EAAI+D,EAAIY,EAAK7H,EAAImG,EAAU,CAACC,SAAQK,SAAQD,QAAOvF,YACxDqG,GAAO,OAWP,GARGT,EACCI,EAAKJ,EAAW+B,iBAAiBf,EAAKZ,EAAIsB,EAAKlC,EAAQzG,EAAKqE,SAGxD4D,EAAI1G,YACJ8F,EAAKnG,EAAM+H,qBAAqB5B,EAAIY,EAAI1G,YAG5C0G,EAAI3G,UAAUsD,OAAO,EAAE,CACvB,MAAMsE,EAAazC,EAAO0C,UAAUtB,MAAM,GAC1CpB,EAAO0C,UAAY3C,EAAOqB,MAAM,EAAGrB,EAAO5B,OAAO,GACjDyC,EAAKnG,EAAMkI,kBAAkB/B,EAAIY,EAAI3G,SACjCtB,EAAKqE,QAASoC,GAClBiC,GAAiB,EAEjBjC,EAAO0C,UAAYD,CACvB,CAER,CAMA,GALI3C,IAAamC,GAAkBnC,EAAS8C,cAExC/B,EAAKD,EACLA,EAAKK,IAASL,EAAKA,EAAKA,EAAGzC,OAAO,EAAG2B,EAAS8C,YAAYhC,EAAIb,EAAQnF,EAASwF,EAAQD,EAAOqB,EAAKxB,GAAU,IAE7GjE,EAAET,OAAO,CAET,IAAIe,EAAKN,EAAE9C,KAAKmG,MAAQrD,EAAET,OAAOrC,KAAKmG,MAClCrF,EAAKgC,EAAE9C,KAAK4D,IAAMd,EAAE9C,KAAKmG,MAEzBwB,EAAGzC,OAAO,GACVpC,EAAET,OAAOyF,OAAOrB,KAAK,CAAClB,MAAM,CAACnC,EAAEtC,GAAI6G,KAAIC,MAE/C,CACA9E,EAAEmE,OAAQ,CACd,CACJ,CAEA,OADAS,EAAQ/E,KAAOiF,EACRD,CACX,EACIiC,EAAiB,SAASf,EAAGhC,GAM7B,OALII,GAAU4B,EAAE3D,OAAO,GACf2B,IACAgC,EAAIhC,EAAS8C,YAAYd,EAAG,CAAC,uBAAwB,WAAY1B,EAAQD,EAAO,KAAMH,IAGvF8B,CACX,EACIA,EAAI,GACJrF,EAAI,GACJqG,EAAQ3I,OAAOD,KAAK2D,GACpBkF,EAAW5I,OAAOD,KAAKgB,GACvB8H,EAAe,KAAK9H,GAA+B,GAAjB6H,EAAS5E,OAC3C8E,EAAY,CAACrH,KAAK,KAAMsH,MAAM7C,EAAQ8C,cAAc,GAAGC,YAAY,IACvE,IAAI,IAAIC,KAAKxF,EAAM,CACf,IAAMmF,GAAmB,GAAHK,GAAQP,EAAM3E,OAAO,EACvC,SAEJ,IAAImF,EAAKzF,EAAMwF,GAgBf,GAdAvB,EAAIzB,EAAO0B,UAAUzB,EAAQgD,EAAGlE,OAC5B0C,EAAE3D,OAAO,IACT1B,GAAKqF,EACLmB,EAAUG,YAAY1D,KAAKoC,GAC3BA,EAAIe,EAAef,EAAGhC,GACtBS,GAAWuB,EACXmB,EAAUE,cAAczD,KAAKoC,IAEjCA,EAAIpB,EAAWL,EAAQiD,EAAGxD,EAAS5E,EAAS6E,EAAOkD,GACnD1C,GAAWuB,EACXxB,EAASgD,EAAGzG,IACZJ,GAAGwG,EAAUrH,KACbqH,EAAUG,YAAY1D,KAAKuD,EAAUrH,MACrCqH,EAAUE,cAAczD,KAAKoC,GACzBkB,EACA,KACR,CACA,GAAI1C,EAASD,EAAOlC,OAAO,CACvB,IAAIoF,EAAIlD,EAAO0B,UAAUzB,GACzB7D,GAAI8G,EACJN,EAAUG,YAAY1D,KAAK6D,GAC3BzB,EAAIe,EAAeU,EAAGzD,GACtBS,GAAWuB,EACXmB,EAAUE,cAAczD,KAAKoC,EACjC,CAKA,OAJI7B,IACAA,EAAUkD,cAAgBF,EAAUE,cACpClD,EAAUmD,YAAcH,EAAUG,aAE/B7C,CACX,CAQA,iBAAO8B,CAAWmB,EAAO5C,EAAIZ,GACzB,IAAIoC,EAAQ,KACRqB,EAAU,KAAO3G,EAAQ,KACzB4G,GAAS,EAab,MAZqB,iBAAX,IACJD,UAAS3G,SAAS0G,GAEpBC,EAAUD,EAEV1G,IAEA4G,GAD6B,iBAAT,EAAmB,IAAIC,OAAO7G,GAASA,GAC5C8G,KAAKhD,IAEpB8C,IACAtB,EAAO,IAAI1E,EAAyB+F,EAASzD,IAE1CoC,CACX,EAEJjJ,EAAQwE,gBAAkBA,C,4BCpU1BxD,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAGpD,MAAMuJ,EACFC,gBAAkB,EAClBA,UAAkB,EAElB,oBAAWC,GACP,OAAOF,GAAM,CACjB,CACA,UAAOvF,CAAI0F,EAAKC,GACZ,GAAIA,GACIA,EAAQJ,EAAMK,SACd,OAGS,iBAAP,IACNF,EAAMG,KAAKC,UAAUJ,GAAK,CAACK,EAAGpF,IACZ,GAAVoF,EAAElG,OACKc,EAEI,iBAAL,EACC,CAAC,EAEG,gBAAL,EACC,GAEJA,KAGf,IAAIqF,EAAO,GACX,GAAIC,UACA,IAAI,IAAIzF,EAAI,EAAGA,EAAIyF,UAAUpG,OAAQW,IACjCwF,EAAK5E,KAAK6E,UAAUzF,IAG5BT,QAAQC,IAAI,sBAAiB0F,OAAUM,EAC3C,CAKA,aAAOE,CAAOC,GACVZ,GAAM,EAAWY,CACrB,EAGJtL,EAAQ0K,MAAQA,C,8BC/ChB1J,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,iBAAEmD,GAAqB,EAAQ,OAC/B,MAAEhD,GAAU,EAAQ,MA+D1BtB,EAAQuL,MA5DR,MACI,cAAAC,CAAeC,EAAQtK,GACnB,OAAkD,GAHtC,iBAGOuK,MAAM,KAAKrF,QAAQoF,EAC1C,CASA,iBAAAE,CAAkBF,EAAQtK,EAAOyK,EAAQ/E,EAAQ9E,GAC7C,IAAI8J,EAAS1K,EACT2K,EAAYD,EAAO5B,YAAY7B,MAC/B2D,EAAcF,EAAO7B,cAAc5B,MACnC4D,EAAcC,IACdJ,EAAO5B,YAAY1D,KAAK0F,EAAIxJ,MAC5BoJ,EAAO7B,cAAczD,KAAK0F,EAAIC,OAAO,EAGrCC,EAAYpK,GAAY6J,EAAOQ,aAAeR,EAAO7J,SACrDsK,EAAa,QAAQ5B,KAAKqB,IAAc,KAAKrB,KAAKqB,GAClDQ,EAAa,KAAOb,EAAS,IAC7Bc,EAAkBnK,KAAKoJ,eAAeC,EAAQtK,GAKlD,GAJIoL,IACAD,EAAa,MAEjBN,EAAW,CAAEE,OAAQH,EAAatJ,KAAMqJ,IACpCA,GAAaQ,EAAY,CACzB,IAAIE,EAAKlL,EAAMmL,eAAeH,GAC1BI,EAAK7F,EAAO8F,iBAAiBf,EAAQY,EAAIL,GAS7C,GANKE,GACIE,GAEDP,EADa1K,EAAMsL,eAAe,IAAKhB,EAAQO,EAAWtF,IAI7D+E,EAAOzF,OAAOnB,OAAS,GAAM5C,KAAKyK,cAAcjB,EAAOzF,QAAS,CACjEU,EAAOiG,aACPjG,EAAOkG,oBACPlG,EAAOkG,oBACP,IAAIvF,EAAU,CAAC,EACf,MAAMwF,EAAWnG,EAAOoG,OAAM,EAAMzF,GACpCX,EAAOqG,qBACPlB,EAAW,CAAEE,OAAQc,EAAUvK,KAAM+E,EAAQ/E,MACjD,MACIuJ,EAAW,CAAEE,OAAQQ,EAAIjK,KAAM6J,GAEvC,CACA,OAAOnL,EAAM6I,cAAcmD,KAAK,GACpC,CACA,aAAAN,CAAc1G,GACV,MAAM,WAAEiH,GAAe9L,EAAMyB,QAC7B,OAAOqK,EAAWC,aAAalH,EACnC,E,8BC/DJnF,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,MAAEoK,GAAW,EAAQ,MAErB+B,EAAU,CACZ/B,SAGJvL,EAAQsN,QAAUA,C,6BCLlBtM,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,IAAIoM,EAAS,KAYb,MAAMC,EACF7C,cAAe,EAIfnK,GACA,WAAA0B,GACI,IAAIuL,EAAW,GACXC,EAAmB,GACnBC,EAAiB,GACjBC,EAAe,GAEnBF,EAAiBG,OAASL,EAAgBM,oBAI1C9M,OAAOE,eAAekB,KAAM,iBAAkB,CAAEC,IAAG,IAAYqL,IAC/D1M,OAAOE,eAAekB,KAAM,eAAgB,CAAEC,IAAG,IAAYsL,IAC7D3M,OAAOE,eAAekB,KAAM,SAAU,CAAEC,IAAG,IAAYoL,IACvDzM,OAAOE,eAAekB,KAAM,aAAc,CAAEC,IAAG,IAAYuL,IAC3D5M,OAAOE,eAAekB,KAAM,SAAU,CAAEC,IAAG,IAAYqL,EAAiB1I,QAE5E,CACA,WAAI+I,GACA,OAAqC,GAA9B3L,KAAK4L,eAAehJ,MAC/B,CAEA,8BAAOiJ,CAAwBjE,GACvBA,KAAmB,WAAYA,KAC/BA,EAAc6D,OAASL,EAAgBM,oBAE/C,CAEA,wBAAOI,CAAkBlE,GACrB,OAAOA,EAAc6D,OAAS,CAAEM,IAC5B,IAAIN,EAASM,EAAElG,MAAM,GAKrB,OAHI4F,EAAOO,GADR,OAAQD,EACKnD,KAAK5H,MAAM4H,KAAKC,UAAUkD,EAAEC,KAE5BZ,EAAgBa,sBACzBR,CACV,EAP6B,CAO3B7D,EAAc6D,QACbL,EAAgBM,mBACxB,CAMA,OAAAQ,CAAQnN,GACJ,IAAI+K,EAAS,KACTzJ,EAAO,KACX,GAAmB,iBAAT,GAEN,KADEyJ,SAAQzJ,QAAOtB,IACZ+K,IAAWzJ,EACZ,MAAM,IAAI5B,MAAM,oBAEjB,CACH,GAAmB,iBAAT,EAIN,MAAM,IAAIA,MAAM,qBAHpBqL,EAASzJ,EAAOtB,CAIpB,CACAiB,KAAK4L,eAAe9F,QAAQgE,GAC5B9J,KAAKmM,aAAarG,QAAQzF,EAC9B,CAOA,UAAA+L,CAAW/F,EAAQ0E,EAAO,IACtB,OAAO/K,KAAK4L,eAAe/F,MAAMQ,GAAQ0E,KAAKA,GAAQ,GAC1D,CAOA,OAAAsB,CAAQhG,EAAQ0E,EAAO,IACnB,OAAO/K,KAAKmM,aAAatG,MAAMQ,GAAQ0E,KAAKA,GAAQ,GACxD,CAKA,UAAIjB,GACA,OAAO9J,KAAK4L,eAAeb,KAAK,GACpC,CAKA,QAAI1K,GACA,OAAOL,KAAKmM,aAAapB,KAAK,GAClC,CAMA,IAAAA,CAAKA,GAED,OAAO/K,KAAK4L,eAAeb,KAAKA,GAAQ,GAC5C,CAIA,YAAAuB,CAAavB,EAAO,IAChB,MAAM,eAAEa,EAAc,aAAEO,GAAiBnM,KACzC,OAAOoL,EAAgBmB,aAAaX,EAAgBO,EACvD,CAQD,mBAAOI,CAAaX,EAAgBO,EAAcpB,EAAO,IACrD,IACIyB,EAAW,GACXC,EAAS,GACb,GAAIb,EAAeH,OAAQ,CACvB,MAAMjL,EAAIoL,EAAeH,OACzBjL,EAAEkM,OACF,MAAMC,EAAMnM,EAAEwL,IAAM,CAAC,EACrB,IAAIY,EAAQ,CAACC,EAAKrM,EAAGiL,KACjB,IAAIlF,EAAI,EACJuG,EAAI,GACR,MAAMN,EAAW,GACXO,EAAU3B,EAAgBM,oBA2BhC,OA1BAmB,EAAIzL,SAAQ2K,IACR,GAAKvL,EAAEoC,OAAS,GAAOpC,EAAE,IAAM+F,EAAI,CAC3BuG,EAAElK,OAAS,IACX4J,EAASrI,KAAK2I,EAAE/B,KAAKA,IACrB+B,EAAElK,OAAS,GAEf4J,EAASrI,KAAK4H,GACdvL,EAAEmF,QACF,IAAIqH,EAAOR,EAAS5J,OAAS,EACzB2D,KAAKoG,GAELzN,EAAM+N,6BAA6BF,EAASC,EAAML,EAAIpG,IAE1DwG,EAAQ5I,KAAK6I,EACjB,MACIF,EAAE3I,KAAK4H,GAEXxF,GAAG,IAEHuG,EAAElK,OAAS,IACX4J,EAASrI,KAAK2I,EAAE/B,KAAKA,IACrB+B,EAAElK,OAAS,GAEX6I,IACAe,EAASf,OAASsB,GAEfP,CAAQ,EAGnBA,EAAWI,EAAMhB,EAAgBpL,EAAEqF,MAAM,IAAI,GAC7C4G,EAASG,EAAMT,EAAc3L,EAAEqF,MAAM,GAEzC,MACI2G,EAASrI,KAAKyH,EAAeb,KAAKA,IAClC0B,EAAOtI,KAAKgI,EAAapB,KAAKA,IAElC,MAAO,CAAEnD,cAAe4E,EAAU3E,YAAa4E,EACnD,CAKA,wBAAOf,GACH,MAAMwB,EAAK,GAEX,OADA9B,EAAgBa,oBAAoBiB,GAC7BA,CACX,CACA,0BAAOjB,CAAoB/K,GACvBA,EAAE8K,GAAK,CAAC,CACZ,CAKA,cAAAmB,CAAezJ,GACX,GAAkB,iBAAP,EACP1D,KAAK4L,eAAezH,KAAKT,GACzB1D,KAAKoN,aAAa1J,OACf,CACH,MAAM,OAAEoG,EAAM,KAAEzJ,EAAI,OAAEoL,EAAM,aAAEU,EAAY,eAAEP,GAAmBlI,EAC/D,GAAIyI,GAAgBP,EAChB5L,KAAKqN,UAAU,CAAEzF,cAAegE,EAAgB/D,YAAasE,SAM7D,GAFAnM,KAAK4L,eAAezH,KAAK2F,GACzB9J,KAAKoN,aAAa/M,GACdoL,EAAQ,CACF,WAAYzL,KAAK4L,iBACnB5L,KAAK4L,eAAeH,OAASL,EAAgBM,qBAEjD,MAAMsB,EAAOhN,KAAK4L,eAAehJ,OAAS,EAC1C5C,KAAK4L,eAAeH,OAAOtH,KAAK6I,GACT,iBAAZ,IACD,OAAQhN,KAAK4L,eAAeH,QAC9BL,EAAgBa,oBAAoBjM,KAAK4L,eAAeH,QAE5DvM,EAAM+N,6BAA8BjN,KAAK4L,eAAeH,OAAQuB,EAAMvB,GAG9E,CAER,CACJ,CAKA,YAAA2B,CAAa1J,GACT1D,KAAKmM,aAAahI,KAAKT,EAC3B,CAMA,aAAA4J,CAAcxD,GAAQ,iBAAEyD,IACpB,GAAuB,iBAAZ,EACHA,GAAqBzD,GAAUyD,EAAiB3F,cAAcmD,KAAK,IACnE/K,KAAKmN,eAAe,CAAErD,SAAQzJ,KAAMkN,EAAiB1F,YAAYkD,KAAK,MAItE/K,KAAKmN,eAAerD,OAErB,CACH,MAAM,QAAE0D,EAAO,MAAEC,GAAU3D,EAC3B,IAAK2D,GAAO7F,cAGR,YADA5H,KAAKmN,eAAeK,GAKxB,GAAIA,GADKC,EAAM7F,cAAcmD,KAAK,IAI9B,YADA/K,KAAKmN,eAAe,CAAErD,OAAO0D,EAASnN,KAAM,UAIhDL,KAAKqN,UAAUI,EAEnB,CACJ,CACA,oBAAOC,EAAc,YAAC7F,EAAW,cAAED,IAC/BC,EAAYjF,OAAS,EACrBgF,EAAchF,OAAS,EACnB,WAAYgF,IACZA,EAAc6D,OAAO7I,OAAS,EAC9BwI,EAAgBa,oBAAoBrE,EAAc6D,QAE1D,CAMA,+BAAOkC,CAAyBC,EAAOhG,GAEjC,MAAMiG,EAAK,GACXjG,EAAc6D,QAAQrK,SAAQsC,IAC1B,MAAMiD,EAAMiB,EAAc6D,OAAOO,GAAGtI,GAC9BoK,EAAWpK,EAAEkK,EACfjH,WACOiB,EAAc6D,OAAOO,GAAGtI,GAC/BxE,EAAM+N,6BAA6BrF,EAAc6D,OAAQqC,EAASnH,IAEtEkH,EAAG1J,KAAK2J,EAAS,IAErBlG,EAAc6D,OAAO7I,OAAS,EAC9BgF,EAAc6D,OAAOtH,QAAQ0J,EACnC,CAKA,SAAAR,EAAU,cAAEzF,EAAa,YAAEC,IACvB,MAAM,qBAAEkG,GAAwB7O,EAAMyB,QAEtC,IAAIoK,EAAOI,IAAmBA,EAAS,IAAI4C,EAA+B5C,GAC1EJ,EAAKnD,cAAgBA,EACrBmD,EAAKlD,YAAcA,EACnBkD,EAAKiD,WAAW,CAAEpG,cAAe5H,KAAK4L,eAAgB/D,YAAa7H,KAAKmM,cAC5E,CAIA,KAAA8B,GACI,MAAM,eAAErC,EAAc,aAAEO,GAAiBnM,KACzC4L,EAAehJ,OAAS,EACxBuJ,EAAavJ,OAAS,EACtBgJ,EAAeH,OAAS,EAC5B,CAIA,WAAAyC,GACIlO,KAAKwF,OAAO5C,OAAS,EACrB5C,KAAKmO,WAAWvL,OAAS,CAC7B,CAIA,QAAAwL,GACIpO,KAAKiO,QACLjO,KAAKkO,aACT,CAIA,OAAAG,GACI,MAAM,eAAEzC,EAAc,aAAEO,GAAiBnM,KACzC,IAAIQ,EAAI,KACR,CAACoL,EAAgBO,GAAc/K,SAAQkN,IACnC,KAAOA,EAAQ1L,OAAS,GAGpB,GAFApC,EAAI8N,EAAQtI,MACZxF,EAAIA,EAAE6N,UACF7N,EAAEoC,OAAS,EAAG,CACd0L,EAAQnK,KAAK3D,GACb,KACJ,CACJ,GAER,CACA,SAAA+N,GACI,MAAM,eAAE3C,EAAc,aAAEO,GAAiBnM,KACzC,IAAIQ,EAAI,KACR,CAACoL,EAAgBO,GAAc/K,SAAQkN,IACnC,KAAOA,EAAQ1L,OAAS,GAGpB,GAFApC,EAAI8N,EAAQxI,UACZtF,EAAIA,EAAE6N,UACF7N,EAAEoC,OAAS,EAAG,CACd0L,EAAQnK,KAAK3D,GACb,KACJ,CACJ,GAER,CACA,IAAAgO,GACIxO,KAAKuO,YACLvO,KAAKqO,SACT,CAKA,WAAAI,GACI,MAAM,eAAE7C,GAAmB5L,KAC3B,OAAI4L,EAAehJ,OAAS,EACjBgJ,EAAeA,EAAehJ,OAAS,GAE3C,IACX,CACA,eAAA8L,GACI,MAAM,aAAEvC,GAAiBnM,KACzB,OAAImM,EAAavJ,OAAS,EACfuJ,EAAaA,EAAavJ,OAAS,GAEvC,IACX,CAIA,eAAA+L,GACI,MAAM,eAAE/C,GAAmB5L,KAC3B,GAAI4L,EAAehJ,OAAS,EAAG,CAC3B,MAAMa,EAAMmI,EAAehJ,OAAS,EAC9B4K,EAAW5B,EAAenI,GAC1BuI,EAAKZ,EAAgBwD,yBAAyBhD,EAAgBnI,GACpE,OAAO,IAAIoL,EAAqBrB,EAASxB,EAC7C,CACA,OAAO,IACX,CAMA,+BAAO4C,CAAyBhD,EAAgBnI,GAC5C,IAAIuI,EAAK,KACT,MAAM,OAAEP,GAAWG,EACnB,GAAIH,EAAO,CACP,IAAI9E,EAAO8E,EAAOO,GAClB,GAAIvI,KAAOmI,EAAeH,OAAO,CAC7B,IAAIzD,EAAI4D,EAAeH,OAAOhI,GAE1BuI,GAAOhE,KAAKrB,IACZqF,EAAIA,EAAGhE,GAEf,CACJ,CACA,OAAOgE,CACX,CAKA,kBAAA8C,CAAmBC,GACf,MAAM,eAAEnD,GAAmB5L,KAC3B4L,EAAe5F,MACf4F,EAAezH,KAAK4K,EACxB,CAQA,0BAAOC,CAAoBC,EAAYjD,EAAK,KACxC,MAAM,cAAEpE,EAAa,YAAEC,GAAgBoH,EACjCzO,EAAIoH,EAAc/B,MAAM,GAC9B,IAAImH,GAAQ,EACZ,OAAQhB,GACJ,IAAK,IAED,KAAOpE,EAAc6D,OAAO7I,OAAS,GACjCoK,EAAOpF,EAAc6D,OAAO9F,eACpBnF,EAAEwM,UACFnF,EAAYmF,GAGxB,MACJ,IAAK,UAED9N,EAAMgQ,kBAAkBtH,EAAeC,GACvC3I,EAAMiQ,qBAAqBvH,GAC3B,IAAIwH,EAAMvH,EAAYwH,QAAO9Q,QAAUyF,IAALzF,IAGlC,OAFAsJ,EAAYjF,OAAS,EACrBiF,EAAY1D,QAAQiL,GACbvH,EAiCX,QACI,GAAmB,mBAAR,EACP,KAAOD,EAAc6D,OAAO7I,OAAS,GACjCoK,EAAOpF,EAAc6D,OAAO9F,QAC5B7E,EAAIN,EAAEwM,GACFhB,EAAGlL,YACKN,EAAEwM,UACFnF,EAAYmF,IAOxC,IAAIoC,EAAMvH,EAAYwH,QAAO9Q,GAAKA,IAOlC,OANAsJ,EAAYjF,OAAS,EACrBiF,EAAY1D,QAAQiL,GAEpBxH,EAAchF,OAAS,EACvBwM,EAAM5O,EAAE6O,QAAO9Q,GAAKA,IACpBqJ,EAAczD,QAAQiL,GACfH,CACX,EAGJ,MAAM,qBAAEJ,GAAyB,EAAQ,OACnC,qBAAEd,GAAyB,EAAQ,MACnC,MAAE7O,GAAU,EAAQ,MAE1BtB,EAAQwN,gBAAkBA,C,4BC5gB1BxM,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAwBtDnB,EAAQ0R,qBArBR,MAUI,iBAAOC,CAAWrK,EAAWnG,EAAOyK,EAAQ/E,GACxCA,EAAOiG,aACPjG,EAAO0I,eAAepO,EAAOyK,GAC7B,IAAIC,EAAShF,EAAOqF,OAChB2D,EAAQhJ,EAAOpE,KAGnB,OAFAoE,EAAOqG,qBAEA,CAAChB,OAAOL,EAAQpJ,KAAKoN,EAChC,E,4BCrBJ7O,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAsBtDnB,EAAQ4R,yBAnBR,MAKIzQ,MAKA0Q,KAMArQ,K,8BClBJ,MAAM,gBAAEgM,GAAoB,EAAQ,KAEpCxM,OAAOE,eAAelB,EAAS,aAAc,CAAEmB,OAAO,IAEtD,MAAM2Q,EACF,WAAA5P,CAAY6P,GACR,MAAMnP,EAAIR,KACVA,KAAK4P,QAAWxQ,KACRuQ,GAGAvQ,KAAQoB,GACDA,EAAEpB,EAIrB,CACA,eAAOyQ,GACH,OAAOC,CACX,CACA,WAAOC,CAAK1P,GACR,IAAIkG,EAAI,IAAImJ,EACRM,EAAW,CAAC,EAChBpR,OAAOD,KAAK0B,GAAMe,SAASmC,IACvB,IAAI0M,EAAI5P,EAAKkD,GACT+G,EAAK,CAAE/G,KAAKA,EAAIA,EAAE+F,MAAM,MAAQtD,MAAczC,EAAEwH,KAAK,MAAhD,CAAyDxH,GAC9D+G,EAAG1H,OAAO,IACVoN,EAAS1F,GAAM,GAGnB1L,OAAOE,eAAeyH,EAAGhD,EAAG,CACxBtD,IAAK,WACD,MAAkB,mBAAP,EACAgQ,IAEJA,CACX,GACF,IAEN,IAAI,IAAI1M,KAAKyM,EACLzM,KAAKgD,GAET3H,OAAOE,eAAeyH,EAAGhD,EAAG,CAAExE,OAAO,IAEzC,OAAOwH,CACX,EAIJ,MAAMuJ,EAAY,IAAIJ,GAAkB,GAGxC9R,EAAQ8R,kBAAoBA,C,8BCrD5B9Q,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,QAAEmM,GAAa,EAAQ,OACvB,MAAE/B,GAAU+B,EACZgF,EAAU,CACZ,eAAgB/G,GAEdgH,EAAM,CAAC,EAWbvS,EAAQwS,0BAVR,MACI,UAAOC,CAAIC,GACP,KAAMA,KAAaH,GAAK,CACpB,MAAOjP,EAAKgP,EAAQI,GACpBH,EAAIG,GAAa,IAAIpP,CACzB,CACA,OAAOiP,EAAIG,EACf,E,2BCfJ1R,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IA0CtDnB,EAAQ2S,8BAxCR,MACI,GACA,GAEA,WAAAzQ,CAAY0Q,EAAW7Q,GACnBK,MAAK,EAAcwQ,EACnBxQ,MAAK,EAAYL,CACrB,CACA,cAAI6Q,GACA,OAAOxQ,MAAK,CAChB,CACA,YAAIL,GACA,OAAOK,MAAK,CAChB,CAKA,IAAAyQ,CAAKC,EAAOnR,EAAWsF,EAAQ9F,EAAOyK,EAAQ/E,EAAQ9E,GAClD,IAAIgR,EAAK3Q,KAAKwQ,WACVI,EAAO,KACPxG,EAAK7K,EAAU,IAAI6I,OAAOuI,GAAKD,GAE/BG,EAAQ,CAAChM,EAAQ9F,EAAOyK,EAAQ/E,EADpB9E,GAAaK,KAAKL,UAE9BkK,EAAM,IAAKiH,SAAS,SAAU,UAAU1G,GAAKjJ,MAAM,KAAM0P,GAa7D,OAZI3K,MAAMC,QAAQ0D,IACdO,EAAKP,EAAIlE,QACTkL,EAAMlL,QACNkL,EAAM/K,WAAW+D,GACjBgH,EAAM/K,QAAQjB,GACd+L,EAAOxG,EAAG2G,QAAQF,KAGlBA,EAAQ,CAAChM,EAAQ9F,EAAOyK,EAAQ/E,EAAQ9E,GAExCiR,EADU,IAAIE,SAAS,SAAS,QAAS,SAAU,SAAU,eAAe1G,EAAG,QACpE2G,KAAK,KAAMF,IAEnBD,CACX,E,4BCxCJhS,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAOtDnB,EAAQoT,gBALO,CACV,IAAK,kBACL,IAAK,cACL,IAAK,kB,8BCLVpS,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,MAAEuJ,GAAU,EAAQ,OACpB,WAAE2I,GAAe,EAAQ,MA0N/BrT,EAAQsT,qBAtNR,MAKI,GAKA,GAKA,GAKA,GAKA,GAKA,GAMA,WAAApR,GACI,MAAMqR,EAAiB,GAEvBnR,KAAKoR,KAAO,SAAUC,GAClB,MAAM,WAAEC,EAAU,KAAEC,EAAI,OAAElL,EAAM,SAAEmL,GAAaxR,KAC/CmR,EAAehN,KAAK,CAAEmN,aAAYC,OAAMlL,SAAQmL,aACtB,iBAAf,IACPxR,KAAKsR,WAAaD,EAE1B,EACArR,KAAKyR,QAAU,KACX,MAAMC,EAAMP,EAAenL,MAC3B,GAAI0L,EAAK,CACL,MAAM,WAAEJ,EAAU,KAAEC,EAAI,OAAElL,EAAM,SAAEmL,GAAaE,EAC/C1R,KAAKsR,WAAaA,EAClBtR,MAAK,EAAUuR,EACfvR,MAAK,EAAYqG,EACjBrG,MAAK,EAAkBwR,CAC3B,EAER,CAKA,aAAIG,GACA,OAAO3R,MAAK,CAChB,CAIA,aAAI2R,CAAUjO,GACV1D,MAAK,EAAe0D,CACxB,CAMA,cAAI4N,CAAW5N,GACX,GAASM,MAALN,EAAgB,MAAM,IAAIjF,MAAM,qBAEpCuB,MAAK,EAAe0D,EACpB1D,MAAK,EAAU0D,EACf1D,MAAK,EAAY,EACjBA,MAAK,EAAkB,CAC3B,CACA,cAAIsR,GACA,OAAOtR,MAAK,CAChB,CACA,QAAIuR,GACA,OAAOvR,MAAK,CAChB,CACA,QAAIuR,CAAK7N,GACL1D,MAAK,EAAU0D,CACnB,CACA,WAAIkO,GACA,OAAO5R,MAAK,EAAawG,UAAUxG,MAAK,EAC5C,CACA,YAAI6R,GACA,OAAO7R,MAAK,EAAawG,UAAUxG,MAAK,EAC5C,CAIA,UAAIqG,GACA,OAAOrG,MAAK,CAChB,CACA,YAAIwR,GACA,OAAOxR,MAAK,CAChB,CACA,UAAIqG,CAAO3C,GACP1D,MAAK,EAAY0D,CACrB,CAIA,YAAI8N,CAAS9N,GACT,MAAMoO,EAAM9R,MAAK,EACjB,GAAI0D,GAAKoO,EAAK,CACV,GAAIpO,EAAIoO,EACJ,MAAM,IAAIrT,MAAM,6BAA+BiF,EAAI,MAAQoO,GAE/D9R,MAAK,EAAYA,MAAK,EACtBA,MAAK,EAAkB0D,CAC3B,CACJ,CACA,KAAAqO,GACI/R,MAAK,EAAY,EACjBA,MAAK,EAAkB,CAC3B,CAMA,WAAAgS,CAAYR,EAAUnL,GAClB,GAAIA,GACA,GAAIA,EAASmL,EACT,MAAM,IAAI/S,MAAM,iDAGpB4H,EAASmL,EAEbxR,MAAK,EAAYqG,EACjBrG,MAAK,EAAkBwR,CAC3B,CAMA,KAAAS,CAAMC,EAAOzN,GACT,MAAM0N,EAAgBlB,EAAWmB,2BAA2BF,GACtDG,EAAiBpB,EAAWqB,sBAAsBJ,IAClD,QAAEN,EAAO,SAAEC,EAAQ,WAAEP,EAAU,SAAEE,EAAQ,UAAEG,EAAS,OAAEtL,GAAWrG,MACjE,MAAE4E,GAAUH,GAAU,CAAEG,OAAO,GACrC,IAAIwF,EAAK,KACT,GAAIiI,EAAgB,CAChB,GAAIV,GAA0B,GAAZH,IACdpH,EAAK8H,EAAMK,KAAKjB,GACZlH,GAEA,OADAA,EAAGoI,MAAO,EACHpI,EAGf,IAAKuH,EAED,OADA/M,GAAS0D,EAAMvF,IAAI,uCACZqH,CAEf,CACA,GAAI+H,GAEA,GADA/H,EAAK8H,EAAMK,KAAKX,GACZxH,EAAI,CACJA,EAAGoI,MAAO,EACVpI,EAAGtG,OAASuC,EACZ,IAAI2G,EAAO5C,EAAGtG,MACV2O,EAAK,KACLC,GAAQ,EACZ,KAAO1F,EAAOwE,GAAU,CACpBkB,GAAQ,EACR1F,IACA,IAAI2F,EAAQrB,EAAW9K,UAAUwG,GAEjC,GADAyF,EAAKP,EAAMK,KAAKI,IACZF,EAMA,MALAzF,GAAQyF,EAAG3O,MACX2O,EAAG3O,MAAQkJ,EACXyF,EAAG9K,MAAQ2J,EACXmB,EAAGD,MAAO,CAIlB,CACIE,IAIItI,EAHCqI,GACI,MAKTrI,IACAA,EAAGtG,QAAU0N,EAErB,OACQpH,IACRA,EAAK8H,EAAMK,KAAKV,IASpB,OAPIzH,IACAA,EAAGtG,OAAS0N,EACZpH,EAAGzC,MAAQ2J,EACPlH,EAAGtG,MAAQ0N,IACXpH,EAAK,OAGNA,CACX,E,4BC1NJxL,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAiDtDnB,EAAQgV,qBA5CR,cAAmC1M,MAC/B,WAAApG,GACI+S,QACA,IAAIC,EAAW,GAEf9S,KAAKoR,KAAO,KACR0B,EAAS3O,KAAKnE,KAAK6F,MAAM,IACzB7F,KAAKiO,OAAO,EAEhBjO,KAAKyR,QAAQ,KACT,IAAIsB,EAAMD,EAAS9M,MACf+M,IACA/S,KAAKiO,QACL4E,MAAM1O,QAAQ4O,GAClB,CAER,CACA,KAAAC,CAAM1E,EAAS7J,GACNA,EAAOwO,aACRJ,MAAM1O,KAAKmK,EAEnB,CACA,IAAAnK,CAAKmK,EAAS7J,GACV,IAAKA,EACD,MAAM,IAAIhG,MAAM,kBAEfgG,EAAOwO,aACRJ,MAAM1O,KAAKmK,EAEnB,CACA,OAAAxI,CAAQwI,EAAS7J,GACb,IAAKA,EACD,MAAM,IAAIhG,MAAM,kBAEfgG,EAAOwO,aACRJ,MAAM/M,QAAQwI,EAEtB,CACA,KAAAL,GACIjO,KAAK4C,OAAS,CAClB,E,4BC7CJhE,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAUtDnB,EAAQsV,mBARR,MACIhL,QACAxJ,KACA,WAAAoB,GAEA,E,8BCPJlB,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IACtD,MAAM,MAAEuJ,GAAU,EAAQ,OACpB,SAAE7H,GAAa,EAAQ,OACvB,MAAEvB,GAAU,EAAQ,MA8G1BtB,EAAQuV,kBAhGR,MAEI,WAAArT,GACI,IAAIsT,EAIJxU,OAAOE,eAAekB,KAAM,aAAc,CAAEC,IAAG,IAAYmT,IAC3DpT,KAAKqT,cAAgB,SAAU7Q,GAC3B4Q,EAAc5Q,CAClB,CACJ,CAMA,UAAA8Q,CAAWC,EAAWzJ,EAAQrF,GAC1BA,EAAOiG,aACPjG,EAAOkG,oBACP,MAAM6I,EAAW/O,EAAOoG,OAAM,GAC9BpG,EAAOqG,qBACPhB,EAAOqD,eAAeqG,EAC1B,CAKA,aAAAC,EAAc,gBAACC,EAAe,QAAEC,EAAO,MAAEC,IAEzC,CAKA,SAAAC,EAAU,SAACC,IAEX,CAIA,UAAAC,GAEA,CAKA,KAAAf,EAAM,OAAClJ,EAAM,KAAEzJ,EAAI,OAAEmF,EAAM,WAAE2I,EAAU,MAAEyF,EAAK,QAAED,EAAO,WAAEK,IACrD,IAAIlT,EAAIgJ,EACJ5I,EAAI0S,EACR,GAAI9S,EAAE8B,OAAS,EAAE,CACToR,IACAxO,EAAOM,QAAQ,IACfqI,EAAWrI,QAAQ,KAEvB,IAAImO,EAAO/S,EAAI,EAAIyS,EAAQO,OAAOhT,GAAK,GACvCsE,EAAOrB,KAAK8P,EAAOnT,GACnBqN,EAAWhK,KAAK8P,EAAK5T,EACzB,CACJ,CAOA,MAAAmF,EAAO,OAACA,EAAM,SAAEsO,IAEZ,OADStO,EAAOuF,KAAK+I,EAEzB,CAWA,WAAAzM,CAAYtI,EAAOyF,EAAQnF,EAASwF,EAAQD,EAAO4E,EAAQ/E,GACvD,MAAM,eAAE0P,GAAmBjV,EAAMyB,QAC3BoH,EAAK,IAAIoM,EAMf,OALApM,EAAGvD,OAASA,EACZuD,EAAG1I,QAAUA,EACb0I,EAAGhJ,MAASA,EACZ0F,EAAO2P,UAAYrM,EACnBnD,GAAOgL,QAAQ,iBAAmBtH,EAAMvF,IAAI,eAAgB6F,KAAK5H,MAAM4H,KAAKC,UAAUd,KAClFlD,EACOA,EAAOwC,YAAYtI,EAAOyF,EAAQnF,EAASmK,GAE/CzK,CACX,E,8BC9GJH,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAEpD,MAAM,MAAEuJ,GAAU,EAAQ,OACpB,gBAAE8C,GAAoB,EAAQ,KAkNpCxN,EAAQyW,oBA5MR,MAIIxQ,OAAQ,EAIRyQ,MAKAN,WAEAO,cACAC,aACAC,UAAW,EAQXC,aAKAC,SAKAC,aAEA,iBAAAC,CAAkBxU,GACd,IAAKL,KAAK4U,cAAgBvU,EAKtB,OAJK6F,MAAMC,QAAQnG,KAAK4U,gBACpB5U,KAAK4U,aAAe,CAAC5U,KAAK4U,oBAE9B5U,KAAK4U,aAAazQ,KAAK9D,GAG3BL,KAAK4U,aAAevU,CACxB,CAEA,QAAAyU,GACI,MAAO,uBAAuB9U,KAAKwJ,OAAOsL,UAC9C,CAMA,kBAAAC,CAAmB1U,GACf,MAAM,cAACuH,EAAa,YAAEC,GAAexH,EAC/BoN,EAAQzN,KAAKK,KACb2U,EAAKvH,EAAM7F,cAAchF,OAC/B6K,EAAM7F,cAAczD,QAAQyD,GAC5B6F,EAAM5F,YAAY1D,QAAQ0D,GAE1B,MAAMkF,EAAUnF,EAAc6D,QAAQ5F,MAAM,GAC5C,GAAIkH,EAAQ,CACR,IAAI,IAAIxG,EAAI,EAAGA,EAAKwG,EAAQnK,OAAQ2D,IAAI,CACpC,IAAI0O,EAAalI,EAAQxG,GAAKyO,EAE9B,GADAjI,EAAQxG,IAAMyO,EACVzO,KAAKqB,EAAc6D,OAAOO,GAAG,CAC7B,IAAIrF,EAAMiB,EAAc6D,OAAOO,GAAGzF,UAC3BqB,EAAc6D,OAAOO,GAAGzF,GAC/BrH,MAAM+N,6BAA6BrF,EAAc6D,OAAQwJ,EAAStO,EACtE,CACJ,CACM8G,EAAM7F,cAAc6D,SACtBgC,EAAM7F,cAAc6D,OAAU,IAClCgC,EAAM7F,cAAc6D,OAAOtH,QAAS4I,GACpCU,EAAM7F,cAAc6D,OAAOO,GAAK,IAAMyB,EAAM7F,cAAc6D,OAAOO,MAAQpE,EAAc6D,OAAOO,GAClG,CAEJ,CASA,WAAAlM,CAAYoF,EAAWgQ,EAASC,EAAOC,EAAW3Q,GAC9CzE,KAAKgU,WAAakB,EAAQG,QAAU,EAAI,EACxCrV,KAAKuU,cAAgBW,EAAQG,QAC7BrV,KAAKwU,cAAe,EACpB,IAAIc,EAAgBJ,EAAQjW,KAG5BL,OAAOE,eAAekB,KAAM,YAAa,CAACC,IAAG,IAAUiF,IACvDtG,OAAOE,eAAekB,KAAM,SAAU,CAACC,IAAG,IAAUiV,IACpDtW,OAAOE,eAAekB,KAAM,WAAY,CAACC,IAAG,IAAUmV,IACtDxW,OAAOE,eAAekB,KAAM,cAAe,CAACC,IAAG,IAAUqV,EACzD,GAAAC,CAAI7R,GACO,GAAHA,GACwB,yCAApB1D,KAAKwJ,OAAOpK,MACZ0D,QAAQC,IAAI,qBAGpBuS,EAAgB5R,CACpB,IAMA,SAAWyR,EAAOK,GACd,IAAIC,EAAWN,EACXO,GAAU,EAEVjI,EAAQ,KAIZ,GAAIhJ,GAAQ8I,kBAAkB3F,cAAcmD,KAAK,KAAKoK,EAAM,CACxD,MAAM,YAAEtN,EAAW,cAAED,GAAkBnD,EAAO8I,kBAC9CE,EAAQ,CAAE5F,YAAaA,EAAYhC,MAAM,GAAI+B,cAAgBA,EAAc/B,MAAM,KAE3E+B,cAAc6D,OAASL,EAAgBU,kBAAkBlE,EACnE,KAAK,CACD,IAAIpJ,EAAI,GACJ0C,EAAI,GACJiU,EAAMvS,OAAO,IACbpE,EAAE2F,KAAKgR,GACPjU,EAAEiD,KAAKgR,IAEX1H,EAAQ,CAAC5F,YAAarJ,EAAGoJ,cAAc1G,EAC3C,CACM,WAAYuM,EAAM7F,gBACnB6F,EAAM7F,cAAc6D,OAASL,EAAgBM,qBAIlD8J,EAAaD,IAAM,WACfG,GAAS,CACb,EAIA9W,OAAOE,eAAe0W,EAAc,OAAQ,CAACvV,IAAG,IACrCwN,IAKX7O,OAAOE,eAAe0W,EAAc,QAAS,CAACvV,IAAG,IACtCyV,IAEX9W,OAAOE,eAAe0W,EAAc,cAAe,CAC/CvV,IAAG,IACQkV,IAGfvW,OAAOE,eAAe0W,EAAc,UAAW,CAC3CvV,IAAG,IACQwV,EAEX,GAAAF,CAAI7R,GAEIA,GAAK+R,IACLhR,EAAOG,OAAOgL,QAAQ,mBAClBtH,EAAMvF,IAAI,sCAAwCW,EAAE,MACpDZ,QAAQC,IAAI,CAACgM,SAAUrL,EAAGiS,SAASF,KAEvCA,EAAW/R,EAEnB,IAEJ9E,OAAOE,eAAe0W,EAAc,SAAU,CAC1CvV,IAAG,IACQuV,EAAahM,OAAOzF,QAGtC,CAnED,CAmEGoR,EAAOnV,KACd,CAMA,SAAA4V,CAAUnR,EAAQxF,GAEde,KAAKsU,MAAQ,CACTxK,OAAQrF,EAAOiP,gBAAgB5J,OAC/BtE,OAAQf,EAAOe,OACfkO,gBAAiBjP,EAAOiP,gBACxB,wBAAImC,GACA,OAAO7V,KAAK0T,gBAAgB5J,MAChC,EACA,QAAI7K,GACA,OAAOA,CACX,EAER,E,4BCjNJL,OAAOE,eAAelB,EAAS,WAA/B,CAA6CmB,OAAO,IAGpD,MAAMkD,EACF,WAAO2E,CAAKkP,GACR,MAAMnP,EAAM,GACZ,IAAI8G,EAaJ,OAZA9G,EAAIoP,UAAY,IAAI9T,EACpBrD,OAAOE,eAAe6H,EAAK,UAAW,CAAE1G,IAAG,KACF,GAA7B0G,EAAI1C,QAAQ,iBAExBrF,OAAOE,eAAe6H,EAAK,SAAU,CAAE1G,IAAG,IAC/B6V,IAEXlX,OAAOE,eAAe6H,EAAK,OAAQ,CAAE1G,IAAG,IAC7BwN,EACR,GAAA8H,CAAI7R,GACH+J,EAAQ/J,CACZ,IACOiD,CACX,EAGJ/I,EAAQqE,wBAA0BA,C,8BCvBlCrD,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,iBAAEiX,GAAqB,EAAQ,KAC/B,MAAE9W,GAAU,EAAQ,OACpB,MAAEoJ,GAAU,EAAQ,OACpB,gBAAE8C,GAAoB,EAAQ,MAC9B,qBAAE8F,GAAyB,EAAQ,OACnC,qBAAE0B,GAAyB,EAAQ,OACnC,kBAAEO,GAAsB,EAAQ,MAuBtC,MAAMjR,EAEF,GAYA+T,UAAY,EAKZC,WAAa,EAEbC,UAAW,EACXC,UAAW,EACXC,cAAe,EACfC,gBAAiB,EACjBC,YAAc,EACdC,SAMAC,WAMAC,aAKA/B,SAIAgC,KAAM,EAINC,KAAM,EAENC,OAAQ,EAKR1P,UAAY,GAKZ2P,cAAe,EACfxC,MAAQ,GACRrR,MAAQ,CACJY,MAAO,EACPvC,IAAK,GAKTyV,OAIAC,cAAgB,GAKhBC,iBAAkB,EAIlBC,UAAY,KAKZC,qBAAsB,EAKtBC,qBAAsB,EAKtBC,gBAAiB,EAMjBC,SAAW,EAKXlD,UAKA3F,YAKAlB,iBAMAoE,UAKA4F,cAKA,gBAAIC,GACA,OAAOxX,KAAKkF,WAAWsS,YAC3B,CAMAxD,WAMAyD,mBAKAC,uBAMAC,cAGA,gBAAIC,GACA,OAAO5X,MAAK,CAChB,CAOA,wBAAA6X,CAAyBrO,GACrB,MAAM,qBAAEsO,GAAyB9X,KACjC,QAAIwJ,EAAOuO,8BACPD,EAAqB3T,KAAK,CAACqF,SAAQ3F,OAAM,KAClC,EAGf,CACA,uBAAAmU,GACI,MAAM,qBAAEF,GAAyB9X,KACjC,OAAO8X,EAAqB9R,KAChC,CAKA,uBAAAiS,GACI,MAAM,qBAAEH,GAA0B9X,KAClC,OAAI8X,EAAqBlV,OAAO,GACpBkV,EAAqBA,EAAqBlV,OAAO,GAChDiB,KAGjB,CAMA,4BAAAqU,GACI,MAAM,qBAAEJ,GAA0B9X,KAClC,OAAI8X,EAAqBlV,OAAO,EACrBkV,EAAqBA,EAAqBlV,OAAO,GAErD,IACX,CAUA,WAAA9C,CAAYmF,EAAYkT,EAAkBC,EAAWC,EAAiBC,GAClE,MAAM,MAAE1T,GAAUK,EACZsT,EAAgB,IAAIrH,EAAqBlR,MACzCwY,EAAyB,GAE/B,IAAI,SAAE1E,EAAQ,QAAEH,GAAY,CAACG,SAASwE,GAAKxE,UAAY7O,EAAWwT,KAAK3E,UAAY,KAC/EH,QAAS2E,GAAK3E,SAAW1O,EAAWwT,KAAK9E,SAAW,MACxD3T,MAAK,EAAkB,IAAI4S,EAC3B,IAAI8F,GAAgB,EAGhBC,EAAUL,GAAK1E,OAAS,EACxBgF,GAAgB,EACpB,MAAMC,EAAe,GACfC,EAAc,GACdC,EAAU,IACV,gBAAE3W,EAAe,gBAAEgJ,EAAe,MAAE9C,GAAUpJ,EAAMyB,QAC1D,IAAIqY,EAA2B,KAC3BC,EAAoB,CACpB1H,KAAM,EACN1N,MAAO,EACPvC,IAAK,EAKL,UAAA4X,CAAWjD,GACPjW,KAAKuR,KAAO0E,EACZjW,KAAK6D,MAAQ7D,KAAKsB,IAAM,CAC5B,EAMA,WAAA6X,CAAYtV,EAAOvC,GACftB,KAAK6D,MAAQA,EACb7D,KAAKsB,SAAsB,IAAT,EAAuBuC,EAAQvC,CACrD,GAEJ,MAAMmD,EAASzE,KACf,IAAIoZ,EAAc,EACdC,EAAsB,KAE1B,IAAK,IAAI9V,KAAK+U,GACkD,GAAxD,CAAC,QAAS,OAAQ,UAAW,YAAYrU,QAAQV,IAGrD3E,OAAOE,eAAekB,KAAMuD,EAAG,CAC3BtD,IAAG,IACQqY,EAAI/U,KAwHvB,SAAS+V,EAAMtR,GACX,OAASA,GAAiB,GAAZA,EAAEpF,MACpB,CACA,SAAS2W,EAAY/Y,GACjB,OAAgC,GAAzB5B,OAAOD,KAAK6B,GAAGoC,MAC1B,CAqQA,SAAS4W,EAAgBC,GACrB,IAAIjZ,EAAIiE,EACJiV,EAAOlZ,EAAE2W,oBACb3W,EAAE2W,qBAAsB,EACxBuB,GAAe,EACf,IAAIxL,EAAKuM,IAGT,OAFAf,GAAgB,EAChBlY,EAAE2W,oBAAsBuC,EACjBxM,CACX,CAvYAlN,KAAK2Z,WAAa,WACd3Z,KAAK4Z,WAAW,EAAG,EACvB,EACA5Z,KAAK4Z,WAAa,SAAU/V,EAAOvC,GAC/BtB,KAAKiD,MAAMY,MAAQA,EACnB7D,KAAKiD,MAAM3B,SAAsB,IAAT,EAAuBuC,EAAQvC,CAC3D,EACAtB,KAAK6Z,sBAAwB,SAAUC,GACnC,OAAOA,IAAqB3B,CAChC,EACAvZ,OAAOE,eAAe2F,EAAQ,uCAAwC,CAClE,GAAAxE,GACI,OAAOD,KAAK6Z,sBAAsB7Z,KAAK0T,gBAC3C,IAIJ9U,OAAOE,eAAe2F,EAAQ,uBAAwB,CAACxE,IAAG,IAAUuY,IACpE5Z,OAAOE,eAAe2F,EAAQ,cAAe,CAACxE,IAAG,IAAUsY,IAC3D3Z,OAAOE,eAAe2F,EAAQ,aAAc,CAACxE,IAAG,IAAUsY,EAAcjH,aACxE1S,OAAOE,eAAe2F,EAAQ,OAAQ,CAACxE,IAAG,IAC/BsY,EAAchH,KACtB,GAAAgE,CAAI7R,GAAI6U,EAAchH,KAAO7N,CAAE,IAClC9E,OAAOE,eAAe2F,EAAQ,aAAc,CAAExE,IAAK,WAAc,OAAOmZ,CAAa,IACrFxa,OAAOE,eAAe2F,EAAQ,eAAgB,CAAExE,IAAK,WAAc,OAAOD,KAAK+W,QAAQjN,MAAQ,IAC/FlL,OAAOE,eAAe2F,EAAQ,WAAY,CAAExE,IAAK,WAAc,OAAOmY,CAAW,IACjFxZ,OAAOE,eAAe2F,EAAQ,YAAa,CAAExE,IAAK,WAAc,OAAOgF,CAAY,IACnFrG,OAAOE,eAAe2F,EAAQ,kBAAmB,CAAExE,IAAK,WAAc,OAAOkY,CAAkB,IAC/FvZ,OAAOE,eAAe2F,EAAQ,eAAgB,CAC1CxE,IAAK,WAAc,OAAO2Y,CAAe,EAAG,GAAArD,CAAI7R,GAC5CkV,EAAgBlV,CACpB,IAEJ9E,OAAOE,eAAe2F,EAAQ,QAAS,CACnC,GAAAxE,GACI,OAAOD,KAAK+Z,KAAO/Z,KAAK4C,MAC5B,IAEJhE,OAAOE,eAAe2F,EAAQ,cAAe,CACzCxE,IAAK,WAAc,OAAOyY,CAAe,IAG7C9Z,OAAOE,eAAe2F,EAAQ,SAAU,CAAExE,IAAK,WAAc,OAAOkY,EAAiBrO,MAAQ,IAC7FlL,OAAOE,eAAe2F,EAAQ,OAAQ,CAAExE,IAAK,WAAc,OAAOkY,EAAiB9X,IAAM,IACzFzB,OAAOE,eAAe2F,EAAQ,mBAAoB,CAAExE,IAAG,IAAYgZ,IACnEra,OAAOE,eAAe2F,EAAQ,cAAe,CACzC,GAAAxE,GACI,MAAM+Z,EAAU/U,EAAWgV,YAC3B,IAAIhK,EAAI+J,EAIR,OAHIha,KAAKmH,WAAWvE,OAAS,IACzBqN,EAAIjQ,KAAKmH,UAAU+S,OAAOF,IAEvB/J,CACX,IAEJrR,OAAOE,eAAe2F,EAAQ,SAAU,CAAExE,IAAK,WAAc,OAAOD,KAAKuR,KAAK3O,MAAQ,IACtFhE,OAAOE,eAAe2F,EAAQ,QAAS,CAAExE,IAAK,WAAc,OAAO2E,CAAO,IAC1EhG,OAAOE,eAAe2F,EAAQ,aAAc,CAAExE,IAAK,WAAc,OAAO6Y,CAAa,IACrFla,OAAOE,eAAe2F,EAAQ,YAAa,CAAExE,IAAK,WAAc,OAAOoY,CAAiB,IACxFzZ,OAAOE,eAAe2F,EAAQ,MAAO,CACjCxE,IAAK,WACD,OAAOsY,EAAc/G,QACzB,EACA,GAAA+D,CAAI7R,GACA6U,EAAc/G,SAAW9N,CAC7B,IAKJ9E,OAAOE,eAAe2F,EAAQ,SAAU,CACpCxE,IAAK,WACD,OAAOsY,EAAclS,MACzB,IAMJzH,OAAOE,eAAe2F,EAAQ,yBAA0B,CACpDxE,IAAK,WAAc,OAAO+Y,CAA0B,EAAG,GAAAzD,CAAI7R,GACvDsV,EAA2BtV,CAC/B,IAEJ9E,OAAOE,eAAe2F,EAAQ,SAAU,CACpCxE,IAAK,WAAc,OAAOkY,EAAiB3S,MAAQ,IAEvD5G,OAAOE,eAAe2F,EAAQ,aAAc,CACxCxE,IAAK,WAAc,OAAOkY,EAAiBhK,UAAY,IAE3DvP,OAAOE,eAAe2F,EAAQ,QAAS,CACnCxE,IAAG,IAAY0Y,EAKf,GAAApD,CAAI7R,GACAiV,EAAUjV,CACd,IAEJe,EAAO0V,oBAAsB,WACzB,MAAM3Z,EAAIR,KACV,OAAOQ,EAAE+Q,KAAK/K,UAAUhG,EAAEyC,MAAMY,MAAOrD,EAAEyC,MAAM3B,IACnD,EACAmD,EAAO2V,cAAiB7b,IACpBua,EAAYhT,QAAQvH,EAAE,EAE1BkG,EAAO4V,YAAc,IACVvB,EAAYnT,QAEvBlB,EAAO6U,MAAQA,EAEf1a,OAAOE,eAAe2F,EAAQ,WAAY,CAACxE,IAAG,IACnC6T,IAsCXrP,EAAO6V,UA1BP,WACI,IAAI/S,EAAQ3I,OAAOD,KAAK8F,GACpB8V,EAAS,CAAC,EACdhT,EAAMnG,SAAQmC,IACV,IAAIuJ,SAAYrI,EAAOlB,GACvB,GAAI,kBAAkB8E,KAAKyE,GACvB,OACJ,IAAI0N,EAAK5b,OAAO6b,yBAAyBhW,EAAQlB,KAC5CiX,GAAOA,EAAGva,KAAOua,EAAGjF,OACrBgF,EAAOhX,GAAKkB,EAAOlB,GACvB,IAEJwV,EAAQjT,QAAQ,IAAKyU,GACzB,EAcA9V,EAAOiW,SAVP,WACI,IAAI5Z,EAAIiY,EAAQpT,QAChB,GAAI7E,EACA,IAAK,IAAIyC,KAAKzC,EACV2D,EAAOlB,GAAKzC,EAAEyC,EAG1B,EAWAkB,EAAOkW,kBAAoB,SAAU7Z,EAAG/B,EAAOmW,GAG3C,GAAIoE,EAAMva,GACN,OAAO+B,EAEX,MAAM,SAAEyD,GAAavE,KACrB,OAAIuE,GAAUqW,WACHrW,EAASqW,WAAW9Z,EAAG/B,EAAOmW,GAElClV,KAAK4a,WAAW9Z,EAAG/B,EAC9B,EAQA0F,EAAOmW,WAAa,SAAU9Q,EAAQ/K,GAClC,MAAM,SAAEqX,EAAQ,YAAEyE,GAAgB7a,KAClC,IAAIc,EAAIgJ,EACR,GAAIsM,EAAU,CACV,IAAIrL,EAAO,IACP8P,IACA9P,EAAO,IAEXjK,EAAI,CAACA,EAAEuN,UAAWtP,EAAMwP,aAAaxD,KAAKA,GAC1C/K,KAAKoW,UAAW,CACpB,MACItV,GAAK/B,EAET,OAAO+B,CACX,EA8BA2D,EAAO0I,eAAiB,SAAUpO,EAAOmW,EAASvQ,GAAQ,EAAMmW,GAAM,GAElE,IAAK/b,EAED,OAGJ,MAAM,MAAE6F,EAAK,gBAAE8O,GAAoB1T,KACnC4E,GAAOgL,QAAQ,oBAIf,IAAIpC,EAAUzO,EAgBVgc,EAAa,KAEjB,GAAqB,iBAAX,EAjBS,EAAChc,EAAOsB,EAAM6U,EAASvQ,KACtC,IAAI6I,EAAUzO,EACV0O,EAAQpN,EACZ,GAAI2Y,EACAja,EAAQia,EAAyBja,EAAOmW,EAASvQ,EAAO3E,UAEvD,CACG2E,IACA6I,EAAUxN,KAAKgb,8BAA8B9F,EAAS1H,IAE1D,MAAM/B,EAASyJ,EAAQ+F,aACvBvH,EAAgBvG,eAAe,CAC3BrD,OAAQ0D,EAASnN,KAAMoN,EAAOhC,UACtC,GAOAyP,CAAanc,EAAM+K,OAAQ/K,EAAMsB,KAAM6U,GAAS,GAChD1H,EAAU/I,EAAOqF,OACjBiR,EAAa,CAACjF,OAAQ/W,EAAMsB,KAAMtB,MAAOA,EAAM+K,aAE9C,GAAI/K,EAAM6D,OAAS,EACpB,GAAIoW,EACAja,EAAQia,EAAyBja,EAAOmW,EAASvQ,EAAO3E,UAEvD,CACG2E,IACA6I,EAAUxN,KAAKgb,8BAA8B9F,EAAS1H,IAG1D,MAAM/B,EAAUyJ,EAAQ+F,aAExBvH,EAAgBvG,eAAe,CAC3BrD,OAAQ0D,EAASnN,KAAMtB,EAAO0M,UACtC,CAEJyJ,EAAQnW,MAAQgc,GAAc,CAAEjF,OAAQ/W,EAAOA,MAAOyO,GAClDsN,GACA7V,EAAWkW,iBAAiBjG,EAAS1H,EAAS/I,GAC9C+I,GAASgB,OAAO5L,OAAO,IACvB6B,EAAOyS,UAAY,KAE3B,EAEAzS,EAAO2W,QAAU,CAAClG,EAASmG,KAElBnG,EAAQoG,aAAeD,EACxB5W,EAAOyS,UAAYmE,EAEnB5W,EAAOyS,UAAY,IACvB,EAEJzS,EAAOuW,8BAAgC,SAAU9F,EAAS1H,GACtD,MAAM,SAAEjJ,EAAQ,YAAEgX,EAAW,OAAE1W,GAAW7E,KAC1C,GAAIuE,GAAU8C,YAAa,EAnG/B,SAA0BmC,EAAQ+R,GAC1BtW,EAAWuW,gBAAgBhS,IACa,mBAA3BA,EAAsB,iBAAoBA,EAAOiS,mBAC1DF,EAAY5V,OAExB,CA+FQ+V,CAAiBxG,EAAQ1L,OAAQ+R,GAI7BrG,EAAQ9V,OAAS8V,EAAQyG,eAAiBJ,EAAYzV,QAAQoP,EAAQ9V,MAG1E,MAAMC,EArGd,SAAoBmK,GAChB,KAAOA,GAAQ,CACX,GAAIA,EAAOnK,QACP,OAAOmK,EAAOnK,QAElB,GAAImK,EAAOoS,WACHpS,EAAOoS,UAAUvc,QACjB,OAAOmK,EAAOoS,UAAUvc,QAIhCmK,EAASA,EAAOzJ,MACpB,CACA,OAAO,IACX,CAuFwB8b,CAAW3G,GAC3B1H,EAAUjJ,EAAS8C,YAAYmG,EAAS+N,EAAalc,EAASwF,EAAQD,EAAOsQ,EAASzQ,EAC1F,CACA,OAAO+I,CACX,EAOA/I,EAAOqX,mBAAqB,SAAUC,EAAahS,EAAWiS,GAC1D,MAAM,OAAExS,EAAM,MAAEkH,GAAUqL,EAE1B,IAAIE,EAAOlS,GAAa7K,EAAMgd,cAAc1S,GAC5C,GAAI+P,EAAY0C,GACZ,OAEJ,IAAIE,EAAK,KAIT,GADAA,EAAK/Z,EAAgBK,gBAAgBiO,EAAOlH,EAAOpK,MAC/C+c,EAAI,CACJH,EAAYA,GAAc,CAAC,EAC3B,IAAI9O,EAAKsM,GAAiB,IACd2C,EAAG7X,OAAOtE,KAAKuE,SAAU0X,GAAM,EAAOjc,KAAKub,YAAavb,KAAMgc,KAI1E,OAFAD,EAAYK,YAAclP,EAC1BlN,KAAKuN,iBAAmByO,EACjB9O,CACX,CACA,OAAO,IACX,EACAzI,EAAO8F,iBAAmB,SAAU8R,EAAYC,EAAU3c,EAAUqc,GAChE,IAAIC,EAAOtc,GAAY,IAAK0c,EAAW1c,YAAa0c,EAAWrS,aAC/D,GAAIuP,EAAY0C,GACZ,OAAIK,EAAS,GAAG1Z,OAAO,EACZ6B,EAAOuW,8BAA8BqB,EAAYC,EAAS,SACrE,EAEJ,MAAM,OAAE9S,GAAW6S,GACb,MAAEzX,GAAU5E,KACZQ,EAAIR,KACJuc,EAAgB,SAAUxd,EAAOkH,EAAK7H,EAAImG,EAAUE,GACtD,MAAM,OAAED,EAAM,OAAEK,EAAM,MAAED,EAAK,QAAEvF,GAAYoF,EAC3C,GAAIwB,EAAI3G,SACJP,EAAQG,EAAMkI,kBAAkBrI,EAAOkH,EAAI3G,SAAU+c,EAAW3L,MAAOlQ,OACpE,CAEH,MAAMwL,EAAK,GACXjN,EAAQkG,EAAW+B,iBAAiBf,EAAKlH,EAAOiN,GAChDjN,EAAQwF,EAAS8C,YAAYtI,EAAOyF,EAAQnF,EAASwF,EAAQD,EAAOqB,EAAIzF,EAC5E,CACA,OAAOzB,CAEX,EACA6F,GAAOgL,QAAQ,kBAAoBtH,EAAMvF,IAAI,4BAA8ByG,GAC3E,IAAIkI,EAAM4K,EACNH,EAAK/Z,EAAgBK,gBAAgBiP,EAAKlI,EAAOpK,MACrD,GAAI+c,EAAI,CACJH,EAAaA,GAAc,CAAC,EAC5B,IAAI9O,EAAKsM,GAAgB,IACZ2C,EAAG7X,OAAOtE,KAAKuE,SAAU0X,EAAMM,EAAevc,KAAKub,YACxD/a,EAAGwb,KAUX,OANAK,EAAWxI,UAAY3G,EACvBlN,KAAKuN,iBAAmByO,EACxBpX,GAAOgL,QAAQ,mBACXtH,EAAMvF,IAAI,mCACVD,QAAQC,IAAI,CAACyZ,SAAStP,KAEnBA,CACX,CACA,OAAO,IACX,EA0BAzI,EAAOgY,cAAgB,SAAUR,EAAM/G,EAASoH,GAG5C,IAAII,EAAO,GACXA,EAAKC,QAAU,CAAC,EAChB,IAAIC,EAAO,KACX,IAAK,IAAIrZ,KAAK0Y,EAAM,CAChBS,EAAKvY,KAAKZ,GACV,IAAIrC,EAAI+a,EAAK1Y,GACb,KAAMA,KAAK+Y,GAAW,CAClBrX,EAAW4X,UAAU,KACrB,QACJ,CACA,IAAI9d,EAAQud,EAAS/Y,GAGjBrC,EAAE3B,YACFR,EAAQG,EAAM+H,qBAAqBlI,EAAOmC,EAAE3B,YAE5C2B,EAAE9B,OACFwd,EAAO,IAAIE,wBACXF,EAAKxd,KAAO8B,EAAE9B,KACdsd,EAAKC,QAAQpZ,GAAK,CACdiG,OAAQoT,EACR7d,MAAOA,IAGfud,EAAS/Y,GAAKxE,CAClB,CACA,OAAO2d,CACX,EAMAjY,EAAOsY,OAAS,SAAUC,EAAaC,GAC/BA,EACAjd,KAAKkd,YAAYlL,YAAYgL,EAAaC,GAE1Cjd,KAAK+Z,IAAMiD,CAEnB,EAKAvY,EAAO0Y,cAAgB,UAAU,MAAE7I,IAC/B6D,EAAmB7D,EAAMZ,eAC7B,EACAjP,EAAO2Y,UAAY,SAAUhf,IACzB+Z,EAAmB,IAAI/M,GACNhN,GAAKA,CAC1B,EAIAqG,EAAOiG,WAAa,WAChB0O,IACAP,EAAa1U,KAAK,CACdqB,OAAQxF,KAAKwF,OACbkO,gBAAiB1T,KAAK0T,kBAE1B1T,KAAKod,UAAU,gBACnB,EAKA3Y,EAAOqG,mBAAqB,WACxB,IAAIhB,EAAS+O,EAAa7S,MACtB8D,IACA9J,KAAKmd,cAAc,CAAE7I,MAAOxK,IAC5BsP,IAER,EAMA3U,EAAOuO,MAKH,SAAUgB,GAAa,GACnB,MACM,OAAElK,EAAM,KAAEzJ,EAAI,OAAEmF,EAAM,WAAE2I,EAAU,MAAEyF,EAAK,gBAAEF,EAAe,SAAEnP,GADrDvE,KAEP6Q,EAAQ,CAAE/G,SAAQtE,SAAOnF,OAAM8N,aAAYyF,QAAOD,UAASD,kBAAiB2J,KAFrErd,KAE2EgU,cACpFzP,GAAUyO,MACVzO,EAASyO,MAAM7R,MAAM,KAAM,CAAC0P,KAEvBwI,IACDA,EAAsB,IAAIlG,GAE9BkG,EAAoBrG,MAAMnC,IAE9BsH,EAAiBlK,OACrB,EAEJxJ,EAAOoG,MAOH,SAAUoD,EAAOqP,GACb,MACM,OAAExT,EAAM,OAAEtE,EAAM,SAAEjB,EAAQ,WAAE4J,EAAU,gBAAEuF,GADjC1T,KAEb,IAAIgI,EAAI,GACJ3H,EAAO,KAgBX,OAdI2H,EADAzD,GAAUiB,OACNjB,EAASiB,OAAOrE,MAAM,KAAM,CAAC,CAAE2I,SAAQtE,SAAQ2I,aAAY2F,WAAUuJ,KALhErd,QAOLwF,EAAOuF,KAAK+I,GAEpBzT,EAAO8N,EAAWpD,KAAK+I,GAEnB7F,IACIqP,IACAA,EAAQnP,WAAa9N,EACrBid,EAAQC,QAAU7J,EAAgBpH,gBAEtCoH,EAAgBtF,WAChB5I,EAAO5C,OAAS,GAEboF,CACX,EACJvD,EAAO6O,WAKH,WACA,MAAM,SAAE/O,GAAavE,MACf,SAAE8T,GAAa7O,EAAWuY,SAChC,OAAIjZ,GAAU+O,WACH/O,EAAS+O,WAAWQ,EACvB9T,KAAK0T,gBAAiB1T,KAAM,CAC5BgT,MAAO,KACHhT,KAAKgT,OAAO,IAIb/N,EAAWkI,eAAe2G,EAAU9T,KAEnD,CACJ,CAQA,cAAAyd,CAAeC,EAAe5T,GAC1B,IAAI6T,EAAQ7T,EAAOlH,OACnB,MAAMuZ,EAAKuB,EAAcE,gBAUzB,OATIzB,IACgB,mBAAN,EACNrS,EAAS5E,UAAU4E,GACG,iBAAR,GAAqBqS,EAAGvc,SACtCkK,EAASqS,EAAGvc,OAAOkK,IAGvB9J,KAAKuR,KAAOzH,EAASrF,OAAO8M,KAAK/K,UAAUmX,IAExC,CAACE,SAAU/T,EAAQ6T,MAAO7T,EAAOlH,OAC5C,CAIA,SAAAkb,GACyB,MAAjB9d,KAAKwW,SAELxW,KAAKwW,SAAW,CACZhF,SAAU,EACVuM,QAAS,KACTnQ,MAAO,IAIX5N,KAAKwW,SAAShF,SAAW,EACzBxR,KAAKwW,SAASuH,QAAS,KACvB/d,KAAKwW,SAAS5I,MAAQ,EAE9B,CACA,gBAAIoQ,GACA,OAAOhe,KAAKkW,WAAalW,KAAKqG,MAClC,CAIA,KAAA0L,GACI/R,KAAKoW,SACLpW,KAAKmX,oBACLnX,KAAKiX,gBACLjX,KAAK2W,IACL3W,KAAK4W,IACL5W,KAAK2R,UACL3R,KAAK8W,aACL9W,KAAKqW,aACLrW,KAAKsW,gBACL,EACAtW,KAAKiW,UAAY,EACjBjW,KAAKuW,YAAc,EACnBvW,KAAKsX,SAAW,EAEhBtX,KAAK2U,SAAW,KAChB3U,KAAKuN,iBAAmB,KACxBvN,KAAKie,gBAAkB,KACvBje,KAAK4X,aAAa3J,QAClBjO,KAAKke,aACT,CACA,kBAAAC,GACI,MAAM1Z,EAASzE,KACf,GAAIA,KAAKiX,iBAAmBxS,EAAOuS,cAAcpU,OAAS,EAAG,CAEzD,IAAIgL,EAAQnJ,EAAOuS,cAAcpU,OACjC,KAAOgL,EAAQ,GAAG,CACd,IAAIwQ,EAAK3Z,EAAO4V,cACZ7Z,EAAIiE,EAAOuS,cAAchR,MAC7B,GAAIoY,IAAO5d,EACP,MAAM,IAAI/B,MAAM,yBAEpBmP,IACA,IAAIyQ,EAAK5Z,EAAOqF,OAChBrF,EAAO0Y,cAAc3c,GACjB6d,EAAGzb,OAAS,GACZ6B,EAAO0I,eAAekR,EAE9B,CACJ,CACJ,CACA,WAAAH,GACIle,KAAKkX,UAAY,KACjBlX,KAAK0X,uBAAyB,KAC9B1X,KAAKuX,eAAgB,CACzB,CAOA,aAAA+G,CAAc5a,EAAG8N,EAAUnL,GACvBrG,KAAKkd,YAAY5L,WAAa5N,EACbM,MAAZwN,GAA2BA,GAAU,GACtCxR,KAAKgS,YAAYR,EAAUnL,EAEnC,CAOA,WAAA2L,CAAYR,EAAUnL,GAClBrG,KAAKkd,YAAYlL,YAAYR,EAAUnL,EAC3C,CAOA,eAAAkY,CAAgBrJ,EAASsJ,GACrBxe,KAAKke,cACLle,KAAKme,qBAEDjJ,EAAQyC,gBACR3X,KAAK2X,cAAgBzC,EAAQyC,eAE7BzC,EAAQ6C,6BACJ/X,KAAKkY,gCAAgChD,GAErClV,KAAKgY,yBAGjB,CACA,iBAAAyG,GAEA,CAQA,mBAAAC,CAAoBC,EAAM9e,GACtB,MAAM4E,EAASzE,KACf,IAAIwe,EAAO/Z,EAAOma,oBAAoBD,EAAM9e,GAC5C,GAAI2e,EAAM,CAEN,IAAI5T,EAAWnG,EAAOqF,OAClB+U,EAASpa,EAAOpE,KACpBoE,EAAO0Y,cAAcqB,GACjB5T,GACAnG,EAAOiP,gBAAgBvG,eACnB,CACA2I,OAAOlL,EAAUvK,KAAMwe,GAEnC,CACA,OAAOL,CACX,CAKA,oBAAIM,GACA,OAAO9e,KAAK2R,WAAc3R,KAAKuR,MAAQvR,KAAKsR,UAChD,CAOA,mBAAAsN,CAAoBpV,EAAQ3J,GAAa,GACrC,GAAIG,KAAKqc,WAAWzZ,OAAS,EAAG,CAC5B,GAAI5C,KAAKqc,WAAW,GAAG7S,SAAWA,EAC9B,OAAOxJ,KAAKqc,WAAW1W,QAE3B,GAAI9F,EACA,MAAM,IAAIpB,MAAM,0CAExB,CACA,OAAO,IACX,CACA,oBAAAsgB,GACI/e,KAAKgT,QACL,IAAIxF,EAAUxN,KAAK6K,OAAM,GACrB2C,EAAQ5K,OAAS,GACjB5C,KAAK0T,gBAAgBvG,eAAeK,EAE5C,CACA,gBAAAwR,CAAiB/Q,EAAO7I,GACpB,MAAMX,EAASzE,KACf,IAAIwN,EAAU/I,EAAOqF,OACjBmV,EAAMxa,EAAOoG,OAAM,EAAMzF,GAI7B,OAHI6I,GACAxJ,EAAOiP,gBAAgBzF,QAEpBgR,EAAIzR,CACf,CACA,mBAAA0R,GACI,OAAIlf,KAAKqc,WAAWzZ,OAAS,EAClB5C,KAAKqc,WAAW,GAEpB,IACX,CAMA,aAAA8C,EAAc,OAAErV,EAAS,KAAI,SAAEsV,GAAW,EAAK,aAAE5K,GAAe,EAAK,MAAEvG,GAAQ,IAE3E,IADAnE,EAASA,GAAU9J,KAAK8J,SACTA,EAAOlH,OAAS,EAC3B,GAAIwc,EACApf,KAAKgT,MAAMwB,OACV,CACD,IAAIxM,EAAIhI,KAAK8J,OACT9B,EAAEpF,QACF5C,KAAKwF,OAAOrB,KAAK6D,EAEzB,CAEAiG,GACAjO,KAAK0T,gBAAgBzF,OAE7B,CAIA,kBAAIoR,GACA,OAAOrf,KAAKqc,WAAWzZ,OAAO,EAAG5C,KAAKqc,WAAW,GAAK,IAC1D,CAEA,iBAAA1R,GACI3K,KAAK4E,OAAOgL,QAAQ,6BAA+BtH,EAAMvF,IAAI,+BAC7D,MAAM,SAAEwB,EAAQ,OAAEiB,EAAO,WAAE2I,GAAcnO,KACzCkC,EAAiBod,sBAAsB,CAAE/a,WAAUiB,SAAQ2I,cAC/D,CAMA,YAAAoR,CAAatR,GACT,MAAMuR,EAAW,CAAC,EAElB,MAAO,CAAC1V,OADQ9J,KAAK6K,MAAMoD,EAAOuR,GACTnf,KAAMmf,EAASrR,WAC5C,CACA,4BAAOmR,EAAsB,SAAE/a,EAAQ,OAAEiB,EAAM,WAAE2I,IACzC5J,GAAUoG,kBACVpG,EAASoG,kBAAkB,CAAEnF,OAAQA,KAErCA,EAAOrB,KAAK,IACZgK,EAAWhK,KAAK,IAExB,CACA,sBAAIsb,GACA,MAAM,gBAAE/L,GAAoB1T,KAC5B,MAAO,CACH4H,cAAgB8L,EAAgB9L,cAChCC,YAAcuD,EAAgBvD,YAEtC,CAIA,eAAI6X,GACA,MAAO,CACH5V,OAAQ9J,KAAK8J,OACbzJ,KAAOL,KAAKK,KACZmF,OAASxF,KAAKwF,OAAOK,MAAM,GAC3BsI,WAAanO,KAAKmO,WAAWtI,MAAM,GACnC+F,eAAiB5L,KAAK0T,gBAAgB9H,eACtCO,aAAenM,KAAK0T,gBAAgBvH,aAE5C,CAEA,eAAAwT,GACI,IAAIC,EAAM5f,KAAK0W,cAAcmJ,cAAgB7f,KAAK0W,cAActX,KAChE,OAAIwgB,EAIO,IAAI1S,EAFFlN,KAAK8f,UAAUC,kBAEVH,GAEX5f,KAAK8f,UAAUE,cAC1B,EAKJpiB,EAAQsE,iBAAmBA,C,4BC3nC3BtD,OAAOE,eAAelB,EAAS,WAA/B,CAA6CmB,OAAO,IAIpD,MAAMkhB,UAAkCxhB,MACpC,WAAAqB,CAAY2I,EAAKyX,EAAS3e,EAAOgQ,GACzBA,IACA9I,GAAO,OAAO8I,GAElBsB,MAAMpK,GACN7J,OAAOE,eAAekB,KAAM,UAAW,CAACC,IAAG,IAAUigB,IACrDthB,OAAOE,eAAekB,KAAM,QAAS,CAACC,IAAG,IAAUsB,GACvD,EAIJ3D,EAAQqiB,0BAA4BA,C,4BChBpCrhB,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAgCpDnB,EAAQiR,qBA1BR,MACI,GACA,GAEA,WAAA/O,CAAYgK,EAAQkC,GAChBhM,MAAK,EAAY8J,EACjB9J,MAAK,EAAQgM,CACjB,CACA,QAAA8I,GACI,OAAO9U,MAAK,CAChB,CACA,UAAI8J,GACA,OAAO9J,MAAK,CAChB,CACA,YAAImgB,GACA,OAAqB,MAAdngB,MAAK,CAChB,CACA,QAAIyY,GACA,OAAIzY,KAAKmgB,SACEngB,MAAK,EAET,IACX,E,6BC3BJ,MAAM,MAAEd,GAAU,EAAQ,MAE1BN,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAItD,MAAMgP,EAIFlG,YAIAD,cAEA,WAAA9H,GACA,CAOA,wBAAOsgB,CAAkBC,GAAS,YAACxY,EAAW,cAAED,IAC5C,IAAI0Y,EAAS,IAAIvS,EACjBuS,EAAOzY,YAAcA,EACrByY,EAAO1Y,cAAgBA,EACvB0Y,EAAOtS,WAAWqS,EACtB,CAKA,UAAArS,CAAWqS,GACP,MAAM,YAACxY,EAAW,cAAED,GAAiB5H,KAC/BugB,EAAUF,EAASzY,cAAchF,OACvCyd,EAASzY,cAAczD,QAAQyD,GAC/ByY,EAASxY,YAAY1D,QAAQ0D,GAC7B,MAAM,OAAE4D,GAAY7D,GACd,gBAAEwD,GAAoBlM,EAAMyB,QAElC,GAAI8K,EAAO,CACF,OAAQA,GACTL,EAAgBa,oBAAoBR,GAKlC,WAAY4U,EAASzY,gBACvByY,EAASzY,cAAc6D,OAASL,EAAgBM,qBAEpD,IAAI8O,EAAK,EACLgG,EAAKH,EAASzY,cAAc6D,OAChCA,EAAOrK,SAAQqf,IACX,MAAMzT,EAAOyT,EAAUF,EACjB,OAAQC,GACVpV,EAAgBa,oBAAoBuU,GAExCA,EAAGrc,KAAK6I,GACR,IAAI0T,EAAMD,KAAWhV,EAAOO,GAAIP,EAAOO,GAAGyU,GAAW,KACrDvhB,EAAM+N,6BAA6BuT,EAAIxT,EAAM0T,GAC7ClG,GAAI,GAEZ,CACJ,EAKJ5c,EAAQmQ,qBAAsBA,C,8BCtE9BnP,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IACtD,MAAM,qBAAE4hB,GAAyB,EAAQ,OACnC,eAAEC,GAAmB,EAAQ,OAC7B,gBAAEC,GAAoB,EAAQ,MAyFpCjjB,EAAQkjB,iBAvFR,MACInN,QAAU,KACVG,SAAW,KACXiN,mBAAoB,EACpBlG,aAAc,EACdmG,YAAcL,EAAqBM,IAKnCC,WAAY,EACZtN,MAAQ,EACRrC,KAAO,EAIP4P,qBAAuB,IAIvBC,6BAA8B,EAM9BC,gBAOAC,cAAgB,SAUhB,UAAAphB,CAAWC,EAAQC,EAAWC,EAAMC,EAAQC,GACxC,OAAQH,GACJ,IAAK,cACD,GAAIugB,EAAqBY,QAAQlhB,GAC7B,OAAOA,EAEX,MAAM,IAAI5B,MAAM2B,EAAY,kBAChC,IAAK,kBACD,IAAIyE,EAAS,KAIb,GAHIxE,aAAgBwgB,IAChBhc,EAASxE,GAEO,iBAAV,EACNwE,EAASgc,EAAgBW,aAAanhB,OACnC,CACH,MAAM,GAACjC,EAAE,OAAEyG,GAAUxE,EAErBwE,EAASgc,EAAgBW,aAAanhB,EAC1C,CACA,OAAOwE,EAEf,OAAOxE,CACX,CAKA,wBAAAohB,GACI,OAAOb,EAAec,QAAQ1hB,KAAKghB,YACvC,CAMA,sBAAAW,CAAuBC,GACnB,IAAIC,EAAI7hB,KAAKmhB,qBAIb,MAHkB,iBAAP,IACPU,EAAIA,EAAEvY,MAAM,OAES,GAAlBuY,EAAE5d,QAAQ2d,EAErB,E,8BC1FJhjB,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,gBAAEqM,GAAoB,EAAQ,MAC9B,0BAAE0W,EAAyB,SAAErhB,GAAa,EAAQ,MAClD,iBAAEuV,GAAqB,EAAQ,KAC/B,MAAE9W,GAAU,EAAQ,OACpB,eAAE6iB,GAAmB,EAAQ,OAC7B,MAAEzZ,GAAU,EAAQ,MAM1B,MAAM0Z,UAA8BF,EAChC1iB,KAAO,iCACPsU,gBACAiL,KACAsD,YAAc,EACdC,cACAC,SAAU,EACVC,QAAS,EACT3W,QAAS,EACT4W,iBAIAC,iBAIAC,gBAIA,aAAIC,GACA,OAAO,CACX,CACA,WAAA1iB,GACI+S,QACA7S,KAAK0T,gBAAkB,IAAItI,EAC3BpL,KAAK0T,gBAAgBtV,GA/BR,qBAgCb,IAAIqkB,EAAU,CAAEC,OAAO,EAAOP,SAAS,GAGvCniB,KAAKmN,eAAiB,SAAUzJ,EAAGgO,GAC/B,GAAIA,EAAK,CACL,MAAM,QAACwD,EAAO,WAAEyN,GAAcjR,EAC9B,GAAIwD,GAAWyN,GAA+B,GAAhBzN,EAAQjW,KAAY,CAC9C,IAAIuO,EAAUxN,KAAK0T,gBAAgB5J,OACnCpG,EAAIif,EAAWC,iBAAiB1N,EAAQjW,KAAMuO,EAAS9J,GACvD1D,KAAK0T,gBAAgBzF,OACzB,CACJ,CAEA,OADAjO,KAAK0T,gBAAgBvG,eAAezJ,GAC7BA,CACX,EACA1D,KAAKiO,MAAQ,WACTjO,KAAK0T,gBAAgBzF,OACzB,EACArP,OAAOE,eAAekB,KAAM,QAAS,CAAEC,IAAG,IAAYwiB,IACtD7jB,OAAOE,eAAekB,KAAM,SAAU,CAAE,GAAAC,GAAQ,OAAOD,KAAK0T,gBAAgB5J,MAAQ,IACpFlL,OAAOE,eAAekB,KAAM,QAAS,CAAE,GAAAC,GAAQ,OAAOD,KAAK2e,MAAMtd,KAAO,IACxEzC,OAAOE,eAAekB,KAAM,MAAO,CAAE,GAAAC,GAAQ,OAAOD,KAAK2e,MAAMrd,GAAK,IACpE1C,OAAOE,eAAekB,KAAM,UAAW,CAAE,GAAAC,GAAQ,OAAOD,KAAK2e,MAAMnf,OAAS,IAC5EZ,OAAOE,eAAekB,KAAM,QAAS,CAAE,GAAAC,GAAQ,OAAOD,KAAK2e,MAAM7a,KAAO,IACxElF,OAAOE,eAAekB,KAAM,WAAY,CACpC,GAAAC,GACI,OAAOD,KAAK2e,MAAMrf,QACtB,EACA,GAAAiW,CAAI7R,GACA,MAAM,IAAIjF,MAAM,qCACpB,IAMJ,MAAM+B,EAAIR,KACVpB,OAAOD,KAAKqjB,EAAsBa,WAAWzhB,SAAQ2K,IAC7C,SAAS1D,KAAK0D,IAElBnN,OAAOE,eAAe0B,EAAGuL,EAAG,CACxB9L,IAAK,WAED,OAAOO,EAAEme,KAAOne,EAAEme,KAAKpb,QAAKS,CAChC,GACF,GAGV,CACA,wBAAI8e,GACA,OAAO,CACX,CACA,yBAAIC,GACA,OAAO,CACX,CACA,oBAAIC,GACA,OAAOhjB,KAAK2e,KAAKqE,gBACrB,CACA,sBAAIC,GACA,OAAOjjB,KAAK2e,KAAKsE,kBACrB,CACA,sBAAIC,GACA,OAAOljB,KAAK2e,KAAKuE,kBACrB,CACA,YAAI5jB,GACA,OAAOU,KAAK2e,MAAMrf,QACtB,CACA,WAAI2E,GACA,OAAOjE,KAAK2e,MAAM1a,OACtB,CACA,YAAIkf,GACA,OAAOnjB,KAAK2e,MAAMwE,QACtB,CAEA,UAAI3Z,GACA,OAAOxJ,KAAK2e,MAAMnV,MACtB,CAGA,iBAAA4Z,CAAkBrH,EAAatX,EAAQiV,EAAM2J,EAAe7E,GACxD,MAAM,KAAEG,EAAI,OAAE5e,GAAWC,MACnB,UAAEkF,EAAS,WAAEmX,GAAe5X,EAE5B6e,EAAQtjB,KAAK8J,OACnB,IAAIyZ,EAAM,KACNC,EAAM,CAAEjS,KAAM9M,EAAO8M,KAAMwI,IAAKtV,EAAOsV,KAI3C,GAHAsJ,EAAc5e,EAAQiV,GACtBxU,EAAUue,cAAc9E,EAAMla,GAEP,GAAnB+e,EAAIjS,KAAK3O,OAGT,OAFA6B,EAAOiP,gBAAgBvG,eAAemW,GACtCtjB,KAAKiO,QACE,KAMX,GAFAxJ,EAAO6Z,cAAcgF,EAAM,GAEb,MAAVvjB,EACA,MAAM,IAAItB,MAAM,8BAQpB,OANI8kB,EAAMvjB,KAAK0jB,kBAAkB3H,EAAatX,EAAQ+Z,EAAMG,GAE5Dla,EAAO8M,KAAOiS,EAAIjS,KAClB9M,EAAOsV,IAAMyJ,EAAIzJ,IACbyE,GAAMhV,QAAUmV,GACpBla,EAAOia,oBAAoBC,GACpB4E,CACX,CAKA,oBAAAI,CAAqBlf,GACjB,MAAMjE,EAAIR,KACV,IAAI4jB,GAAY,EACZC,GAAoB,EACxB,SAASC,EAAoBrf,GACzB,IAAIsf,EAAWtf,EAAOqF,QACjB8Z,GAAcG,EAASnhB,OAAS,GACjCpC,EAAE2M,eAAe4W,EAGzB,CACA,SAASV,EAAc5e,EAAQiV,GACvBkK,IAGJE,EAAoBrf,GACpBA,EAAOuf,uBAAyBtK,EAAKjV,OAAOF,SAC5Cqf,GAAY,EAChB,CACA,SAASK,EAAoBlkB,GAIzBA,EAAOd,KAAOya,EAAKwK,UACvB,CACA,MAAMxK,EAAOlZ,EAAEkiB,MACf,GAAKliB,EAAE2hB,QAUCzI,EAAK3Z,SACL2Z,EAAK3Z,OAAOd,KAAO8iB,EAAeoC,eAX1B,CAEZ3jB,EAAE2hB,SAAU,EACZ,MAAM,OAAEpiB,GAAWS,EAAEme,KACjB5e,IACA2Z,EAAK3Z,OAASA,EAEd2Z,EAAKwK,WAAankB,EAAOd,KAEjC,CAMA,OAAO,SAAUod,EAAY5X,GAGzBA,EAAOsS,OAASvW,EAChB,MAAM,MAAEoE,GAAUH,EACZQ,EAAajF,KACEyE,EAAOsV,IAA5B,IACIvM,EAAUhN,EAAEsJ,OAChB,MAAM,KAAE6U,GAASne,EACX8iB,EAAQ7e,EAAO8M,KAAK/K,UAAU/B,EAAOsV,KAC3C,IAAI3P,EAAIga,EACR,MAAMtL,EAAcrU,EAAO4X,WAC3BzX,GAAS0D,EAAMvF,IAAI,4BACnB,IACS2W,EAAKyI,UAKNzI,EAAKyI,SAAU,KAGhB/X,KAAIga,YAAanf,EAAWof,kBAAkBf,EAAOjH,EAAY5X,EAAQ4X,GAChF,CAAE,MAAO7d,GAOL,MALWsa,EAAYnT,QACnB+T,EAAKgJ,OACLW,EAAc5e,EAAQiV,GAE1BjV,EAAO8M,KAAO/Q,EAAEsJ,OAASrF,EAAO8M,KAAK/K,UAAU/B,EAAOsV,KAChDvb,CACV,CAEA,IAAIggB,EAAO/Z,EAAOia,oBAAoBrC,GAAY,GAC9CmC,IACAqF,GAAoB,GAGxBrF,EAAQ1F,EAAYlW,OAAS,EAAK6B,EAAOma,oBAAoBD,GAAM,GAAS,KACvEjF,EAAKgJ,QACNhJ,EAAKjV,OAAS,CACVF,SAAUE,EAAOuf,wBAGrBvf,EAAOuf,uBAAyB,CAACtgB,EAAGwR,EAASvQ,EAAOF,KAChD,IAAI+I,EAAU/I,EAAOqF,OACrB,MAAM,WAAE6Y,GAAele,EAAOS,UACxBof,EAAO,CAACpP,UAASyN,cAcvB,OAbIhe,IAAUnE,EAAEme,KAAKzZ,YACjBxB,EAAIe,EAAOuW,8BAA8B9F,EAASxR,IAIlD8J,EAAQ5K,OAAS,GACb4K,GAAW/I,EAAOyS,YACtB1W,EAAE2M,eAAeK,EAAS8W,GAC1B7f,EAAOiP,gBAAgBzF,SAGvBvK,EAAEd,OAAS,GACXpC,EAAE2M,eAAezJ,EAAG4gB,GACjB5gB,CAAC,EAEZgW,EAAKgJ,OAAQ,GAGjBje,EAAOmV,WAAWnV,EAAOsV,KACzB,IAAI9J,EAAI,KACR,MAAMsU,EAAWvC,EAAsBwC,qBAAqBhkB,EAAG6b,EAAY3C,EAAMzU,EAAYoe,EAAeY,GAO5G,GANAzjB,EAAE6hB,iBAAmB,CAAC7U,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,KAC3D,MAAMqD,EAAI0C,EAAS/W,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,GAE5D,OADAsF,EAAoBrf,GACbod,CAAC,EAGRpd,EAAOkS,KAAc,MAANvM,GAA4B,MAAZga,EAC/B,OAAO5jB,EAAE4iB,kBAAkB/G,EAAY5X,EAAQiV,EAAM2J,EAAe7E,GAExE,GAAI/Z,EAAOoS,MAKP,OAFW0N,EAASpjB,MAAMsD,EAAOS,UAAW,CAACsI,EAAS8V,EAAOjH,EAAYjS,EAAI3F,EAAQ+Z,IAMzF,IAKI,GAJa,MAARA,GAAkBhR,EAAQ5K,OAAS,IAEpC4K,EAAU,KAEThN,EAAEiL,OAAQ,CACX,MAAMgZ,EAAcxf,EAAWyf,oCAAoCrI,EAAY,KAAM,GAAI,KAAM5X,GAC/FjE,EAAEiL,QAAS,EACXgZ,EAAYF,SAAWA,CAC3B,CAEAtU,EAAIhL,EAAW0f,iBAAiB,CAC5Bva,KACAoU,OACA4F,WACAd,QACAvH,YAAa4C,EACbla,OAAQA,EACR+I,UACA+W,WACAK,eAAc,CAAC7I,EAAauH,EAAO7e,KAC3B6e,EAAM9U,OAAO5L,OAAS,GACtB6B,EAAO0I,eAAemW,EAAOvH,GAEjCtX,EAAOsV,KAAOuJ,EAAM1gB,OAChB4b,GACA/Z,EAAO2V,cAAcoE,GACdA,EAAKhV,QAET6S,KAIX7b,EAAE4hB,QAAU5hB,EAAEiL,QACdhH,EAAOia,oBAAoBrC,GAAY,EAG/C,CAAE,MAAO7d,GAKL,OAHAsE,QAAQC,IAAI,mBAAoBvE,GAChCslB,EAAoBrf,GACpBQ,EAAW4f,aACJ,IACX,CAGA,GAFAf,EAAoBrf,GACpBA,EAAOsS,OAAS,KACZ9G,KAAOA,aAAa+F,GACpB,MAAM,IAAIvX,MAAM,qBAEpB,OAAK+B,EAAE4hB,QACCnS,IAAMzP,EAAEme,KAKT1O,EAJQoM,CAKnB,CACJ,CAaA,iBAAAqH,CAAkB3H,EAAatX,EAAQ+Z,EAAMnC,EAAYyI,EAAeliB,EAAQmiB,GAC5E,MAAM,OAAEhlB,EAAM,aAAEilB,EAAY,aAAEC,EAAY,QAAEhhB,GAAY8X,GAClD,YAAEmB,GAAgBzY,EACxByY,EAAYnL,QACZmL,EAAY5L,WAAayT,GAAU,GAEnCtgB,EAAOmV,WAAWnV,EAAOsV,KACzB,IAAImL,EAAYF,EACZ9lB,EAAMimB,gBAAgBH,EAAc/gB,EAASghB,GAAgB,GAEjE,GAAIC,EAAUtiB,OAAS,EAAG,CAEtB,IAAIif,EAAI3iB,EAAMkmB,8BAA8B3gB,EAAO8M,KAAM2T,EAAWzgB,EAAQ1E,GAM5E,GALIye,GACIA,GAAMhV,QAAU6S,GAChB5X,EAAO0Y,cAAcqB,GAGzBqD,EAIA,OAFArD,EACI/Z,EAAOia,oBAAoB3C,GAAa,GACrC8F,EAGX,GAAe,OAAX9hB,EAAiB,CAGjB,IAAIslB,EAAUP,EAAgBliB,EAC1B0iB,EAAU7gB,EAAO8M,KAAK/K,UAAU,EAAG6e,GAIvC,OAHA5gB,EAAO0I,eAAemY,EAAS7gB,EAAOqb,UAAUyF,oBAChD9gB,EAAO8M,KAAO9M,EAAO8M,KAAK/K,UAAU6e,GACpC5gB,EAAOsV,IAAM,EACN,IACX,CAEJ,CACA,OAAe,OAAXha,GAEA0E,EAAO0I,eAAe1I,EAAO8M,KAAM9M,EAAOqb,UAAUyF,oBACpD9gB,EAAOsV,IAAMtV,EAAO7B,OACb,MAEJ7C,CACX,CAWA,2BAAOykB,CAAqBhkB,EAAG6b,EAAY3C,EAAMzU,EAAYoe,EAAeY,GACxE,MAAO,CAACzW,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,KAC7C,MAAM,OAAEze,GAAWgc,GACb,UAAE7W,GAAcT,GAChB,SAAE0e,GAAa9G,EACrB7b,EAAE4hB,QAAS,EAEX,IAAIzE,EAAQlZ,EAAOsV,IAEfvG,EAAWhT,EAAEsJ,OACb0b,EAAe,KACfC,EAAiB,EAMrB,GALAhhB,EAAOyY,YAAYnL,QAEnByT,EAAetmB,EAAMwmB,eAAepC,EAAOH,EAAU1e,GACrDA,EAAOmV,WAAWnV,EAAOsV,KACzB0L,EAAiBD,EAAa1hB,MAAQ0hB,EAAanf,QAC9Cmf,EACD,MAAM,IAAI/mB,MAAM,mBAEpB,MAAMiH,EAAO8f,EAAa,GACpBG,EAASrC,EAAM9c,UAAU,EAAGgf,EAAa1hB,OAC/Cwf,EAAQA,EAAM9c,UAAUgf,EAAa1hB,MAAQ4B,EAAK9C,QAClD,MAAMgjB,EAASpS,EAAWmS,EAASjgB,EAC7Bqf,EAAS/C,EAAsB6D,gBAAgB3gB,EACjD0gB,EAAQnhB,EAAQsX,GAWpB,GAVAtX,EAAO8M,KAAOwT,EAASzB,EACvBD,EAAc5e,EAAQiV,GAGtBlM,EAAU/I,EAAOua,kBAAiB,GAClCR,GAAQ/Z,EAAO0Y,cAAcqB,GACzBhR,EAAQ5K,OAAS,GACjB6B,EAAOiP,gBAAgBvG,eAAeK,GAE1CtI,EAAUue,cAAc1H,EAAatX,GACjC1E,EAAQ,CAIR,GAFAkkB,EAAoBlkB,IAEN,IADDgc,EAAY9X,QAErB,MAAM,IAAIxF,MAAM,0CAiBpBkf,EAAQoH,EAAOniB,OAAS6iB,EACxB,IAAI5H,EAAWkH,EAAOve,UAAU,EAAGmX,GAWnC,QAVGE,WAAUF,SAAUlZ,EAAOgZ,eAAejd,EAAGqd,IAEhDpZ,EAAOsV,IAAM4D,EACblZ,EAAOmV,WAAWnV,EAAOsV,KACzBtV,EAAO0I,eAAe0Q,EAAUpZ,EAAOqb,UAAUgG,sBAG7C/lB,GAAWgc,EAAYhY,OAAOnB,OAAS,GACvCmZ,EAAYhY,OAAO3C,SAAQ2K,GAAKhM,EAAOgE,OAAOI,KAAK4H,KAEhDhM,CACX,CAEA,OAAOS,EAAEkjB,kBAAkB3H,EAAatX,EAAQ+Z,EAAMnC,EAClDoJ,EACA/f,EAAK9C,OAAQmiB,EAAO,CAEhC,CASA,sBAAOc,CAAgB3gB,EAAW6gB,EAAWthB,EAAQsX,GACjD,MACMiK,EAAS,CAACD,GAChB,IAAIzC,EAAQpe,EAAU8B,iBAAiB+U,EAAagK,EAFzC,GAEwDthB,EAAQuhB,GAC3E,MAAMjc,EAAYgS,EAAYkK,gBAAkBlK,EAAYpc,SAI5D,OAHIoK,IACAuZ,EAAQpkB,EAAMgnB,aAAanK,EAAahS,EAAWuZ,EAAO,GAAI7e,IAE3D6e,CACX,CAMA,KAAAzf,CAAMY,GACFzE,KAAKiiB,YAAcxd,EAAO6S,QAC9B,EAGJ1Z,EAAQokB,sBAAwBA,C,4BCjgBhCpjB,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAEpD,MAAMoD,UAAiC1D,MACnC0nB,GAEA,WAAArmB,CAAYoI,GAAS,UAAC+N,IAClBpD,MAAM3K,GACNlI,KAAKmmB,GAAKlQ,CACd,EAEJrY,EAAQuE,yBAA2BA,C,4BCXnCvD,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAO,IAWrDnB,EAAQuW,eATR,MACI3P,OACAnF,QACAN,MAIAqnB,W,6BCTJxnB,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,aAAEsnB,GAAiB,EAAQ,OAC3B,yBAAE7W,GAA6B,EAAQ,OACvC,MAAEtQ,GAAU,EAAQ,OACpB,SAAEuB,GAAa,EAAQ,OACvB,YAAEC,GAAgB,EAAQ,OAC1B,WAAEiB,GAAe,EAAQ,OACzB,MAAE2G,GAAU,EAAQ,OACpB,kBAAE6K,GAAsB,EAAQ,OAChC,iBAAE2N,GAAqB,EAAQ,OAC/B,iBAAE9K,GAAqB,EAAQ,KAC/B,YAAE7W,GAAgB,EAAQ,OAC1B,gBAAEiD,GAAoB,EAAQ,OAC9B,gBAAEgJ,GAAoB,EAAQ,MAC9B,iBAAElJ,GAAqB,EAAQ,OAC/B,qBAAEye,GAAyB,EAAQ,OACnC,iBAAE2F,EAAgB,eAAEvE,EAAc,gCAAEwE,GAAoC,EAAQ,OAChF,oBAAElS,GAAwB,EAAQ,OAClC,WAAEpD,GAAe,EAAQ,OACzB,UAAEjS,GAAc,EAAQ,OACxB,0BAAEihB,GAA8B,EAAQ,OACxC,eAAE9L,GAAmB,EAAQ,OAC7B,kBAAEzE,GAAsB,EAAQ,OAChC,8BAAEa,GAAkC,EAAQ,MAC5C,0BAAEH,GAA8B,EAAQ,OACxC,qBAAErC,GAAyB,EAAQ,MACnC,gBAAEiD,GAAoB,EAAQ,MAiCpC,IAAIwV,EAIAC,EAxBJvnB,EAAMyB,QAAU,CACZD,cACAD,WACAuV,mBACA7W,cACAiD,kBACAgJ,kBACAlJ,mBACAye,uBACArY,QACA2I,aACAjS,YACAihB,4BACAzQ,2BACA2E,iBACAzE,oBACAa,gCACAxC,wBAWJ,MAAM/C,EAKF0b,WAIApnB,SAIAqnB,WAIArW,UAOAsW,kBAIAhiB,MAKA4Y,SAMAhe,QAMAgF,OAEAqiB,mBAEAC,kBAEAC,UAKAC,KAKAC,eAKA5mB,KAKAyJ,OAOA,0BAAWod,GACP,OAAOT,CACX,CAIA,0BAAWS,CAAgBnoB,GACvB0nB,EAAsB1nB,CAC1B,CAKA,uBAAWooB,GACP,OAAOX,CACX,CAIA,uBAAWW,CAAazjB,GACpB8iB,EAAkB9iB,CACtB,CACA,2BAAO0jB,CAAqB5d,EAAQ/E,GAChC,MAAO,CACHpF,QAASmK,EAAOnK,QAChB8H,UAAW1C,EAAO8W,YAClBlV,OAAQ5B,EAAO4B,OACf2X,aAAcvZ,EAAOuZ,aACrBjf,MAAOyK,EAAOzK,OAAgB,CAAGA,MAAO0F,EAAOqF,OAAQgM,OAAQrR,EAAOpE,MAE9E,CAIAkE,SAMA8iB,SAMA5O,KAKA,WAAA3Y,GAII,IAAIwnB,EACAC,EACAC,EAAS,CACTC,gBAAiB,EACjBC,aAAc,MAElB1nB,KAAK4E,OAAQ,EACb5E,KAAKV,SAAW,GAChBU,KAAK2mB,WAAa,CAAC,EAMnB/nB,OAAOE,eAAekB,KAAM,WAAY,CAAEC,IAAG,IAAYqnB,EAAe,GAAA/R,CAAIxW,GAASuoB,EAAavoB,CAAM,IAIxGH,OAAOE,eAAekB,KAAM,OAAQ,CAAEC,IAAG,IAAYunB,IACrD5oB,OAAOE,eAAekB,KAAM,WAAY,CAAEC,IAAG,IAAYsnB,IAGzDvnB,KAAK6c,UAAare,IACdwB,KAAK2nB,SAASxjB,KACV6M,EAAgBxS,GACnB,EAELwB,KAAK4nB,eAAiB,SAAU9mB,GAC5BymB,EAAazmB,SACNd,KAAK4nB,cAChB,CAGJ,CAEA,UAAA/C,GAEI,KAAM,WAAY7kB,MAAO,CACrB,MAAMQ,EAAIR,MACV,WACI,IAAI6nB,GAAQ,EACZjpB,OAAOE,eAAe0B,EAAG,SAAU,CAC/BP,IAAG,IACQ4nB,EAEX,GAAAtS,CAAI7R,GACAmkB,EAAQnkB,CACZ,GAEP,CAVD,EAWJ,CAEJ,CAIA,gBAAAyX,CAAiBjG,EAAS1H,EAAS/I,GAC/BzE,KAAK2iB,YAAYxH,iBAAiBnb,KAAMkV,EAAS1H,EAAS/I,GAI1DA,EAAOkN,WAAY,EACnBlN,EAAOqS,cAAe,EACtBrS,EAAOqjB,YAAa,EACpBrjB,EAAO1C,eAAiB,KACxB0C,EAAOgK,YAAchK,EAAOiP,gBAAgB/E,kBAE5ClK,EAAOmT,aAAazT,KAAKM,EAAOgK,YAAahK,EACjD,CAIA,YAAIqP,GACA,OAAO9T,KAAK+nB,SAASjU,QACzB,CAIA,YAAIA,CAAS/U,GACTiB,KAAK+nB,SAAWhpB,CACpB,CACA,SAAAipB,GACI,MAAM/mB,EAAI,aACV,IAAI4L,EAAMjO,OAAOD,KAAKqB,MAClByD,EAAMoJ,EAAI5I,QAAQhD,GAGtB,cAFQ4L,EAAIpJ,GACZoJ,EAAI/G,QAAQ7E,GACL4L,CACX,CAOA,aAAAob,CAAcC,EAAYhnB,EAAGinB,GACzB,MAAMC,EAAY,CACd9oB,SAAS4B,GACEgF,MAAMC,QAAQjF,GAEzBylB,WAAWzlB,GACc,iBAAP,EAElB0D,MAAM1D,GACmB,kBAAP,GAAoB,eAAemH,KAAKnH,GAE1Dsc,SAAStc,GACQ,MAALA,GAA4B,iBAAP,EAEjCoP,UAAUpP,GACO,MAALA,GAA4B,iBAAP,GAGrC,IAAImnB,EAAID,EAAUF,GAClB,GAAIG,IAAMA,EAAEnnB,GAAI,CACZ,GAAIinB,EACA,MAAM,IAAI1pB,MAAM,IAAIypB,mBAExB,OAAO,CACX,CACA,OAAO,CACX,CASA,UAAAhoB,CAAWC,EAAQC,EAAWC,EAAMC,GAChC,MAAMgoB,EAAiBnoB,EAAOooB,kBAAoB9nB,EAE5CO,EAAQ,CACV4D,MAAM1D,GACgB,kBAAP,EACHA,EACOwO,EAAkBG,WAEtB,KAEJH,EAAkBK,KAAK7O,GAElC,UAAAwlB,CAAWxlB,EAAGf,GACV,MAAMqoB,EAAS,CAAC,EAChB,IAAK,IAAIjlB,KAAKrC,EAAG,CACb,IAAIJ,EAAII,EAAEqC,GACNklB,EAAO,IAAIvV,EAEf,GADAuV,EAAK/pB,KAAOgqB,SAASnlB,GACH,iBAAP,EACPklB,EAAKvgB,QAAUpH,MACZ,CACH,MAAM,QAAEoH,EAAO,IAAEygB,EAAG,QAAEC,GAAY9nB,EAClC2nB,EAAKE,IAAMA,EACXF,EAAKvgB,QAAUA,EACfugB,EAAKG,QAAUA,CACnB,CACAJ,EAAOjlB,GAAKklB,CAChB,CACA,OAAOD,CACX,EACAlpB,SA7BaJ,EAAM0B,wBAAwBT,EAAQM,EAAUC,GA8B7D,UAAAimB,CAAWzlB,EAAGf,GACV,IAAImG,EAAO,CAAC,EACRjC,EAAK,KACT,MAAM,SAAEwkB,GAAa1oB,EACrB,IAAK,IAAIoD,KAAKrC,EACVmD,EAAK,IAAIikB,EACT3mB,EAAWC,UAAUzB,EAAQkE,EAAInD,EAAEqC,GAAIA,EAAGc,GAC1ClE,EAAO2oB,WAAWzkB,GAClBiC,EAAK/C,GAAKc,EAGd,OADAlE,EAAO4oB,cAAgB,KAChBziB,CACX,EACA1B,MAAM1D,GACgB,kBAAP,EACAA,IAEDA,EAEdsc,SAAQ,CAACtc,EAAGf,IACC,MAALe,EACO,KAEHS,EAAWC,UAAUzB,EAAQ,IAAI2gB,EAAkB5f,GAG/DsD,OAAM,CAACtD,EAAGf,IACF+F,MAAMC,QAAQjF,GACPA,EAEJ,MAGf,IAAIc,EAAKhB,EAAMZ,GACf,OAAI4B,EACOA,EAAG3B,EAAMF,EAAQG,GAErBD,CACX,CAOA,WAAO0P,CAAK3Q,EAAM4pB,GACd,MAAM3oB,EAAO,QAAQ,KAAmBjB,EAAO,oBAC/C,OAAIiB,EACO2K,EAAWie,WAAW5oB,EAAM2oB,GAEhC,IACX,CAOA,iBAAOC,CAAW5oB,EAAM2oB,GACpB,MAAME,EAAS,CAAC,EAChB,IAAIC,EAAsB,KAC1B9C,EAAa+C,OACb,MAAMlkB,EAAYhG,EAAMmqB,cAAcre,EAAY3K,EAAM,CACpD,UAAAyoB,CAAWrnB,IACDA,aAAahB,GAAcgB,aAAatC,IAAkBsC,EAAM,MAClEzB,KAAKspB,aAAa7nB,EAAErC,KAE5B,EACA,YAAAkqB,CAAaroB,GACLA,EAAE2B,QAAU,IAChBsmB,EAAOjoB,GAAK,EAChB,GACD+nB,GA+BH,OA9BApqB,OAAOE,eAAeoG,EAAW,gBAAiB,CAAEjF,IAAG,IAAYipB,IACnEhkB,EAAUqkB,wBAA0B,WAChC,GAA2B,MAAvBJ,EACA,OAAOA,EAEX,IAAIN,EAAW,CAAC,EACZW,EAAS,GACb,IAAK,IAAIjmB,KAAK2lB,EAAQ,CAClB,GAAS,UAAL3lB,EACA,MAAM,IAAI9E,MAAM,sBAEpB8E,EAAE+F,MAAM,KAAKlI,SAAQK,IAEjBvC,EAAMuqB,WAAWhoB,OAAGuC,EAAW6kB,GAC/B,IAAI5nB,EAAIQ,EAAE6H,MAAM,KAAK,IACK,GAAtBkgB,EAAOvlB,QAAQhD,IACfuoB,EAAOrlB,KAAKlD,EAChB,GAER,CAEA,OADAkoB,EAAsB,CAAEO,WAAYF,EAAQX,YACrCM,CACX,EACKjkB,EAAUsY,WACXtY,EAAUsY,SAAW,IAAIsD,GAG7BliB,OAAOE,eAAeoG,EAAW,aAAc,CAAEjF,IAAG,IAAYiF,EAAUsY,SAASiE,6BACnF7iB,OAAOE,eAAeoG,EAAW,oBAAqB,CAAEjF,IAAG,IAAY+oB,IACvE3C,EAAasD,UACNzkB,CACX,CACA,0BAAO0kB,GACH,OAAO,IAAI9I,CACf,CACA,KACI,MAAM,SAAEvc,GAAavE,KACrB,IAAIqE,EAAK,KAQT,OAPIE,IAGIF,EAFqB,mBAAd,EAEFE,EAASpD,MAAMnB,MAEfuE,GAENF,GAAM,IAAI8O,CACrB,CAMA,GAAgB1O,GACZ,MAAM6T,EAAM7T,GAAUzE,KAAKwd,UAAYxS,EAAW4e,sBAElD,IAAIxR,EAAYpY,MAAK,IAEjBmY,EAAmB,IAAI/M,EAC3B+M,EAAiB/Z,GAAK,WACtB,MAAMia,EAAkB,CACpBwR,qBAAsB,IAAIC,EAC1BC,aAAc,IAAIC,EAClBhK,eAAgB,IAAIiK,EACpB1E,mBAAoB,IAAI2E,EACxBpE,qBAAsB,IAAIqE,EAC1BC,4BAA6B,IAAIA,EACjCrK,iBAAkBsK,GAEtB,IAAIhD,EAAW,IAAInlB,EAAiBlC,KAAMmY,EAAkBC,EAAWC,EAAiBC,GAExF,OADAtY,KAAK4nB,eAAeP,GACbA,CACX,CAOA,WAAAiD,CAAYjqB,EAAMgJ,EAAQ5E,GACtB,MAAM,IAAIhG,MAAM,0BACpB,CACA,UAAA8rB,GACI,IAAI,MAAE3lB,GAAU5E,KACA,QAAV4E,GAA6BZ,MAATY,GAAwBA,aAAiB8K,IAG/D9K,EADkB,kBAAX,EACCA,EAAQ8K,EAAkBG,WAAa,MACxCjL,GAAWA,aAAiB8K,EAG3B,KAFAA,EAAkBK,KAAKnL,GAGnC5E,KAAK4E,MAAQA,EACjB,CAOA,MAAAhF,CAAOS,EAAMoE,EAAO,MAKhB,GAJAzE,KAAKuqB,aACLlE,EAAa+C,QAGRljB,MAAMC,QAAQ9F,GAAO,CACtB,GAAqB,iBAAV,EAGN,MAAM,IAAI5B,MAAM,sBAFjB4B,EAAOA,EAAKiJ,MAAM,KAG1B,CACA,QAA+B,IAAnBtJ,KAAc,UACtB,MAAM,IAAIvB,MAAM,4BAEpB,IAAI,SAAE4oB,EAAQ,KAAE5O,GAAQzY,KAKnBqnB,EAG2B,GAAxB5O,EAAKgP,iBACLJ,EAAStV,QAHbsV,EAAWrnB,MAAK,EAAgByE,GAOpC4iB,EAAS3Q,aAAejS,EAGxB,IAAI+lB,EAAe,KACfvlB,EAAajF,KACbyqB,GAAa,EAEjB,MAAM,MAAE7lB,EAAK,SAAEkP,GAAauT,GACtB,QAAE1T,EAAO,UAAEuN,GAAclhB,KAAKwd,SAE/Bxd,KAAKyY,MAAMgP,kBACZJ,EAAS7S,cAAe,GAExBxU,KAAKyY,MAAMgP,kBACXgD,GAAa,GAGjB,MAAMC,EAAiB,CAAC1lB,EAASP,KAC7B,GAAIA,EAAOgK,aAAagK,MAAMkS,QAAS,CACnC,MAAM9I,EAAIpd,EAAOgK,YAAYqG,WAE7B,KAAO9P,EAAQpC,OAAS,GAAMoC,EAAQ4lB,SAAS/I,IAC3C7c,EAAUA,EAAQwB,UAAU,EAAGxB,EAAQpC,OAASif,EAAEjf,OAAS,GAAGyL,SAEtE,CACA,OAAOrJ,CAAO,EAMZ6lB,EAAa,KACf,MAAM,WAAElI,GAAe1d,EAEvB,SAAS6lB,EAAwBC,EAAkBtmB,GAC/C,MAAM,IAAEsV,GAAQtV,EAChB,IAAKsmB,GAAoBtmB,EAAO4S,gBAAmB5S,EAAOxB,MAAMY,MAAQkW,EAAM,CAC1E,IAAIiR,EAAKvmB,EAAO8M,KAAK/K,UAAU/B,EAAOxB,MAAMY,MAAOkW,GAC/CiR,EAAGxc,OAAO5L,OAAS,GACnB6B,EAAO0I,eAAe6d,EAAIvmB,EAAOkb,mBACrClb,EAAOmV,WAAWG,GAClBtV,EAAO4S,gBAAiB,CAC5B,CACJ,CACA,MAAM4T,EAAqBhmB,EAAWwT,KAAKgP,gBAAkB,GACvD,YAAEvK,EAAW,aAAEtF,GAAiByP,EACtC,IAAI6D,EAAkB,EAmItB,GAjIA7qB,EAAKe,SAASmQ,IAEV8V,EAASnR,WAAagV,EACtBA,GAAmB3Z,EAAK3O,OAAS,EAEjC,IAAImoB,GAAmB,EAEvB,GADAnT,EAAa3J,QACTjO,KAAKmrB,OACL,OAKJ,MAAM1mB,EAAS4iB,EAQf,GAPAziB,GAAOgL,QAAQ,cAAgBtH,EAAMvF,IAAI,SAAWskB,EAASpR,UAAY,OAAS1E,GAClF8V,EAAS1N,aACTuD,EAAY5L,WAAaC,EACzB8V,EAASlR,UAAW,EACpBkR,EAASpR,YACToR,EAAS9Q,YAAc,EACvB8Q,EAAS1V,WAAY,EACjB6Y,EAAc,CACd,IAAKA,EAAahhB,OAAO4hB,eACrB,MAAM,IAAI3sB,MAAM,WAAW+rB,EAAaprB,kCAE5CioB,EAASlR,SAAWqU,EAAahhB,OAAOsZ,qBACxCuE,EAASjR,UAAW,EACpBoU,EAAevlB,EAAWomB,cAAcb,EAAcnD,EAE1D,KAAO,CACH,IAAIiE,EAAab,IAAevJ,EAAYmG,EAAS9V,KAAKhD,YAAc8Y,EAAS9V,KAC7E8V,EAAS1P,gBACT2T,EAAYjE,EAAS1P,cAAgB2T,EACrCjE,EAAS1P,cAAgB,MAG7B,IAAI4T,EAAiBlE,EAAS9V,KAAK3O,OAAS0oB,EAAU1oB,OAEtDykB,EAASnR,YAAcqV,EAEvBrO,EAAY5L,WAAaga,EACzBb,GAAa,CACjB,CACA,GAAIlZ,EAAK3O,QAAU,EACf,OAEJ,IAAI4oB,EAAKnE,EAASzkB,OACdmX,EAAMsN,EAAStN,IACnB9U,EAAWwmB,gBAAgBpE,EAAkB,GAAPtN,IAAcsN,EAASvQ,cAC7DuQ,EAASvJ,YACT,IAAI4N,EAAY3R,EAChB,KAAOA,EAAMyR,GAAI,CAKb,GAJAnE,EAASlR,UAAW,EACpB4U,GAAmB,EACnB1D,EAAS9Q,YAAc,EACvBmV,EAAY3R,EACRyQ,EACAnD,EAASlR,UAAW,EACpBkR,EAASzN,WAAWyN,EAAStN,KAC7ByQ,EAAevlB,EAAWomB,cAAcb,EAAcnD,QAGtD,GADAmD,EAAetrB,EAAMysB,kBAAkB3rB,KAAKV,SAAU+nB,GAClDmD,EACAxqB,KAAKyrB,gBAAgBpE,EAAUA,EAAS1V,WACxC0V,EAASzN,WAAWG,EAAKyQ,EAAa1mB,OACtC0mB,EAAevlB,EAAWomB,cAAcb,EAAcnD,GACtDyD,GAAwB,EAAOzD,OAC5B,CACHA,EAAS9Q,YAAc,EACvB,IAAIqV,EAAIvE,EAAS9V,KAAK/K,UAAU6gB,EAAStN,KACpCkR,IACDW,EAAIA,EAAEvd,WACNgZ,EAASvQ,eACT8U,EAAInB,IAAevJ,EAAY0K,EAAErd,YAAcqd,GAE/CA,EAAEhpB,OAAS,IACX5C,KAAKyrB,gBAAgBpE,EAAUA,EAAS1V,WACxC0V,EAASla,eAAeye,EAAGvE,EAAS1H,oBAExC0H,EAAStN,IAAMyR,CACnB,CAqBJ,GAnBAzR,EAAMsN,EAAStN,IACfyR,EAAKnE,EAASzkB,OACd,CAAE6B,IACE,MAAM,SAAE+R,GAAa/R,EACrB,GAAIinB,GAAa3R,EAAK,CAMlB,GAJIvD,EAASuH,SAAWyM,IACpBhU,EAASuH,QAAUyM,GAEvBhU,EAAShF,SAAWuI,EAChBvD,EAAS5I,MAAQ,EAClB,MAAM,IAAInP,MAAM,0BAA4BmK,KAAKC,UAAU2N,IAG9DA,EAAS5I,OACb,MACI4I,EAAS5I,MAAQ,CAExB,EAhBD,CAgBGyZ,GACCrnB,KAAKmrB,OACL,OAEJL,EAAwBC,EAAkB1D,EAC9C,CACAyD,EAAwBC,EAAkB1D,GAE1CA,EAASjR,UAAW,EAChBoU,IACIgB,GAAMzR,GAGFsN,EAASzQ,KAAM,EACX4T,EAAaqB,mBAAmBxE,IAChCA,EAASnK,YAAYlL,YAAY+H,EAAKA,GAE1CyQ,EAAevlB,EAAW6mB,wBAAwBtB,EAAcnD,GAChEA,EAASzQ,KAAM,GAMnB5W,KAAK+rB,wBAAwBvB,EAAcnD,IAGnD1E,EAAWqJ,wBAAwBxB,EAAc/lB,EAAO,IAExDzE,KAAKmrB,OAEL,OADAnrB,KAAKmrB,QAAS,EACP,KAgCX,GA9BA,CAAE1mB,IAEE,GAAI+lB,EACA,GAAKxqB,KAAKyY,KAAKgP,iBAeX,GAAI+C,EAAazqB,OACb,MAAM,IAAItB,MAAM,gCAhBQ,CAM5B,IALAmG,GAAS0D,EAAMvF,IAAI,YAAcynB,EAAa1V,YAC9CrQ,EAAOkS,KAAM,EACblS,EAAOyY,YAAYnL,QAGZyY,GAIHA,EAAevlB,EAAWomB,cAAcb,EAAcnD,GACtD5iB,EAAOyY,YAAYnL,QAEvBtN,EAAOkS,KAAM,CACjB,CAKP,EAtBD,CAsBG0Q,GAEHziB,GAAOgL,QAAQ,SACXtH,EAAMvF,IAAI,aACVD,QAAQC,IAAI,CACR6Q,MAAOyT,EAASzT,SAGnByT,EAAShL,WAAWzZ,OAAS,GAAoC,GAA7B5C,KAAKyY,KAAKgP,gBAAuB,CACtE,MAAMwE,EAAcjsB,KAAK2iB,WAEzB,KAAO0E,EAAShL,WAAWzZ,OAAS,GAAG,CACnC,IAAI4b,EAAO6I,EAAShN,cACpBra,KAAKksB,yBAAyB1N,EAAM6I,EAAU4E,EAClD,CAEJ,MACI5E,EAAShL,WAAWzZ,OAAS,EAEjCykB,EAASrU,QACT,IAAIhO,EAAU,GAEd,IAAKhF,KAAKyY,MAAMgP,iBAAoBJ,EAASlgB,UAAUvE,OAAS,EAC5D,MAAM,IAAInE,MAAM,0BAEpB,IAAKuB,KAAKyY,MAAMgP,iBAAmBznB,KAAKuE,SAAU,CAE9C,MAAM,SAAEA,GAAavE,KAAKqnB,UACpB,WAAEtT,EAAU,UAAEF,EAAS,YAAEsY,GAAgB5nB,EAC3C4nB,EACAnnB,EAAUT,EAAS4nB,YAAY,CAAE3mB,OAAQ6hB,EAAS7hB,OAAQsO,WAAUH,UAASlP,OAAQzE,KAAKqnB,YAE1FriB,EAAUqiB,EAAS7hB,OAAOuF,KAAK+I,GAAUzF,UACzCrJ,EAAU0lB,EAAe1lB,EAASqiB,IAGlCxT,IACA7O,GAAWT,EAASsP,UAAU,CAAEC,cAEhCC,IACA/O,GAAWT,EAASwP,aAE5B,MACI/O,EAAUqiB,EAAS7hB,OAAOuF,KAAK+I,GAC1B9T,KAAKyY,MAAMgP,kBACZziB,EAAUA,EAAQqJ,UAClBrJ,EAAU0lB,EAAe1lB,EAASqiB,IAK1C,OADArnB,KAAKqnB,SAAS3T,gBAAgBtF,WACvBpJ,CAAO,EAElB,IAAIA,EAAU,KACd,IACIA,EAAU6lB,IACwB,GAA7B7qB,KAAKyY,KAAKgP,iBAAuD,mBAArBhjB,GAAQ2nB,UACrD3nB,EAAO2nB,SAAS,CAAElnB,UAAWlF,MAErC,CAAE,MAAOxB,GACDwB,KAAKiI,OACA/B,MAAMC,QAAQnG,KAAKiI,SACpBjI,KAAKiI,MAAQ,CAACjI,KAAKiI,QAEvBjI,KAAKiI,MAAM9D,KAAK3F,EAAE0J,UAGlBlI,KAAKiI,MAAQzJ,EAAE0J,QAEnBtD,GAAS9B,QAAQmF,MAAM,WAAazJ,EAAE0J,QAC1C,CAEA,OADAme,EAAasD,UACN3kB,CACX,CACA,eAAAymB,CAAgBhnB,EAAQkN,GAAY,GAC5BlN,EAAO2S,oBACP3S,EAAO2S,qBAAsB,GAGjC3S,EAAOkN,UAAYA,EACflN,EAAOqS,eACFrS,EAAOiP,gBAAgB/H,UACxBlH,EAAOuO,QACPvO,EAAOqS,cAAe,GAE1BrS,EAAOkN,WAAY,GAE3B,CAMA,uBAAAma,CAAwB/P,EAAatX,GACjC,MAAM,MAAEG,GAAUH,EAClBG,GAAS0D,EAAMvF,IAAI,+BAAiCgZ,EAAYjH,YAChE,IAAI1K,EAAK,KACLga,EAAW,KACXd,EAAQ7e,EAAO8M,KAAK/K,UAAU/B,EAAOsV,KAIzC,QADG3P,KAAIga,YAAapkB,KAAKqkB,kBAAkBf,EAAOvH,EAAatX,IAC3D2F,GAAmB,MAAZga,GAGPha,GAAMga,GACFA,EAAS1T,MAAM5M,OAASsG,EAAGtG,MAHxB9D,KAAKqrB,cAActP,EAAatX,GAWvC2f,EAEIA,EAASiI,gBAEErsB,KAAKssB,uBAAuBlI,EAAU,GAAI,KAAM3f,EAAQ,KAAM,KAAM,IAAI,GAGhFzE,KAAKqrB,cAAcjH,EAAU3f,GAEjCsX,CACX,CACA,qBAAAwQ,CAAsBnI,EAAU3f,GAG5B,OAFAzE,KAAKwsB,2BAA2BpI,EAAU3f,GAC/BzE,KAAKqrB,cAAcjH,EAAU3f,EAE5C,CAOA,uBAAAsnB,CAAwB7W,EAASzQ,EAAQgoB,GAAQ,GAE7C,MAAM,WAAE9J,GAAe3iB,KACnBkV,EAAQwX,eACR/J,EAAWgK,mBAAmB3sB,KAAMkV,EAASzQ,EAAQgoB,GAErDzsB,KAAK4sB,gBAAgBnoB,EAAQyQ,EAASuX,EAE9C,CACA,wBAAAI,CAAyBrf,EAAS0H,EAASzQ,GACvCA,EAAOiP,gBAAgBzF,QACvBxJ,EAAO0I,eAAeK,EAAS0H,GAC/BzQ,EAAOuO,QACPxF,EAAU/I,EAAOoG,OAAM,GACvBpG,EAAOiP,gBAAgBvG,eAAeK,EAAS0H,EACnD,CAQA,wBAAA4X,CAAyBtjB,EAAQ/E,EAAQ+Z,GAGrC,MAAM,gBAAEuO,EAAe,MAAErc,EAAK,iBAAEsS,GAAqBxZ,EACrD,IAAIY,EAAK,GACL8H,EAAQ,GACZ,IAAK8Q,EAAkB,CACnB,GAAwBhf,MAAnB+oB,GAAsD,OAApBA,EAEnC,GAAIA,aAA2Bxc,EAA+B,CAC1D,MAAM1L,EAASuL,EAA0BC,IAAIrQ,KAAKsQ,WAElD,IAAI0c,EAAUD,EAAgBtc,KAAKC,GAC9B5P,GAAM5B,EAAM+tB,kBAAkB/tB,EAAMguB,cAAcpsB,GAAI4P,IACvD7L,EAAQ2Z,GAAMne,KAAMmJ,EAAQ/E,GAChC,GAAI+Z,EAIA,OAFAA,EAAK2O,QAAUH,EACf5iB,EAAKlL,EAAMmL,eAAe,IACnBD,CAEf,MACI8H,EAAQhT,EAAM+tB,kBAAkBF,EAAiBrc,QAGjD8N,GAAuC,QAA9BA,EAAKhV,OAAOlI,IAAIwT,aACzB5C,EAAQhT,EAAM+tB,kBAAkB/tB,EAAMguB,cAAc1jB,EAAOlI,KAAMoP,IAGzEwB,EAAQA,EAAQA,EAAMkb,QAAQ,MAAO,IAAM,EAC/C,CAKA,OAJAhjB,EAAGjG,KAAK+N,GACR9H,EAAGvH,QAAU,CAAC,CAAC,EAAGqP,EAAMtP,SACxBwH,EAAGtG,MAAQ,EACXsG,EAAGzC,MAAQ,KACJyC,CACX,CACA,wBAAA8hB,CAAyB1N,EAAM/Z,EAAQwnB,GAEnC,MAAM,OAAEziB,GAAWgV,EACbwH,EAASxc,EAAOkH,MACtB,GAAIlH,EAAOA,OAAOuZ,sBACd,MAAM,IAAItkB,MAAM,kBAEpB,GAAI+K,EAAOwZ,iBACP,OAEJ,IAAI9Q,EAAQ,GAERoT,EADS7gB,EAAO8M,KACD/K,UAAUwf,EAAOliB,OAEF,QAA9B0a,EAAKhV,OAAOlI,IAAIwT,aAChB5C,EAAQhT,EAAM+tB,kBAAkB/tB,EAAMguB,cAAc1jB,EAAOlI,KAAM0kB,EAAQ,QAC7E9T,EAAQA,EAAMkb,QAAQ,MAAO,IAC7BnB,EAAYoB,yBAAyB,CAAE5oB,SAAQ+Z,SAC/C,IAAIpU,EAAK,GACLie,EAAI,KAIR,GAHAje,EAAGjG,KAAK+N,GACR9H,EAAGvH,QAAU,CAAC,CAAC,EAAGqP,EAAMtP,SACxBwH,EAAGtG,MAAQ,EACP0F,EAAO6L,QAAS,CAChB5Q,EAAO8M,KAAOW,EACdzN,EAAOsV,IAAM,EACb,IAAIvM,EAAU/I,EAAOqF,OASrB,OARAue,EAAI4D,EAAYqB,oBAAoB,CAChCruB,KAAMuK,EAAOvK,KACb6K,OAAQ0D,EACR/I,OAAQA,EACRS,UAAWlF,OAGfqoB,EAAS,MAALA,EAAY7J,EAAK2O,QAAU1oB,EAAOoG,OAAM,GAAQwd,EAC7CroB,KAAKutB,uBAAuBlF,EAAGnW,EAAO1I,EAAQY,EAAI3F,EAAQ+Z,EACrE,CAEA,MAAMgP,EAAMlI,EAAQ1iB,OAKpB,OAJAwH,EAAGtG,MAAQ0pB,EACXlI,GAAWpT,EACXzN,EAAOsV,IAAMyT,EACb/oB,EAAOmV,WAAW4T,GACXxtB,KAAKutB,uBAAuB,GAAIjI,EAAS9b,EAAQY,EAAI3F,EAAQ+Z,EACxE,CAEA,gBAAAiP,CAAiBvY,EAASzQ,GACtB,OAAOyQ,EAAQG,UAAY5Q,EAAO0R,QACtC,CAMA,WAAAuX,CAAYjpB,GACRA,EAAOmP,QACP,MAAM,OAAEpO,EAAM,QAAEmO,EAAO,MAAEC,EAAK,gBAAEF,EAAe,SAAEnP,GAAaE,EACtB,mBAA5BF,GAAUkP,eAClBlP,EAASkP,cAAc,CAAE3J,OAAQ,GAAI4J,kBAAiBlO,SAAQmO,UAASC,UAK3EnP,EAAOuP,YAAa,CACxB,CAKA,SAAAiG,GACI,MAAO,CAACja,KAAKsQ,UACjB,CAOA,iBAAAqd,CAAkB7U,EAAaxX,GAAM,GAEjC,GAAIwX,aAAuB3Z,EACvB,OAAO2Z,EAAYnZ,SAEvB,MAAM,OAAE6J,GAAWsP,EACnB,IAAKtP,EACD,OAAO,KAGX,GAAa,GADCA,EAAOgZ,UACL,CACZ,MAAM1hB,EAAIQ,EAAMkI,EAAOQ,YAAcR,EAAOokB,cAC5C,MAAO,IAAKpkB,EAAO7J,YAAamB,EACpC,CACA,MAAO,IAAK0I,EAAO7J,SACvB,CAOA,kBAAAkuB,CAAmBrkB,EAAQ/E,GACvB,MAAM,KAAErF,EAAI,cAAEuc,EAAa,UAAE6G,GAAchZ,GACrC,UAAErC,GAAc1C,EAElBrF,GAAsB,GAAbojB,IAAqB7G,IAC9Bzc,EAAM6H,YAAY3H,EAAM+H,GACxBqC,EAAOmS,eAAgB,EAE/B,CACA,8BAAAmS,CAA+B5Y,EAASzQ,GACpCzE,KAAK+tB,2BAA2B7Y,EAASzQ,GACzCA,EAAOmV,WAAWnV,EAAOsV,IAC7B,CAMA,aAAAsR,CAAcnW,EAASzQ,GACnB,IAAKyQ,EAAS,OACTzQ,EAAO0R,UACRnW,KAAK8tB,+BAA+B5Y,EAASzQ,GAGjD,MAAM,UAAE+d,GAActN,EAAQ1L,OAC9BxJ,KAAK6tB,mBAAmB3Y,EAASzQ,GACjCA,EAAO8R,cAEP,MAAMyX,EAAShuB,KAAKiuB,gBAAgBzL,EAAW/d,IAC3C,EAAEhD,EAAGgD,IAAWhD,EAAEkiB,qBAAuBliB,EAAEkiB,qBAAqBlf,GAAU,KAA1E,CAAgFyQ,EAAQ1L,OAAQ/E,GACpG,IAAKupB,GAA8B,mBAAZ,EACnB,MAAM,IAAIvvB,MAAM,+CAAiD+jB,GAErE,IAAIe,EAAMyK,EAAO7sB,MAAMnB,KAAM,CAACkV,EAASzQ,IAEvC,OADAzE,KAAKkuB,wBAAwBhZ,EAASqO,EAAK9e,GACpC8e,CACX,CAWA,qBAAA4K,CAAsBjZ,EAASnW,EAAO2R,EAAOjM,EAAQ2pB,EAASzpB,GAAQ,GAClE,IAAIM,EAAajF,KACjB,MAAM,YAAEP,EAAW,qBAAE+B,GAAyB0T,EAC9C,IAAI2M,EAAInR,EAER,GADA0d,EAAUA,GAAW,CAAC,GACjB3uB,EAED,OADA2uB,EAAQC,UAAW,EACZtvB,EAEX,IAAIkV,EAAOxU,EAKX,GAHIwU,aAAgBvS,IAChBuS,EAAO,CAACA,KAER/N,MAAMC,QAAQ8N,GAuBb,CACD,IAAIqa,EAAOpvB,EAAMguB,cAAcztB,GAC/B,MAAM8uB,EAAQ/sB,EACd,IAAID,EAAQgtB,GAAOhtB,MACnB,MAAMwI,EAAYwkB,GAAO5uB,SAEzB,GAAI4B,EAAO,CACP,IAAIoF,EAAM4nB,EAAMC,UAAY,IACxBrS,EAAKjd,EAAM+tB,kBAAkBsB,EAAMtc,MAAO4P,GAC9C,GAAI,QAAQxZ,KAAK1B,GAAM,CACnB,IAAIsJ,EAAI1O,EAAM8G,KAAK8T,GACnB,GAAIxV,IACa,KAAPA,IAAgBsJ,GAAe,MAAPtJ,GAAgB,GAE1C,OADAynB,EAAQC,UAAW,EACZtvB,CAGnB,MAAO,GAAI,UAAUsJ,KAAK1B,GAAM,CAC5B,IAAI8nB,EAAMltB,EAAMuT,WAAWsY,QAAQ,QAAS,IAC5C,IACa,MAAPzmB,GAAiBwV,GAAMsS,GAChB,MAAP9nB,GAAiBwV,GAAMsS,IAErBtS,GAAMsS,EAEN,OADAL,EAAQC,UAAW,EACZtvB,CAGnB,CACJ,CAGA,OADQG,EAAMwvB,cAAc3vB,EAAOkG,EAAYqpB,EAAMzM,EAAG3M,EAASzQ,EAAQsF,EAAWpF,EAExF,CApDI,IAHAsP,EAAOA,EAAKpO,MAAM,GAGXoO,EAAKrR,OAAS,GAAG,CACpB,MAAMpC,EAAIyT,EAAKtO,SACT,WAAE6K,EAAU,MAAEjP,EAAK,SAAE5B,GAAaa,EACxC,GAAKgQ,GAIDjP,EAAO,CACP,MAAM6I,EAAK,CAAEikB,UAAU,EAAMxM,IAAGyM,KAAM,MAChCK,EAASzvB,EAAM0vB,iBAAiBpe,EAAYzR,EAAOyB,EAAG4J,GAC5D,GAAIA,EAAGikB,SAAU,CACb,MAAM,KAAEC,GAASlkB,EAGjB,OAFQlL,EAAMwvB,cAAcC,EAAQ1pB,EAAYqpB,EAAMzM,EAAG3M,EAASzQ,EAAQ9E,EAAUgF,EAGxF,CACJ,CACJ,CAqCJ,OADAypB,EAAQC,UAAW,EACZtvB,CACX,CAMA,eAAAkvB,CAAgBxe,EAAMhL,GAElB,MAAO,CACH,EAAKA,EAAOF,UAAUsqB,sBAAwB7uB,KAAK8uB,sBACnD,EAAKrqB,EAAOF,UAAUwqB,mBAAqB/uB,KAAKgvB,mBAChD,EAAKvqB,EAAOF,UAAU0qB,kBAAoBjvB,KAAKkvB,kBAC/C,EAAKzqB,EAAOF,UAAU4qB,sBAAwBnvB,KAAKovB,uBACrD3f,EACN,CACA,qBAAA2f,CAAsB5lB,EAAQ/E,GAC1B,MAAM,OAAE1E,GAAWyJ,EACnB,IAAI6R,EAAY7R,EAAOkH,MAAM,GACzB1E,EAAK,GAaT,OAZAhM,KAAK6tB,mBAAmBrkB,EAAQ/E,GAChC4W,EAAYrb,KAAKgH,iBAAiBwC,EAAQ6R,EAAWrP,EAAIvH,EAAQ+E,EAAOkH,OAAO,GAC3E2K,EAAUzY,OAAS,IACfoJ,EAAG3L,KACHoE,EAAOiP,gBAAgBvG,eAAe,CAClChB,aAAcH,EAAG3L,KAAKwH,YACtB+D,eAAgBI,EAAG3L,KAAKuH,gBAG5BnD,EAAO0I,eAAenB,EAAG3L,KAAMmJ,IAEvC/E,EAAO1C,eAAiByH,EACjBzJ,CAEX,CACA,cAAAsvB,CAAehT,EAAY5X,GAAQ,KAAEgL,IACjC,MAAM,SAAElL,GAAavE,KACjBuE,GAAU+qB,gBACV/qB,EAAS+qB,eAAejT,EAAY5X,EAAQ,CAAEgL,OACjDvK,UAAWlF,KACXynB,gBAAiBznB,KAAKyY,KAAKgP,gBAAkB,GAElD,CAMA,aAAAhE,CAAcpH,EAAY5X,GACtB,MAAM,UAAE0C,GAAc1C,GAChB,SAAEF,GAAavE,KAEjBuE,GAAUgrB,cACVhrB,EAASgrB,aAAalT,EAAY5X,EAAO,CAC7CgjB,gBAAiBznB,KAAKyY,KAAKgP,gBAAkB,KAC1Czc,EAAWoc,qBAAqB/K,EAAY5X,IAC5CzE,MAECqc,EAAWmT,sBACXxvB,KAAKyvB,yBAAyBpT,EAAY5X,GAEzC4X,EAAwB,eAAMlV,EAAUvE,OAAS,IAClD1D,EAAMwwB,cAAcrT,EAAWjd,KAAM+H,GACrCkV,EAAWV,eAAgB,GAG3BlX,EAAO6W,aACPxY,QAAQC,IAAI,aAEpB,CAYA,gBAAA4sB,CAAiBtU,EAAWnG,EAASzQ,EAAQkC,EAAK+J,EAAO/L,GAAQ,GAC7D+L,EAAQA,GAASwE,EAAQxE,MACzB,MAAMkf,GAAejrB,GAAQ,CAAC,EAE9B,GADA0W,EAAYrb,KAAKgH,iBAAiBkO,EAASmG,EAAW1U,EAAKlC,EAAQzE,KAAK6vB,eAAenf,GAAQkf,GAC3FjrB,EAAO,CACP,GAAIgC,EAAImpB,QAGJ,OAFAnpB,EAAItG,KAAOuvB,EAAavP,SAASxY,YAAYkD,KAAK,IAClDpE,EAAI0Z,SAAWuP,EAAavP,SACrBhF,EAEX,MAAM3B,EAAO2B,EACbA,EAAYrb,KAAK+vB,kBAAkB1U,EAAW1U,EAAKuO,EAASzQ,IAExB,GAA/BkC,EAAI1C,QAAQ,gBAA0BoX,GAAa3B,IACpD/S,EAAItG,KAAOqZ,EAEnB,CACA,OAAO2B,CACX,CAQA,eAAA2U,CAAgB3U,EAAWnG,EAASnL,GAChC,MAAMkmB,EAAU/a,EAAQgb,gBAAkBhb,EAAQ3T,MAElD,GADAwI,EAAYmL,EAAQib,mBAAqBpmB,EACpCsR,EAAUzY,OAAS,GAAM,EAAa,CAGvC,MAAMojB,EAASiK,EAAUA,EAAQ1d,KAAK8I,GAAa,KACnD,GAAI2K,EAEAA,EAAOliB,MAAQoR,EAAQxE,MAAM5M,MAC7BoR,EAAQxE,MAAM9N,OAAS,EACvBsS,EAAQxE,MAAM7N,QAAUmjB,EAAOnjB,QAC/BmjB,EAAO5kB,SAAQ2K,GAAKmJ,EAAQxE,MAAMvM,KAAK4H,UAEvC,GAAyB,GAArBmJ,EAAQsN,UACR,MAAM,IAAI/jB,MAAM,sEAE5B,CACA,MAAO,CAAEsL,YACb,CACA,iBAAAgmB,CAAkB1U,EAAW1U,EAAKuO,EAASzQ,GACvC,IAAIsF,EAAYmL,EAAQvV,SAaxB,OAZiC,GAA7BgH,EAAI1C,QAAQ,gBACT8F,aAAc/J,KAAKgwB,gBAAgB3U,EAAWnG,EAASnL,KAE3B,GAA/BpD,EAAI1C,QAAQ,gBACR8F,IACAsR,EAAY5W,EAAOqX,mBAAmB5G,EAASnL,IAGnDmL,EAAQ5V,UAAUsD,OAAS,IAE3ByY,EADkBnc,EAAMkI,kBAAkBiU,EAAWnG,EAAQ5V,SAAU4V,EAAQxE,MAAOjM,IAC7D4W,GAEtBA,CACX,CAEA,cAAAwU,CAAenf,GAEX,OADmB1Q,KACAyY,KAAKgP,gBAAkB,EADvBznB,KAEJyY,KAAKiP,aAAehX,CACvC,CACA,qBAAA0f,CAAsBlb,EAASzQ,EAAQ+Z,GACnC,OAAO8H,EAAiBnlB,MAAMnB,KAAM,CAACkV,EAASzQ,EAAQ+Z,GAC1D,CAIA,mBAAA6R,CAAoBnb,EAAS3D,EAAM9M,GAC/B,MAAM+e,EAAM,CAAEjS,KAAM9M,EAAO8M,KAAMwI,IAAKtV,EAAOsV,KAC7C,IAAInJ,EAAO,KAWX,OATIsE,EAAQmX,iBAERrsB,KAAK0kB,oCAAoCxP,EAAS,KAAM,GAAIA,EAAQiO,SAAU1e,GAElFA,EAAO6Z,cAAc/M,GACrB9M,EAAOoS,OAAQ,EACfjG,EAAO5Q,KAAKqrB,cAAcnW,EAASzQ,GACnCA,EAAOoS,OAAQ,EACfpS,EAAO6Z,cAAckF,EAAIjS,KAAMiS,EAAIzJ,IAAMtV,EAAOsV,KACzCnJ,CACX,CAWA,gBAAA5J,CAAiBkO,EAAS3O,EAAGyF,EAAIvH,EAAQiM,EAAO/L,GAAQ,GACpD,GAAIuQ,EAAQzV,YAAa,CAErB,MAAM2uB,EAAU,CAAEC,UAAU,GACtBiC,GAAmB,IAAV3rB,EAAiB,CAAC,EAAIA,EACrC4B,EAAIvG,KAAKmuB,sBAAsBjZ,EAAS3O,EAAGmK,GAASwE,EAAQxE,MAAOjM,EAAQ2pB,EAASkC,GAChFlC,EAAQC,WACRriB,EAAG7H,KAAK,eACR6H,EAAG3L,KAAOiwB,EAAOjQ,SAEzB,CAUA,OATInL,EAAQ3V,YAA4C,GAA9ByM,EAAG/H,QAAQ,iBAEjCsC,EAAIrH,EAAM+H,qBAAqBV,EAAG2O,EAAQ3V,WAC1CyM,EAAG7H,KAAK,cAERM,GAAWA,EAAgB,WAAKyQ,EAAQqb,qBACxChqB,EAAIrH,EAAM+H,qBAAqBV,EAAG2O,EAAQqb,oBAC1CvkB,EAAG7H,KAAK,uBAELoC,CACX,CACA,mBAAAiqB,CAAoBhnB,EAAQ/E,GACxB,MAAM8B,EAAIiD,EAAOzK,MAAM+W,OACjBpF,EAAQ,CAACnK,GACTyF,EAAK,GACX,GAAIxC,EAAO/J,YAAY,CAEnB,IAAIwQ,EAAIjQ,KAAKgH,iBAAiBwC,EAAQjD,EAAGyF,EAAIvH,EAAQiM,GAAO,GAO5DjM,EAAOiP,gBAAgBzF,QACvBxJ,EAAOiP,gBAAgBvG,eAAe8C,EAE1C,CACJ,CASA,eAAAwgB,CAAgB1U,EAAahd,EAAO0F,EAAQisB,GAAe,EAAMC,EAAuB,MACpF,IAAI,MAAE/rB,EAAK,SAAEL,GAAaE,GACtB,WAAEke,GAAe3iB,KACrB4E,GAAOgL,QAAQ,oBAAsBtH,EAAMvF,IAAI,0BAA4BhE,EAAQ,KACnF,IAAI6xB,EAAkC,GAAvB7xB,EAAMyP,OAAO5L,OAC5B,GAAI6B,EAAOuP,YAAc4c,EACrB,OAGJ,IAAIC,EAAYpsB,EAAOqb,UAAU+J,qBACjC9qB,EAAQ4jB,EAAWmO,mBAAmB/xB,EAAOgd,EAAatX,GACtDmsB,IAEAC,EAAYpsB,EAAOqb,UAAUsK,6BAEjC,IAAI2G,EAAO,IAAI/a,EACf+a,EAAKC,IAAI,CAAExnB,OAAQmnB,GAAwBE,EAAWtf,KAAM9M,EAAO8M,KAAMzN,OAAQ,EAAG6e,eAEpF4D,EAAgCxK,EAAatX,GAC7C,MAAMwsB,EAAY,KACdtO,EAAWuO,qBAAqBnyB,EAAOgd,EAAY9c,KAAM8xB,EAAMtsB,EAAO,EAEtEisB,GACA3U,EAAYhY,OAAOI,KAAK4sB,GAExBxsB,GAAU4sB,eACV5sB,EAAS4sB,eAAe,CAAEC,OAAQH,EAAWlV,cAAa1b,KAAMtB,EAAO0F,SAAQssB,SAE/EE,IAKJlV,EAAY9c,KAAO8xB,EAAK9xB,IAC5B,CAUA,sBAAAqtB,CAAuBvQ,EAAauH,EAAOlO,EAAW3Q,EAAQ0D,EAAQqW,EAAMhR,EAAS6jB,GAAW,GAC5F,MAAM,MAAEzsB,GAAUH,GACZ,MAAEiM,GAAUqL,GACZ,WAAE4G,GAAe3iB,KACvB,IAAIsxB,EAAc7sB,EAAO8M,KAAK3O,OAI9B,GAFAgC,GAAOgL,QAAQ,iBAAmBtH,EAAMvF,IAAI,+BAAiCgZ,EAAYjH,YAEvD,GAA9BiH,EAAY2Q,eAKZ,OAHAjoB,EAAOsV,IAAMgC,EAAYjY,MACN9D,KAAKuxB,6BAA6BxV,EAAa,GAAI3G,EAAW3Q,GAKrF,IAAI+sB,EAAa/sB,EAAOkN,UACpB8f,EAAe1V,EAAY1G,UAAY0G,EAAY2V,iBAAmB3V,EAAY4V,eAKtF,GAJIF,GACAzxB,KAAKwsB,2BAA2BzQ,EAAatX,GAAQ,GAGrD+Z,EAAM,CACN,MAAMoT,EAAapT,EAAKhV,QACnBooB,GAAc7V,GAAiBtX,EAAOsV,IAAMrJ,EAAM5M,SACnDW,EAAOmV,WAAWnV,EAAOsV,IAAKrJ,EAAM5M,OACpC9D,KAAK6xB,+BAA+BD,EAAYntB,EAAQ+Z,IAE5D/Z,EAAO4X,WAAWvW,QAAQ0Y,EAC9B,MACIA,EAAOxe,KAAK0kB,oCAAoC3I,EAAa,KAAMvO,EAAS4H,EAAW3Q,GAM3F,GAJIgtB,GACA9O,EAAWmP,uBAAuBtT,GAEtC/Z,EAAOkN,UAAY6f,EACfH,GACK/N,EAAM9U,OAAO5L,OAAS,GAAO4b,EAAU,QACxC/Z,EAAO0I,eAAemW,EAAOvH,GAEjCtX,EAAOsV,IAAMuX,MACV,CACH,IAAIlnB,EAAIga,EAER,KADGha,KAAIga,YAAapkB,KAAKqkB,kBAAkBf,EAAOvH,EAAatX,IAC3D2F,IAAOga,EAAU,CAEjB,IAAI2N,EAAS7yB,EAAMwmB,eAAepC,EAAOvH,EAAYoH,SAAU1e,GAC3D+I,EAAUxN,KAAKgyB,wBAAwBxT,EAAM/Z,GACjDA,EAAOiP,gBAAgBvG,eAAeK,GACtC,IAAIykB,EAAUxtB,EAAOsV,IAAMgY,EAAOjuB,MAAQiuB,EAAO1rB,OACjD5B,EAAOmV,WAAWnV,EAAOsV,IAAKkY,GAC9B,IAAIC,EAAQztB,EAAOma,oBAAoB7C,GAAa,GASpD,OARAtX,EAAO0Y,cAAc+U,GACjBztB,EAAOsV,KAAOkY,EACdjyB,KAAK8tB,+BAA+B/R,EAAatX,GAEjDA,EAAOsV,IAAMkY,EAAUF,EAAO1rB,OAElCrG,KAAKyjB,cAAc1H,EAAatX,GAChCA,EAAO4S,gBAAiB,EACjB0E,EAAYhc,MACvB,CAGI,GAAIqkB,EAAU,CACV,IAAI+N,EAAiB1tB,EAAO8M,KAAK/K,UAAU/B,EAAOsV,IAAKqK,EAAS1T,MAAM5M,OAQtE,OANIquB,EAAevvB,OAAS,GACxB5C,KAAKywB,gBAAgB1U,EAAaoW,EAAgB1tB,GAEtDA,EAAOmV,WAAWnV,EAAOsV,KACzB/Z,KAAK6tB,mBAAmB9R,EAAatX,GAC1BzE,KAAKqrB,cAAcjH,EAAU3f,EAE5C,CAIR,CACA,OAAOsX,CACX,CAIA,mCAAAqW,CAAoCld,EAASzQ,EAAQkM,GACjD,MAAM0K,EAAY1K,EAAG5R,MACrB,GAAImW,EAAQmd,uBAAwB,CAChC,IAAIC,EAAItyB,KAAKwd,SAASmE,uBAAuBtG,EAAU7M,QACvDmC,EAAG0hB,uBAAyBC,CAChC,CACJ,CACA,6BAAAC,CAA8Brd,EAASzQ,EAAQkM,GAAI,KAAE6N,EAAI,MAAE9N,EAAK,MAAEnP,IAC9D,IAAI8Z,EAAY3K,EAAM,GACtB,MAAM,OAAE3Q,GAAWmV,EACb+W,EAAcjsB,KAAK2iB,WACzB,IAAI2P,EAAI3hB,EAAG0hB,uBAIX,GAHY7T,IAA8B,GAApBnD,EAAUzY,QAA4C,GAA3ByY,EAAU7M,OAAO5L,SACzDqpB,EAAYuG,gBAAgBhU,EAAKhV,OAAOvK,KAAMwF,KACnDyQ,EAAQud,mBACD,CAQP,GAPA9hB,EAAGqd,QAAS,EAEZ3S,EADiBnc,EAAMwmB,eAAehV,EAAM/I,MAAOpG,EAAOkD,GACnC,GACnByQ,EAAQmd,yBACRC,EAAItyB,KAAKwd,SAASmE,uBAAuBtG,EAAU7M,SAGnDzO,GAA2B,GAAhB2Q,EAAMrK,OAAc,CAM/B,GAJImY,GAAQ8T,GACRrG,EAAYyG,iBAAiBxd,EAASzQ,GAGtC1E,EAAO4yB,UAAU7uB,OAAS4M,EAAM5M,MAAO,CACvC,IAAIoJ,EAAKlN,KAAKqwB,oBAAoBtwB,EAAQsb,EAAU7M,OAAQ/J,GAQ5D,OAPI6tB,IAAM7tB,EAAOiP,gBAAgB/H,UAC7BlH,EAAOuO,QACHkC,EAAQG,UAERnI,EAAKlN,KAAK4yB,iBAAiBnuB,EAAQyQ,EAAShI,EAAIgI,EAAQ2d,mBAGzD3lB,CACX,CACA,GAAIgI,EAAQ4d,YACR,OAAO9yB,KAAK+yB,aAAa7d,EAASnV,EAAQ0E,EAAQyQ,EAAQ2d,gBAElE,CACA,OAAO9yB,CACX,CACJ,CACA,kBAAAizB,CAAmBj0B,EAAO0F,GACtBA,EAAO0I,eAAepO,EAAO,IAAIk0B,EACrC,CASA,cAAAC,CAAeppB,EAAQzJ,EAAMmJ,EAAQ/E,EAAQqW,GAAQ,GACjD,MAAMha,EAAI,CAAEgJ,SAAQzJ,SACd,MAAEuE,EAAK,gBAAE8O,GAAoBjP,EACnCvF,EAAMi0B,oBAAoBryB,EAAG0I,GAC7B5E,GAAOgL,QAAQ,yBACXtH,EAAMvF,IAAI,6BACVD,QAAQC,IAAIjC,IAEhB4S,EAAgBvG,eAAerM,GAC3Bga,GACA9a,KAAKmb,iBAAiB3R,EAAQ1I,EAAG2D,EAEzC,CACA,uBAAA2uB,CAAwBle,EAASzQ,EAAQkM,EAAI0iB,GACzC,MAAM,IAAE1sB,EAAG,KAAE6X,EAAI,YAAE8U,GAAgBD,EACnC,IAAIhY,EAAY1K,EAAG5R,MACf0O,EAAQkD,EAAGtQ,KACf,MAAMG,EAAIR,KAEJisB,EAAcjsB,KAAK2iB,WACnB2P,EAAI3hB,EAAG0hB,yBAA0B,EACjCkB,EAAW9uB,EAAOkQ,UAAYlQ,EAAOkN,UACrC6hB,EAAmB,CAACnY,EAAW5N,EAAOhJ,KAC3BT,MAATyJ,EACAjN,EAAE0yB,eAAe7X,EAAW5N,EAAOyH,EAASzQ,GAAQ,GAEpDA,EAAO0I,eAAekO,EAAWnG,EACrC,EAGJ,GAAIod,IAAOpd,EAAQpB,UAAcrP,EAAOqF,OAAOlH,OAAS,GAAOyY,EAAUzY,OAAS,EAAI,CAElF,IAAmC,GAA/B+D,EAAI1C,QAAQ,eACRsvB,GAEAvzB,KAAKgzB,mBAAmBvuB,EAAOkQ,SAAUlQ,GAG7C+uB,EAAiBnY,EAAW5N,EAAOhJ,OAEhC,CACH,GAAKA,EAAOyS,WAAamE,EAErB,OADArb,KAAKyjB,cAAcvO,EAASzQ,GACrByQ,EAAQnV,SAGd0E,EAAO0S,qBAAwBkE,EAAU7M,OAAO5L,OAAS,KACtD2wB,GAEA9uB,EAAOiP,gBAAgBvG,eAAe1I,EAAOkQ,UAEjD6e,EAAiBnY,EAAW5N,EAAOhJ,GAC/BA,EAAO0S,sBACP1S,EAAO0S,qBAAsB,GAGzC,CACIqH,GAAQ8T,GACRrG,EAAYyG,iBAAiBxd,EAASzQ,GAE1CA,EAAO2W,QAAQlG,EAASmG,GACxBrb,KAAKyzB,gBAAgBve,EAASzQ,GAC9BkM,EAAG+iB,YAAa,EAChB1zB,KAAK4sB,gBAAgBnoB,EAAQyQ,EACjC,CACJ,CACA,eAAAue,CAAgBve,EAASzQ,GACjByQ,EAAQP,SACRlQ,EAAOkQ,SAAWO,EAAQP,SAE1BlQ,EAAOkQ,SAAW,IAE1B,CAQA,mBAAAgf,CAAoBze,EAAS0e,EAAeC,EAASpvB,GACjD,KAAOmvB,EAAchxB,OAAS,GAAG,CAC7B,IAAIkxB,EAAUF,EAAcjuB,QACxBouB,EAAM,KACNC,EAAU,KACVC,EAAW,KACXC,EAAc,KAOlB,GALIhuB,MAAMC,QAAQ2tB,KACdC,EAAMD,EAAQ,GACdE,EAAUF,EAAQ,GAClBI,EAAe,KAAKJ,EAAWA,EAAQ,GAAK,MAE5CC,IACAE,EAAWF,EAAI5yB,MAAM6yB,EAAS,CAAC9e,EAASzQ,EAAQovB,EAASK,IACrDL,EAAQ7F,QAKR,OAJI6F,EAAQM,aACRn0B,KAAKo0B,mBAAmBlf,GAE5BlV,KAAKyjB,cAAcvO,EAASzQ,GACrBwvB,CAGnB,CACJ,CACA,sBAAAI,CAAuB7V,EAAMnD,EAAW5W,GAcpC,OAbI+Z,GAAQA,EAAK9J,eACb2G,EAAYmD,EAAK9J,aAAe2G,EAChCmD,EAAK9J,aAAe,KAEpBjQ,EAAOiG,aACPjG,EAAO0I,eAAekO,EAAWmD,EAAKhV,QAEtC6R,EAAY5W,EAAOqF,OACnBrF,EAAOiP,gBAAgBzF,QACvBxJ,EAAOqG,qBACP0T,EAAKza,OAAOI,KAAK,IAAImwB,EAAoBjZ,KAGtCA,CACX,CAQA,kBAAA2T,CAAmB9Z,EAASzQ,GAExBA,EAAOG,OAAOgL,QAAQ,gBAAkBtH,EAAMvF,IAAI,kCAAoCmS,EAAQJ,YAC9FrQ,EAAO6P,MAAQ,QACf,MAAM,OAAEvU,EAAM,MAAE2Q,EAAK,MAAEnP,EAAK,gBAAEsxB,GAAoB3d,GAC5C,WAAEyN,GAAe3iB,KACvByE,EAAOgS,WAAavB,EACpB,MAAMsJ,EAAO/Z,EAAOya,sBACpB,IAEIqV,EAAkBC,EAFlBnZ,EAAY3K,EAAM,GAClB+U,EAAiB/U,EAAM5M,MAAQ4M,EAAMrK,OAGzC,MAAMouB,GAAehwB,EAAOmS,KAAQnS,EAAO8M,KAAK3O,QAAU6iB,EAM1D,GAJIgP,IACAhwB,EAAO8S,eAAgB,IAGtBkd,GAAgBhwB,EAAOsV,KAAO0L,IAAqBvQ,EAAQ4d,YAAc,CAE1E,GAAI5d,EAAQwX,eAGR,OAFA1sB,KAAK+rB,wBAAwB7W,EAASzQ,GAAQ,GAC9CA,EAAOiT,uBAAyBxC,EACzBlV,KAAK00B,mBAAmBH,EAAkBC,EAAqB/vB,EAAQyQ,EAAQnV,QAE1F,GAAI0E,EAAOmS,IACP,OAAO7W,EAGX,IAAI6Q,EAAO5Q,KAAK20B,kBAAkBzf,EAASzQ,GAM3CA,EAAOsV,IAAMtV,EAAO7B,OACpB,IAAIuvB,EAAiB1tB,EAAO8M,KAAK/K,UAAUif,EAAgBhhB,EAAOsV,KAWlE,OAVIoY,EAAe3jB,OAAO5L,OAAS,GAC/B5C,KAAKywB,gBAAgBvb,EAASid,EAAgB1tB,GAK9CmM,IACAA,EAAO5Q,KAAK40B,iBAAiBhkB,EAAMnM,GACnCA,EAAOqS,cAAe,GAEnBlG,CACX,CACAyK,EAAYrb,KAAKq0B,uBAAuB7V,EAAMnD,EAAW5W,GAEzDA,EAAOsV,IAAM0L,EACb,MAAM9e,EAAM1E,EAAwB2E,KAAKyU,GAIzCA,EAAYrb,KAAK2vB,iBAAiBtU,EAAWnG,EAASzQ,EAAQkC,GAG9D,MAAMkuB,EAAyC,GAA3BxZ,EAAU7M,OAAO5L,OAC/BkyB,EAAerwB,EAAOyS,UAE5B,IAAIoc,EAAgB7uB,EAAOkN,WAAakjB,GACnCC,GAAiBA,GAAgB5f,EAAQoG,aACzCwZ,GAAiBA,GAAgBzZ,GACpB,IAAbA,EASL,IAJKiY,GAAepe,EAAQoG,aAAepG,EAAQ6f,mBAAqBtwB,EAAOuwB,QAC3E1B,GAAe,GAGfvzB,IAAWuzB,GAAevzB,EAAOijB,iBAAkB,CAEnD,IAAI5Y,EAAKrK,EAAO4yB,SACZvoB,GAAOqb,GAAkBrb,EAAGtG,SACzBywB,mBAAkBC,uBAAwBx0B,KAAKi1B,uBAC9Cl1B,EAAQmV,EAAS9K,EAAIoU,EAAM/Z,EAAQ,GAAI,GAAIiM,EAAM5M,MAAO,SAEpE,CAEA,IAAI+vB,EAAU,CACV7F,QAAQ,EACRjvB,MAAOsc,EACP/G,MAAO,QACP6f,aAAa,EACbb,cACAjB,wBAAwB,EACxBhyB,KAAMsG,EAAItG,MAEVuzB,EAAgB,CAChB,CAAC5zB,KAAMA,KAAKoyB,qCACZ,CAACpyB,KAAMA,KAAKk1B,2BAA4B,CAAErC,oBAC1C,CAAC7yB,KAAMA,KAAKuyB,8BAA+B,CAAE/T,OAAM9N,QAAOnP,UAC1D,CAACvB,KAAM,SAAUkV,EAASzQ,EAAQkM,GAC9B,GAAIA,EAAG2iB,YAGH,OAFA3iB,EAAGqd,QAAS,EACZrd,EAAGwjB,aAAc,EACbjf,EAAQG,SAAWH,EAAQnV,OAEpBC,KAAK4yB,iBAAiBnuB,EAAQyQ,EAASA,EAAQnV,OAAQ8yB,IAE9D3d,EAAQnV,QAERC,KAAK4sB,gBAAgBnoB,EAAQyQ,EAAQnV,QAElCmV,EAAQnV,OAEvB,GACA,CAACC,KAAMA,KAAKozB,wBAAyB,CAAEzsB,MAAK6X,UAE5C5N,EAAO5Q,KAAK2zB,oBAAoBze,EAAS0e,EAAeC,EAASpvB,GACrE,OAAIovB,EAAQ7F,OACDhuB,KAAK00B,mBAAmBH,EAAkBC,EAAqB/vB,EAAQmM,IAElF5Q,KAAKo0B,mBAAmBlf,GAEnB2e,EAAQH,YACT1zB,KAAKozB,wBAAwBle,EAASzQ,EAAQovB,EAAS,CAAEltB,MAAK6X,SAElExe,KAAKyjB,cAAcvO,EAASzQ,GAE5Bke,EAAWwS,0BAA0BjgB,EAASzQ,EAAQ+Z,GAElDtJ,EAAQ4d,YACD9yB,KAAK+yB,aAAa7d,EAASnV,EAAQ0E,EAAQyQ,EAAQ2d,iBAEvD7yB,KAAK00B,mBAAmBH,EAAkBC,EAAqB/vB,EAAQ1E,GAClF,CAOA,gBAAA60B,CAAiB1f,EAASzQ,GACtB,IAAImM,EAAOsE,EAEX,KAAOtE,GAAM,CACT,MAAMwkB,EAAQ3wB,EAAOma,oBAAoBhO,GAAM,GACzCykB,EAAW5wB,EAAOib,YACxBjb,EAAO0Y,cAAciY,GACrB3wB,EAAOiP,gBAAgBvG,eACnB,CACIvB,eAAgBwpB,EAAM/0B,KAAKuH,cAC3BuE,aAAcipB,EAAM/0B,KAAKwH,cAGjCpD,EAAOiP,gBAAgBvG,eACnBkoB,EAASh1B,MAEbL,KAAKyjB,cAAc7S,EAAMnM,GACzBmM,EAAOA,EAAK7Q,MAChB,CACA,OAAO6Q,CACX,CACA,eAAAgc,EAAgB,SAAEtV,GAAY9N,GAC1B8N,EAAW9N,EAAOvK,KAClB+J,UAAU,GAAGsO,SAAWA,CAC5B,CAMA,wBAAAmY,CAAyB1T,EAAatX,GAClC,MAAM,UAAE0C,GAAc1C,EAChBrF,EAAO2c,EAAYuZ,YACzB,GAAIl2B,GAAQ2c,EAAYyT,qBAAsB,CAC1C,KAAKroB,EAAUvE,OAAS,GAKpB,MAAMnE,MAAM,uBAJZS,EAAMwwB,cAActwB,EAAM+H,GAC1B4U,EAAYyT,sBAAuB,CAK3C,CACJ,CAMA,0BAAA+F,CAA2BxZ,EAAatX,GACpC,MAAM,UAAE0C,GAAc1C,EAChBrF,EAAO2c,EAAYuZ,YACrBl2B,IAAS2c,EAAYyT,uBACrBtwB,EAAM6H,YAAY3H,EAAM+H,GACxB4U,EAAYyT,sBAAuB,EAE3C,CAOA,iCAAAgG,CAAkChsB,EAAQ/E,GACtC,MAAM+Z,EAAO/Z,EAAO4a,eACdoW,EAAejX,EAAKkX,YAC1B,IAAIjgB,EAAW+I,EAAK2O,QAChBjY,EAAUsJ,EAAKhV,OACfmsB,EAASlgB,EAASmgB,WAAWH,GAAgBhgB,EAASjP,UAAUivB,EAAa7yB,QAAU6S,EAE3F,MAAM,WAAEkN,GAAe3iB,MACjB,cAAE4H,EAAa,YAAEC,GAAgB2W,EAAKne,KAC5C,GAAIo1B,EAAa7yB,OAAS,EAAG,CACzB,IAAIa,EAAMmE,EAAc3D,QAAQwxB,GAChC,MAAMp1B,EAAOwH,EAAYpE,GAEzB+a,EAAKlK,MAAMZ,gBAAgBvG,eAAe,CAAErD,OAAQ2rB,EAAcp1B,SAClE,IAAIw1B,EAAS,EACb,KAAOpyB,GAAO,GACVoE,EAAYlC,QACZiC,EAAcjC,QACdlC,IACAoyB,IAEAjuB,EAAc6D,SACdL,EAAgBuC,yBAAyBkoB,EAAQjuB,GACjDwD,EAAgB4D,oBAAoB,CAAEnH,cAAaD,iBAAiB,WAE5E,CAMA,GAJA4W,EAAK/J,UAAW,EAChB+J,EAAKhK,cAAe,EACpBU,EAAQwc,gBAAiB,EACzB1xB,KAAK81B,oCAAoCtsB,EAAQ/E,GAC7CkxB,EAAO/yB,OAAS,EAAG,CAEnB6B,EAAOiG,aACPjG,EAAOkG,oBAEPlG,EAAOiP,gBAAgBvG,eAAe,CAAEhB,aAActE,EAAa+D,eAAgBhE,IACnFnD,EAAOuO,QACP,MAAMxF,EAAU/I,EAAO8a,cAAa,GACpC9a,EAAOqG,qBACP6qB,EAASnoB,EAAQ1D,OAEjBsB,EAAgBsC,cAAc,CAAE9F,gBAAeC,gBAC/CD,EAAczD,KAAKqJ,EAAQ1D,QAC3BjC,EAAY1D,KAAKqJ,EAAQnN,KAG7B,CACAme,EAAK2O,QAAUwI,EACfnX,EAAK/J,UAAW,EAChB+J,EAAKxK,WAAa,EAClB2O,EAAW3O,WAAWwK,EAC1B,CAOA,kBAAAuX,CAAmBvsB,GAAQ,MAAEoK,IACzBpK,EAAOwsB,+BAAgC,EACvCxsB,EAAOmoB,eAAiB,CACpB/d,MAAOA,EAEf,CAOA,qBAAAkb,CAAsB/S,EAAatX,GAC/BA,EAAO6P,MAAQ,YAAa,MAAM,WAAEqO,GAAe3iB,MAC7C,MAAE4E,EAAK,KAAE2M,EAAI,WAAE8K,GAAe5X,GAC9B,OAAE1E,EAAM,SAAE+T,EAAQ,MAAEpD,GAAUqL,EACpCnX,GAAOgL,QAAQ,oBAAsBtH,EAAMvF,IAAI,0CAA4CgZ,EAAYjH,YAEvG,IAKI1K,EAAIga,EAAUjc,EALdiN,EAAY,KACZ6gB,GAAS,EACT3S,EAAQ,GACR9E,EAAO,KACPhR,EAAU,KAKd,GAAK6O,EAAWzZ,OAAS,IAAO4b,EAAO/Z,EAAOma,oBAAoB7C,GAAa,IAC3Eka,GAAS,EACTzoB,EAAUxN,KAAKgyB,wBAAwBxT,EAAM/Z,OAC1C,KAAIsX,EAAYlY,MAiEnB,MAAM,IAAIpF,MAAM,uBAAyBsd,GAjEf,CAE1B,IAAIhS,EAAY,KACZmsB,EAAe,CAAEpsB,OAAQ,KAAMzJ,KAAM,MACzC,GAAI0b,EAAYxc,UAAW,CAEvB,IAAI8b,EAAYU,EAAYrL,MAAM,GAC9B/J,EAAM,GACVuvB,EAAa71B,KAAOgb,EACpBA,EAAYrb,KAAK2vB,iBAAiBtU,EAAWU,EAAatX,EAAQkC,EAAK,MAAM,IAC5C,GAA7BA,EAAI1C,QAAQ,eACZ8F,EAAYgS,EAAYoU,mBAAqB,OAC1CpmB,aAAc/J,KAAKgwB,gBAAgB3U,EAAWU,EAAahS,KAGlEmsB,EAAapsB,OAASuR,CAC1B,CAGA,MAAMW,EAAa,CAAC,EACpB,GAAqEhY,MAAjES,EAAOqX,mBAAmBC,EAAahS,EAAWiS,GAA0B,CAC5E,MAAMma,EAAgBpa,EAAYK,YAClC8Z,EAAapsB,OAASrF,EAAOuW,8BAA8Be,EAAaoa,GACxED,EAAa71B,KAAO,CAChBwH,YAAa,CAACsuB,GACdvuB,cAAe,CAACsuB,EAAapsB,QAErC,MACIosB,EAAapsB,OAASiS,EAAYK,YAClC8Z,EAAa71B,KAAO2b,EAExB5Q,EAAgBS,wBAAwBqqB,EAAa71B,KAAKuH,eAC1DmU,EAAYlY,OAAQ,EAChBkY,EAAY1G,UAGP0G,EAAYsQ,iBACbrsB,KAAK+1B,mBAAmBha,EAAatX,IAEzCsX,EAAYhE,6BACZtT,EAAOoT,yBAAyBkE,GAEpC/b,KAAKo2B,mBAAmBra,GAAa,EAAMtX,GACvC1E,EACIA,EAAOsV,UAAYtV,EAAO2xB,gBAAkB1xB,KAAKyK,cAAcsR,EAAatX,IAExE4X,EAAWzZ,OAAS,GACpB5C,KAAKw1B,kCAAkCzZ,EAAatX,GAIxDqP,GAA6B,GAAhBrP,EAAOmP,QAEfnP,EAAO+P,eACR/P,EAAO+P,cAAe,IAIlC,MAAM6hB,EAAQta,EAAY9c,KAC1B0jB,EAAW2T,sBAAsBD,EAAO5xB,GACxCzE,KAAKu1B,2BAA2BxZ,EAAatX,GAC7CsX,EAAYK,YAAc8Z,EAAapsB,OACvCiS,EAAYwa,UAAYL,EAAa71B,KACrCL,KAAKqvB,eAAetT,EAAatX,EAAQ,CAAEgL,KAAM,aACrD,CAEA,CAKA,GAJAjC,EAAUyoB,EAASla,EAAYK,YAAc5O,EAC7C4H,EAAY2G,EAAYoH,SACxBG,EAAQ/R,EAAK/K,UAAU/B,EAAOsV,MAEzBkc,GAAUxxB,EAAOoS,MAGlB,OAFAzM,EAAK2R,EAAY4W,UAAY,CAAC,IAC9BvoB,EAAGtG,MAAQ,EACJ9D,KAAKutB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,GAGhF,GAAI/Z,EAAOkS,IAMP,OAFAvM,EAAKpK,KAAK8sB,yBAAyB/Q,EAAatX,EAAQ+Z,GACxDhR,EAAUgR,EAAK2O,QACRntB,KAAKutB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,GAGhF,GAAoB,GAAhB8E,EAAM1gB,OAAa,GAGhBwH,KAAIga,WAAUjc,UAAWnI,KAAKqkB,kBAAkBf,EAAOvH,EAAatX,IACvE,MAAM+xB,EAAO/xB,EAAOmS,IACpB,GAAIxM,IAAoB,MAAZga,GAAqB,GAAS,CACtC,IAAIqS,EAAWC,KAAKC,IAAIlyB,EAAOsV,IAAK3P,EAAGtG,OAIvC,GAFAW,EAAOsV,IAAM0c,EAEO,GAAhBrsB,EAAG,GAAGxH,OAAa,CACnB,IAAIg0B,EAAc7a,EAAY8W,gBAC9B,GAAI+D,EAAa,CACb,MAAMjwB,EAAM,GACZiwB,EAAc52B,KAAK2vB,iBAAiBiH,EAAa7a,EAAatX,EAAQkC,EAAK,MAAM,GACjF6G,GAAWopB,EACPpY,IACAA,EAAKne,KAAKuH,cAAczD,KAAKyyB,GAC7BpY,EAAKne,KAAKwH,YAAY1D,KAAKyyB,GAEnC,CACJ,CACA,OAAO52B,KAAKutB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,EAChF,CAEA,OADAxe,KAAK0kB,oCAAoC3I,EAAayC,EAAMhR,EAASuO,EAAYoH,SAAU1e,GACpFsX,CACX,CAEA,IAAI8a,EAAOpyB,EAAOsV,IAClB,GAAIkc,EAAQ,CACR,IAAIxQ,EAAiB1J,EAAYrL,MAAM5M,MAAQiY,EAAYrL,MAAMrK,OAEjEwwB,EAAOpR,EACPhhB,EAAOsV,IAAM0L,CACjB,CAGA,GAFAnC,EAAQ/R,EAAK/K,UAAUqwB,GAEnB9a,EAAYsQ,iBAAmB4J,EAC/B,OAAOj2B,KAAKssB,uBAAuBvQ,EAAauH,EAAOlO,EAAW3Q,EAAQ,KAAM,KAAM+I,GAAS,GAOnG,KAFGpD,KAAIga,WAAUjc,UAAWnI,KAAKqkB,kBAAkBf,EAAOvH,EAAatX,IAEnE0D,EACA,MAAM,IAAI1J,MAAM0J,GAEpB,OAAgB,MAAZic,EAEU,MAANha,EAEI2R,EAAYsQ,gBAELrsB,KAAKssB,uBAAuBvQ,EAAauH,EAAOlO,EAAW3Q,EAAQ0D,EAAQqW,EAAMhR,GAAS,IAErGxN,KAAKwsB,2BAA2BzQ,EAAatX,GAI7CzE,KAAK0kB,oCAAoC3I,EAAayC,EAAMhR,EAAS4H,EAAW3Q,GAC5E6e,EAAM9U,OAAO5L,OAAS,GACtB5C,KAAKywB,gBAAgB1U,EAAauH,EAAO7e,GAE7CA,EAAOsV,IAAMtV,EAAO8M,KAAK3O,OACpB4K,EAAQ5K,OAAS,GAAM5C,KAAKyY,KAAKgP,kBAClChjB,EAAOiP,gBAAgBvG,eACnB,CACIvB,eAAgBmQ,EAAYwa,UAAU3uB,cACtCuE,aAAc4P,EAAYwa,UAAU1uB,cAG5C2F,EAAU,MAEPuO,GAKA/b,KAAKutB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,GAMrE,MAANpU,GAAgBga,EAAS1T,MAAM5M,MAAQsG,EAAGtG,OAC3C9D,KAAKwsB,2BAA2BzQ,EAAatX,GAEzC2f,EAASiI,iBAITrsB,KAAK0kB,oCAAoC3I,EAAayC,EAAMhR,EAAS4H,EAAW3Q,GAEzEzE,KAAKssB,uBAAuBlI,EAAUd,EAAOlO,EAAW3Q,EAAQ0D,EAAQ,KAAM,IAAI,IAKtFnI,KAAK82B,2BAA2B31B,MAAMnB,KAAM,CAC/CokB,EAAUrI,EAAayC,EAAMhR,EAAS4H,EAAW3Q,KAIrD2f,EAAS1T,MAAM5M,OAASsG,EAAGtG,MACvBsgB,EAAS2S,YAIF/2B,KAAKutB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,GAEzExT,EAAWgsB,gBAAgBh3B,KAAM+b,EAAaqI,EAAUha,EAAIoU,EAAMhR,EAAS4H,EAAW3Q,EAAQ,KAAM6e,GAGxGtjB,KAAKutB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,EAEpF,CACA,iBAAAmW,CAAkBnrB,EAAQ/E,GACtB,MAAM,OAAE1E,GAAWyJ,EACnB,IAAIyG,EAAIxL,EAAO4a,gBAEX,IAAEtF,EAAG,KAAExI,EAAI,SAAE+F,GAAa7S,EAC1B3D,EAAI,KAIR,GAHImP,GAAGzG,QAAUA,GACbxJ,KAAKi3B,mBAAmBztB,EAAQA,EAAOmpB,SAAUluB,GAEjD1E,IACAkQ,EAAIxL,EAAO4a,eACPpP,GAAGzG,QAAUzJ,GAAQ,CACrB,IAAIqK,EAAK,CAAC,IACVA,EAAGtG,MAAQ,EACXsG,EAAGvH,QAAU,GACb/B,EAAId,KAAKi3B,mBAAmBl3B,EAAQqK,EAAI3F,EAAQ,CAC5CyyB,gBAAiB5f,GAEzB,CAOJ,OAJA7S,EAAOsV,IAAMA,EACbtV,EAAO8M,KAAOA,EACd9M,EAAO6S,SAAWA,EAEXxW,CACX,CAcA,iBAAAujB,CAAkBf,EAAOvH,EAAatX,EAAQ0yB,EAAmBt3B,GAAa,GAC1E,IAAIukB,EAAW,KACXha,EAAK,KACLgL,EAAY2G,EAAYoH,SAExBhb,EAAS,KACbgvB,EAAoBA,GAAqBpb,EACzC,MAAM,SAAEzc,GAAayc,EACfnP,EAAStN,GAAaA,EAASsD,OAAS,EACxCw0B,EAAqB,CAAChtB,EAAIgL,KAC5BhL,EAAGitB,YAAcjiB,EACjBhL,EAAGqF,KAAO,QACVrF,EAAG/D,OAAS+D,EAAG,GAAGxH,MAAM,EAE5B,IACIwhB,EAAWxX,EAAQ1N,EAAMysB,kBAAkBrsB,EAAUmF,EAAQ0yB,GAAqB,IAItF,CACA,MAAO34B,GACH,GAAIqB,EACA,MAAMrB,EAEV2J,EAAS,CACLmb,QACAxf,MAAOtF,EAAE+C,MAAMuC,MAAQW,EAAOsV,IAEtC,CAEA,GAAI3E,EAAW,CAIX,GADAhL,EAAK3F,EAAOyY,YAAYjL,MAAMmD,GAC1BhL,EAEAgtB,EAAmBhtB,EAAIgL,QACpB,GAAI3Q,EAAO6M,YAAcgS,EAAO,CACnC,MAAM,YAAEpG,GAAgBzY,EAExB,IAAIic,EAAMzP,EAAWqmB,mBAAmBliB,GACpC7O,EAAI0K,EAAWsmB,qCAAqC7W,GAEpD/b,EAAQ,KACR4B,GAAKA,EAAE3D,OAAS,IAGhB+B,EADe,IAAKyD,OAAO7B,EAAG,KAAMgM,KAAK2K,EAAYtL,UAGzD,MAAM4lB,EAASpiB,EAAU7C,KAAK2K,EAAYtL,SACtC4lB,EAEIptB,EADAzF,GAAUA,EAAMb,OAAS0zB,EAAO50B,OAC3B+B,EAEA6yB,EAEF7yB,IACPyF,EAAKotB,GAELptB,IACAA,EAAGtG,OAASoZ,EAAY7W,OACxB+wB,EAAmBhtB,EAAIgL,GAE/B,CACA2G,EAAY4W,SAAWvoB,CAC3B,CAIA,OAHIA,GAAM2R,EAAY0b,kBAAkBrtB,EAAI3F,KACxC2F,EAAK,MAEF,CAAEA,KAAIga,WAAUjc,SAC3B,CACA,0BAAA4lB,CAA2B7Y,EAASzQ,EAAQizB,EAAOrxB,EAAQqqB,GAAe,IACtEgH,EAAQA,GAASjzB,EAAO0V,uBACdvX,OAAS,IACfyD,EAASA,GAAU,IACd5B,EAAOkN,WAAc+lB,EAAMlpB,OAAO5L,OAAS,IAC5C5C,KAAKywB,gBAAgBvb,EAASwiB,EAAOjzB,EAAQisB,GAEjDjsB,EAAOsV,KAAQ1T,GAAUqxB,EAAM90B,OAEvC,CAMA,aAAA6H,CAAcsR,EAAatX,GACvB,MAAM,OAAE1E,GAAWgc,EACnB,IAAI9L,GAAI,EACR,MAAM0nB,EAA8B53B,GAAQ43B,4BAQ5C,OAPIA,IACA1nB,EAAIjQ,KAAK43B,qBAAqB,CAC1B7zB,OAAQ,CAACgY,GACT7G,QAASnV,EACT83B,UAAWF,KAGZ1nB,CACX,CASA,aAAA6nB,CAAc5iB,EAASzQ,GAAQ,QAAE6gB,EAAO,QAAE9X,EAAO,MAAEC,EAAK,YAAEsqB,IACtD,MAAMv3B,EAAIR,MACJ,OAAED,GAAWmV,GACb,gBAAExB,GAAoBjP,EAC5B,IAAIuzB,EAAc,EAClB,GAAIxqB,EAAQ5K,OAAS,EAAG,CAEpB,GAAIm1B,EAAa,CACb,GAAItqB,EAAM7F,cAAcmD,KAAK,KAAOyC,EAChC,MAAM,IAAI/O,MAAM,6BAEpB2M,EAAgB4D,oBAAoBvB,EAAO,WAC3CD,EAAUC,EAAM7F,cAAcmD,KAAK,GACvC,CAGA2I,EAAgBpG,cAAc,CAAEE,UAASC,SAAShJ,GAClD+I,EAAU,EACd,CAEA,GADyC,GAAnB0H,EAAQsN,WAAkB8C,EAAQ1iB,OAAO,GAAO0iB,EAAQ9W,OAAO5L,OAAS,EAC7E,CAKb,GAHIsS,EAAQ8gB,gCAAkC9gB,EAAQ+iB,UAClD/iB,EAAQ+iB,SAAU,GAElBl4B,GAAQm4B,mBAAoB,CAC5B,IAAIjoB,EAAIxL,EAAOqF,OACfrF,EAAOiP,gBAAgBzF,QACnBgC,EAAErN,OAAS,EACX6B,EAAOe,OAAOrB,KAAK8L,GAEnBxL,EAAOkG,oBACXnK,EAAEiwB,gBAAgBvb,EAASoQ,EAAS7gB,GACpCA,EAAOuO,QACP/C,EAAIxL,EAAOoG,OAAM,GACjBpG,EAAOiP,gBAAgBvG,eAAe8C,EAC1C,MAEIzP,EAAEiwB,gBAAgBvb,EAASoQ,EAAS7gB,GACpCuzB,EAAc1S,EAAQ1iB,OAE1B0iB,EAAU,EACd,CAEA,OADA7gB,EAAO6S,SAAWpC,EAAQjW,KACnB,CAAEqmB,UAAS9X,UAASwqB,cAC/B,CAOA,0BAAA9C,CAA2BhgB,EAASzQ,EAAQ0zB,EAAM,CAAEnK,QAAQ,GAASqF,GACjE,MAAM,MAAEzuB,GAAUH,EAClB,IAAIqvB,GAAU,EACVrmB,EAAQ4lB,GAAQR,gBACpB,GAAa7uB,MAATyJ,EACA,OAEJ,IAAIP,EAAK,KACTtI,GAAS0D,EAAMvF,IAAI,oCAAsCmS,GACzDijB,EAAIhE,YAAcn0B,KAAKo4B,oBAAoBljB,EAASijB,EAAI7jB,OACxD,IAAI+jB,EAAWnjB,EAAQnV,OAYvB,OAXIs4B,IAEInrB,EADAmrB,EAAShjB,QACJrV,KAAK4yB,iBAAiBnuB,EAAQyQ,EAASmjB,EAAU5qB,GAEjDzN,KAAKs4B,sBAAsBpjB,EAASmjB,EAAU5zB,EAAQgJ,IAInEqmB,GAAU,EAEVqE,EAAInK,QAFM,EAGH9gB,CACX,CACA,mBAAAkrB,CAAoBljB,EAASZ,GACzB,MAAa,SAATA,GACQY,EAAQxE,MAAM,GAAG9N,OAAS,CAG1C,CASA,gBAAAgwB,CAAiBnuB,EAAQyQ,EAASqjB,EAASl4B,EAAO,GAAI2S,GAAQ,GAC1D,MAAM,WAAE2P,GAAe3iB,KAIvB,GAHIgT,GAAUvO,EAAOmP,MAAQ,GACzBnP,EAAOuO,QACXvO,EAAOmP,MAAQ8iB,KAAKC,MAAMlyB,EAAOmP,MAAO,GACpCsB,GAAWqjB,EACX,OAAOv4B,KAAKs4B,sBAAsBpjB,EAASqjB,EAAS9zB,EAAQpE,EAEpE,CACA,qBAAAi4B,CAAsBpjB,EAASqjB,EAAS9zB,EAAQpE,GAC5C,MAAM,WAAEsiB,GAAe3iB,KACvB,IAAIw4B,EAAKx4B,KAAK+yB,aAAa7d,EAASqjB,EAAS9zB,EAAQpE,GAErD,OADAsiB,EAAW8V,sCAAsCD,EAAI/zB,EAAQ,CAAExF,KAAMiW,EAAQjW,KAAMytB,eAAgB6L,EAAQ7L,iBACpG8L,CACX,CACA,YAAAzF,CAAa7d,EAAShI,EAAIzI,EAAQpE,EAAO,IACrC,MAAM,MAAEuE,GAAUH,EAMlB,GALAG,GAAS0D,EAAMvF,IAAI,oBAAsBmS,GACrCA,GAASG,UACTrV,KAAK2iB,WAAW+V,YAAYxjB,GAC5BA,EAAQG,SAAU,GAElBnI,EACJ,CACI,MAAM,SAAEylB,GAAazlB,EAKrB,IAAIzD,EAASpJ,EACTs4B,EAAQ,KAMZ,GALqB,iBAAV,IACPlvB,EAASpJ,EAAKtB,MACd45B,EAAQt4B,EAAKoP,MAGbkjB,GAAaA,EAAS,IAAMlpB,EAAS,CACrC,IAAImiB,EAAI1e,EAAGiW,SAAS5Q,KAAK9I,IAAW,CAAEvI,IAClCA,EAAE2B,QAAU,CAAC,CAAC,EAAG3B,EAAE,GAAG0B,SACtB1B,EAAE4C,MAAQ,EACH5C,GAHyB,CAIjC,CAACuI,IAEJmiB,EAAE9nB,OAASW,EAAOsV,IAClB7M,EAAGylB,SAAW/G,CAClB,CACA1e,EAAKlN,KAAKqwB,oBAAoBnjB,EAAIzD,EAAQhF,GAC1C,IAAI+I,EAAU/I,EAAOqF,OACjB6uB,GACAnrB,EAAU/I,EAAOoG,OAAM,GAAQ2C,EAC/B/I,EAAO0I,eAAeK,EAAS,IAAIorB,EAAsBD,EAAO,CAAEx4B,OAAQH,KAAK64B,kBAAmBx4B,WAElGoE,EAAOuO,OAEf,CACA,OAAO9F,CACX,CAcA,sBAAA+nB,CAAuBl1B,EAAQmV,EAAS9K,EAAIoU,EAAM/Z,EAAQ+I,EAAS8V,EAAOmC,EAAgBnR,EAAQ,aAE9F,IAAIkgB,EACAD,EACJ,MAAMuE,EAAkBr0B,EAAO4R,aAmB/B,OAlBItW,IAAW+4B,GAAwC,GAApB/4B,EAAOyiB,YACrCziB,EAAOijB,kBAAoB9N,EAAQ8N,oBAEpCuR,EAAmB,CACfjR,QACApO,UACAsJ,OACAze,SACA+J,OAAQ0D,EACRuM,IAAK0L,EACLlU,KAAM9M,EAAO8M,KACblL,OAAQ5B,EAAO4B,OACfssB,SAAUvoB,EACV2uB,WAAah5B,EAAOijB,kBAAoB9N,EAAQ8N,iBAChD1O,SAEJkgB,EAAsBx0B,KAAKg5B,uBAExB,CAAExE,sBAAqBD,mBAClC,CASA,gBAAA0E,CAAiB/jB,EAASzQ,EAAQ+Z,GAC9B,GAAI/Z,EAAOkS,IAAK,CACZ,GAAI6H,EAAM,CACN,MAAM0a,EAAS1a,EAAKne,KACpB,GAAI64B,EAAOtxB,cAAchF,OAAS,EAC9B,OAAOs2B,CAEf,CACA,OAAOhkB,EAAQqhB,SACnB,CACA,OAAO/X,GAAMne,MAAQ6U,EAAQqhB,SACjC,CAWA,sBAAAhJ,CAAuB/f,EAAS8V,EAAOpO,EAAS9K,EAAI3F,EAAQ+Z,GAExD,MAAM,MAAE5Z,GAAUH,GACZ,OAAE1E,GAAWmV,EACnB,IACIikB,EADA1T,EAAiBrb,EAAGtG,MAAQsG,EAAG,GAAGxH,OAElC0iB,EAAU7gB,EAAOsV,IAAM3P,EAAGtG,MAAQW,EAAO8M,KAAK/K,UAAU/B,EAAOsV,IAAK3P,EAAGtG,OAAS,GAChFywB,EAAmB,KACnBC,EAAsB,KAC1B,MAAMh0B,EAAIR,KACJisB,EAAczrB,EAAEmiB,WAChBmW,EAAkBr0B,EAAO4R,aACzBzB,EAAe4J,GAAM5J,aAC3B,IAAIwkB,EAAK,KACL3rB,EAAQ,KAKZ,GAHA7I,GAAOgL,QAAQ,wBAA0BtH,EAAMvF,IAAI,oDAAoDmS,KACvGzQ,EAAOgS,WAAavB,EAEhBN,EAAc,CACd,IAAI3E,EAAIgc,EAAYoN,oBAAoBzkB,EAAc,KAAMnQ,GAC5D+I,GAAWyC,EAAEqpB,MACb9a,EAAK5J,aAAe,IACxB,GACG2f,mBAAkBC,uBAAwBx0B,KAAKi1B,uBAAuBl1B,EAAQmV,EAAS9K,EAAIoU,EAAM/Z,EAAQ+I,EAAS8V,EAAOmC,IAI5H,IAAI8T,GAAS,EACD,MAAR/a,IACA/Z,EAAOiG,aACP6uB,GAAS,GAEbv5B,KAAKyvB,yBAAyBva,EAASzQ,KAEpC20B,KAAI3rB,SAAU,MACb,MAAM+rB,EAAS,CAAEJ,GAAI,GAAI3rB,MAAO,IAChC,OAAOqrB,EAAkBU,EAAS,MAC9B,GAAIpvB,EAAG,GAAGxH,OAAS,EAAG,CAClB,IAAI62B,EAAMh1B,EAAO8F,iBAAiB2K,EAAS9K,GAI3C,OAHWpG,MAAPy1B,IACAA,EAAMh1B,EAAOuW,8BAA8B9F,EAAS9K,EAAG,KAEpD,CAAEgvB,GAAIK,EAAKhsB,MAAOrD,EAAG,GAChC,CACH,EARiC,IAQ1BovB,CACX,EAXgB,IAcjB/0B,EAAO4R,cAAe,EACtB,IAAIqjB,GAAe,EACf1B,EAAc,EAgClB,GA1BAh4B,KAAKo0B,mBAAmBlf,EAASzQ,KAK9B6gB,UAAS9X,UAASwqB,eAAgB/L,EAAY0N,kBAAkB,CAC/DnwB,OAAQ0L,EACRzQ,SACA+I,UACAC,MAAOzN,KAAKi5B,iBAAiB/jB,EAASzQ,EAAQ+Z,GAC9CuZ,aAAa,EACb3G,OAAO3Y,GACIjY,EAAEs3B,cAAc5iB,EAASzQ,EAAQ,CAAE6gB,UAAS9X,aAAaiL,GAAQ,CAAC,OAI7Euf,IACAmB,EAAezC,KAAKkD,IAAInU,EAAgBhhB,EAAO4B,OAAS2xB,EAAc,IAItE9iB,EAAQG,UAAYH,EAAQyc,gBAE5B3xB,KAAK4yB,iBAAiBnuB,EAAQyQ,EAAS,KAAM,MAAM,GAGnDA,EAAQG,SAAWH,EAAQyc,eAAgB,CAK3C,GAFA+H,GAAe,EAEXxkB,EAAQ8gB,8BAA+B,GACpCoD,KAAI3rB,SAAUwe,EAAY4N,+BAA+Br5B,EAAG0U,EAASzQ,EAAQ+I,EAC5E,CAAE4rB,KAAI3rB,WACV,MAAM+R,EAAW,CAAC,EAClBhS,EAAU/I,EAAOua,kBAAiB,EAAMQ,GACxC/a,EAAOe,OAAOrB,KAAKqJ,GACnB/I,EAAO0J,WAAWhK,KAAKqb,EAASjC,QAAQ1V,YAAYkD,KAAK,IAC7D,MACIkhB,EAAY6N,0CAA0Ct5B,EAAG0U,EAASzQ,GAEtE+I,EAAU,GAEVxN,KAAK4yB,iBAAiBnuB,EAAQyQ,EAAS,KAAM,MAAM,EACvD,OAEOkkB,MAAOnN,EAAY8N,2BAA2B/5B,KAAMkV,EAASzQ,EAC5D,CAAE20B,KAAI5a,OAAMne,KAAM+J,EAAG,MAuB7B,GAnBIgvB,EAAGx2B,OAAS,IACZ6B,EAAOiP,gBAAgBvG,eAAeisB,GACtCA,EAAK,IAMTp5B,KAAK+rB,wBAAwB7W,EAASzQ,GAElCi1B,IACAj1B,EAAOuO,QACPxF,EAAU/I,EAAO8a,cAAa,GAC9B9a,EAAOiP,gBAAgBvG,eAAeK,GAGlCgR,IACAtJ,EAAQG,QAAUmJ,EAAKjK,gBAEnB,MAARiK,GAGKA,EAAKhV,QAAU0L,EAAU,CAE1B1H,EAAU/I,EAAOib,YAGjB,IAAIsa,EAAc,MAEbxb,EAAK/J,UAAYS,EAAQG,SAG1B5Q,EAAOe,OAAOrB,KAAKqJ,EAAQ1D,QAC3B0D,EAAU/I,EAAOoG,OAAM,IAEnB2T,EAAK/J,UAAY1U,IAAWA,EAAOsV,SAAWH,EAAQ+kB,mBAAmB5kB,SAAYmJ,EAAKkX,YAAY9yB,OAAS,KAE5G4K,UAASwsB,eAAgBh6B,KAAKk6B,4BAA4B1sB,EAAS0H,EAASsJ,EAAM/Z,IAG7FA,EAAO0Y,cAAcqB,GAErByN,EAAYkO,mCAAmC35B,EAAG0U,EAAS1H,EAASgR,EAAM/Z,GAC1E+I,EAAU,GACNwsB,GACAv1B,EAAO4a,eAAexK,kBAAkBmlB,EAEhD,CAiBJ,GAZAp1B,GAAOgL,QAAQ,kBAAqBsF,EAAQnR,OAAOnB,OAAS,GAAM0F,EAAMvF,IAAI,uBAAuBmS,EAAQ9V,aAAa8V,EAAQnR,OAAOnB,iBAEnIsS,GAASnV,QAAQk4B,UACjB/iB,EAAQnV,OAAOk4B,SAAU,GAGT,GAAhB7tB,EAAG,GAAGxH,SACN6iB,EAAiBiR,KAAKC,IAAIlyB,EAAOsV,IAAK0L,IAG1ChhB,EAAOsY,OAAO0I,EAAgB0T,GAE1BI,EAAQ,CACR,MAAMa,EAAa31B,EAAOib,YAC1Bjb,EAAOqG,qBACHsvB,EAAWtwB,OAAOlH,OAAS,GAI3B6B,EAAO0I,eAAeitB,EAAYllB,GAAS,GAAM,GAEhDwkB,IAAiBxkB,EAClB8gB,gCAAiC9gB,EAAQG,QAIlCqkB,GACPzN,EAAYoO,oBAAoBnlB,EAAQjW,KAAMwF,GAJ1C1E,GAA2B,GAAhBmV,EAAQjW,MACnBwF,EAAOuO,OAKnB,CAwBA,IAtBKkC,EAAQnW,OAASyf,IAElBtJ,EAAQnW,MAAQ,CACZ+W,OAAQrR,EAAOpE,KACftB,MAAO0F,EAAOqF,SAKtB9J,KAAKwwB,oBAAoBtb,EAASzQ,GAGlCzE,KAAKyjB,cAAcvO,EAASzQ,GAE5BA,EAAO8Z,gBAAgBrJ,EAASsJ,GAGhCxe,KAAKyzB,gBAAgBve,EAASzQ,GAK1B1E,GAAUmV,EAAQ4d,YAAa,CAC/B,IAAIrlB,EAAQyH,EAAQ2d,gBACpB,OAAO7yB,KAAK+yB,aAAa7d,EAASnV,EAAQ0E,EAAQgJ,EACtD,CAEA,OAAOzN,KAAK00B,mBAAmBH,EAAkBC,EAAqB/vB,EAAQ1E,EAClF,CASA,kBAAA20B,CAAmBH,EAAkBC,EAAqB/vB,EAAQ61B,GAC9D,OAAI/F,GAAoBC,EACbA,EAAoBrzB,MAAMnB,KAAM,CAACu0B,EAAkB9vB,IAEvD61B,CACX,CAOA,2BAAAJ,CAA4B1sB,EAAS0H,EAASsJ,EAAM/Z,GAChD,MAAM81B,EAAc91B,EAAO4a,eAC3B,IAAI2a,EAAc,KAElB,GAA0C,IAAtCxsB,EAAQvJ,QAAQua,EAAKkX,aAAoB,CACzC,IAAIlI,EAAMhP,EAAKkX,YAAY9yB,OACvB43B,EAAMhtB,EAAQhH,UAAU,EAAGgnB,GAC/BwM,EAAcxsB,EAAQhH,UAAUgnB,GAEhCxtB,KAAKgyB,wBAAwBuI,EAAa91B,EAAQ+1B,EAAK,IACvDhtB,EAAU,EACd,CACA,MAAO,CAAEA,UAASwsB,cAEtB,CACA,kBAAA/C,CAAmBztB,EAAQc,EAAI7F,GAAQ,MAAE6e,EAAQ,GAAE,SAAEhM,IACjD,IAAIkH,EAAO,KACPic,EAAYz6B,KAAKutB,uBACjB/f,EAAU,KAyBd,OAvBAlD,EAAKA,GAAM,CAAC,IACRd,EAAOmV,MAASla,EAAO4X,WAAWzZ,OAAS,GAC3C4b,EAAO/Z,EAAOma,oBAAoBpV,EAAOmV,MAAM,GAC/CH,EAAO/Z,EAAOma,oBAAoBpV,GAAQ,GAC1CixB,EAAYjc,EAAK+F,UAAYkW,EAC7BjxB,EAASA,EAAOmV,MAEhBH,EAAO/Z,EAAOma,oBAAoBpV,GAAQ,GAI9CgE,EAAUgR,EAAOxe,KAAKgyB,wBAAwBxT,EAAM/Z,GAAU,GAI9DA,EAAOyY,YAAY9L,KAAK,IACxB9G,EAAG3C,MAAQ,GACX2C,EAAGxG,MAAQ,EACXW,EAAO4R,cAAe,EACtB7M,EAAOmpB,SAAWroB,EAClBd,EAASixB,EAAUt5B,MAAMnB,KAAM,CAACwN,EAAS8V,EAAO9Z,EAAQc,EAAI7F,EAAQ+Z,IACpE/Z,EAAO4R,cAAe,EACtB5R,EAAOyY,YAAYzL,UACZjI,CACX,CAMA,uBAAA0kB,CAAwBvP,EAAM+b,EAAIj2B,GAC9B,MAAM,WAAEke,GAAe3iB,KACZ,OAAP06B,EAEA/X,EAAWgY,uBAAuBhc,EAAMla,IAGxCi2B,EAAGz7B,KAAOwF,EAAO6S,SACbojB,IAAO/b,IACPla,EAAOqS,cAAe,GAGlC,CAOA,qBAAAkiB,CAAsBvgB,EAAMhU,GACxB,MAAM,OAAE1E,EAAM,SAAE4yB,EAAQ,MAAEre,GAAUmE,GAC9B,YAAEyE,GAAgBzY,EACxB,IAAImnB,EAAI,KACR,MAAMtI,EAAQ7K,EAAKlH,KAAK/K,UAAUiS,EAAKsB,KACjC6gB,EAAgBn2B,EAAOsV,IACvB8gB,EAAWp2B,EAAO8M,KACxB,IAAIupB,EAAiB5d,EAAY7W,OAC7B1B,GAAQ,EACRo0B,EAAYtgB,EAAKsgB,UACjBzuB,EAAK,KACLywB,EAAmB,CAACvxB,EAAQc,EAAIgN,KAChC9N,EAAOvK,KAAOqY,EACd,IAAI0jB,EAAch7B,KAAKi3B,mBAAmBztB,EAAQc,EAAI7F,EAAQ,CAAE6e,QAAOhM,aAEvE,OADAtX,KAAKkuB,wBAAwB1kB,EAAQwxB,EAAav2B,GAC3Cu2B,CAAW,EAElBC,EAAkBL,EAClBM,EAAqB,SAAT5mB,EACZ4mB,IACAD,EAAkBxiB,EAAKsB,KAE3B,IAAIohB,EAAUje,EAAYtL,QACtBwpB,EAAWle,EAAY7W,OAGvB4vB,EAA+B,GAAtBtD,EAAS,GAAG/vB,OAErBy4B,GAAkB,EACtB,KAAOpF,GAAUxd,EAAK1Y,SAAWg5B,GAAasC,GAAmB5iB,EAAK1Y,OAAOijB,mBAAmB,CAC5F4I,EAAInT,EAAK1Y,OACT,MAAM,SAAEojB,GAAayI,EAGrB,GAAgB,MAAZzI,EAAkB,CAElBxe,GAAQ,EACR,KACJ,CACA,GAAI2F,EAAK6Y,EAAS5Q,KAAK4oB,GAAU,CAC7B,IAAInzB,EAAKsC,EAAGxG,MAAQs3B,EAChB5N,EAAMljB,EAAG,GAAG1H,OACZ04B,EAAyB,GAAP9N,EACtB,KAAMxlB,GAAK2qB,EAAS7uB,OAAUw3B,GAAoBD,IAAoBC,GAAmB3I,EAAS7uB,OAASkE,EAAIwlB,GAMxG,EAGExlB,EAAI2qB,EAAS7uB,QAAWw3B,KACzBR,EAAiBG,GACrB,KACJ,CAXQI,IAAoBC,GAAmB3I,EAAS7uB,OAASkE,EAAIwlB,EAC7DljB,EAAGxG,OAASs3B,EAAW5N,EAEvBljB,EAAGxG,OAASs3B,EAChBxP,EAAImP,EAAiBnP,EAAGthB,EAAI7F,EAAO6S,UAQvC3S,GAAQ,CACZ,MAEI,GADA2F,EAAK6Y,EAAS5Q,KAAK+Q,GACfhZ,EAAI,CACJ,GAAKA,EAAGxG,MAAQm3B,GAAoBtI,EAAS7uB,MASzC,MAPAwG,EAAGxG,OAASm3B,EAEQ,GAAhB3wB,EAAG,GAAG1H,SAENgpB,EAAImP,EAAiBnP,EAAGthB,EAAI7F,EAAO6S,WAK3C3S,GAAQ,CACZ,KAAO,CACH,GAAIA,EAAO,CACP,GAAIF,EAAOkS,IAAK,CACZiV,EAAImP,EAAiBnP,EAAG,MACxBnT,EAAK1Y,OAAS6rB,EACd,KACJ,CACI,KAGR,CACAA,EAAI,IACR,CAEJnT,EAAK1Y,OAAS6rB,EACdmN,GAAY,EACZsC,IAAkBzP,GAAI,CAAEA,IACpB,MAAM,SAAEzI,GAAayI,EACrB,OAAO3a,EAAWsqB,mBAAmBpY,EACxC,EAHqB,CAGnByI,EACP,CAEA,GAAIsP,GAAa,GAAWtP,EAAG,CAC3B,MAAMxW,EAAYwW,EAAEzI,SAChB/N,IACA9K,EAAK8K,EAAU7C,KAAK+Q,GAChBhZ,GAAuB,GAAhBA,EAAG,GAAG1H,QAAiB0H,EAAGxG,MAAQm3B,GAAmBtI,EAAS7uB,QACrEwG,EAAGxG,OAASm3B,EACZrP,EAAImP,EAAiBnP,EAAGthB,IAGpC,CAKA,OAJA7F,EAAOsV,IAAM6gB,EACbn2B,EAAO8M,KAAOspB,EAGVl2B,GACAF,EAAOyY,YAAY7W,OAASu0B,EACrBhP,IAEXnnB,EAAOyY,YAAY7W,OAASy0B,EACrB/6B,EACX,CAMA,oBAAA63B,EAAqB,OAAE7zB,EAAM,QAAEmR,EAAO,UAAE2iB,IACpC,GAAqB,GAAjB9zB,EAAOnB,OACP,OAAO,EAEX,MAAM44B,EAAWz3B,EAAO8B,MAAM,GAC9B,GAAIgyB,EAAW,CACX,IAAI5nB,GAAI,EACJzP,EAAI,KACJgQ,EAAaxQ,KAAKupB,0BACtB,MAAM7M,EAAOlM,EAAWkZ,WAAWra,QAAQ9Q,IAEb,GAAnBA,EAAE0F,QAAQ,OAClB8G,KAAK,KACR,IAAI/I,EAAK,IAAI8O,SAAS,WAAY,QAAS,SAAU,UAAU4L,yBAA4Bmb,MAC3F,KAAO2D,EAAS54B,OAAS,GAAG,CACxBpC,EAAIg7B,EAAS71B,QAEb,IACIsK,EAAIjO,EAAGb,MAAM,CAAEs6B,MAAOj7B,GAAK,CACvBgQ,EAAWqY,SAAUroB,EAAG0U,GAChC,CACA,MAAO1W,GAEH,OADAsE,QAAQmF,MAAM,WAAYzJ,IACnB,CACX,CACA,GAAIyR,EACA,OAAO,CAEf,CACA,OAAO,CACX,CACA,OAAO,CACX,CAKA,kBAAAmkB,CAAmBlf,EAASzQ,GACxB,MAAM,OAAE1E,GAAWmV,EACdnV,IAELA,EAAOgE,OAAOI,KAAK,CACf/E,KAAM8V,EAAQ9V,KACdoK,OAAQ0L,IAEZlV,KAAKo2B,mBAAmBlhB,GAAS,EAAOzQ,GAC5C,CAMA,mBAAOwG,CAAalH,GAChB,IAAI23B,GAAS,EAIb,OAHA33B,EAAO3C,SAAQmF,IACXm1B,EAASA,GAAWn1B,EAAEiD,OAAc,OAAC,IAElCkyB,CACX,CAUA,mCAAAhX,CAAoCxP,EAASsJ,EAAMhR,EAAS4H,EAAW3Q,GAanE,OAZI+Z,GACAA,EAAK2O,QAAU3f,GACV/I,EAAO4X,WAAWzZ,OAAS,GAAO6B,EAAO4X,WAAW,KAAOmC,IAC5D/Z,EAAO2V,cAAcoE,KAEpBxe,KAAKwd,SAAS0D,UAGnB1C,EAAOxe,KAAK27B,wBAAwBl3B,EAAQyQ,EAAS1H,EAAS4H,GAC1D3Q,EAAOwS,iBACPxS,EAAOuS,cAAc7S,KAAKqa,IAE3BA,CACX,CAOA,cAAAod,CAAen3B,EAAQpE,GACnBoE,EAAOG,OAAS0D,EAAMvF,IAAI,4BAC1B0B,EAAO0Y,cAAc9c,EACzB,CAQA,uBAAAs7B,CAAwBl3B,EAAQyQ,EAASC,EAAOC,GAC5C3Q,EAAOG,OAAOgL,QAAQ,uBAAyBtH,EAAMvF,IAAI,iCAAmCoS,EAAQ,KACpG,IAAI0mB,EAAa,KACjB,MAAM5P,EAAcjsB,KAAK2iB,WACrBzN,EAAQG,SAAWH,EAAQ4mB,gBAAkB5mB,EAAQmX,kBAErDwP,EAAa1mB,EACbA,EAAQ,IAER1Q,EAAOuf,yBACPvf,EAAOuf,uBAAuB7O,EAAOD,GAAS,EAAOzQ,GACrD0Q,EAAQ,IAEZ,MAAM4b,EAAO,IAAI1c,EAAoBrU,KAAMkV,EAASC,EAAOC,EAAW3Q,GA2BtE,OAxBAA,EAAO2V,cAAc2W,GAErBA,EAAKnb,UAAUnR,EAAQyQ,EAAQjW,MAE/BwF,EAAO2Y,UAAU3Y,EAAO4X,WAAWzZ,QAEnC6B,EAAO6S,SAAWyZ,EAAKgL,YAEvBt3B,EAAOkN,WAAY,EAEnBlN,EAAO0S,qBAAsB,EAEzBjC,EAAQnV,SACR0E,EAAOqS,cAAe,GAE1BmV,EAAYqK,sBAAsB7xB,EAAO6S,SAAU7S,GAC/Co3B,IACA9K,EAAKrc,aAAemnB,EACpBp3B,EAAO6S,SAAW2U,EAAY+P,YAIlCv3B,EAAO2W,QAAQlG,EAAS,IAEjB6b,CACX,CAQA,uBAAAiB,CAAwBxT,EAAM/Z,EAAQqF,EAAQwvB,GAC1C,IAAI,QAAEnM,EAAO,OAAE3jB,EAAM,YAAEuyB,EAAW,cAAEE,EAAa,aAAErnB,GAAiB4J,EAChEne,EAAO,KACX,MAAM4rB,EAAcjsB,KAAK2iB,WAGzB,IAAIuZ,EAAe,KAFWl4B,MAAV8F,GAAkC9F,MAATs1B,GAIzC4C,EAAez3B,EAAOiP,gBAAgBpH,aAAa,IACnDxC,EAASrF,EAAOqF,OAChBzJ,EAAOoE,EAAOpE,KACdi5B,EAAQ70B,EAAOoG,OAAM,EANP,CAAC,KAQff,EAASA,GAAU,GACnBwvB,EAAQA,GAAS,IAErB,MAAM6C,EAAiB3d,EAAK/J,UAAa0Y,GAAW3O,EAAKkX,YACzD,IAAI0G,EAAY,KACZ5d,EAAK9J,eACL5K,EAAS9J,KAAKq0B,uBAAuB7V,EAAM1U,EAAQrF,GACnD23B,EAAY5yB,EAAOmL,UAGvB,MAAM0nB,EAAQ,CACV7yB,SAAQM,SAAQwvB,QAAO70B,SACvB0oB,UACA9sB,OACAggB,SAAU7B,EAAKne,KACfpB,KAAM88B,EACNE,gBACAjoB,WAAYwK,EAAKxK,WACjBmoB,iBACAvnB,eACA3F,WAAYitB,GAiBhB,OAfA/O,EAAUlB,EAAYqQ,uBAAuBD,GAEzC7d,EAAKud,aAAeM,EAAMp9B,KAC1Buf,EAAKud,YAAcM,EAAMp9B,KAClBwF,EAAO6S,UAAYkH,EAAKud,cAC/Bvd,EAAKud,YAAct3B,EAAO6S,UAG9BkH,EAAK2O,QAAUA,EACf3O,EAAKxK,WAAa,EAClBwK,EAAKyd,cAAgBI,EAAMJ,cAE3Bzd,EAAK7J,SAAWynB,EAChB5d,EAAK5J,aAAeynB,EAAMznB,aAC1B4J,EAAKjJ,MACE4X,CACX,CAEA,iBAAAoP,CAAkBrnB,EAASkP,EAAUha,EAAIoU,EAAMhR,EAAS/I,EAAQ2Q,GAC5D,MAAM,WAAEuN,GAAe3iB,KAEvB,OADAA,KAAKwsB,2BAA2BpI,EAAU3f,GACtC2f,EAAS1T,MAAM,GAAG9N,OAGe,GAA5B6B,EAAO4X,WAAWzZ,QAAiB6B,EAAO4X,WAAW,KAAOnH,GAC7DlV,KAAK0kB,oCAAoCxP,EAASsJ,EAAMhR,EAAS4H,EAAW3Q,GAEvEzE,KAAKqrB,cAAcjH,EAAU3f,EAQ9C,CAOA,kBAAA2xB,CAAmBlhB,EAAS+gB,EAAQxxB,GAChC,MAAM,OAAE1E,EAAM,kBAAEk6B,EAAiB,4BAAEtC,GAAgCziB,EACnE,GAAInV,GAAUk6B,EAAmB,CAC7B,MAAMuC,EAAQ,CAAC,UAAW,YAC1BA,EAAMp7B,SAAQ2K,IACV,KAAMA,KAAKhM,EAAO08B,oBAAuB1wB,KAAKkuB,EAAoB,CAC9D,IAAIn5B,EAAIm5B,EAAkBluB,GACtBA,GAAKywB,EAAM,IACP17B,GAAK,IACLA,EAAId,KAAK43B,qBAAqB,CAC1B7zB,OAAQmR,EAAQnR,OAChBmR,UACA2iB,UAAWF,KAInB53B,EAAOgM,IAAMjL,IACbf,EAAOgM,GAAKjL,EACZf,EAAO08B,kBAAkB1wB,GAAKA,EAEtC,KAICkqB,EAGDj2B,KAAK08B,kCAAkC38B,EAAQ0E,GAAQ,GAFvDzE,KAAK81B,oCAAoC5gB,EAASzQ,EAI1D,CACJ,CAOA,iCAAAi4B,CAAkCxnB,EAASzQ,EAAQipB,GAC/C,MAAM,kBAAE+O,EAAiB,eAAE/K,EAAc,eAAEC,GAAmBzc,IACzD,YAAaunB,IAAuB/K,GAAmBC,IAGnDjE,IACDxY,EAAQwc,gBAAiB,GAE7Bxc,EAAQyc,eAAiB,CACrB/d,MAAOnP,EAAOmP,OAElB8Z,GAAe1tB,KAAK0tB,YAAYjpB,GAExC,CACA,mCAAAqxB,CAAoC5gB,EAASzQ,GACzC,MAAM,OAAE1E,GAAWmV,EAEfnV,GAAW,YAAaA,EAAO08B,mBAAuBvnB,EAAsB,gBAC5ElV,KAAK08B,kCAAkC38B,EAAQ0E,GAAQ,EAG/D,CAQA,qBAAAk4B,CAAsB5gB,EAAauH,EAAO7e,GACtC,MAAM2Q,EAAY2G,EAAYoH,SAC9B,IAAIyZ,EAAgB58B,KAAKuxB,6BAA6BxV,EAAauH,EAAOlO,EAAW3Q,GAGrF,OAFAA,EAAOsV,IAAMtV,EAAO8M,KAAK3O,OACzB5C,KAAK0kB,oCAAoCkY,EAAe,KAAM,GAAIxnB,EAAW3Q,GACtEm4B,CACX,CAKA,mBAAAC,GACI,OAAO,IAAI7a,CACf,CASA,4BAAAuP,CAA6BxV,EAAauH,EAAOlO,EAAW3Q,GAExD,IAAIq4B,EAAiB98B,KAAK68B,sBAC1BC,EAAene,KAAO5C,EACtB+gB,EAAe7a,YAAcxd,EAAO6S,SAEpCwlB,EAAexa,iBAAmB7d,EAAO4X,WAAWxW,MAAM,GAC1Di3B,EAAeva,gBAAkB9d,EAAO0C,UAAUtB,MAAM,GACpDyd,GAASA,EAAM1gB,OAAS,GACxBk6B,EAAe3vB,eAAemW,GAGlC,IAAIsZ,EAAgB,IAAI5mB,EACpBhJ,EAAO+O,EAAY9X,QAavB,OAZA24B,EAAc5L,IAAI,CACdxnB,OAAQszB,EACR3Z,SAAUpH,EAAYoH,SACtBzS,MAAOqL,EAAYrL,MACnBa,KAAM9M,EAAO8M,KACbxR,OAAQgc,GAAahc,OACrBT,SAAUyc,EAAYiJ,aACtBlhB,MAAOkJ,EACP2V,WAAY3iB,KAAK2iB,aAErBma,EAAe5a,cAAgBzd,EAAOsV,IACtC+iB,EAAej5B,MAAMY,GACdm4B,CACX,CAOA,0BAAApQ,CAA2BzQ,EAAatX,EAAQs4B,GAAO,GACnD,MAAM9Q,EAAcjsB,KAAK2iB,WAErB5G,EAAY1G,UAAY0G,EAAY2V,iBACpCqL,GAAQ/8B,KAAK+1B,mBAAmBha,EAAatX,GAC7CwnB,EAAY+Q,qBAAqBh9B,KAAM+b,EAAatX,GAE5D,CAOA,8BAAAotB,CAA+B9V,EAAatX,EAAQ+Z,GAC5C/Z,EAAOxB,MAAMY,OAASY,EAAOxB,MAAM3B,MACnCtB,KAAK+tB,2BAA2BhS,EAAatX,EAAQ,KAAM,MAAM,GACjEzE,KAAKgyB,wBAAwBxT,EAAM/Z,GACnCA,EAAOmV,WAAWnV,EAAOsV,KAEjC,CAKA,wBAAA+c,GACI,OAAO,SAAU1S,EAAUrI,EAAayC,EAAMhR,EAAS4H,EAAW3Q,GAC9D,MAAM,MAAEG,GAAUH,EAClB,IAAI,SAAE6S,GAAa7S,EACP,MAAR+Z,GACAxe,KAAK6tB,mBAAmB9R,EAAatX,GAIzC,IAAIw4B,EAAUj9B,KAAK0kB,oCAAoC3I,EAAayC,EAAMhR,EAAS4H,EAAW3Q,GAe9F,OAdA6S,EAAW2lB,EAAQlB,YAGnBt3B,EAAOmV,WAAWnV,EAAOsV,IAAKqK,EAAS1T,MAAM5M,OACzCW,EAAOxB,MAAMY,OAASY,EAAOxB,MAAM3B,MACnCtB,KAAK+tB,2BAA2BhS,EAAatX,EAAQ,KAAM,MAAM,GACjEw4B,EAAQlB,YAAczkB,EACtBtX,KAAKgyB,wBAAwBiL,EAASx4B,GACtCA,EAAOmV,WAAWnV,EAAOsV,MAE7B/Z,KAAKwsB,2BAA2BzQ,EAAatX,GAC7CzE,KAAKwsB,2BAA2BpI,EAAU3f,GAC1CG,GAAOgL,QAAQ,gBAAkBtH,EAAMvF,IAAI,qBAAuBqhB,EAAStP,YAChE9U,KAAKqrB,cAAcjH,EAAU3f,EAE5C,CACJ,CAMA,gBAAAkgB,EAAiB,GACbva,EAAE,SAAEga,EAAQ,QAAE5W,EAAO,KAAEgR,EAAI,YAAEzC,EAAW,OAAEtX,EAAM,MAAE6e,EAAK,SACvDiB,EAAQ,UACR2Y,EAAS,eAAEtY,IAEX,IAAIuY,GAAwB,EAC5B,MAAM/nB,EAAY2G,EAAYoH,SACxB3iB,EAAIR,KAIV,OAHAukB,EAAWA,GAAY/jB,EAAE+sB,uBACzB3I,EAAiBA,GAAkBpkB,EAAEm8B,sBACrCO,EAAYA,GAAa18B,EAAEs2B,2BACX,MAAZ1S,EAmBW,MAANha,GAAgBga,EAAS1T,MAAM5M,MAAQsG,EAAGtG,MAEpCo5B,EAAU/7B,MAAMX,EAAG,CAAC4jB,EAAUrI,EAAayC,EAAMhR,EAAS4H,EAAW3Q,IAG5E2f,EAAS1T,MAAM5M,OAASsG,EAAGtG,MACpBkH,EAAWgsB,gBAAgBx2B,EAAGub,EAAaqI,EAAUha,EAAIoU,EAAMhR,EAAS4H,EAAW3Q,EAAQ8f,GAG/FA,EAASpjB,MAAMX,EAAG,CAACgN,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,IA1BzD,MAANpU,EAUOma,EAASpjB,MAAMX,EAClB,CAACgN,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,KAT9C2e,GAAwB,EAExB38B,EAAEiwB,gBAAgB1U,EAAauH,EAAO7e,GACtCA,EAAOsV,IAAMtV,EAAO8M,KAAK3O,OAwB7Bu6B,GACA38B,EAAEkkB,oCAAoC3I,EAAayC,EAAMhR,EAAS4H,EAAW3Q,GACtEsX,IAIXxX,SAAS64B,OAAO1sB,MAAM,GAAIqL,GAE1BtX,EAAOsY,OAAO0I,gBACP1J,EAAYhc,QACvB,CACA,sBAAOi3B,CAAgBx2B,EAAGub,EAAaqI,EAAUha,EAAIoU,EAAMhR,EAAS4H,EAAW3Q,EAAQ8f,EAAUjB,GAE7F,MAAM,MAAE1e,GAAUH,EAElBG,GAAOgL,QAAQ,sBACXtH,EAAMvF,IAAI,6BAGd,IAAI6N,EAAO,KACX0S,EAAQA,GAAS7e,EAAO8M,KAAK/K,UAAU/B,EAAOsV,KAC9C,IAAIpI,EAAYoK,EAAYsQ,gBAAkB5nB,EAAOkN,eAAY3N,EAajE,OAVI4M,EADA2T,EACOA,EAASpjB,MAAMX,EAAG,CAACgN,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,IAE5Dhe,EAAE+sB,uBAAuB/f,EAAS8V,EAAOvH,EAAa3R,EAAI3F,EAAQ+Z,GAEzE7M,IACAlN,EAAOkN,UAAYA,EACfA,IACAlN,EAAO2S,qBAAsB,IAG9BxG,CACX,CACA,eAAA4K,CAAgBhS,GACZ,OAAOA,aAAkBsY,CAC7B,CAOA,mBAAAub,CAAoBC,EAAI9zB,EAAQ/E,GAC5BA,EAAO0I,eAAemwB,EAAI9zB,GAC1B/E,EAAOuO,QACPvO,EAAOkG,mBACX,EAGJ,MAAMmX,UAAkCrhB,EACpC,aAAI88B,GAAc,OAAO,CAAM,EAkBnC,MAAMC,UAA8B1b,EAChCziB,QAAU,WACVE,UAAY,CAAC,SAAUmE,GACnB,OAAuB,GAAnBA,EAAE8K,OAAO5L,OAAoB,GAAWc,CAChD,EAAG,aACH,UAAAuX,GACI,OAAO/b,EAAMu+B,cAAcz9B,KAC/B,EAGJ,MAAM8pB,UAAoC0T,EACtCp+B,KAAO,iCAMP,eAAAqc,GACI,OAAO,CACX,EAGJ,MAAM2O,UAAoCN,EACtC,WAAAhqB,GACI+S,QACA7S,KAAK09B,cAAgB,CACjB/S,SAAS,EAEjB,EAKJ,MAAMV,UAA8BuT,EAChCp+B,KAAO,8BAGX,MAAM8qB,UAAkCsT,EACpCp+B,KAAO,8BAEX,MAAM+qB,UAAoCqT,EACtCp+B,KAAO,gCACP,aAAIojB,GACA,OAAOmb,GACX,EAGJ,MAAM3T,UAA4BwT,EAC9Bp+B,KAAO,4BAQX,MAAMirB,UAA2BmT,EAC7B,WAAA19B,CAAYmB,GACR4R,QACA7S,KAAKZ,KAAO6B,CAChB,EAEJ,MAAMgyB,UAA0BnR,EAC5B,aAAIU,GACA,OAAOmb,GACX,EAGJ,MAAMrJ,UAA4BxS,EAC9B1iB,KAAO,wBACP,aAAIojB,GACA,OAAOmb,GACX,CACA,WAAA79B,CAAYf,GACR8T,QACAjU,OAAOE,eAAekB,KAAM,QAAS,CAAEC,IAAG,IAAYlB,GAC1D,EAEJ,MAAM65B,UAA8B9W,EAChC,aAAIU,GACA,OAAOmb,GACX,CACA,WAAA79B,CAAY2P,GAAM,OAAEtP,EAAM,KAAEE,IAOxB,GANAwS,QACqB,iBAAV,IACPpD,EAAOA,EAAK2d,QAAQ,IAAK,KACzBptB,KAAKX,QAAUgB,GAAMhB,SAAWoQ,EAChCzP,KAAKZ,KAAOiB,GAAMjB,MAAQqQ,GAE1BpP,EAAM,CAEN,MAAM1B,EAAOC,OAAOD,KAAK0B,GACnBu9B,EAASh/B,OAAOD,KAAKqB,MAE3B,CAAC,OAAQ,SAASoB,SAAQmC,IACtB,MAAME,EAAM9E,EAAKsF,QAAQV,IACZ,IAATE,UACQ9E,EAAK8E,EAAK,IAG1B,MAAMo6B,EAAQl/B,EAAK0Q,QAAQtD,IAA6B,IAAvB6xB,EAAO35B,QAAQ8H,KAC1CvL,EAAIR,KACV69B,EAAMz8B,SAAS7C,IACXK,OAAOE,eAAe0B,EAAGjC,EAAG,CAAE0B,IAAG,IAAYI,EAAK9B,IAAQ,GAElE,CACJ,EAGJW,EAAMyB,QAAU,IACTzB,EAAMyB,QACTqK,cAGJpN,EAAQoN,WAAaA,EACrBpN,EAAQsB,MAAQA,EAChBtB,EAAQ6C,SAAWA,EACnB7C,EAAQ+D,WAAaA,EACrB/D,EAAQkkB,0BAA4BA,EAEpC,MAAM,sBAAEE,GAA0B,EAAQ,OACpC,mBAAE9O,GAAuB,EAAQ,OACjC,qBAAE4qB,GAAyB,EAAQ,OACnC,qBAAEp8B,GAAyB,EAAQ,OACnC,wBAAEO,GAA4B,EAAQ,MAI5C/C,EAAMyB,QAAQqhB,sBAAwBA,C,4BClkHtC,MAAMf,EAAM,QACN8c,EAAQ,QACRC,EAAS,SACTC,EAAS,SACTC,EAAS,SACf,MAAMvd,EACF,cAAWM,GAAM,OAAOA,CAAK,CAC7B,gBAAW8c,GAAQ,OAAOA,CAAO,CACjC,iBAAWC,GAAS,OAAOA,CAAQ,CACnC,iBAAWC,GAAS,OAAOA,CAAQ,CACnC,iBAAWC,GAAS,OAAOA,CAAQ,CAMnC,cAAO3c,CAAQlhB,GAEX,OAAmE,GAA5DsgB,EAAqBwd,qBAAqBl6B,QAAQ5D,EAC7D,CACA,yBAAO89B,GACH,MAAO,CACHld,EAAI8c,EAAOC,EAAQC,EAAQC,EAEnC,EAEJtgC,EAAQ+iB,qBAAuBA,C,8BC1B/B/hB,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtDnB,EAAQgjB,oBAAiB,EACzB,MAAM,MAAEtY,GAAU,EAAQ,OACpB,qBAAEyF,GAAyB,EAAQ,MACnC,gBAAE3C,GAAoB,EAAQ,KAG9BgzB,EAAwB,CAAC,EA21B/BxgC,EAAQgjB,eAv1BR,MACIyd,aAEA,UAAArqB,EAAW,YAAE+nB,GAAe7mB,EAASopB,GACjCvC,EAAcwC,EACdv1B,UAAU,GAAG+yB,YAAcA,CAC/B,CACA,sBAAAjK,EAAuB,YAACiK,IAGxB,CAQA,oBAAA7K,CAAqB7wB,EAAMpB,EAAMiW,EAASzQ,GACtC,MAAM,gBAAEiP,GAAoBjP,EAC5B,OAAQxF,GACJ,KAAKs/B,EACL,KAAKC,EACDn+B,EAAOA,EAAKkO,YACZ,IAAIf,EAAU/I,EAAOqF,OACjB0D,EAAQ5K,OAAS,IACjB6B,EAAOe,OAAOrB,KAAKqJ,GACnBkG,EAAgBzF,SAEpBxJ,EAAO0I,eAAe9M,EAAM6U,GAC5BjW,EAAOklB,EACP,MACJ,KAAKA,EACD1f,EAAO0I,eAAe9M,EAAM6U,GAC5B,MACJ,KAAKupB,GAEDp+B,EAAOA,EAAKkO,aACH3L,OAAS,IACd6B,EAAO0I,eAAe9M,EAAM6U,GAC5BjW,EAAOklB,GAEX,MACJ,KAAKua,GACDr+B,EAAOA,EAAKkO,aACH3L,OAAS,IACd6B,EAAOqS,cAAgBrS,EAAOkG,oBAC9BlG,EAAO0I,eAAe9M,EAAM6U,GACxBzQ,EAAOe,OAAO5C,OAAS,IACvB6B,EAAOuO,QACPU,EAAgBvG,eAAe1I,EAAOoG,OAAM,KAEhD5L,EAAOklB,GAEX,MACJ,KAAKwa,GACDt+B,EAAOA,EAAKkO,aACH3L,OAAS,IACd6B,EAAO0I,eAAe9M,EAAM6U,GAC5BzQ,EAAOuO,QACP/T,EAAOklB,GAEX,MACJ,QACI,MAAM,IAAI1lB,MAAM,+BAAiCQ,GAEzDiW,EAAQjW,KAAOA,CACnB,CAKA,wBAAA2/B,EAAyB,KAAE3/B,EAAI,aAAE6X,EAAY,UAAEnF,GAAalN,GACxD,MAAMjG,EAAIwK,UAAU,GACpB,OAAQ/J,GACJ,KAAK4/B,EACL,KAAKL,EACL,KAAKD,EACL,KAAKG,EACL,KAAKI,EACDntB,GAAY,EACZmF,GAAe,EAMvBtY,EAAEsY,aAAeA,EACjBtY,EAAEmT,UAAYA,EACVlN,IACAA,EAAOkN,UAAYA,EACnBlN,EAAOqS,aAAeA,EACtBrS,EAAO6S,SAAWrY,EAE1B,CAMA,sBAAA07B,EAAuB,KAAE17B,EAAI,eAAEytB,IAAkB,aAAE5V,EAAY,KAAEvF,EAAI,IAAEwI,EAAG,OAAEnX,IAExE,MAAM6B,EAASuE,UAAU,GAQzB,OANI0jB,GAAkBqS,EAAsBC,2BACpC//B,GAAQs/B,IACRt/B,EAAOklB,EACPrN,EAAgBiD,GAAOnX,GAAY2O,EAAKlD,UAAUzL,QAAUmX,GAG5D9a,GACJ,KAAKs/B,EACL,KAAKE,EACL,KAAKD,EACD1nB,GAAe,EAGvBrS,EAAOqS,aAAeA,CAC1B,CAMA,kBAAAga,CAAmB/xB,EAAOyK,EAAQ/E,GAI9B,OAHIzE,KAAKq+B,eACLt/B,EAAQA,EAAMsP,WAEXtP,CACX,CAIA,cAAIi9B,GACA,OAAO7X,CACX,CACA,qBAAAmS,CAAsBr3B,EAAMwF,GACxB,OAAQxF,GACJ,KAAKs/B,EACL,KAAKE,EACDh6B,EAAOkN,WAAY,EAI/B,CACA,qCAAA8mB,CAAsC14B,EAAQ0E,GAAQ,eAAEioB,IACpD,GAAI3sB,EACAA,EAAOd,KAAOs/B,MACX,CACH,IAAIU,EAAe9a,EACfuI,GAAkBqS,EAAsBG,gBACxCD,EAAeV,GAEnBv+B,KAAK26B,uBAAuB,CAAE17B,KAAMggC,EAAcvS,kBAAkBjoB,EACxE,CACJ,CAKA,WAAAi0B,CAAYlvB,GACHA,EAAc,SAAMA,EAAOvK,MAAQklB,IACpC3a,EAAOvK,KAAOs/B,EAEtB,CACA,mBAAAY,EAAoB,QAAEhS,EAAO,OAAE3jB,EAAM,OAAE/E,EAAM,MAAE60B,EAAK,OAAExvB,EAAM,WAAEs1B,EAAU,UAAEC,IACtE,IAAItgC,EAAQ,GACRE,EAAOuK,EAAOvK,KAMlB,OALImgC,IACArgC,GAAS+K,EACT7K,EAAOs/B,GAGJ,CAAEx/B,QAAOouB,QADhBA,EAAUA,EAAQ9e,UACOpP,OAC7B,CAMA,uBAAA+sB,CAAwBxiB,EAAQ/E,GAC5B,GAAI+E,EAAQ,CACR,MAAMgV,EAAO/Z,EAAO4X,WAAW,IACzB,eAAEqQ,EAAc,KAAEztB,GAASuK,EACjC,IAAI81B,EAAmB76B,EAAOiP,gBAAgB/H,QACzC+gB,GAAkBqS,EAAsBC,2BAA+B//B,GAAQklB,IAChF1f,EAAO6S,SAAWinB,EAClB/0B,EAAOvK,KAAOs/B,EAET/f,EAAKud,aAAe5X,GAAc,IACnC3F,EAAKud,YAAcwC,GAG/B,CACJ,CACA,mBAAAlF,CAAoBzkB,EAAc0kB,EAAO70B,GACrCA,EAAOiG,aACP,IAAIuF,EAAI,GAWR,OAVE/J,MAAMC,QAAQyO,GAAiCA,EAAjB,CAACA,IAC7BxT,SAAQmC,IACJkB,EAAOiP,gBAAgBvG,eAAe5J,GACtCkB,EAAOuO,OAAO,IAER,OAAVsmB,GACA70B,EAAOe,OAAOrB,KAAKm1B,GACvBrpB,EAAIxL,EAAOoG,OAAM,GACjBpG,EAAOqG,qBAEA,CAAEwuB,MADTA,EAAQrpB,EAEZ,CAMA,8BAAAsvB,CAA+B7rB,EAAiBzE,GAC5C,MAAM,cAAErH,EAAa,YAAEC,GAAgBoH,EACvCyE,EAAgBvG,eAAe,CAC3BvB,eAAgBhE,EAChBuE,aAActE,GAEtB,CAKA,sBAAAy0B,EAAuB,QAAEnP,EAAO,OAAE3jB,EAAM,MAAE8vB,EAAK,OAAExvB,EAAM,KAAEzJ,EAAI,SAAEggB,EAAQ,OAAE5b,EAAM,KAAExF,EAAI,eAAEk9B,EAAc,cACjGF,EAAa,aAAErnB,EAAY,WAAE3F,IAC7B,IAAIuwB,EAAM,GACV,MAAM,MAAE56B,EAAK,SAAE+P,EAAQ,gBAAEjB,GAAoBjP,EAC7CxF,EAAe+E,MAAR/E,EAAoBklB,EAAYllB,EACvC,MAAMwgC,EAASz2B,UAAU,GACzB,IAAIq2B,EAAa/F,EAAM12B,OAAS,EAC5Bw8B,EAAct1B,EAAOlH,OAAS,EAClC,IAAKy8B,IAAcD,EACf,OAAOjS,EAEPvY,MAIG0kB,SAAUt5B,KAAKq5B,oBAAoBzkB,EAAc0kB,EAAO70B,IAC3DmQ,EAAe,MAInB,IAAI8qB,OADmC,IAAhBl2B,EAAW,KACD2a,EAAY3a,EAAOvK,KAEpD2F,GAAOgL,QAAQ,uBACXtH,EAAMvF,IAAI,iCACVD,QAAQC,IAAI,CAAEoqB,UAASrjB,SAAQwvB,QAAOr6B,OAAMoB,UAGhD,MAAMs/B,EAAY,KACd,MAAMj4B,EAAY,CAAC,EACb8F,EAAU/I,EAAOoG,OAAM,EAAMnD,GACnC83B,GAAOhyB,EACPoyB,EAAe,CAAE91B,OAAQ0D,EAASnN,KAAMqH,EAAUrH,MAAO,EAEvDu/B,EAAiB,EAAG91B,SAAQzJ,WAC9BggB,EAASzY,cAAczD,KAAK2F,GAC5BuW,EAASxY,YAAY1D,KAAK9D,EAAK,EAG7Bw/B,EAAsB,EAAGh4B,cAAaD,oBACxCmG,EAAqBqS,kBAAkBC,EAAU,CAAExY,cAAaD,iBAAgB,EAEpF,IAAIk4B,GAAqB,EAEzB,MAAMC,EAAwB,CAAC/zB,EAAG,aAC1B8zB,IACJ10B,EAAgB4D,oBAAoBC,EAAYjD,GAChDlC,EAASmF,EAAWrH,cAAcmD,KAAK,IACvC+0B,GAAqB,EAAI,GAIxBt2B,EAAOw2B,mBAAmBC,kBAAoB,WAAW53B,KAAK8kB,KAAc3jB,EAAOzF,OAAOnB,OAAS,GACpGm9B,IAMJ,MAAMG,EAAa,CAAC,EACpB,OAAQjhC,GACJ,KAAKs/B,EACDwB,IAEIP,EADA7qB,EACM7K,EAEA9J,KAAKmgC,uBAAuB17B,GAAQ,EAAM60B,EAAOxvB,EAAQs1B,EAAYC,GAE3EG,EAAI58B,QAAU,EACd88B,EAAoBnB,EAEpB2B,EAAW/xB,WAAaqxB,EAC5B,MACJ,KAAKhB,EAGD/5B,EAAOkG,oBACP,IAAI5L,EAAQ,KACTA,QAAOE,OAAMkuB,WAAYntB,KAAKm/B,oBAAoB,CAAEhS,UAAS3jB,SAAQ8vB,QAAOxvB,SAAQrF,SAAQ26B,aAAYC,eAC3G56B,EAAOiP,gBAAgBvG,eAAepO,GACtC0F,EAAOuO,QACPwsB,EAAM/6B,EAAOoG,OAAM,EAAMq1B,GACzB,MACJ,KAAKzB,EACDh6B,EAAOkG,oBACH00B,GACA56B,EAAOe,OAAOrB,KAAKm1B,GACnB8F,IACA1rB,EAAgBvG,eAAerD,GAC/BrF,EAAOuO,SAEXwsB,EAAM/6B,EAAOoG,OAAM,EAAMq1B,GACrBR,GAAqBlB,IACrBkB,EAAoBnB,GAExB,MACJ,KAAKG,EACGW,IACA56B,EAAOe,OAAOrB,KAAKm1B,GACnBkG,EAAM/6B,EAAOoG,OAAM,GACnBw0B,GAAY,GAEZD,IACKC,GACD56B,EAAOkG,oBAEXlG,EAAOiP,gBAAgBvG,eAAerD,EAAOyE,aAC7C9J,EAAOuO,QACPwsB,GAAO/6B,EAAOoG,OAAM,IAExB,MACJ,KAAKu1B,EACGf,IACA56B,EAAOkG,oBACPlG,EAAOe,OAAOrB,KAAKm1B,GACnBkG,EAAM/6B,EAAOoG,OAAM,IAEnBf,EAAOlH,OAAS,IACX,QAAQyF,KAAK8kB,KACdA,GAAWjuB,EAAMqQ,WAAW9K,EAAOiP,gBAAiB,IAAKlK,EAAQ/E,IAErE+6B,GAAO11B,GAEX,MAEJ,KAAKu2B,EAED57B,EAAOkG,oBACH00B,IACA56B,EAAOe,OAAOrB,KAAKm1B,GACnBqG,KAEAP,IAEAh0B,EAAgB4D,oBAAoBC,EAAY,WAChDjP,KAAKu/B,+BAA+B7rB,EAAiBzE,IAGzDxK,EAAOuO,QACPwsB,EAAM/6B,EAAOoG,OAAM,EAAMq1B,GACrBz7B,EAAO6S,UAAYrY,IACnBygC,EAAoBzgC,GAExB,MACJ,KAAKklB,EACGkb,IACA56B,EAAOkG,oBACPlG,EAAOe,OAAOrB,KAAKm1B,GACnBqG,KAEA71B,EAAOlH,OAAS,IAChB48B,GAAO11B,EACP+1B,EAAoB5wB,IAExB,MACJ,KAAK4vB,EACDp6B,EAAOkG,oBACHy0B,IACA1rB,EAAgBvG,eAAerD,GAC/BrF,EAAOuO,SAEXwsB,EAAM/6B,EAAOoG,OAAM,GACnB5L,EAAO0/B,EACP,MACJ,KAAKA,EACDa,EAAMx/B,KAAKmgC,uBAAuB17B,GAAQ,EAAM60B,EAAOxvB,EAAQs1B,EAAYC,GAC3EK,EAAoBvb,EACpB,MACJ,KAAK2a,IACE3R,UAASqS,OAAQx/B,KAAKsgC,cAAcnT,EAASmM,EAAOxvB,EAAQs1B,EAAYC,EAAWlD,EAAgB+D,EAAY7f,IAC5G,eAAgB6f,IAClBA,EAAuB,WAAIjxB,EAAWpH,YAAYkD,KAAK,KAE3D,MAEJ,QACI,MAAM,IAAItM,MAAM,qBAAuBQ,GAW/C,MATI,eAAgBihC,GAChBL,EAAoB,CAAEh4B,YAAa,CAACq4B,EAAW/xB,YAAavG,cAAe,CAAC43B,KAGhFh2B,EAAOvK,KAAOygC,EACd1/B,KAAKugC,oCAAoC/2B,EAAQ/E,GACjDg7B,EAAOxgC,KAAOuK,EAAOvK,KACrBwgC,EAAOxD,cAAgBA,EACvBwD,EAAO7qB,aAAeA,EACfuY,EAAUqS,CACrB,CAUA,aAAAc,CAAcnT,EAASmM,EAAOxvB,EAAQs1B,EAAYC,EAAWlD,EAAgB+D,GACzE,IAAIV,EAAM,GAOV,OANIlG,EAAM12B,OAAS,IACf48B,GAAOlG,GAEPxvB,EAAOlH,OAAS,IAChB48B,GAAO11B,GAEJ,CAAEqjB,UAASqS,MACtB,CAMA,mCAAAe,CAAoC/2B,EAAQ/E,GACxC,MAAM,KAAExF,EAAI,eAAEytB,GAAmBljB,GAC3B,aAAEsN,EAAY,UAAEnF,GAAclN,EACpCzE,KAAK4+B,yBAAyB,CAAE3/B,OAAMytB,iBAAgB5V,eAAcnF,aAAalN,EACrF,CACA,sBAAA07B,CAAuB17B,EAAQ+7B,EAAalH,EAAOxvB,EAAQs1B,EAAYC,GACnE,MAAM,gBAAE3rB,GAAoBjP,EAE5B+7B,GAAe/7B,EAAOkG,oBAClB00B,GACA56B,EAAOe,OAAOrB,KAAKm1B,GAEnB8F,IACA1rB,EAAgBvG,eAAerD,GAC/BrF,EAAOuO,SAEX,IAAIwsB,EAAM/6B,EAAOoG,OAAM,GACvB,OAAO20B,EAAIhxB,OAAO5L,OAAS,EAAI48B,EAAM,EACzC,CAMA,UAAAiB,CAAW/T,GACP,OAAQA,GAAkBqS,EAAsBG,eAC3CxS,GAAkBqS,EAAsBC,yBACjD,CAMA,uBAAA0B,CAAwBzhC,GACpB,OAAQA,GACJ,KAAKy/B,EACL,KAAKF,EACD,OAAO,EAGf,OAAO,CACX,CAOA,gBAAArjB,CAAiBjW,EAAWsE,EAAQzK,EAAO0F,GACvC,IAAI,KAAExF,GAASuK,EACf,MAAM,MAAE5E,GAAUH,EAClB,GAAIA,EAAO4X,WAAWzZ,OAAS,EAAG,CAC9B,MAAM4b,EAAO/Z,EAAO4X,WAAW,GAC/BzX,GAAOgL,QAAQ,yBACXtH,EAAMvF,IAAI,4CACVD,QAAQC,IAAKhE,IAGbyK,EAAOkjB,gBAAkBqS,EAAsBC,2BAE3Ch/B,KAAK0gC,wBAAwBliB,EAAKud,eAC9Bt3B,EAAOkN,WAAwD,GAA1ClN,EAAO8M,KAAKhD,YAAYtK,QAAQlF,GACrDyf,EAAKud,YAAcwC,EAEnB/f,EAAKud,YAAcqE,EAInC,CACI52B,EAAOsK,WACP7U,EAAOs/B,GAEX/0B,EAAOvK,KAAOA,CAGlB,CACA,cAAA0hC,CAAez7B,EAAWsE,EAAQ/E,EAAQ+I,EAAS4rB,GAC/C,OAAO5vB,EAAOzJ,MAClB,CACA,cAAO2hB,CAAQtiB,GACX,GAAIA,KAAQg/B,EACR,OAAOA,EAAsBh/B,GAEjC,IAAI0B,EAAI,KACJ8/B,EAAQxhC,EAAO,aACnB,MAAMyhC,EAAWC,EACjB,IACIjf,EADK,IAAI/Q,SAAS,MAAO,UAAU8vB,oBAAwBA,MACpDz/B,MAAM4/B,WAAY,CAACF,IAC9B,GAAIhf,EAGA,OAFA/gB,EAAI,IAAI+gB,EACRuc,EAAsBh/B,GAAQ0B,EACvBA,EAEX,MAAM,IAAIrC,MAAM,gCACpB,CAUA,oBAAAuiC,CAAqB9rB,EAAS1H,EAAS/I,EAAQ+Z,GAC3C,IAAIyiB,EAAW,GAgBf,OAfIx8B,EAAOmP,MAAQ,IACV4K,EAAKhK,cAAwC,GAAvBgK,EAAK2O,QAAQvqB,SAKhC4b,EAAKkX,YAAY9yB,QAAU4b,EAAK2O,QAAQ3e,OAAO5L,QAC/C6B,EAAOuO,QAEXiuB,EAAWx8B,EAAOoG,OAAM,GAAQ2C,IAGpC/I,EAAOuO,QACPiuB,EAAWx8B,EAAOoG,OAAM,IAErB,CAAEo2B,WACb,CAOA,0BAAAlH,CAA2B70B,EAAWg8B,EAAaz8B,GAAQ,GAAE20B,EAAE,KAAE5a,IAE7D,MAAM,OAAEze,EAAM,KAAEd,EAAI,SAAE6U,EAAQ,eAAE4Y,GAAmBwU,EACnD,IAAIC,EAAOzU,GAAkBqS,EAAsBG,eAAkB,EACjEkC,GAAY,EAmBhB,GAlBIrhC,EAEIA,EAAOd,KADPkiC,EACc5C,EAIAt/B,GAIlBmiC,EAAaF,EAAYjiC,MAAQohC,EAC7Bc,EACAD,EAAYjiC,KAAOs/B,EAGnBv+B,KAAKugC,oCAAoCW,EAAaz8B,IAG1DioB,GAAkBqS,EAAsBC,2BAExC,GAAIh/B,KAAKqhC,yBAAyB58B,IAC7B20B,EAAGx2B,OAAS,EAAI,CACjB6B,EAAOiG,aACPjG,EAAOkG,oBACPlG,EAAOiP,gBAAgBvG,eAAeisB,GACtC30B,EAAOuO,QACP,IAAIxF,EAAU/I,EAAOoG,OAAM,GAC3BpG,EAAOqG,qBACPrG,EAAOiP,gBAAgBvG,eAAeK,GACtC4rB,EAAK,EACT,OAGA,GADAgI,EAAYA,GAAc5iB,GAAMud,aAAewC,EAC3C6C,EAAW,CACX38B,EAAOiG,aACPjG,EAAOkG,oBACPlG,EAAOiP,gBAAgBvG,eAAeisB,GACtC30B,EAAOuO,QACP,IAAIxF,EAAU/I,EAAOoG,OAAM,GAC3BpG,EAAOqG,qBACPrG,EAAOiP,gBAAgBvG,eAAeK,GACtC4rB,EAAK,EACT,CAEJ,MAAO,CAAEA,KACb,CACA,wBAAAiI,EAAyB,OAAEv3B,EAAM,UAAE6H,IAC/B,OAAOA,GAAa7H,EAAOR,MAAM,MAAM1G,OAAS,CACpD,CAQA,gBAAAggB,CAAiB3jB,EAAM6K,EAAQszB,GAC3B,OAAOtzB,EAASszB,CACpB,CAQA,kCAAAjD,CAAmCj1B,EAAWgQ,EAAS1H,EAASgR,EAAM/Z,GAClE,MAAM,OAAE1E,EAAM,QAAEsV,GAAYH,EAC5B,IAAIosB,GAAe,EACnB,GAAIvhC,EAAQ,CACR,MAAM,KAAEd,EAAI,OAAE8E,EAAM,mBAAEm0B,GAAuBn4B,EAC7C,GAAIm4B,GACA,GAAKn0B,EAAOnB,OAAS,EACb3D,GAAQs/B,IAER95B,EAAOiG,aACIjG,EAAOiP,gBACbvG,eAAeK,GACpB/I,EAAOuO,QACPxF,EAAU/I,EAAOoG,OAAM,GACvBpG,EAAOqG,qBACPrG,EAAOe,OAAOrB,KAAKqJ,GACnBA,EAAU,SAEX,GAAI6H,IAAY5Q,EAAOiP,gBAAgB/H,QAAS,CACnD,IAAIpF,EAAI9B,EAAOqF,OACfvD,EAAI9B,EAAOoG,OAAM,GAAQtE,EACzB9B,EAAOe,OAAOrB,KAAKoC,EAAIiH,GACvBA,EAAU/I,EAAOoG,OAAM,GACvB9K,EAAOd,KAAOu/B,CAClB,OAEA8C,GAAe,CAEvB,CAEI9zB,GAAShI,QAAQ5C,OAAS,GAC1B6B,EAAOe,OAAOrB,QAAQqJ,EAAQhI,QAE9BgI,GAASW,YAAYvL,OAAS,GAC9B6B,EAAO0J,WAAWhK,QAAQqJ,EAAQW,YAItC,MAAMozB,EAAa98B,EAAO4X,WAAWzZ,OAAS,EAAK6B,EAAO4X,WAAW,GAAK,KACrEilB,GAGGC,GAAaA,EAAU5sB,WACvBzP,EAAU8tB,mBAAmBuO,EAAU5sB,SAAUlQ,GACjD88B,EAAU5sB,SAAW,MAED,iBAAb,EACPlQ,EAAO0I,eAAeK,EAAS0H,GAE/BzQ,EAAOiP,gBAAgBvG,eAAeK,IAT1C/I,EAAOiP,gBAAgBvG,eAAeK,GAYtC6H,GAAWksB,GAEPA,EAAUxF,aAAe5X,IAEzBod,EAAUxF,YAAc+C,EACxBr6B,EAAO6S,SAAWiqB,EAAU/3B,OAAOvK,KAC7Bs/B,EAGlB,CAOA,yBAAApJ,CAA0B3rB,EAAQ/E,EAAQ+Z,GACtCA,EAAOA,GAAQ/Z,EAAO4a,eACtB,IAAI,QAAE8N,EAAO,YAAE4O,GAAgBvd,GAAQ,CAAC,EACxC,MAAMgjB,EAAgBhjB,GAAMhV,QACtB,eAAEkjB,GAAmBljB,EAC3B,IAAI,aAAEsN,EAAY,SAAEQ,EAAQ,UAAEpS,GAAcT,EAC5C,OAAQioB,GACJ,KAAKqS,EAAsBG,cACvBpoB,GAAe,EACfQ,EAAWinB,EACX,MACJ,KAAKQ,EAAsBC,0BAEvB,GAAK7R,GAASvqB,OAAS,GAAO6B,EAAOmT,aAAahV,OAAS,GAAOm5B,IAAgBsE,GAAiBtE,GAAewC,EAAgB,CAC9HznB,GAAe,EACfilB,EAAc5X,EACd3F,EAAKud,YAAc5X,EACnB3F,EAAKhV,OAAOvK,KAAOwF,EAAO6S,SAAW+oB,EACrC,MAAMoB,EAAWj4B,EAAOk4B,uBACxB,IAAIC,EAA6B39B,MAAZy9B,EAAwB,IAAMA,EACnD,GAAIE,EAAgB,CAChB,IAAI7gC,EAAIwO,EAAqBC,WAAWrK,EAAWy8B,EAAgBn4B,EAAQ/E,GAC3EA,EAAOiP,gBAAgBxH,QAAQpL,EACnC,CACAoE,EAAU8sB,wBAAwBxT,EAAM/Z,GACxCqS,GAAe,EACfQ,EAAWkH,EAAKhV,OAAOvK,IAC3B,KAAO,CACH,IAAI2iC,EAASvB,EACTmB,GAAensB,SAA6B,GAAjB8X,GAASvqB,SACpC4b,EAAKud,YAAc0C,GAEvB3nB,GAAe,EACfQ,EAAWsqB,CACf,EAKRn9B,EAAOqS,aAAeA,EACtBrS,EAAO6S,SAAWA,CACtB,CACA,mBAAA+iB,CAAoBp7B,EAAMwF,GACdxF,IACCw/B,IACDx/B,EAAOu/B,GAGf/5B,EAAO6S,SAAWrY,EAClBwF,EAAOkN,UAAY3R,KAAK6hC,YAAY5iC,EACxC,CACA,WAAA4iC,CAAY5iC,GACR,OAAOA,GAAQu/B,CACnB,CAIA,iBAAA7E,EAAkB,OAAEnwB,EAAM,OAAE/E,EAAM,OAAE2sB,EAAM,QAAE5jB,EAAO,MAAEC,EAAK,YAAEsqB,GAAc,IACtE,OAAO3G,EAAO,CAAE5nB,SAAQgE,UAASC,QAAOsqB,eAAetzB,EAC3D,CAMA,6BAAAq9B,CAA8BC,EAAKt9B,GAC/Bs9B,EAAIhG,YAAc+C,CACtB,CAOA,oBAAA9B,CAAqB93B,EAAW6W,EAAatX,GAGzC,GAFAsX,EAAY2V,gBAAiB,EAC7BxsB,EAAUwoB,YAAYjpB,IACjBA,EAAOu9B,qCAAsC,CAC9C,IAAIC,EAAMx9B,EAAOoG,OAAM,GACvB,GAAIo3B,EAAIr/B,OAAS,EACb,MAAM,IAAInE,MAAM,oCAAsCwjC,EAE9D,CACAlmB,EAAY9c,KAAOw/B,EACnB,MAAM,OAAE1+B,GAAWgc,EACfhc,IACAA,EAAOd,KAAOklB,EAEtB,CAQA,yCAAA2V,CAA0C50B,EAAWg8B,EAAaz8B,GAC9D,MAAM,KAAExF,GAASiiC,EACjB,GAAQjiC,IACCs/B,EAAL,CAEI,IAAI/wB,EAAU/I,EAAOqF,OACrBrF,EAAOkG,oBACP,IAAIs2B,EAAWx8B,EAAOoG,OAAM,GACxB2C,EAAQ5K,OAAS,GACjB6B,EAAOe,OAAOrB,KAAKqJ,GAEvB/I,EAAOiP,gBAAgBvG,eAAe8zB,GACtCC,EAAYjiC,KAAOklB,CACd,CAEjB,CACA,4BAAA+d,CAA6B14B,EAAQ/E,GACjC,MAAM,KAAExF,GAASuK,EACjB,IAAIy3B,EAAWx8B,EAAOqF,OAGtB,OADAm3B,GAAYx8B,EAAOoG,OAAM,GAClBo2B,CACX,CACA,gBAAAvO,CAAiBlpB,EAAQ/E,GAErB+E,EAAOvK,KAAOy/B,EACd1+B,KAAKugC,oCAAoC/2B,EAAQ/E,EACrD,CACA,oBAAA09B,CAAqBzM,EAAa5rB,GAC9B,MAAO,CAAC4rB,EAAa5rB,GAAQiB,KAAK,KACtC,CACA,uBAAAq3B,CAAwB54B,EAAQ6pB,EAAQ5uB,GACpC,IAAI,KAAExF,GAASuK,EACXyG,EAAIojB,EAYR,OAXQp0B,IACCy/B,IACDj6B,EAAOiG,aACPjG,EAAOkG,oBACPlG,EAAOe,OAAOrB,KAAK8L,GACnBA,EAAIxL,EAAOoG,OAAM,GACjBpG,EAAOqG,qBACP7L,EAAOklB,GAGf3a,EAAOvK,KAAOA,EACPgR,CACX,GAWJ,MAAM,gBAAEoyB,GAAoB,EAAQ,MAC9B,UAAEle,EAAS,cAAEoa,EAAa,eAAEE,EAAc,aAAED,EAAY,wBAAEK,EAAuB,gBAAEC,EAAe,mBACpGJ,EAAkB,qBAAEC,EAAoB,kBAAEyB,EAAiB,YAAEC,EAC7D,sBAAEtB,EAAqB,eACvBhd,GAAmB,EAAQ,OACzB,iBAAE7f,GAAqB,EAAQ,OAC/B,WAAE8I,EAAU,MAAE9L,GAAU,EAAQ,MAChC,iBAAE8W,GAAqB,EAAQ,KAC/B,qBAAE1G,GAAyB,EAAQ,MAGnCwxB,EAAU,CACZuB,kB,4BCn3BJzjC,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAcpDnB,EAAQumB,UAXU,EAYlBvmB,EAAQ2gC,cAPc,EAQtB3gC,EAAQ6gC,eAXe,EAYvB7gC,EAAQ4gC,aAVa,EAWrB5gC,EAAQihC,wBATwB,EAUhCjhC,EAAQ8gC,mBAbmB,EAc3B9gC,EAAQ+gC,qBAVqB,EAW7B/gC,EAAQkhC,gBAjBgB,EAkBxBlhC,EAAQwiC,kBAXkB,GAY1BxiC,EAAQyiC,YAXY,GA+BpBziC,EAAQmhC,sBAAwB,CAC5B,iBAAIG,GACA,OAhBc,CAiBlB,EACA,qBAAIoD,GACA,OAjBkB,CAkBtB,EACA,iBAAIC,GACA,OAlBc,CAmBlB,EACA,iBAAIC,GACA,OAlBc,CAmBlB,EACA,6BAAIxD,GACA,OAnB0B,CAoB9B,EACA,qCAAIyD,GACA,OApBkC,CAqBtC,GAIJ7kC,EAAQmkB,eAAiB,CACrBoC,UA/Dc,EAgEdsa,eA9DmB,EA+DnBC,mBA9DuB,EA+DvBF,aA9DiB,EA+DjBD,cA9DkB,EA+DlBM,wBA9D4B,EA+D5BC,gBApEoB,GAwExBlhC,EAAQ0oB,iBAAmB,SAASpR,EAASzQ,EAAQ+Z,GAC7C,IAAI6X,EAAQnhB,EAAQjW,KAChBgiC,EAAW,GACXzzB,EAAU/I,EAAOqF,OAEjBmiB,EAAcjsB,KAAK2iB,WACvB,OAAQ0T,GACJ,KAjFK,EAgHL,KAAK,EAED5xB,EAAOuO,QACPvO,EAAOkG,oBACPs2B,EAAWx8B,EAAOoG,OAAM,GACxBwrB,EA/GM,EAiHN,MAhCJ,KAjFU,EAmFN,IAAI/Q,GAAU,EACe,GAAzB9X,EAAQgB,OAAO5L,QACf6B,EAAOiP,gBAAgBzF,QACvBT,EAAU,GACV8X,GAAS,GAET7gB,EAAOuO,QAEXiuB,EAAWx8B,EAAOoG,OAAM,GACpBya,GAAY2b,EAASr+B,OAAS,IAC9ByzB,EAlGF,GAoGF,MACJ,KArGM,EAuGF4K,EAAWx8B,EAAOqF,OAClBm3B,EAAWx8B,EAAOoG,OAAM,GAAQo2B,EAChC,MACJ,KAvGe,EAyGXA,EAAWx8B,EAAOoG,OAAM,GAAM2C,EAC9B6oB,EAxGM,EAyGN,MASJ,KArHW,EAsHH7oB,EAAQ5K,OAAO,IACf6B,EAAOuO,QACPiuB,EAAWx8B,EAAOoG,OAAM,GACxBwrB,EA3HF,GA6HF,MACJ,KA1HS,IA2HH4K,YAAYhV,EAAY+U,qBAAqB9rB,EAAS1H,EAAS/I,EAAQ+Z,IACzE6X,EA3HM,EA4HN,MACJ,KA5HoB,EA6HhB5xB,EAAOuO,QACPiuB,EAAWx8B,EAAOoG,OAAM,GAEpBwrB,EADA4K,EAASr+B,OAAS,EAhIhB,EALJ,EA4IV,OADAsS,EAAQjW,KAAOo3B,EACR4K,CACf,EASArjC,EAAQ2oB,gCAHR,SAAyCxK,EAAatX,GAEtD,EAgBA7G,EAAQ8kC,cAVR,MACI,iBAAWC,GACP,MAJU,QAKd,CACA,eAAWC,GACP,MANQ,MAOZ,E,6BCpKJhkC,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,iBAAEmD,GAAqB,EAAQ,OAC/B,iBAAE8T,GAAqB,EAAQ,KAC/B,eAAE4K,GAAmB,EAAQ,OAC7B,UAAEuD,EAAS,cAAEoa,EAAa,eAAEE,EAAc,aAAED,EAAY,wBAC1DK,EAAuB,mBAAEH,EAAkB,qBAC3CC,EAAoB,sBACpBI,GAA0B,EAAQ,OAEhC,MAAE7/B,GAAU,EAAQ,MAKpB2jC,EAAoB,CAAC1e,EAAWoa,GA8QtC3gC,EAAQykC,gBA5QR,cAA8BzhB,EAC1BkiB,eAAgB,EAShB,gBAAAlgB,CAAiB3jB,EAAM6K,EAAQszB,GAC3B,OAAQn+B,IACCw/B,EACD30B,EAASA,EAAOuE,UAAY+uB,EAI7BvqB,MAAM+P,iBAAiB3jB,EAAM6K,EAAQszB,EAChD,CAEA,mBAAA+B,EAAoB,QAAEhS,EAAO,OAAE3jB,EAAM,OAAE/E,EAAM,MAAE60B,EAAK,OAAExvB,EAAM,WAAEs1B,EAAU,UAAEC,IACtE,GAAIr/B,KAAK8iC,cACL,OAAOjwB,MAAMssB,oBAAoBn2B,UAAU,IAE/C,IAAIjK,EAAQ,GACRE,EAAOuK,EAAOvK,KASlB,OARImgC,IACArgC,GAAS+K,EACT7K,EAAOs/B,GAEXpR,EAAUA,EAAQ9e,UAClB5J,EAAOe,OAAOrB,KAAKgpB,GACnB1oB,EAAOkG,oBAEA,CAAE5L,QAAOouB,QADhBA,EAAU1oB,EAAOoG,OAAM,GACE5L,OAC7B,CAOA,eAAAuzB,CAAgBvzB,EAAMwF,GAClB,OAAIA,EAAOiP,gBAAgB9Q,OAAS,IAGO,GAApCigC,EAAkB5+B,QAAQhF,EACrC,CAUA,8BAAA46B,CAA+B30B,EAAWsE,EAAQ/E,EAAQ+I,EAASgS,GAC/D,IAAI,GAAE4Z,EAAE,MAAE3rB,GAAU+R,EAChB8d,EAAK,GACLyF,EAAK,GACLC,EAAWv+B,EAAOqF,OAClBm5B,EAASx+B,EAAOpE,KAEpB,MAAM,gBAAEqT,EAAe,aAAEoD,GAAiBrS,EAC1C,IAAIy+B,GAAS,EAETljC,KAAK8iC,gBAELE,EAAWA,EAAS30B,WAEI,GAAxB7E,EAAOzF,OAAOnB,QACd06B,EAAK0F,EACLD,EAAKE,EACDnsB,GACArS,EAAOqS,cAAe,EACtBrS,EAAOiG,aACPjG,EAAOkG,oBACPlG,EAAOe,OAAOrB,KAAKi1B,EAAG7qB,aACtB+uB,GAAM74B,EAAOoG,OAAM,GACnBpG,EAAOqG,uBAEPwyB,GAAMlE,EACN2J,GAAMt1B,GAEViG,EAAgBzF,QAChByF,EAAgBvG,eAAe,CAACrD,OAAOwzB,EAAIj9B,KAAK0iC,IAChDrvB,EAAgBxF,cAChBg1B,GAAS,IAETz+B,EAAOiP,gBAAgBzF,QACvBxJ,EAAOiP,gBAAgBvG,eAAe61B,GAElChjC,KAAK8iC,cACAt5B,EAAOvK,MAAQu/B,GAA0C,GAAxBh1B,EAAOzF,OAAOnB,SAEhD6B,EAAOiP,gBAAgBvG,eAAeisB,EAAG/qB,WACzC60B,GAAS,GAGR15B,EAAOvK,MAAQu/B,GAA0C,GAAxBh1B,EAAOzF,OAAOnB,SAEhD6B,EAAO0a,cAAc,CAAElR,OAAO,IAC9BxJ,EAAOiP,gBAAgBvG,eAAeisB,EAAG/qB,WACzC5J,EAAOsa,uBACRmkB,GAAS,IAIpB,IAAIC,EAA4B,GAAjB35B,EAAOzF,OAChBogB,EAAYqa,EAoBlB,OAnBI0E,IACA9J,EAAK,GACL2J,EAAK,IAITt+B,EAAO6S,SAAW6rB,EAClB1+B,EAAOkN,UAAY3R,KAAK6hC,YAAYsB,GAChC/J,GAAO5vB,EAAOkjB,gBAAkBqS,EAAsBuD,oBACtD79B,EAAOiP,gBAAgBvG,eAAeisB,EAAG/qB,WACzC60B,GAAS,GAETA,IACA9J,EAAK,GACL2J,EAAK,IAGTvjB,EAAS4Z,GAAKA,EACd5Z,EAAS/R,MAAQs1B,EACVvjB,CACX,CAaA,aAAA8gB,CAAcnT,EAASmM,EAAOxvB,EAAQs1B,EAAYC,EAAWlD,EAAgB+D,EAAY7f,GACrF,MAAM,gBAAEjV,GAAoBlM,EAAMyB,QAClC,IAAI6+B,EAAM,GA0BV,OAzBIlG,EAAM12B,OAAS,IACf48B,GAAOlG,GAEPxvB,EAAOlH,OAAS,IAChB48B,GAAO11B,GAcXqjB,EAAWgP,EAA8BhP,GAXjC9M,IAEAjV,EAAgB4D,oBAAoBqR,EAAU,WAC9C8M,EAAU9M,EAASzY,cAAcmD,KAAK,KAGnCoiB,EAAQ9e,WAMdrO,KAAK8iC,gBACNr+B,OAAOkG,oBACPlG,OAAOiP,gBAAgBvG,eAAeqyB,EAAIjxB,aAC1C9J,OAAOuO,QACPwsB,EAAM/6B,OAAOoG,OAAM,EAAMq1B,IAEtB,CAAE/S,UAASqS,MACtB,CACA,cAAAmB,CAAez7B,EAAWsE,EAAQ/E,EAAQ+I,EAAS4rB,GAC/C,IAAIkE,EAAK,GAMT,OAL4B,GAAxB9zB,EAAOzF,OAAOnB,SACd06B,EAAK9vB,EAAQa,UAAY+qB,EAAG7qB,YAC5B9J,EAAO0I,eAAemwB,EAAI9zB,IAGvBA,EAAOzJ,MAClB,CAEA,oBAAAoiC,CAAqBzM,EAAa5rB,GAC9B,MAAO,CAAC4rB,EAAa5rB,GAAQiB,KAAK,GACtC,CAQA,kBAAA4hB,CAAmBznB,EAAWgQ,EAASzQ,EAAQgoB,GAAM,GACjD,IAAIjf,EAAU/I,EAAOqF,OACrB,MAAM,OAAE/J,EAAM,YAAEqc,GAAgBlH,GAC1B,eAAEwX,EAAc,QAAErX,EAAO,eAAE+tB,GAAmBluB,EACpD,IAAImuB,EAAmB,KACftjC,GACAmV,EAAQjW,KAAOs/B,EACfv+B,KAAKugC,oCAAoCrrB,EAASzQ,KAGlDS,EAAU2nB,yBAAyBrf,EAAS0H,EAASzQ,GACjC,GAAhBA,EAAOmP,QACPnP,EAAO0S,qBAAsB,GAErC,EAGJ,OAAQuV,GACJ,KAAKqS,EAAsBG,eAEnBzS,GAAUvX,EAAQnR,OAAOnB,OAAS,GAAOwZ,EAAY5N,OAAO5L,OAAO,IACpEygC,IAEH,MACJ,KAAKtE,EAAsB0D,mCACnBhW,GAAWvX,EAAQnR,OAAOnB,OAAO,IAAOyS,GAAW+tB,KACnDC,IAEJ,MACJ,KAAKtE,EAAsBuD,kBAC3B,KAAKvD,EAAsBC,0BAC3B,KAAKD,EAAsBuD,kBAE3B,KAAKvD,EAAsBwD,cAE3B,KAAKxD,EAAsByD,cACvB,MACJ,QACI,MAAM,IAAI/jC,MAAM,iCAAiCiuB,GAE7D,CAOA,mBAAAY,EAAoB,KAAEruB,EAAI,OAAEwF,EAAM,OAAEqF,IAChC,IAAIue,EAAI,KAWR,OAVQppB,IACCu/B,EACG10B,EAAOlH,OAAS,IAChBylB,EAAI5jB,EAAOoG,OAAM,GAAQf,GAI7BrF,EAAOuO,QAGRqV,CACX,CACA,wBAAAgF,EAAyB,KAAE7O,EAAI,OAAE/Z,IAC7B,IAAIzE,KAAK8iC,gBAGJtkB,EAAKhK,cAAiB/P,EAAOe,OAAO5C,OAAS,EAAI,CAClD6B,EAAOe,OAAOrB,KAAKM,EAAOqF,QAC1B,IAAI0D,EAAU/I,EAAOoG,OAAM,GAC3BpG,EAAOiP,gBAAgBvG,eAAeK,GACtC/I,EAAOsa,sBACX,CACJ,GAIJnhB,EAAQgjB,eAAiBA,C,eC/RzBhiB,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAKpD,MAAM4C,EACFmU,OACAzV,KACAwoB,SACAE,cACAua,aAIA/a,iBAIAgb,qBAEA,WAAIC,GACA,OAAOxjC,KAAKyjC,SAChB,CAEA,WAAA3jC,GACIE,KAAKyjC,UAAY,KACjBzjC,KAAKsjC,cAAe,CACxB,CAMA,UAAAxa,CAAWzkB,GACHrE,KAAK6oB,UACL7oB,KAAK6oB,SAASC,WAAWzkB,EAEjC,CAEA,KAAArD,GAII,OAHA0iC,IAAM,IAAI1jC,KAAK8V,OACf9V,KAAKyjC,UAAYzjC,KAAKK,KACtBsB,EAAWC,UAAU5B,KAAM0jC,IAAK1jC,KAAKK,MAC9BqjC,GACX,CAUA,gBAAO9hC,CAAUzB,EAAQujC,EAAKrjC,EAAMC,EAAQ8tB,GACxC,MAAMuV,EAAgBxjC,EAAOmjC,aAO7B,IAAIM,EAAaF,EAAIzb,cACjB4b,EAAeH,EAAIxjC,WAcvB,OApBQwjC,EAAI1b,UACG0b,EAAI1b,YAERppB,OAAOD,KAAK+kC,IAIbtiC,SAASmC,IACf,IAAIi1B,EAAKn4B,EAAKkD,QACE,IAAN,IAGN,IAAgBqgC,EAAWziC,MAAMuiC,EAAK,CAACngC,EAAGi1B,EAAImL,MAG9CE,IACArL,EAAKqL,EAAa1iC,MAAMuiC,EAAK,CAACvjC,EAAQoD,EAAGi1B,EAAIl4B,EAAQ8tB,KAEzDsV,EAAIngC,GAAKi1B,GAAE,IAERkL,CACX,EAGJ9lC,EAAQ+D,WAAaA,C,4BC/ErB/C,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IACtD,MAAM+kC,EAAe17B,OACf27B,EAAc,MAChB,MAAMC,EAAMF,EAAajhB,UAAUtQ,KACnC,IAAiD,IAA7CyxB,EAAIlvB,WAAW7Q,QAAQ,iBACvB,OAAO+/B,EACX,MAAM,IAAIvlC,MAAM,6BACnB,EALmB,GAMdwlC,EAAc,MAChB,MAAMD,EAAMF,EAAajhB,UAAUxa,KACnC,IAAiD,IAA7C27B,EAAIlvB,WAAW7Q,QAAQ,iBACvB,OAAO+/B,EACX,MAAM,IAAIvlC,MAAM,6BACnB,EALmB,GASpB,MAAM4nB,EACF9d,SAAoB,GACpB,WAAO6gB,GACH/C,GAAa,EAAWvgB,QAAQ,CAC5ByM,KAAMuxB,EAAajhB,UAAUtQ,KAC7BlK,KAAMy7B,EAAajhB,UAAUxa,OAEjCy7B,EAAajhB,UAAUtQ,KAAOwxB,EAC9BD,EAAajhB,UAAUxa,KAAO47B,CAClC,CACA,cAAOta,GACH,MAAMzc,EAAKmZ,GAAa,EAAW1gB,QAC/BuH,IACA42B,EAAajhB,UAAUtQ,KAAOrF,EAAGqF,KACjCuxB,EAAajhB,UAAUxa,KAAO6E,EAAG7E,KAEzC,EAGJge,EAAaxD,UAAUtQ,KAAOwxB,EAC9B1d,EAAaxD,UAAUxa,KAAO47B,EAE9BrmC,EAAQyoB,aAAeA,C,eCxCvBznB,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAmBpDnB,EAAQkgC,qBAbR,MAKI51B,QAKAxJ,K,4BChBJE,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAUtDnB,EAAQsmC,yBAPR,MAKIC,c,4BCRJvlC,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,WAAEkS,GAAe,EAAQ,OACzB,MAAE/R,GAAU,EAAQ,MAuZ1BtB,EAAQoY,iBAvYR,MAMInS,OAAQ,EAKRmyB,+BAAgC,EAKhCoO,wBAIAnhC,MAAQ,CACJ0O,UAAW,EACX9N,MAAO,EACPvC,IAAK,GAKTyC,OAAS,GAMThF,MAKA4yB,eAKAsG,SAAU,EAKVtF,SAAW,KAKXhX,eAAgB,EAOhB6T,sBAAuB,EAKvB+G,UAEA,oBAAI8N,GACA,OAAkC,IAA1BrkC,KAAKskC,kBAAqD,MAAtBtkC,KAAK09B,aACrD,CAMA,kBAAA7R,EAAmB,YAAC3O,EAAW,WAAEzG,IAC7B,MAAM,OAAE1S,GAAW/D,KAGnB,GADAyW,GADgB1S,EAAOnB,OAAO,EAAImB,EAAOA,EAAOnB,OAAO,GAAG4G,OAAS,OACzCiN,EACX,CACX,MAAM,QAAE7E,GAAYsL,GACd,IAAE5b,EAAG,UAAEkhB,EAAS,MAAEjhB,GAAUkV,EAClC,GAAe,GAAX+L,EAEA,OAAOvR,EAAWszB,oBAAoBhjC,IAAUA,EAAMgR,KAAKX,GAE1D,GAAe,GAAX4Q,EAEL,OAAOvR,EAAWszB,oBAAoBjjC,IAASA,EAAIiR,KAAKX,EAEhE,CACA,OAAO,CACX,CACA,UAAAqJ,GAEI,OAAO/b,EAAMu+B,cAAcz9B,KAC/B,CACA,WAAAF,GACI,IAAI0kC,EACAC,EACAC,EACAC,EACAC,EACAC,GAAY,EACZC,GAAa,EACbC,EAAgB,KAChBC,EAAc,KACdC,EAAsB,CAAC,EACvBC,GAAkB,EAClBC,EAAe,EACfC,EAAa,KACbC,EAAc,KACdC,GAAW,EACXC,EAAU,KAId3mC,OAAOE,eAAekB,KAAM,OAAQ,CAChCC,IAAG,IAAYklC,EACf,GAAA5vB,CAAI7R,GACIA,GAAKyhC,IACLA,EAAezhC,EAEvB,IAMJ9E,OAAOE,eAAekB,KAAM,iBAAkB,CAC1C,GAAAC,GACI,QAAQD,KAAY,SAAIklC,CAC5B,EAAG,GAAA3vB,CAAI7R,GACH,GAAkB,kBAAP,EACP,MAAM,IAAIjF,MAAM,qBAEhBuB,KAAKqV,UACL6vB,EAAkBxhC,EAE1B,IAGJ9E,OAAOE,eAAekB,KAAM,SAAU,CAAEC,IAAG,IAAYukC,IACvD5lC,OAAOE,eAAekB,KAAM,oBAAqB,CAAEC,IAAG,IAAYglC,IAClErmC,OAAOE,eAAekB,KAAM,UAAW,CACnCC,IAAG,IAAY4kC,EAAc,GAAAtvB,CAAIxW,GAE7B,GAAc,OAAVA,EACA,MAAM,IAAIN,MAAM,6BAEpBomC,EAAY9lC,CAChB,IAEJH,OAAOE,eAAekB,KAAM,WAAY,CACpCC,IAAG,IACQ6kC,IAGflmC,OAAOE,eAAekB,KAAM,SAAU,CAAEC,IAAG,IAAYwkC,IACvD7lC,OAAOE,eAAekB,KAAM,WAAY,CAAEC,IAAG,IAAYykC,IAEzD9lC,OAAOE,eAAekB,KAAM,QAAS,CAAEC,IAAG,IAAY0kC,IACtD/lC,OAAOE,eAAekB,KAAM,QAAS,CAAEC,IAAG,IAAYslC,IAEtD3mC,OAAOE,eAAekB,KAAM,OAAQ,CAAEC,IAAG,IAAY2kC,IACrDhmC,OAAOE,eAAekB,KAAM,cAAe,CACvCC,IAAG,IAEuB,MAAjB8kC,GAA4C/gC,MAAjB+gC,EACrBJ,EAAQ,GACZI,EAEX,GAAAxvB,CAAI7R,GACAqhC,EAAgBrhC,CACpB,IAEJ9E,OAAOE,eAAekB,KAAM,YAAa,CACrCC,IAAG,IAAY+kC,EAAgB,GAAAzvB,CAAI7R,GAC/BshC,EAActhC,CAClB,IAEJ9E,OAAOE,eAAekB,KAAM,8BAA+B,CACvD,GAAAC,GACI,MAAM,OAAEuJ,GAAWxJ,KACnB,OAAOwJ,EAAOuO,6BACHvO,EAAOkjB,gBAAkBljB,EAAOmuB,2BAG/C,EAAG,GAAApiB,CAAI7R,IArMnB,SAAYA,EAAG8hC,GACX,MAAM14B,SAAW,EACjB,OAA6B,GAArB04B,EAAMvhC,QAAQP,KAAmC,GAArB8hC,EAAMvhC,QAAQ6I,EACtD,EAmMoB24B,CAAG/hC,EAAG,CAAC,eAAWM,EAAW,gBAC7BhE,KAAKkgB,QAAQnI,4BAA8BrU,EAEnD,IAGJ9E,OAAOE,eAAekB,KAAM,UAAW,CACnCC,IAAG,IACQqlC,IAGf1mC,OAAOE,eAAekB,KAAM,eAAgB,CACxCC,IAAG,IACQmlC,IAGfxmC,OAAOE,eAAekB,KAAM,YAAa,CACrCC,IAAG,IACQolC,IAQfrlC,KAAKgxB,IAAM,UAAU,OAAExnB,EAAM,SAAE2Z,EAAQ,MAAEzS,EAAK,KAAEa,EAAI,OAAExR,EAAM,SAAET,EAAQ,WAAEqjB,EAAU,UAAE/G,EAAS,MAAE9X,GAAQ,EAAG,MAAEwQ,IACxGmwB,EAAWj7B,EACXk7B,EAAavhB,EACbwhB,EAAUj0B,EACV60B,EAAUjxB,EACVswB,EAASrzB,EACTizB,EAAWzkC,EAEX8kC,EAAYr7B,EAAO6L,QACnByvB,EAAat7B,EAAOsK,UAAY6O,EAAW8d,WAAWj3B,EAAOkjB,gBAC7D0Y,EAAa9lC,EACb+lC,EAAczpB,EACd0pB,EAAUxhC,EAGV,SAAWtD,EAAG0f,GACV,MAAM3Y,EAAQ3I,OAAOD,KAAK6B,GACpBklC,EAAU9mC,OAAOD,KAAKuhB,GAC5B,CAAC,UAAW,WAAY,eAAgB,+BAA+B9e,SAAQN,WACpE4kC,EAAQA,EAAQzhC,QAAQnD,GAAG,IAEtC4kC,EAAQtkC,SAAQmC,IAEZ,IAAyB,GAArBgE,EAAMtD,QAAQV,GAEd,YADAT,QAAQC,IAAI,4BAA8BQ,EAAI,KAGlD,IAAIiX,EAAK5b,OAAO6b,yBAAyByF,EAAS3c,KAC7CiX,GAAOA,EAAM,KAAKA,EAAGmrB,WAEtB/mC,OAAOE,eAAe0B,EAAG+C,EAAG,CAAEtD,IAAG,IAAYigB,EAAQ3c,IACzD,GAEP,CAlBD,CAkBGvD,KAAMykC,EACb,CACJ,CAIA,kBAAIrB,GACA,MAAM,kBAAE3G,GAAsBz8B,KAC9B,OAAOy8B,GAAsB,YAAaA,CAC9C,CACA,sBAAIhK,GACA,OAAOzyB,KAAKwJ,QAAQipB,kBACxB,CAEA,oBAAIzP,GACA,OAAOhjB,KAAKwJ,QAAQwZ,gBACxB,CACA,sBAAIC,GACA,OAAOjjB,KAAKwJ,QAAQyZ,kBACxB,CACA,sBAAIC,GACA,OAAOljB,KAAKwJ,QAAQ0Z,kBACxB,CACA,iBAAI4Y,GACA,OAAO97B,KAAKwJ,QAAQsyB,aACxB,CAIA,eAAI/E,GACA,OAAO/2B,KAAKwJ,QAAQutB,WACxB,CAEA,mBAAIlE,GACA,IAAIpxB,EAAIzB,KAAKwJ,QAAQspB,YACjB6F,SAAe,EACnB,MAAa,UAATA,EACOl3B,EAEE,WAATk3B,EACQl3B,EAAgB,QAAZuC,EAETvC,CACX,CAIA,mBAAI4qB,GACA,OAAIrsB,KAAKwJ,QAAQutB,aAGV/2B,KAAK87B,eAA0C,GAAxB97B,KAAK0Q,MAAM,GAAG9N,MAChD,CAIA,sBAAIs1B,GACA,OAAOl4B,KAAKqV,UAAYrV,KAAKg2B,6BACjC,CAEA,SAAIlyB,GACA,OAAO9D,KAAK0Q,OAAO5M,KACvB,CACA,UAAIuC,GACA,OAAOrG,KAAK0Q,OAAOrK,MACvB,CACA,QAAIjH,GACA,OAAOY,KAAKwJ,QAAQpK,IACxB,CACA,YAAIO,GACA,OAAOK,KAAKwJ,QAAQ7J,QACxB,CACA,eAAIqK,GACA,OAAOhK,KAAKwJ,QAAQQ,WACxB,CACA,iBAAI4jB,GACA,OAAO5tB,KAAKwJ,QAAQokB,aACxB,CACA,eAAInuB,GACA,OAAOO,KAAKwJ,QAAQ/J,WACxB,CACA,wBAAI+B,GACA,OAAOxB,KAAKwJ,QAAQhI,oBACxB,CACA,gBAAIyjB,GACA,MAAM,aAAEA,GAAiBjlB,KAAKwJ,OAC9B,OAAOyb,GAAgB,MAC3B,CAIA,aAAIzC,GACA,OAAOxiB,KAAKwJ,OAAOgZ,SACvB,CAMA,kBAAIojB,GAEA,OAAO,CACX,CAIA,SAAIhhC,GACA,OAAO5E,KAAKwJ,QAAQ5E,KACxB,CAKA,QAAAkQ,GACI,MAAO,sBAAwB9U,KAAKwJ,QAAQsL,WAAa,GAC7D,CAKA,qBAAIigB,GACA,MAAMzC,EAAItyB,KAAKsb,YACf,GAAiB,iBAAP,EAAgB,CACtB,IAAI,kBAAEyZ,GAAsBzC,GAAK,CAACyC,mBAAkB,GACpD,OAAOA,CACX,CACA,OAAO/0B,KAAK+0B,iBAEhB,CAQA,iBAAA0C,CAAkBn2B,GAAK,UAAC2U,IACpB,OAAQjW,KAAK0Q,MAAM5M,OAASxC,EAAIwC,OAC5B9D,KAAKsU,MAAM2B,WAAaA,CAChC,E,8BCvZJrX,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,WAAE4C,GAAe,EAAQ,OACzB,qBAAED,GAAyB,EAAQ,OACnC,MAAExC,GAAU,EAAQ,OACpB,WAAE+R,GAAe,EAAQ,OACzB,UAAEjS,GAAc,EAAQ,OACxB,qBAAE8+B,GAAyB,EAAQ,OACnC,YAAE+H,GAAgB,EAAQ,MAC1B,yBAAE3B,GAA6B,EAAQ,MAqB7C,MAAMzjC,EAIFu/B,kBAIA8F,UAIAvkC,MAMAQ,eAIAV,MAIAC,IAMAykC,YAMAC,MAKAC,cAKAlZ,gBAKA3tB,KAKAk2B,YAIA91B,QAIAH,QAIAC,SAKAwU,SAKAuB,QAMA0C,4BAKAusB,iBAKA5G,cAMAwI,oBAMAvO,4BAOAtF,uBASAjH,eAIA+a,iBAKAzmC,oBAAqB,EAMrBD,YAMA+B,qBAMA+uB,mBAKA3C,cAKA5jB,YAKArK,SAKAs6B,kBAMA16B,UAMA2wB,eAMAC,kBAMAiW,oBAKA1Z,eAAiB,EAOjBgV,uBAKApmB,YAMA3G,SAMA9U,WAOAolB,aAMArH,gBAKAqI,eAOAtU,WAAY,EAKZ00B,oBAKAzhC,MAOA0hC,UAMAxT,YAOAyT,KAKA5uB,cAMAod,kBAKA,WAAAj1B,GACIE,KAAKV,SAAW,GAChBU,KAAKqV,SAAU,EACfrV,KAAKorB,gBAAiB,EACtBprB,KAAKmmC,kBAAmB,EACxBnmC,KAAK+lC,YAAc,EACnB,IAAIvB,EAAW,KACXgC,GAAc,EAElB5nC,OAAOE,eAAekB,KAAM,SAAU,CAClCC,IAAG,IAAYukC,EAAa,GAAAjvB,CAAI7R,GAC5B,KAAU,MAALA,GAAeA,aAAajD,GAG7B,MAAMhC,MAAM,0BAFZ+lC,EAAW9gC,CAGnB,IAEJ9E,OAAOE,eAAekB,KAAM,cAAe,CACvCC,IAAG,IACQumC,EACR,GAAAjxB,CAAI7R,GACH8iC,EAAc9iC,CAClB,GAER,CACA,gBAAO+iC,CAAUF,GACb,OAAOt1B,EAAWw1B,UAAUF,EAChC,CACA,UAAArmC,CAAWC,EAAQC,EAAWC,EAAMC,EAAQC,GAMxC,MAAM,SAAEE,EAAQ,YAAEC,EAAW,YAAEvB,GAAgBD,EAAMyB,QAC/CH,EAAIR,KACJV,EAAWJ,EAAM0B,wBAAwBT,EAAQM,EAAUC,GAC3DnB,EAAYL,EAAM2C,4BAClBhB,EAAgBoQ,EAAWy1B,YAAYlmC,GACvCmmC,EAAkBznC,EAAM4C,qBAAqBtB,GAyB7CQ,EAAQ,CACV,eAAA+rB,CAAgB9rB,EAAGd,GACf,GAAkB,iBAAP,EAAiB,CACxB,MAAM,8BAAEoQ,GAAkCrR,EAAMyB,SAC1C,WAAE6P,GAAevP,EACvB,IAAI,SAAEtB,GAAasB,EAInB,OAHItB,IACAA,EAAWgnC,EAAgBhnC,EAAUQ,IAElC,IAAIoQ,EAA8BC,EAAY7Q,EACzD,CACA,OAAOsB,CACX,EACA,WAAA6xB,CAAY7xB,EAAGd,GACX,MAAMw4B,SAAe,GACf,yBAAEnpB,GAA6BtQ,EAAMyB,QACrCimC,EAAOzmC,EAAO0mC,0BAA4Br3B,EAChD,GAAa,UAATmpB,EAAmB,CAEnB,IAAIl3B,EAAI,IAAImlC,EAEZ,OADAjlC,EAAWC,UAAUzB,EAAQsB,EAAGR,GACzBQ,CACX,CACA,GAAa,WAATk3B,EACA,OAAO13B,EAEX,GAAa,UAAT03B,EACA,OAAO13B,EAEX,MAAM,IAAIxC,MAAM,0BACpB,EACA,QAAAa,CAAS2B,EAAGd,EAAQG,EAAQC,GACxB,IAAIW,EAAI5B,EAAS6B,MAAMX,EAAG,CAACS,EAAGd,EAAQG,EAAQC,IAI9C,OAHAW,EAAEE,SAASN,IACPA,EAAEf,OAASS,CAAC,IAETU,CACX,EACAG,MAAOR,EACPS,IAAK,SAAUL,EAAGd,EAAQG,EAAQC,GAC9B,MAAkB,iBAAP,GAES,GAAZU,EAAE2B,OACKqO,EAAW61B,WAGnBjmC,EAAcI,EAAGd,EAAQG,EAAQC,EAC5C,EACAylC,MAAOnlC,EACPU,MAAOV,EACPkB,eAAgBlB,EAChBpB,YA3EkB,CAACwB,EAAGd,EAAQC,EAAWG,KACzC,GAAkB,iBAAP,EAIP,OADaM,EAAcM,MAAMX,EAAG,CAACS,EAAGd,EAAQC,EAAWG,IAG/D,GAAkB,iBAAP,EAAiB,CACxB,IAAIkB,EAAI,IAAIC,EAEZ,OADAC,EAAWC,UAAUzB,EAAQsB,EAAGR,EAAGV,GAC5BkB,CACX,CACA,GAAIyE,MAAMC,QAAQlF,GAAI,CAClB,IAAIC,EAAI,GAMR,OALAD,EAAEG,SAAQH,IACN,IAAIQ,EAAI,IAAIC,EACZC,EAAWC,UAAUzB,EAAQsB,EAAGR,EAAGV,GACnCW,EAAEiD,KAAK1C,EAAE,IAENP,CACX,CACA,OAAO,IAAI,EAuDXgvB,eAAgBrvB,EAChBilC,UAAW,SAAU7kC,EAAGd,GACpB,MAAMwC,SAAY,EAClB,IAAIokC,EAAM,CAAE7+B,QAAS,KAAMxJ,KAAM,MACjC,GAAU,UAANiE,EACAokC,EAAI7+B,QAAUvF,OACX,GAAI1B,EAAG,CACV,MAAM,KAAEvC,EAAI,QAAEwJ,EAAO,KAAE8+B,GAAS/lC,GAC1B,WAAEylB,GAAevmB,EAAOE,KAC9B,GAAI2mC,GAAQtgB,GACJsgB,KAAQtgB,EAAY,CACpB,MAAM,KAAEhoB,EAAI,QAAEwJ,GAAY,CAAExJ,KAAMsoC,EAAM9+B,QAASwe,EAAWsgB,IAG5D,OAFAD,EAAI7+B,QAAUA,EACd6+B,EAAIroC,KAAOA,EACJqoC,CACX,CAGJA,EAAI7+B,QAAUA,EACd6+B,EAAIroC,KAAOA,CACf,CACA,OAAOqoC,CACX,EACA,oBAAAvlC,CAAqBP,EAAGd,GACpB,IAAIsB,EAAI,IAAIC,EAEZ,OADAC,EAAWC,UAAUzB,EAAQsB,EAAGR,EAAGV,GAC5BkB,CACX,EACAmsB,cAAe+Y,EACf38B,YAAa28B,EACbhnC,SAAUgnC,EACV1gB,eAAgB0gB,EAChBxW,kBAAmBwW,EACnBpnC,YACA,iBAAAygC,CAAkB9+B,EAAGf,GACjB,GAAe,iBAAL,EAAc,CACxB,MAAM6H,EAAI,IAAIk8B,EAEd,OADAviC,EAAWC,UAAUzB,EAAQ6H,EAAG9G,GACzBA,CACP,CACJ,EACA4S,SAAQ,CAAC5S,EAAGf,IACa,kBAAP,GAAmBe,EAErC,OAAAmU,CAAQnU,EAAGf,GACP,IAAIwC,SAAY,EAChB,GAAU,UAANA,EAAgB,CAChB,IAAIlB,EAAI,IAAIzC,EAEZ,OADA2C,EAAWC,UAAUzB,EAAQsB,EAAGP,GACzBO,CACX,CACA,MAAa,WAANkB,GAAkBzB,CAC7B,EACA,UAAArB,CAAWqB,EAAGf,GACV,GAAkB,iBAAP,EAAiB,CACxB,IAAI6H,EAAI,IAAI81B,EAEZ,OADA91B,EAAEE,QAAUhH,EACL8G,CACX,CACA,OAAOi/B,EAAU/lC,EAAGf,EAAQ29B,EAChC,GASJ,IAAI97B,EAAKhB,EAAMZ,GACf,OAAI4B,EACOA,EAAGb,MAAMX,EAAG,CAACH,EAAMF,EAAQG,EAAQC,IAEvCF,CACX,CACA,aAAA4nB,CAAcC,EAAYhnB,EAAGinB,GACzB,MAAMC,EAAY,CACd9oB,SAAS4B,GACEgF,MAAMC,QAAQjF,GAEzBM,qBAAqBN,GACI,iBAAP,GAGtB,IAAImnB,EAAID,EAAUF,GAClB,GAAIG,IAAMA,EAAEnnB,GAAI,CACZ,GAAIinB,EACA,MAAM,IAAI1pB,MAAM,IAAIypB,mBAExB,OAAO,CACX,CACA,OAAO,CACX,CAEA,aAAI1F,GACA,MAAM,MAAEnhB,EAAK,IAAEC,EAAG,MAAEC,EAAK,eAAEQ,GAAmB/B,KACxCknC,EAASlnC,KAAKgmC,MACpB,GAAI3kC,EAAO,CACP,GAAIC,EACA,OA/gBM,EAghBL,GAAI4lC,EACL,OA/gBQ,CAihBhB,KAAO,IAAI3lC,EACP,OAnhBM,EAohBH,GAAIQ,EACP,OAnhBgB,CAohBpB,CACA,OAAQ,CACZ,CAIA,oBAAIihB,GACA,IAAIliB,EAAId,KAAKsB,IACb,QAAIR,GACOmQ,EAAWk2B,oBAAoBrmC,EAAEgU,WAGhD,CAIA,sBAAIoO,GACA,IAAIpiB,EAAId,KAAKqB,MACb,QAAIP,GACOmQ,EAAWk2B,oBAAoBrmC,EAG9C,CAKA,iBAAIg7B,GACA,IAAI,MAAEz6B,EAAK,IAAEC,GAAQtB,KACrB,SAAIqB,IAASC,IACFtB,KAAKkjB,oBAAsBljB,KAAKgjB,gBAG/C,CAIA,sBAAIyP,GACA,IAAI3xB,EAAId,KAAKuB,MACb,QAAIT,GACOmQ,EAAWk2B,oBAAoBrmC,EAG9C,CAIA,wBAAIgiB,GACA,OAAO,CACX,CACA,WAAOlc,CAAKvC,IACJA,EAAGhD,OAAUgD,EAAG/C,KAAQ+C,EAAG2hC,QAE3B3hC,EAAG/C,IAAM2P,EAAW61B,aAGF,GAAjBziC,EAAGme,WAAqBne,EAAG/E,UAAUsD,OAAS,GAC/CyB,EAAG/E,SAAS8B,SAAQN,IAChBuD,EAAG+iC,SAAStmC,EAAE,GAI1B,CAKA,QAAAsmC,CAASr7B,IACAA,EAAE1M,SAAWW,KAAKX,UACnB0M,EAAE1M,QAAUW,KAAKX,QAEzB,CACA,aAAAgoC,GACI,MAAM,MAAEhmC,EAAK,MAAEE,EAAK,eAAEQ,GAAmB/B,KAEzC,OAAQA,KAAKwiB,WACT,KAnmBU,EAomBV,KAlmBY,EAmmBR,OAAOnhB,EACX,KArmBM,EAsmBF,OAAOE,EACX,KArmBgB,EAqmBU,OAAOQ,EAEzC,CASA,KAAAkQ,CAAMjK,EAAGvD,EAAQ0yB,EAAmBjlB,GAChC,IAAI0Z,EAAI,KACR,MAAM,SAAEtsB,GAAaU,KAErB,KADAkS,EAAQA,GAASlS,KAAKqnC,iBAGf,CAEH,GAAI/nC,EAAU,CACV,MAAMmT,EAAKvT,EAAMooC,aAAahoC,EAAU0I,EAAGvD,EAAQ0yB,GACnD,QAAI1kB,GACO,CAAEmZ,EAAGnZ,EAAG80B,OAAQzmC,EAAG2R,EAAG+0B,GAAI7oB,KAAM3e,KAAMV,SAAUA,EAAUwE,MAAO2O,EAAG3O,MAAOoO,MAAOO,EAAGP,MAGpG,CACA,MAAM,IAAIzT,MAAM,kBAAoBuJ,EACxC,CACA,OAZI4jB,EAAI1Z,EAAMK,KAAKvK,GAYZ,CAAE4jB,IAAG9qB,EAAGd,KAAM8D,OAAQ,EAAGoO,QACpC,CAEA,cAAIu1B,GAOA,MANY,CACR,EAAKznC,KAAKqB,MACV,EAAKrB,KAAKuB,MACV,EAAKvB,KAAKgmC,MACV,EAAKhmC,KAAK+B,gBAEH/B,KAAKwiB,UACpB,CAMA,QAAAW,CAASyI,GACL,MAAM,IAAEtqB,GAAQtB,KAChB,IAAKsB,GAAStB,KAAKsB,eAAeukC,GAAgBvkC,EAAIqK,SAC/ClL,EAASgmC,UAAUnlC,GACtB,OAAO,KAKX,GAAsB,GAAlBtB,KAAKwiB,UAAgB,CACrB,IAAI1hB,EAAId,KAAKsB,IAAIwT,WACbrR,EAAM3C,EAAE4mC,YAAY,KACpBC,EAAO,GAMX,OALIlkC,EAAO3C,EAAE8B,OAAS,IAElB+kC,EAAO7mC,EAAE0F,UAAU/C,EAAM,GACzB3C,EAAIA,EAAE0F,UAAU,EAAG/C,EAAM,IAEtBvE,EAAM0oC,aAAa9mC,EAAG8qB,EAAG+b,EAAM,MAC1C,CACA,OAAO,IACX,CACA,QAAAE,CAASjc,GACL,GAAsB,GAAlB5rB,KAAKwiB,UAAgB,CACrB,IAAI1hB,EAAId,KAAKgmC,MAAMlxB,WACfrR,EAAM3C,EAAE4mC,YAAY,KACpBC,EAAO,GAMX,OALIlkC,EAAO3C,EAAE8B,OAAS,IAElB+kC,EAAO7mC,EAAE0F,UAAU/C,EAAM,GACzB3C,EAAIA,EAAE0F,UAAU,EAAG/C,EAAM,IAEtBvE,EAAM0oC,aAAa9mC,EAAG8qB,EAAG+b,EAAM,QAC1C,CACA,OAAO,IACX,CAEA,QAAA7yB,GACI,IAAI,KAAE1V,EAAI,MAAEiC,EAAK,IAAEC,EAAG,MAAEC,EAAK,UAAE+kC,EAAS,UAAE9jB,GAAcxiB,KAqBxD,OApBeA,KAAKgmC,MACpB5mC,GAAQknC,EAAY,IAAMA,EAAY,IAAM,OAASlnC,EAahDA,IACDA,EAAOwJ,KAAKC,UAAU,CAClB4G,KAAM+S,KAIP,aAAapjB,IACxB,EAKJ,MAAM6nC,EAAY,CAAC/lC,EAAGf,EAAQ2nC,KAC1B,IAAInlC,SAAY,EAChB,GAAU,UAANA,EAAgB,CAChB,IAAIlB,EAAI,IAAIqmC,EAEZ,OADAnmC,EAAWC,UAAUzB,EAAQsB,EAAGP,GACzBO,CACX,CACA,MAAa,WAANkB,GAAkBzB,CAAS,EAItCtD,EAAQ6C,SAAWA,C,8BC9uBnB7B,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAEpD,MAAM,SAAE0B,GAAa,EAAQ,MAqD7B7C,EAAQ8C,YAnDR,cAA0BD,EAMtB,WAAAX,CAAYogB,GAER,GADArN,UACKqN,GAAaA,aAAmBzf,GACjC,MAAM,IAAIhC,MAAM,mCAGpB,SAAU+B,EAAG0f,GACKthB,OAAOD,KAAK6B,GACpBY,SAAQmC,IAIV,IAAIiX,EAAK5b,OAAO6b,yBAAyBja,EAAG+C,KACvCiX,GAAOA,EAAM,KAAKA,EAAGmrB,WAEtB/mC,OAAOE,eAAe0B,EAAG+C,EAAG,CAACtD,IAAG,IAAWigB,EAAQ3c,IACvD,GAEP,CAZD,CAYGvD,KAAMkgB,GAETthB,OAAOE,eAAekB,KAAM,UAAW,CAAEC,IAAG,IAAUigB,GAC1D,CACA,KAAAjO,CAAMjK,EAAGvD,EAAQ0yB,GACb,OAAOn3B,KAAKkgB,QAAQjO,MAAMjK,EAAGvD,EAAQ0yB,EACzC,CAKA,aAAAkQ,GACI,OAAOrnC,KAAKkgB,QAAQmnB,eACxB,CACA,QAAAvyB,GACI,IAAI7T,EAAIjB,KAAKkgB,QAAQ9gB,KAMrB,OALK6B,IAC+B,GAA5BjB,KAAKV,SAASkjB,YACdvhB,EAAI,UAGL,gBAAgBA,IAC3B,CACA,QAAAkiB,CAASyI,GACL,OAAO5rB,KAAKkgB,QAAQiD,SAASyI,EACjC,E,6BCrDJhtB,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAEpD,MAAM,WAAEkS,GAAe,EAAQ,MAK/B,MAAM40B,EACFptB,KAEA,WAAA3Y,CAAY4R,EAAK4H,GACb,MAAMyuB,EAAOr2B,EACb,IAAIinB,EACJ/5B,OAAOE,eAAekB,KAAM,SAAU,CAACC,IAAG,IAAU8nC,IACpDnpC,OAAOE,eAAekB,KAAM,QAAS,CAACC,IAAG,IAAU04B,IACnD/5B,OAAOE,eAAekB,KAAM,UAAW,CAACC,IAAG,IAAUqZ,IAErDtZ,KAAKgoC,OAASxpC,IACVupC,EAAK5jC,KAAK3F,EAAE,EAEhBwB,KAAKioC,OAAQ,KAAMF,EAAKnlC,OAAS,CAAC,EAClC5C,KAAKkoC,YAAe7f,IAChBsQ,EAAQtQ,CAAC,CAEjB,CACA,QAAAvT,GACI,OAAwB,GAApB9U,KAAKmoC,OAAOvlC,OACL5C,KAAKmoC,OAAO,GAAGrzB,WAEnB9U,KAAKyY,KAAK3X,CACrB,CACA,WAAOiP,CAAKS,EAAY8I,GACpB,IAAK9I,EACD,OAAO,KAEX,GAAI8I,EACA,OAAO,IAAIusB,EAAY,CAACr1B,GAAa8I,GAEzC,IAAI8uB,EAAQ,KACZ,GAAwB,iBAAd,EAAuB,CAE7B,IAAIC,GADJ73B,EAAaA,EAAWsE,YACH4yB,YAAY,KAC7BjjC,EAAS+L,EAAWhK,UAAU6hC,EAAI,GAEtC,GADA73B,EAAaA,EAAWhK,UAAU,EAAG6hC,EAAI,GAAGxiC,MAAM,GAAG,GACjDpB,EAAO,CACP,IAAI6jC,EAAU,IACY,GAAtB7jC,EAAOR,QAAQ,MAAUqkC,EAAQnkC,KAAK,MAChB,GAAtBM,EAAOR,QAAQ,MAAUqkC,EAAQnkC,KAAK,MAChB,GAAtBM,EAAOR,QAAQ,OAAUmkC,EAAQ,KAEjCE,EAAQ1lC,OAAO,IACf4N,EAAa,KAAK83B,EAAQv9B,KAAK,IAAI,IAAIyF,EAE/C,CAEJ,CACA,IAAI+3B,EAAMt3B,EAAWu3B,UAAUh4B,GAC3B2L,EAAKosB,EAAIznC,EAETuC,EAAU,EACV+G,EAAK,KAELka,EAAO,GACPijB,EAAS,YACTkB,EAAM,KACNC,GAAyC,GAA1BH,EAAI9jC,OAAOR,QAAQ,KAQtC,GAPAskC,EAAI9jC,OAAS8jC,EAAI9jC,OAAO2oB,QAAQ,IAAI,IAChCgb,IACAG,EAAI9jC,QAAS2jC,GAKbM,EAAa,CACb,IAAIC,EAAMJ,EAAIznC,EAAEwI,MAAM,MAClBs/B,EAAM,GACVD,EAAIvnC,SAAQmC,IACRA,EAAIA,EAAEgL,YACF,KAAKlG,KAAK9E,KACdA,EAAIA,EAAE6pB,QAAQ,OAAQ,KACtBwb,EAAIzkC,KAAKZ,GAAE,IAGf4Y,EAAKysB,EAAI79B,KAAK,IACdw9B,EAAIznC,EAAIqb,CACZ,CAGA,KAAO/R,EAAKm9B,EAAOh1B,KAAK4J,IAAI,CAExB9Y,EAAU+G,EAAGtG,MACb,IAAI+kC,EAAY1sB,EAAG3V,UAAU,EAAGnD,GAE5BihB,EAAKngB,KAAK,IAAIiE,OAAOygC,EAAWN,EAAI9jC,SAExC,IAAIqkC,EAAM3sB,EAAG3V,UAAUnD,GAGvB,GAFA8Y,EAAKssB,EAAMK,EAAI1b,QAAQma,EAAQ,OAC/BkB,EAAMx3B,EAAW83B,UAAUN,EAAK,EAAG,GAC/BlB,EAAOl/B,KAAKogC,GAEZ,MAAM,IAAIhqC,MAAM,4CAEpB6lB,EAAKngB,KAAK,IAAIiE,OAAOqgC,EAAK,MAC1BplC,EAAUolC,EAAI7lC,OACduZ,EAAKA,EAAG3V,UAAUnD,EACtB,CAKA,GAJI8Y,EAAGvZ,OAAO,GACV0hB,EAAKngB,KAAK,IAAIiE,OAAO+T,EAAImI,EAAK1hB,OAAO,EAAE,GAAI2lC,EAAI9jC,SAG/C6f,EAAK1hB,OAAO,EAAE,CACd,IAAIomC,EAAU,IAAInD,EAAYvhB,GAAM,GAEpC,OADA0kB,EAAQvwB,KAAO8vB,EACRS,CACX,CACA,OAAO,IACX,CACA,IAAA3gC,CAAKL,GACD,OAAuB,OAAhBhI,KAAKuS,KAAKvK,EACrB,CACA,IAAAuK,CAAKvK,GACD,GAAIhI,KAAK2L,QACL,OAAO,KAEX,IAAI4iB,GAAQ,EACR0a,EAAKjpC,KAAKmoC,OAAOtiC,QACjB+K,EAAO,KACPs4B,EAAQ,KACRC,EAAS,EACb,KAAM5a,GAAU0a,EAAGrmC,OAAO,GAEtBgO,EADQq4B,EAAGtjC,QACF4M,KAAKvK,GACV4I,EACW,MAAPs4B,EAEAA,EAAQt4B,GAIRs4B,EAAM,IAAMt4B,EAAK,GACjBu4B,GAASv4B,EAAK,GAAGhO,OACjBoF,EAAIA,EAAExB,UAAU2iC,KAGpB5a,GAAQ,EACR2a,EAAQ,MAGhB,OAAOA,CACX,EAGJtrC,EAAQioC,YAAcA,C,8BCxJtBjnC,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MACMqqC,EAAkB,sBAClBtC,EAAa,CACfv0B,KAAI,IACO,KAEXlK,KAAI,IACO,KAEXyM,SAAQ,IACG,IAMf,MAAM7D,EAMF,gBAAOw1B,CAAUF,GACb,OAAOA,IAASO,CACpB,CAIA,qCAAWuC,GAIP,MAAO,2BACX,CACA,2BAAWD,GACP,OAAOA,CACX,CAIA,uCAAWE,GAIP,MAAO,yBACX,CAOA,yBAAO/N,CAAmBrpB,GAGtB,OAFSjB,EAAWo4B,2BACLhhC,KAAK6J,EAExB,CAMA,iCAAOE,CAA2BF,GAE9B,MADW,gBACD7J,KAAK6J,EACnB,CAOA,kBAAOw0B,CAAYlmC,GACf,MAAM,MAAEtB,GAAU,EAAQ,OACpB,YAAE2mC,GAAgB,EAAQ,KAChC,OAAQ/kC,IACK,QAALA,IACAN,EAAEu2B,aAAc,EAChBj2B,EAAI,IAER,IAAIyoC,GAAW,EACN,IAALzoC,IACAyoC,GAAW,GAEf,IAAI1nB,EAAI3iB,EAAM6B,WAAWD,EAAG,KAE5B,OADA+gB,EAAIgkB,EAAY91B,KAAK8R,EAAG0nB,GACjB1nB,CAAC,CAEhB,CAOA,kCAAO2nB,CAA4BC,GAC/B,IAAI3oC,EAAImQ,EAAWy4B,cAAcD,EAAKx4B,EAAWo4B,4BACjD,OAAIvoC,EACOmQ,EAAW04B,mBAAmB7oC,GAElCA,CACX,CAMA,2CAAOy2B,CAAqCkS,GACxC,IAAI3oC,EAAImQ,EAAWy4B,cAAcD,EAAKx4B,EAAWq4B,8BACjD,OAAIxoC,EACOmQ,EAAW04B,mBAAmB7oC,GAElCA,CACX,CACA,yBAAO6oC,CAAmB7oC,GAItB,MAHW,KAANA,EAAE,IAA4B,KAAfA,EAAEA,EAAE8B,OAAO,KAC3B9B,EAAIA,EAAE+E,MAAM,GAAG,IAEZ/E,EAAEwI,MAAM,KAAK+F,QAAO9Q,GAAKA,EAAEqE,OAAS,IAAGmI,KAAK,IACvD,CAMA,yBAAOusB,CAAmBx2B,GAEtB,OADAA,EAAIA,EAAEgU,YACGtO,UAAU,EAAG1F,EAAE4mC,YAAY,KAAK,GAAG7hC,MAAM,GAAG,EACzD,CAKA,gBAAO2iC,CAAU1nC,GACb,IAAI2D,EAAS,GACb,GAAS,QAAL3D,EACA,MAAO,CACHA,EAAG,MACH2D,SACAmlC,WAAW,GAInB,IAAItL,EAAU,iDACVuL,EAAU,KACd,GAAIA,EAAUvL,EAAQ/rB,KAAKzR,GAAI,CAC3B,IAAIgpC,EAAK,GACLD,EAAQE,SACRD,EAAKD,EAAQE,OAAOC,QAAU,GAC1BH,EAAQE,OAAOE,SACfJ,EAAQE,OAAOE,QAAQ3gC,QAAQlI,SAAQmC,IACnCumC,EAAKA,EAAG1c,QAAQ7pB,EAAG,GAAG,KAIlCzC,EAAIA,EAAEssB,QAAQkR,EAAS,IACvB75B,EAASqlC,CACb,CACA,MAAO,CACHhpC,IACA2D,SAER,CAMA,4BAAO6N,CAAsB43B,GAIzB,MAAO,iBAAiB7hC,KAAK6hC,EAAIp1B,WACrC,CAMA,0BAAOyvB,CAAoB2F,GAIvB,MAAO,iBAAiB7hC,KAAK6hC,EAAIp1B,WACrC,CAOA,gBAAOq1B,CAAU5jC,GACb,OAAOA,EAAEuO,WAAWjP,MAAM,GAAI,GAAGunB,QAAQ,MAAO,IACpD,CAOA,oBAAOsc,CAAcD,EAAKv3B,GAEtB,GAAoB,iBAAT,EACP,MAAM,IAAIzT,MAAM,sBAGpB,IAAIuJ,EAAIyhC,EACJ7d,EAAI,EACJhK,EAAK,GAET,SAASwoB,EAASpiC,EAAGlE,EAAOD,EAAQ,IAAKvC,EAAM,KAC3C,IAAIiC,EAAI,EACJioB,EAAKxjB,EAAEpF,OACX,MAAMynC,EAAcvmC,EACpB,IAAIwmC,GAAU,EACd,KAAQ/mC,EAAIioB,GAAQjoB,EAAI,GAAOO,EAAQ0nB,GAEnC5J,EAAK5Z,EAAElE,EAAQ,GACX8d,GAAM/d,EACDymC,GACD/mC,IAEGqe,GAAMtgB,IACRgpC,GACD/mC,KAER+mC,EAAgB,MAAN1oB,EACV9d,IAMJ,OAHKA,EAAQ,EAAI0nB,GAAQ,WAAWnjB,KAAKL,EAAElE,EAAQ,KAC/CA,IAEGkE,EAAExB,UAAU,EAAG6jC,GAAeriC,EAAExB,UAAU1C,EAAQ,EAC7D,CAzBAoO,EAAQA,GAAS,kBA0BjB,IAAIq4B,GAAU,EACV7S,EAAQ,GACZ,KAAO9L,EAAI1Z,EAAMK,KAAKvK,IACd4jB,EAAE9nB,MAAM,GACoB,MAAdkE,EAAE4jB,EAAE9nB,MAAM,IAEpB4zB,GAAS1vB,EAAExB,UAAU,EAAGolB,EAAE9nB,MAAM,GAChCkE,EAAIA,EAAExB,UAAUolB,EAAE9nB,MAAM,KAIhCkE,EAAIoiC,EAASpiC,EAAG4jB,EAAE9nB,OAClBymC,GAAU,GAOd,OALI7S,EAAM90B,OAAO,GACT2nC,IACAviC,EAAI0vB,EAAM1vB,GAGXuiC,EAAUviC,EAAIyhC,CACzB,CAEA,gBAAOV,CAAUU,EAAKj4B,EAAU5D,EAAQ,EAAG/J,EAAQ,IAAKvC,EAAM,KAC1D,MAAMkqB,EAAKie,EAAI7mC,OACf,IAAIgf,EAAK,KACL4oB,EAASh5B,EACb,KAAOA,EAAWga,GAAI,CAElB,GADA5J,EAAK6nB,EAAIj4B,GACLoQ,GAAM/d,EACN+J,SACG,GAAIgU,GAAMtgB,GAEA,KADbsM,EACgB,CACZ4D,IACA,KACJ,CAEJA,GACJ,CACA,OAAOi4B,EAAIjjC,UAAUgkC,EAAQh5B,EACjC,CAOA,0BAAO21B,CAAoBj1B,GACvB,IAAImW,GAAI,EACJvnB,EAAIoR,EAAM4C,WAGd,OAFAhU,EAAIA,EAAE0F,UAAU,EAAG1F,EAAE4mC,YAAY,KAAO,GAAG7hC,MAAM,GAAI,GACrD/E,EAAImQ,EAAWy4B,cAAc5oC,EAAG,uBACvB,MAALA,IAGJA,EAAIA,EAAEwI,MAAM,KAAKyB,KAAK,IAAIyD,OAE1B6Z,EAAgB,GAAZvnB,EAAE8B,OACCylB,EACX,CAKA,mBAAOoiB,CAAahpC,GAChB,MAAM0mC,EAAS,cACf,IAAIvc,EAAI,KACJ9qB,EAAI,GACJ8gB,EAAK,KACT,KAAOgK,EAAIuc,EAAO51B,KAAK9Q,IAAI,CACvBX,EAAIW,EAAE+E,UAAU,EAAGolB,EAAE9nB,OAErB,IAAIP,EAAI,EACJse,EAAIpgB,EAAE+E,UAAUolB,EAAE9nB,MAAQ8nB,EAAE,GAAGhpB,QAC/B4oB,EAAK3J,EAAEjf,OACPmX,EAAM,EACV,KAAOA,EAAMyR,GAAI,CAEb,GADA5J,EAAKC,EAAE9H,GACG,KAAN6H,GAEA,GADAre,IACS,GAALA,EAAQ,CACHwW,EAAM,EAAIyR,GAAO,QAAQnjB,KAAKwZ,EAAE9H,EAAM,KACvCA,IAGJjZ,GADU+gB,EAAErb,UAAU,EAAGuT,GAAO8H,EAAErb,UAAUuT,EAAM,GAElD,KACJ,MAEW,KAAN6H,GACLre,IAEJwW,GACJ,CACAtY,EAAIX,CACR,CACA,OAAOW,CACX,EAGJwP,EAAW61B,WAAaA,EAExBlpC,EAAQqT,WAAaA,C,8BCnVrBrS,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAGpD,MAAM,MAAEG,GAAU,EAAQ,MAuC1BtB,EAAQ8D,qBApCR,MAKI8O,WACAyB,MACAuc,SAAW,IACXjtB,MACA5B,SAEA,WAAAG,GACA,CAEA,UAAAI,CAAWC,EAAQC,EAAWC,EAAMC,GAChC,MAAMO,EAAiBC,GACZ5B,EAAM6B,WAAWD,GAEtB6lC,EAAkBznC,EAAM4C,qBAAqB9B,MACnD,OAAOd,EAAMwrC,UAAU1qC,KAAM,CACzBwQ,WAAY3P,EACZU,MAAOV,EACPlB,SAAWgnC,GACZxmC,EAAQC,EAAWC,EAAMC,EAChC,CACA,aAAA2nB,CAAcC,EAAYhnB,EAAGinB,GACzB,IAAIwiB,EAAejnC,GAAgB,iBAAL,EAC9B,OAAOxE,EAAM0rC,aAAa5qC,KAAM,CAC5BiS,MAAM04B,EACNnc,SAASmc,EACTnc,SAASmc,GACXziB,EAAYhnB,EAAGinB,EACrB,E,4BCtCJvpB,OAAOE,eAAelB,EAAS,aAAc,CAAEmB,OAAO,IAEtD,MAAM8rC,EAAY,CAAC,EAkCnBjtC,EAAQijB,gBA9BR,MAOI,eAAOiqB,CAAS1sC,EAAI2sC,GAChBF,EAAUzsC,GAAM2sC,CACpB,CACA,qBAAOC,GACHpsC,OAAOD,KAAKksC,GAAWzpC,SAAS7C,WACrBssC,EAAUtsC,EAAG,GAG5B,CAMA,aAAO0sC,CAAO7sC,GACV,MAAMsT,EAAMm5B,EAAUzsC,GACtB,OAAIsT,EACO,IAAIA,EAER,IACX,E,8BCjCJ9S,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,WAAE4C,GAAe,EAAQ,OACzB,WAAEsP,GAAe,EAAQ,MAK/B,MAAM/R,EACFqJ,iBAMA,wBAAO2G,CAAkBtH,EAAeC,GACpC,GAAIA,EAAYjF,QAAUgF,EAAchF,OACpC,MAAM,IAAInE,MAAM,6CAEpB,MAAMysC,EAAStjC,EAAc6D,OAAO5F,MAAM,GAC1C,IAAIslC,EAAO,EACPn+B,EAAO,EACP6oB,EAAS,EACTr1B,EAAIoH,EACJ4lB,EAAM5lB,EAAchF,OAExB,KAAOsoC,EAAOtoC,OAAS,GAAG,CACtBoK,EAAe,GAARm+B,EAAYD,EAAOvlC,QAAUulC,EAAOllC,MAC3C,IAAIolC,EAAOxjC,EAAc6D,OAAOO,GAAGgB,IAAS,KACxCq+B,EAAoBr+B,GAAQ6oB,EAShC,GARIuV,GAAQC,GAASD,EAAKzgB,iBAEdnqB,EAAEwM,UACFnF,EAAYmF,UACZpF,EAAc6D,OAAO7D,EAAc6D,OAAOxH,QAAQ+I,WAClDpF,EAAc6D,OAAOO,GAAGgB,IAGxB,GAARm+B,EAAW,CACX,IAAKE,EACD,MAEJxV,GACJ,KAAO,CACH,IAAKwV,EAAO,CACRF,EAAO,EACPtV,EAASrI,EAAM,EACf0d,EAAOplC,QAAQkH,GACf,QACJ,CACA6oB,GACJ,CACJ,CAEA,GAAIhuB,EAAYjF,QAAUgF,EAAchF,OACpC,MAAM,IAAInE,MAAM,yBAExB,CAMA,oBAAOg/B,CAAcj0B,GACjB,IAAI9G,EAAQ,KACZ,MAAM,iBAAE2hC,EAAgB,iBAAEC,EAAgB,cAAE5G,GAAkBl0B,EAC9D,QAAI66B,IAEI3hC,EAD0B,iBAAnB,EACC,CACJioB,QAAS2Z,KACN5G,GAGC,CAAC4N,UAAWhH,GAEjB5hC,EAGf,CACA,2BAAOyM,CAAqBvH,GACxB,MAAM,gBAAEwD,GAAoBlM,EAAMyB,QAE5BgG,EAAMiB,EAAc6D,OAAOO,GAC3Be,EAAUnF,EAAc6D,OAC9B,IAAI8/B,EAAM,EACNC,EAAQ,GACZA,EAAM//B,OAASL,EAAgBM,oBAE/B,IAAK,IAAI+/B,EAAK,EAAGA,EAAK7jC,EAAchF,OAAQ6oC,IACfznC,MAArB4D,EAAc6jC,KAEdD,EAAMrnC,KAAKyD,EAAc6jC,IACrBA,KAAM9kC,GACN6kC,EAAM//B,OAAOtH,KAAKonC,GAClBC,EAAM//B,OAAOO,GAAGu/B,GAAO5kC,EAAI8kC,KACI,GAAxB1+B,EAAQ9I,QAAQwnC,IACvBD,EAAM//B,OAAOtH,KAAKonC,GAEtBA,KAIR3jC,EAAchF,OAAS,EACvBgF,EAAczD,QAAQqnC,GACtB5jC,EAAc6D,OAAS+/B,EAAM//B,MAEjC,CAQA,mCAAOwB,CAA6BuT,EAAIxT,EAAMhB,GAC1C,GAAuB,GAAnB9F,MAAMC,QAAQqa,GACd,MAAM,IAAI/hB,MAAM,kBAOpB+hB,EAAGxU,GAAGgB,GAAQhB,CAClB,CACA,0BAAOmnB,CAAoBryB,EAAGoU,GACtBA,EAAQmvB,mBACRvjC,EAAE2K,OAASyJ,EAAQ+F,aAE3B,CAOA,oBAAOiB,CAAc1S,GACjB,MAAO,IAAKA,EAAO7J,YAAa6J,EAAOokB,cAC3C,CACA,kBAAO8d,CAAYliC,GACf,MAAO,IAAKA,EAAO7J,YAAa6J,EAAOQ,YAC3C,CAEA,wBAAO2hC,GACH,OAAQ7qC,IACK,QAALA,IACAN,EAAEu2B,aAAc,EAChBj2B,EAAI,IAER,IAAIyoC,GAAW,EACN,IAALzoC,IACAyoC,GAAW,GAEf,IAAI1nB,EAAI3iB,EAAM6B,WAAWD,EAAG,KAE5B,OADA+gB,EAAIgkB,YAAY91B,KAAK8R,EAAG0nB,GACjB1nB,CAAC,CAEhB,CAOA,qBAAOxX,CAAetL,EAAO4I,GACzB,MAAMyC,EAAK,CAACrL,GAIZ,OAHAqL,EAAGtG,MAAQ,EACXsG,EAAGvH,QAAU,CAAC,CAAC,EAAG9D,EAAM6D,SACxBwH,EAAGzC,MAAQA,GAAS,KACbyC,CACX,CAEA,uBAAOwkB,CAAiBnvB,EAAaV,GAAO,MAAEwC,EAAK,SAAE5B,EAAQ,SAAE6uB,EAAQ,MAAEvc,GAASmc,GAC9E,IAAIE,EAAOpvB,EAAMguB,cAAcztB,GAC/B,MAAM,EAAEoiB,GAAMuM,EAEd,GADAA,EAAQE,KAAOA,EACX/sB,EAAO,CACP,IAAIoF,EAAM6nB,GAAY,IAClBrS,EAAKjd,EAAM+tB,kBAAkBhb,EAAO4P,GACxC,GAAI,QAAQxZ,KAAK1B,GAAM,CACnB,IAAIsJ,EAAI1O,EAAM8G,KAAK8T,GACnB,GAAIxV,IACa,KAAPA,IAAgBsJ,GAAe,MAAPtJ,GAAgB,GAE1C,OADAynB,EAAQC,UAAW,EACZtvB,CAGnB,MAAO,GAAI,UAAUsJ,KAAK1B,GAAM,CAC5B,IAAI8nB,EAAMltB,EAAMuT,WAAWsY,QAAQ,QAAS,IAC5C,IACa,MAAPzmB,GAAiBwV,GAAMsS,GAChB,MAAP9nB,GAAiBwV,GAAMsS,IAErBtS,GAAMsS,EAEN,OADAL,EAAQC,UAAW,EACZtvB,CAGnB,CACJ,MAEIqvB,EAAQC,UAAW,EAEvB,OAAOtvB,CACX,CAUA,qBAAOyL,CAAezL,EAAOyK,EAAQ7J,EAAU8E,GAC3C,IAAI4W,EAAYtc,EACZ6sC,EAAW7sC,EAMf0F,EAAOiG,aACPjG,EAAO0I,eAAekO,EAAW7R,EAAQ/E,GACzCA,EAAOuO,QACP,IAAIsK,EAAU,CAAEjd,KAAM,MAKtB,OAJAgb,EAAY5W,EAAOoG,OAAM,EAAMyS,GAC/BsuB,EAAWtuB,EAAQjd,KACnBoE,EAAOqG,qBAEA,CACH,OAAUuQ,EACV,KAAQuwB,EAGhB,CAMA,uBAAOC,CAAiBxiC,EAAQqI,GAC5B,IAAK,IAAInO,KAAKmO,EACVrI,EAAO9F,GAAKmO,EAAInO,EAExB,CAQA,wBAAOuoC,CAAkB7qC,EAAGyC,EAAGqoC,GAC3B,IAAIxlC,EAAI,EACJylC,EAAS,EACTlrC,EAAI,GAkBR,OAjBIirC,IACAjrC,EAAI,yGAA2GirC,EAAa,MAAS9qC,EAAI,yBAE7IA,EAAEqI,MAAM,KAAKlI,SAASmC,IACbyoC,GAGGzlC,IACAylC,GAAU,KAEdA,GAAUzoC,EAAI,IACdgD,KANAylC,EAASzoC,EAAI,mBAAqBzC,EAAI,GAO1C,IAEJ4C,OAAkB,IAAP,EAAqB,aAA6B,iBAAP,EAAkBkF,KAAKC,UAAUnF,GAAKA,IAAM,IAAMzC,EAAI,IAC5G+qC,GAAUtoC,EAAI,IAAIwQ,OAAO3N,GAAK,MAAQ7C,EAAI,IAEnCsoC,CACX,CAQA,iBAAOviB,CAAWxoB,EAAGyC,EAAGuoC,GACpB,MAAO,EAAEzrC,EAAGkD,EAAGuoC,KACX,IAAIh8B,EAAI,KAAUxO,EAAI,KAAUyqC,EAAQ,KAAU7nC,EAAK,KAEvD,OADAX,OAAmB,IAAP,EAAqBA,EAAIzC,EACrB,GAAZT,EAAEoC,OAAoBc,GAC1BlD,EAAEY,SAAQmC,IACG,MAAL0M,IAEAA,EAAIxO,GAAKwqC,EAASA,EAAO1oC,GAAK,OAAS,CAAC,EACpC0oC,IACAA,EAAO1oC,GAAK0M,IAGhBi8B,IACA7nC,EAAK5C,EACgB,iBAATA,EAAE8B,KACV9B,EAAE8B,GAAK,CAAC,GAEZ9B,EAAE8B,GAAK9B,EAAE8B,IAAM,CAAC,EAChB9B,EAAIA,EAAE8B,IAEV2oC,EAAQ3oC,CAAC,IAGTc,EACAA,EAAG6nC,GAASxoC,EAERuoC,IACAA,EAAOzrC,EAAE,IAAMkD,GAGhBuM,EACV,EA/BM,CA+BJhP,EAAEqI,MAAM,KAAM5F,EAAGuoC,EACxB,CAMA,kBAAOllC,CAAY3H,EAAMoF,GACrBA,EAAOsB,WAAW1G,EAAKkK,MAAM,KAAK6iC,UACtC,CAMA,oBAAOzc,CAActwB,EAAMoF,GACvB,MAAMyL,EAAI7Q,EAAKkK,MAAM,KAAK6iC,UAC1B,KAAOl8B,EAAErN,OAAS,GAAG,CACjB,MAAMpC,EAAIyP,EAAEtK,QACZ,GAAInB,EAAO,IAAMhE,EAGb,MAAM,IAAI/B,MAAM,6BAA+B+B,GAF/CgE,EAAOmB,OAIf,CACJ,CAEA,8BAAO/E,CAAwBT,EAAQM,EAAUC,GAE7C,MAAM4nB,EAAiBnoB,EAAOooB,kBAAoB9nB,EAClD,OAAOvB,EAAMktC,YAAY9jB,EAAgB5nB,EAC7C,CASA,oBAAO2oB,CAAcgjB,EAAYhsC,EAAMwoB,EAAUG,GAC7C,IAAI7oB,EAAS,IAAIwB,EAKjB,GAJAxB,EAAO2V,OAASu2B,EAChBlsC,EAAOE,KAAOA,EACdF,EAAOmsC,SAAW,CAAC,EAEgB,iBAAxB,EAAkC,CACzC,MAAM,iBAAE/jB,EAAgB,qBAAEgb,EAAoB,yBAAEsD,GAA6B7d,EAC7E7oB,EAAOooB,iBAAmBA,EAC1BpoB,EAAOojC,qBAAuBA,EAC9BpjC,EAAO0mC,yBAA2BA,CACtC,MACI1mC,EAAOooB,iBAAmBS,EAK9B,OAHIH,IACA1oB,EAAO0oB,SAAWA,GAEf3pB,EAAMqtC,SAASpsC,EAAQ,IAAIksC,EAAchsC,EAAM,KAC1D,CACA,eAAOksC,CAASpsC,EAAQujC,EAAKrjC,EAAMC,GAC/B,OAAOqB,EAAWC,UAAUzB,EAAQujC,EAAKrjC,EAAMC,EACnD,CAMA,kBAAO8rC,CAAYC,EAAYG,GAC3B,IAAKA,QAAmD,IAAvB,EAC7B,MAAM,IAAI/tC,MAAM,6BAKpB,OAAO,SAAUyC,EAAGf,EAAQG,EAAQC,GAChC,IAAI+F,EAAO,GACP9F,EAAID,GAAUP,KAClB,MAAM,WAAEgL,GAAe9L,EAAMyB,QAiD7B,OAhDAO,EAAEE,SAAS2K,IACP,MAAM,QAAE0gC,GAAY1gC,EACd2gC,EAAW3gC,EAAE4gC,QACnB,IAAItoC,EAAK,KAAMuoC,EAAO,KAAMtoB,EAAO,KACnC,GAAImoB,EACA,GAAkB,KAAdA,EAAQ,GAERG,EAAOH,EAAQjmC,UAAU,GACrBomC,KAAQzsC,EAAOmsC,SACfjoC,EAAK,IAAImoC,EAAkBrsC,EAAOmsC,SAASM,IAGvCtsC,GAAWA,GAAUssC,GAASrsC,EAC9B8D,EAAK,IAAImoC,EAAkBhsC,IAE3B8jB,EAAOnkB,EAAOE,KAAKsmB,WAAWimB,GAC1BtoB,IACAjgB,EAAK,IAAIgoC,EACTlsC,EAAOmsC,SAASM,GAAQvoC,EACxB1C,EAAWC,UAAUzB,EAAQkE,EAAIigB,EAAMsoB,EAAMrsC,GAAU8D,GACvDlE,EAAO2oB,WAAWzkB,GAClBgoC,EAAWzlC,KAAKvC,SAIzB,CAGH,MAAM,gBAAE6iB,GAAoBlc,EAC5B,GAAIkc,EACA,OAAOA,EAAgBroB,QAAQ4tC,EAGvC,KAEC,IAAIC,EACL,MAAM,IAAIjuC,MAAM,2BAGhB4F,EAAK,IAAIgoC,EACT1qC,EAAWC,UAAUzB,EAAQkE,EAAI0H,EAAGzL,EAAQC,GAAU8D,GACtDlE,EAAO2oB,WAAWzkB,EAEtB,CACIA,GACAiC,EAAKnC,KAAKE,EACd,IAEGiC,CACX,CACJ,CAQA,gBAAOumC,CAAUtG,EAAM/8B,EAAQ/E,GAEN,iBAAV,IACP8hC,EAAO,CAACA,IAEZ,MAAMuG,EAAS,CACXn7B,UAAWlN,EAAOkN,UAClBqC,WAAYvP,EAAOuP,WACnB+4B,oBAAqBtoC,EAAOwT,2BAEhC,KAAOsuB,EAAK3jC,OAAS,GAAG,CACpB,IAAIpC,EAAI+lC,EAAK5gC,QACb,GAAInF,KAAKssC,GACDA,EAAOtsC,GACP,OAAO,CAGnB,CACA,OAAO,CACX,CAOA,gBAAOwsC,CAAUlsC,EAAG2D,GAChB,IAAIojB,GAAQ,EAgBZ,OAfI/mB,EAAE6Q,YACGlN,EAAOkN,YACRkW,GAAQ,KAGXA,GAAS/mB,EAAEylC,OACZ1e,EAAQ3oB,EAAM2tC,UAAU/rC,EAAEylC,KAAMzlC,EAAG2D,KAElCojB,GAASpjB,EAAO1C,gBAAkBjB,EAAEiB,iBACrC8lB,GAAQ,GAEPA,GAAUpjB,EAAOiT,wBAAwBlO,QAAU1I,IACpD+mB,GAAQ,EACRpjB,EAAOiT,uBAAyB,MAE7BmQ,CACX,CASA,mBAAOyf,CAAahoC,EAAU0I,EAAGvD,EAAQ0yB,GAErC,IAAIqQ,EAAK,KACLyF,EAAQ,KACR1F,EAAS,EACT4B,GAAU,EACVjkB,EAAY5lB,EACZ4tC,GAAa,EACjB,MAAM,YAAEhwB,EAAW,MAAEtY,GAAUH,EAC/ByY,EAAYvL,UAAYlN,EAAOkN,UAC/B,MAAMw7B,EAAS,CAAC,CAAE7tC,SAAUA,EAAUqf,KAAM,KAAMyuB,IAAKjW,EAAmBvpB,MAAO,EAAI/H,MAAM,IAE3F,KAAOsnC,EAAOvqC,OAAS,GAAG,CACtB,MAAMyqC,EAAcF,EAAOxnC,QAC3B,IAAIkwB,EAAS,EACTyX,EAAaD,EAAY/tC,SAASuG,MAAMwnC,EAAYxnC,OACxD,KAAOynC,EAAW1qC,OAAS,GAAG,CAC1B,IAAI9B,EAAIwsC,EAAW3nC,QAEfimB,EAAI,KACJjN,EAAO,KACP4uB,EAAa,KAGjB,IAFWruC,EAAM8tC,UAAUlsC,EAAG2D,GAEnB,CACP,IAAI,SAAEnF,GAAawB,EACnB,MAAMqnC,EAASrnC,EAAEumC,gBACjB,IAAI7mB,EAAK,KACT,GAAI2nB,EACAvc,EAAI1O,EAAYjL,MAAMk2B,EAAQ1jC,GAC9B+b,EAAK,CACDoL,IAAG9qB,EAAGA,EAAGgD,OAAQ,EAAGoO,MAAOi2B,EAAQxpB,KAAM0uB,EAAY1uB,KACrDrf,SAAU+tC,EAAY/tC,SACtB8tC,IAAKC,EAAYD,UAIrB,GAAI9tC,EAAU,CACT6tC,EAAOhpC,KAAK,CAAE7E,SAAUA,EAAUqf,KAAM7d,EAAGssC,IAAKjW,EAC7CvpB,MAAOioB,EACPhwB,MAAO,IACPynC,EAAW1qC,OAAS,IACpBuqC,EAAOhpC,KAAK,CAAE7E,SAAU+tC,EAAY/tC,SAAUqf,KAAM0uB,EAAY1uB,KAAMyuB,IAAKjW,EACvEvpB,MAAOioB,EACRhwB,MAAQwnC,EAAY/tC,SAASsD,OAAS0qC,EAAW1qC,SACpD0qC,EAAW1qC,OAAS,GAExB,QACJ,CAEA4d,MACGoL,IAAG9qB,IAAG6d,OAAMrf,YAAakhB,GAC5B+sB,GAA0B,GAAb/sB,EAAG1c,MAAc+xB,EAASrV,EAAG1c,OAE1C8nB,KAAkB,GAAXud,GAAkBA,EAASvd,EAAE9nB,SACpCqlC,EAASvd,EAAE9nB,MACX0jC,EAAK1mC,EACLymC,EAAS3b,EACTqhB,EAAQtuB,EACRuG,EAAY5lB,GAAY4lB,EACxBgoB,EAAYK,GAAc1X,EAElC,CACAA,GAEJ,CACJ,CACA,OAAe,IAAX0R,GAGG,CAAEC,KAAID,SAAQ0F,QAAO3tC,SAAU4lB,EAAWphB,MAAOopC,EAC5D,CAQA,wBAAOvhB,CAAkBrsB,EAAUmF,EAAQ0yB,EAAoB,MAC3D,MAAM,KAAE5lB,EAAI,MAAE3M,EAAK,MAAEgP,EAAK,UAAEqC,EAAS,YAAEiH,EAAW,UAAEvL,GAAclN,GAC5D,0BAAEwb,GAA8B/gB,EAAMyB,QAC5C,IAAI6mC,EAAK,KACLD,EAAS,EACT0F,GAAS,EACTjlC,EAAIkV,EAAYrL,SACpB,MAAM,YAAEnR,GAAgBxB,EAAMyB,QAC9B,IAAImD,EAQJ,KAPG0jC,KAAID,SAAQ0F,QAAO3tC,WAAUwE,SAAU5E,EAAMooC,aAAahoC,EAAU0I,EAAGvD,EAAQ0yB,IAC9EoQ,GACIA,EAAOzjC,MAAQW,EAAO7B,SACtB4kC,EAAK,KACLD,EAAS,MAGbC,EAAI,CAsBJ,GApBA5iC,GAAOgL,QAAQ,kBAAoB9M,QAAQC,IAAI,kBAAmB,CAC9D,OAAUykC,EAAG1yB,WACb1V,KAAMooC,EAAGpoC,KACTmS,OACAwI,IAAKwtB,EAAOzjC,MACZ8P,QACA45B,UAAwB,MAAbhG,EAAGznC,OACdsV,QAASmyB,EAAGnyB,QACZ7V,QAASgoC,EAAGhoC,QACZiuC,MAAOjG,aAAc9mC,EACrB3B,MAAOwoC,EAAO,GACdmG,SAAU1lC,EACV3B,OAAQ6W,EAAY7W,OACpB6L,MAAOs1B,EAAGC,WACVh4B,KAAsB,GAAhB+3B,EAAGhlB,UAAiB,YAAc,QACxCmrB,eAAyB,MAATV,EAChBltC,OAAQynC,EAAGznC,QAAQ+U,WACnB6J,KAAMsuB,GAAOn4B,WACbnD,cAEA61B,EAAG3nC,WAAY,CACf,IAAIrB,EAAIgpC,EAAG3nC,WACP4I,EAAoB,iBAAP,EAAkBjK,EAAE0J,QAAU,gBAE/C,MADAO,EAAMA,EAAI2kB,QAAQ,UAAW,IAAMma,EAAO,GAAK,KACzC,IAAItnB,EAA0BxX,EAAK++B,EAAID,EAAQtxB,EACzD,CAEAsxB,EAAOlhC,OAASkhC,EAAO,GAAG3kC,OAE1B,IAAIF,EAAQ,IAAIsT,EAMhB,OALA9W,EAAM0uC,qBAAqBlrC,EAAO8kC,EAAID,EAAQpQ,EAAmB8V,EAAO17B,EAAMjS,EAAUwE,EAAOW,EAAOS,UAAUyd,WAC5G,CACI1M,UAAWxR,EAAOwR,YAGnBvT,CACX,CACA,OAAO8kC,CACX,CAcA,2BAAOoG,CAAqBlrC,EAAO8kC,EAAID,EAAQpQ,EAAmB8V,EAAO17B,EAAMjS,EAAUwE,GAAQ,EAAI6e,EAAW,KAAMrO,EAAQ,MAC1H5R,EAAMsuB,IAAI,CACNxnB,OAAQg+B,EACRrkB,SAAUqkB,EAAGrkB,SAASokB,GACtBh2B,OACAb,MAAO62B,EACPxnC,OAAQo3B,EACR73B,WACAsc,UAAWqxB,EACXnpC,QACA6e,aACArO,SAER,CASA,oCAAO8Q,CAA8B7T,EAAMjS,EAAUmF,EAAQ0yB,GACzD,MAAM,MAAEvyB,EAAK,MAAEgP,EAAK,UAAEqC,EAAS,UAAE/Q,GAAcT,GACzC,YAAE/D,EAAW,0BAAEuf,GAA8B/gB,EAAMyB,QACzD,IAAI6mC,EAAK,KACLD,EAAS,EAET0F,EAAQ,KACRnpC,GAAS,EACb,MAAM,WAAE6e,GAAezd,EAGvB,KAFGsiC,KAAID,SAAQ0F,QAAO3tC,WAAUwE,SAAU5E,EAAMooC,aAAahoC,EAAUiS,EAAM9M,EAAQ0yB,IAEjFqQ,EAAI,CAeJ,GAbI5iC,GACA9B,QAAQC,IAAI,oBAAqB,CAC7B,OAAUykC,EAAG1yB,WACb1V,KAAMooC,EAAGpoC,KAAMmS,OAAMwI,IACjBwtB,EAAOzjC,MAAO8P,QAClB45B,UAAwB,MAAbhG,EAAGznC,OACdsV,QAASmyB,EAAGnyB,QACZo4B,MAAOjG,aAAc9mC,EACrB3B,MAAOwoC,EAAO,GACdr1B,MAAOs1B,EAAGC,WACV3jC,UAGJ0jC,EAAG3nC,WAAY,CACf,IAAIrB,EAAIgpC,EAAG3nC,WAEX,MAAM,IAAIogB,EADgB,iBAAP,EAAkBzhB,EAAE0J,QAAU,gBACRs/B,EAAID,EAAQtxB,EACzD,CAEAsxB,EAAOlhC,OAASkhC,EAAO,GAAG3kC,OAG1B,IAAIF,EAAQ,IAAIsT,EAEhB,OADA9W,EAAM0uC,qBAAqBlrC,EAAO8kC,EAAID,EAAQpQ,EAAmB8V,EAAO17B,EAAMjS,EAAUwE,EAAO6e,GACxFjgB,CACX,CACA,OAAO8kC,CACX,CAOA,mBAAOI,CAAa9mC,EAAG8qB,EAAG+b,EAAM37B,GAmB5B,OAhBIlL,EAFO,OAANkL,GAAuB,SAANA,EAEdlL,EAAEssB,QAAQ,cAAc,CAACrhB,EAAGtK,IAErBmqB,EAAEnqB,KAMTX,EAAEssB,QAAQ,oBAAoB,CAACrhB,EAAGtK,IACtB,MAARsK,EAAE,GAAmBA,EACb,KAARA,EAAE,GACKA,EAAE,GAAK6f,EAAEnqB,GACbmqB,EAAEnqB,KAGjBX,EAAI,WAAWuH,KAAKvH,GAAKA,EAAE+E,MAAM,GAAI,GAAK/E,EACnC,IAAIsH,OAAOtH,EAAG6mC,GAAQ,GACjC,CAGA,wBAAO1a,CAAkBnsB,EAAG4P,EAAO1E,GAC/B,IAAI6hC,EAAK3uC,EAAM0oC,aAAa9mC,EAAG4P,EAAO,KAAM1E,GAG5C,OAFA6hC,EAAKA,EAAG/4B,WAAWtO,UAAU,GAAGX,MAAM,GAAI,GAAGunB,QAAQ,QAAS,KAC1DtsB,EAAEssB,QAAQtsB,EAAG+sC,EAErB,CAMA,oBAAO3gB,CAAchb,GACjB,IAAIpR,EAAIoR,EAAM4C,WAEd,OADAhU,EAAIA,EAAE0F,UAAU,EAAG1F,EAAE4mC,YAAY,KAAO,GACjC5mC,CACX,CAMA,gBAAO0nC,CAAU1nC,GACb,OAAOmQ,EAAWu3B,UAAU1nC,EAChC,CACA,qBAAOgtC,CAAehtC,EAAG6mC,GACrB,IAAIjlC,EAAQxD,EAAMspC,UAAU1nC,GAI5B,OAHI6mC,GAAiC,GAAvBjlC,EAAM+B,OAAO7B,SAAgD,GAA/BF,EAAM+B,OAAOR,QAAQ0jC,KAC7DjlC,EAAM+B,QAAUkjC,GAEbjlC,CACX,CASA,iBAAO3B,CAAWD,EAAG6mC,GACjB,GAAkB,iBAAP,EAAiB,CACxB,IAAIjlC,EAAQxD,EAAM4uC,eAAehtC,EAAG6mC,GACpC,OAAO,IAAIv/B,OAAO1F,EAAM5B,EAAG4B,EAAM+B,OACrC,CAAO,GAAkB,iBAAP,EAAiB,CAC/B,GAAI3D,aAAasH,OAAQ,CAErBtH,EAAImQ,EAAWqmB,mBAAmBx2B,GAClC,IAAI4B,EAAQxD,EAAM4uC,eAAehtC,EAAG6mC,GAEpC,OADU,IAAIv/B,OAAO1F,EAAM5B,EAAG4B,EAAM+B,OAExC,CACA,MAAM,OAAEA,EAAM,MAAEyN,GAAUpR,EAC1B,OAAIoR,aAAiB9J,QACjB8J,EAAQhT,EAAM0oC,aAAa11B,EAAM4C,WAAYrQ,GACtCyN,GAEJ,IAAI9J,OAAO8J,EAAOzN,EAC7B,CACA,OAAO3D,CACX,CACA,2BAAOmG,CAAqBvD,EAAGnE,GAC3B,MAAMwuC,EAAQ,CACV,UAAAC,CAAWltC,GACP,IAAImtC,EAAK,GAIT,OAHAntC,EAAEwI,MAAM,KAAKlI,SAAQ2K,IACjBkiC,EAAG9pC,KAAK4H,EAAEmiC,OAAO,GAAGC,cAAcpiC,EAAElG,MAAM,GAAGuoC,cAAc,IAExDH,EAAGljC,KAAK,IACnB,EACAsjC,UAAUvtC,GACFA,EAAEssB,QAAQ,OAAQ,KAG1BkhB,UAAU5qC,GACCA,EAAEyqC,cAEbI,UAAU7qC,GACCA,EAAE0qC,cAEb5/B,KAAK9K,GACMA,EAAE8K,OAObggC,MAAM9qC,GACKA,EAAE2K,UAObogC,MAAM/qC,GACKA,EAAE6K,aAqCjB,OAlCAhP,EAAU6B,SAASN,IAIf,IAAIsJ,EAAK,KACT,GAAIA,EAAK,uCAAuCmI,KAAKzR,GAAI,CAErD,IAAIG,EAAIynB,SAASte,EAAG2/B,OAAe,QAC/B5tB,EAAK/R,EAAG2/B,OAAe,OAC3B,GAAI9oC,EAAIyC,EAAEd,OAAQ,CACd,IAAIsK,EAAK9C,EAAG,GACZ,GAAU,KAAN+R,EACAzY,EAAIA,EAAEoR,WAAW45B,OAAOztC,EAAGiM,QACxB,GAAU,KAANiP,EACPzY,EAAIA,EAAEoR,WAAW65B,SAAS1tC,EAAGiM,QAE5B,GAAU,KAANiP,EAAW,CAChB,IAAI5V,EAAImwB,KAAKkY,OAAO3tC,EAAIyC,EAAEd,QAAU,GAEpCc,GADAA,EAAIA,EAAEoR,WAAW45B,OAAQnoC,EAAI,GAAM,EAAItF,EAAIsF,EAAItF,EAAIsF,EAAI,EAAG2G,IACpD4H,WAAW65B,SAAS1tC,EAAGiM,EACjC,CACJ,CACA,OAAOxJ,CACX,CAEA,GAAI0G,EAAK,0BAA0BmI,KAAKzR,GAAI,CACxC,IAAIyF,EAAIrH,EAAM0oC,aAAax9B,EAAG2/B,OAAmB,WAAG,CAACrmC,IAGrD,OAFA6C,EAAI0K,EAAWk5B,UAAU5jC,GACzB7C,EAAIA,EAAE0pB,QAAQ1pB,EAAG6C,EAErB,CAEA7C,EAAkB,mBAAP,EAAoB5C,EAAE4C,GAAKqqC,EAAMjtC,GAAG4C,EAAE,IAE9CA,CACX,CAUA,mBAAOknC,CAAapqC,EAAG4nB,EAAWF,EAAYhnB,EAAGinB,GAE7C,IAAIE,EAAID,EAAYA,EAAUF,GAAc,KAC5C,GAAIG,IAAMA,EAAEnnB,GAAI,CACZ,GAAIinB,EACA,MAAM,IAAI1pB,MAAM,IAAIypB,mBAExB,OAAO,CACX,CACA,OAAO,CACX,CAWA,gBAAOwiB,CAAUlqC,EAAGQ,EAAOb,EAAQC,EAAWC,EAAMC,GAChD,IAAI0B,EAAKhB,EAAQA,EAAMZ,GAAa,KACpC,OAAI4B,EACOA,EAAGb,MAAMX,EAAG,CAACH,EAAMF,EAAQG,IAE/BD,CACX,CACA,gCAAOwB,GACH,OAAO,SAAUZ,EAAGd,GAChB,GAAkB,iBAAP,EAAiB,CACxB,IAAI2M,EAAI,GAMR,OALA7L,EAAEqI,MAAM,KAAKlI,SAASmC,IAClBA,EAAEiL,OACEjL,EAAEX,OAAS,GACXkK,EAAE3I,KAAKZ,EAAE,IAEVuJ,CACX,CACA,GAAI5G,MAAMC,QAAQlF,GACd,OAAOA,CAEf,CACJ,CAaA,oBAAOytB,CAAc3vB,EAAOkG,EAAY4pC,EAAcn+B,EAAOwE,EAASzQ,EAAQ9E,EAAUgF,GAAQ,GAC5F,IAAIkd,EAAInR,EACJo+B,EAAMD,EACNptC,EAAI,GACR,MAAM,gBAAEW,GAAoBlD,EAAMyB,SAC5B,SAAE4D,GAAaE,EACrB,GAAIod,EAAG,CAIHpgB,EAAIvC,EAAM+tB,kBAAkB6hB,EAAKjtB,GACjC,IAAI5P,EAAQxQ,EAAE2rB,QAAQ,yBAA0B,IAK5C3a,EAAK,IAAIrK,OAAO3G,EAAG,KACnBstC,EAAMhwC,EAAMquB,QAAQruB,EAAOkT,GAAOmb,QAAQ,QAAS,OAEnD/qB,EAAUoQ,EAAGF,KAAKw8B,GACtB,MAAM/0B,EAAUvV,EAAO8W,YACjByzB,EAAQrvC,GAAYsF,EAAW0oB,kBAAkBzY,GACvD,GAAI7S,GAAW2sC,EAAO,CAClBntB,EAAIzf,EAAgBK,gBAAgBJ,EAAS2X,GAC7C,MAAMgC,EAAa,CAAC,EACpB,IAAIizB,EAAMptB,EAAEvd,OAAOC,EAAUyqC,GAAO,EAAOh1B,EAASvV,EAAQuX,EAAYrX,GAIxE,MAHsB,iBAAX,IACPA,EAAM0b,SAAWrE,GAEdizB,CACX,CAEA,OADAh9B,EAAQA,EAAMmb,QAAQ,SAAU,MACzBnb,CAEX,CASA,OAPI68B,EAAMA,EAAItoC,UAAU,GAAGX,MAAM,GAAI,GACtB,QAAPipC,IACAA,EAAM,IAEVrtC,EAAIqtC,EAAI1hB,QAAQ,QAAS,KAErBruB,EAAMquB,QAAQruB,EAAO0C,EAEjC,CAUA,wBAAO2F,CAAkBrI,EAAOO,EAAUoR,EAAOjM,GAC7C,MAAMQ,EAAaR,EAAOS,UAC1B,IAAIgqC,EAAcjqC,EAAWwT,KAAKiP,aAClCziB,EAAWwT,KAAKiP,aAAehX,EAC/B,IAAItR,EAAO,KACP+vC,EAAQ,KACR1lC,EAAS,KAES,iBAAX,IACJ1K,QAAOK,QAASL,GAEnB0K,EAAS1K,EAEbowC,EAAQ/vC,EACRqK,EAAS1K,EAET,MAAMyB,EAAIiE,EACV,GAAIQ,EAAWuY,SAAS4D,4BAA6B,CACjD3c,EAAO6V,YAEP,IAAIZ,EAAO,CACPpa,SAAU2F,EAAW3F,SACrBwK,OAAQtJ,EAAEsJ,OACVtE,OAAQhF,EAAEgF,OACVkO,gBAAiBlT,EAAEkT,gBACnBuC,UAAWzV,EAAEyV,UACboG,WAAY7b,EAAE6b,WAAWxW,MAAM,GAC/B0L,KAAM/Q,EAAE+Q,KACRwI,IAAKvZ,EAAEuZ,IACPnG,MAAOpT,EAAEoT,MACTzM,UAAW3G,EAAE2G,UAAUtB,MAAM,GAC7B0Q,YAAa/V,EAAE+V,YACf/B,aAAchU,EAAEgU,aAChBwP,uBAAwBxjB,EAAEwjB,uBAC1BtM,uBAAwBjT,EAAOiT,wBAInClX,EAAEwjB,uBAAyB,KAC3BxjB,EAAEyV,UAAY,EACdzV,EAAEoT,MAAQ,EACVpT,EAAE6b,WAAWzZ,OAAS,EACtB6B,EAAOyY,YAAY9L,OACnB3M,EAAOmT,aAAaxG,OACpB3M,EAAOiT,uBAAyB,KAChClX,EAAE4c,UAAU,sBACZnY,EAAWwT,KAAKgP,kBAChBxiB,EAAW3F,SAAWA,EAEtBP,EAAQkG,EAAWrF,OAAO6J,EAAQ,CAAErK,KAAM+vC,IAC1ClqC,EAAWwT,KAAKgP,kBAChBxiB,EAAW3F,SAAWoa,EAAKpa,SAE3BkB,EAAEyV,UAAYyD,EAAKzD,UACnBxR,EAAOyY,YAAYzL,UACnBhN,EAAOmT,aAAanG,UACpBjR,EAAE+Q,KAAOmI,EAAKnI,KACd/Q,EAAEoT,MAAQ8F,EAAK9F,MAEfpT,EAAEwjB,uBAAyBtK,EAAKsK,uBAChCxjB,EAAE2c,cAAc,CAAE7I,MAAO,CAAEZ,gBAAiBgG,EAAKhG,mBACjDgG,EAAK2C,WAAWjb,SAAQ2K,GAAKvL,EAAE6b,WAAWlY,KAAK4H,KAC/CtH,EAAOiW,WACPjW,EAAOiT,uBAAyBgC,EAAKhC,sBAEzC,MAGI3Y,EADkBiM,WAAWie,WAAW,CAAE3pB,SAAU4B,EAAE5B,WAClCM,OAAOb,GAG/B,OADAkG,EAAWwT,KAAKiP,aAAewnB,EACxBnwC,CACX,CAWA,mBAAOmnB,CAAa1c,EAAQyS,EAAMvL,EAAO6K,EAAa9W,GAClD,MAAM,SAAEF,GAAaE,GACf,gBAAErC,GAAoBlD,EAAMyB,QAClC,IAAIwb,EAAK,KACT,GAA4B,GAAxBjW,MAAMC,QAAQuK,GAAiB,CACjB,OAAVA,IACAA,EAAQ,IACZ,MAAM7N,EAAU,GAChBA,EAAQsB,KAAK,CAAC,EAAGuM,EAAM9N,UACvB8N,EAAQ,CAACA,IACH7N,QAAUA,CACpB,CAEA,GADAsZ,EAAK/Z,EAAgBK,gBAAgBiO,EAAOlH,EAAOpK,MAC/C+c,EAEA,OADSA,EAAG7X,OAAOC,EAAU0X,GAAM,EAAOV,EAAa9W,EAG/D,CAQA,qBAAOihB,CAAenU,EAAM4R,EAAU1e,GAClC,MAAM,WAAEwM,GAAe/R,EAAMyB,QAC7B,IAAIc,EAAI0hB,EAASrO,WACjBrT,EAAIA,EAAE+E,UAAU,EAAG/E,EAAEimC,YAAY,KAAO,GAAG7hC,MAAM,GAAI,GACrDpE,EAAIwP,EAAWw5B,aAAahpC,GAC5B,IACImP,EADM,IAAIxI,OAAO3G,GACN8Q,KAAKhB,GAIpB,OAHIX,IACAA,EAAKvK,OAASuK,EAAK,GAAGhO,QAEnBgO,CACX,CAEA,2BAAO9O,CAAqBtB,GACxB,MAAO,CAACM,EAAGX,KACP,MAAMivC,EAAcjvC,EAAOojC,sBAAwBrkC,EAAMyB,QAAQxB,YACjE,IAAI+B,EAAI,CAAC,EACT,IAAK,IAAIqC,KAAKzC,EAAG,CACb,IAAIW,EAAI,IAAI2tC,EAAY5uC,GACxBmB,EAAWC,UAAUzB,EAAQsB,EAAGX,EAAEyC,IAClCrC,EAAEqC,GAAK9B,EACPtB,EAAO2oB,WAAWrnB,EACtB,CACA,OAAOP,CAAC,CAEhB,CAQA,sBAAOikB,CAAgB7lB,EAAUmE,EAAK4rC,GAClC,OAAQA,GACJ,IAAK,OACD,OAAO/vC,EAASuG,MAAMpC,EAAM,GAChC,IAAK,SACD,MACJ,IAAK,MACD,OAAOnE,EAASuG,MAAM,GAC1B,IAAK,UACD,IAAIoK,EAAI3Q,EAASuG,MAAM,GAEvB,cADQoK,EAAExM,GACHwM,EAEf,MAAO,EACX,EAKJrS,EAAQsB,MAAQA,EAGhB,MAAM,iBAAE8W,GAAqB,EAAQ,G,iBC1oCrCpX,OAAOE,eAAelB,EAAS,aAA/B,CAA+CmB,OAAO,IAEtD,MAAM,yBAAEyQ,GAA6B,EAAQ,MACvC8/B,EAAS,EAAQ,OAGjB,SAAE7uC,EAAQ,YAAEtB,EAAW,MAAEmJ,GAAUgnC,EAAOpwC,MAAMyB,QAehD4uC,EAAkB,CACpB,QAAU,UACV,gBAAgB,QA+BdC,EAAgB,CAClBjnB,iBAhBJ,cAA2B9nB,EACvBgvC,UACA,QAAArI,CAASr7B,GACL8G,MAAMu0B,SAASr7B,IACVA,EAAE0jC,WAAazvC,KAAKyvC,YACrB1jC,EAAE0jC,UAAYzvC,KAAKyvC,UAE3B,GAUAlM,qBARJ,cAA2BpkC,EACvBswC,UACA,WAAA3vC,CAAYU,GACRqS,MAAMrS,EACV,GAKAqmC,yBAzBJ,cAA4Cr3B,EACxCigC,UACApwC,QACA,QAAAqwC,GACI,OAXUrwC,EAWMW,KAAKX,WAVVkwC,EACJA,EAAgBlwC,GAEpBA,EAAQ+uC,cAJnB,IAAkB/uC,CAYd,IAqKJzB,EAAQ4xC,cAAgBA,EACxB5xC,EAAQ+xC,SAnMR,SAAkBtmC,EAAQumC,GACtB,IACIC,EAAS,yEADGD,EAAiB,IAAIhtC,OAC6D,MAC9FktC,EAAa,EACjBzmC,EAAO0mC,iBAAiB,YAAY3uC,SAAQmC,IACxC,IAAItC,EAAI+uC,SAASC,cAAc,OAC/BhvC,EAAEivC,UAAYJ,EAAa,EAC3B7uC,EAAEkvC,MAAQN,EACVtsC,EAAE6sC,aAAanvC,EAAGsC,EAAE8sC,YACpBP,GAAY,GAEpB,EAyLAlyC,EAAQ0yC,sBA3IR,SAA+BhsB,GAa3B,OAZAA,EAAKisB,cAAgB,EAErBjsB,EAAKksB,eAAiB,CAClB,QAAU,EACV,SAAW,EACX,KAAO,EACP,OAAS,EACT,SAAW,EACX,gBAAgB,EAChB,OAAS,EACT,OAAS,GAEN,WACH,IAIIC,EAAS,CACT58B,UAAS,EAAC,SAACC,KACA,GAEXC,WAAU,IACC,GAEX,cAAAod,EAAe,KAACJ,EAAI,OAAEK,EAAM,KAAE/wB,EAAI,YAAE0b,IACN,GAAtB1b,EAAKmO,OAAO5L,QACRmZ,EAAY1G,SAAuC,GAA3B0G,EAAYhY,OAAOnB,QAGnDwuB,GACJ,EACA,WAAA/pB,CAAY3D,EAAGc,EAAQnF,EAASwF,EAAQD,EAAO4E,GAE3C,GADA5E,GAAS0D,EAAMvF,IAAI,cAAe,CAAChE,MAAM2E,EAAGrE,UAASmF,OAAQA,EAAOqB,MAAM,KAC5D,GAAVnC,EAAEd,OACF,MAAO,GAEX,IAAI8tC,EAAKlsC,EAAOmB,QACZ1E,EAAI,KACJ0vC,EAAU,GACVC,EAAO,CAAC,EAsBZ,OArBIvxC,IACAuxC,EAAKvxC,GAAW,EAChBilB,EAAKksB,eAAenxC,GAAW,GAE/BmK,GAAQimC,WACRjmC,EAAOimC,UAAUnmC,MAAM,KAAKlI,SAAQ2K,IACb,GAAjBA,EAAEyC,OAAO5L,SACXguC,EAAK7kC,GAAG,EACFA,KAAKuY,EAAKksB,iBACZlsB,EAAKksB,eAAezkC,GAAK,GAAC,IAGlC,YAAY1D,KAAKqoC,KACjBhtC,EAAIA,EAAE0pB,QAAQ,IAAK,QAAQA,QAAQ,IAAK,QACxCwjB,EAAQ,EAAE,EACVA,EAAa,OAAE,GAEf,mBAAmBvoC,KAAKqoC,KACxBhtC,EAAI,0FAA6FA,EAAE,mCAAoCA,GAE3IitC,EAAU/xC,OAAOD,KAAKiyC,GAAM7lC,KAAK,KACb,GAAhB4lC,EAAQ/tC,OACDc,EAEiB,oBAAd,UACVzC,EAAI+uC,SAASC,cAAc,QAC3BhvC,EAAEwuC,UAAYkB,EACd1vC,EAAEivC,UAAYxsC,EAEPzC,EAAE4vC,YAEDF,EAAQ/tC,OAAO,IACf+tC,EAAU,WAAYA,EAAQ,KAEzB,QAAQA,EAAQ,IAAIjtC,EAAE,UAG3C,EACA,OAAAu0B,GACIn1B,QAAQC,IAAI,eAChB,EACA,iBAAA4H,EAAkB,OAACnF,IAEfA,EAAOrB,KAAK,GAChB,EACA,WAAAgoB,EAAY,OAAC3mB,EAAM,SAAEsO,EAAQ,QAAEH,IAC3B,MAAM3L,EAAI,GAWV,OATAxC,EAAOpE,SAASK,IACZA,EAAE6H,MAAM,MAAMlI,SAAQ4pB,IAElBA,EAAK,qBAAuBA,EAC5BA,GAAK,SACLhjB,EAAE7D,KAAK6mB,GACP1G,EAAKisB,eAAe,GACtB,IAECvoC,EAAE+C,KAAK+I,GAAUzF,SAC5B,EACA,MAAA7I,EAAO,OAAEsE,EAAM,OAAEtE,EAAM,SAAEsO,EAAQ,MAAEjJ,EAAK,KAAEwS,IACtC,IAAIrV,EAAI,GAIR,OAFIA,EAAKxC,EAAOuF,KAAK+I,GAEd9L,CACX,EAKA,KAAAgL,EAAM,OAAExN,EAAM,OAAEsE,EAAM,MAAE8J,EAAK,QAAED,EAAO,gBAAED,IAa1B,CAAC5J,GACT1I,SAZmB,SAAS0I,GACP,GAAfA,EAAOlH,SAGPgR,EAAQ,IACR9J,EAAS,SAAY,SAASoK,OAAO,GAAIA,OAAON,GAAS,UAAY9J,GAIzEtE,EAAOrB,KAAK2F,GAChB,GAGJ,EACA,aAAA2J,CAAc1H,GAEd,GAKJ,OAHAnN,OAAOE,eAAewlB,EAAM,aAAc,CAACrkB,IAAG,IACnC6wC,WAEJL,CACX,CACJ,C,mrgJCzMIM,EAA2B,CAAC,EAGhC,SAASzyC,EAAoB0yC,GAE5B,IAAIC,EAAeF,EAAyBC,GAC5C,QAAqBhtC,IAAjBitC,EACH,OAAOA,EAAarzC,QAGrB,IAAIC,EAASkzC,EAAyBC,GAAY,CAGjDpzC,QAAS,CAAC,GAOX,OAHAszC,EAAoBF,GAAUnzC,EAAQA,EAAOD,QAASU,GAG/CT,EAAOD,OACf,CCtBAU,EAAoBC,EAAI,CAACmlC,EAAK9mB,IAAUhe,OAAOikB,UAAUsuB,eAAepgC,KAAK2yB,EAAK9mB,G,0CCClF,MAAM,WAAE5R,EAAU,MAAE9L,EAAK,SAAEuB,GAAa,EAAQ,KAChD7B,OAAOE,eAAelB,EAAS,aAA/B,CAA8CmB,OAAM,IAEpDnB,EAAQoN,WAAaA,EACrBpN,EAAQ6C,SAAWA,EACnB7C,EAAQuB,YAAcD,EAAMyB,QAAQxB,YACpCvB,EAAQsB,MAAQA,EAChBtB,EAAQwzC,QAAU,SAClBxzC,EAAQyzC,IAEG,CACHnyC,MAFU,EAAS,M","sources":["webpack://balafon-formatters/webpack/universalModuleDefinition","webpack://balafon-formatters/./src/formatters/ sync ^\\.\\/.*\\.btm\\-syntax\\.json$","webpack://balafon-formatters/./src/lib/BlockInfo.js","webpack://balafon-formatters/./src/lib/CaptureInfo.js","webpack://balafon-formatters/./src/lib/CaptureRenderer.js","webpack://balafon-formatters/./src/lib/Debug.js","webpack://balafon-formatters/./src/lib/EndMissingEngine/bhtml.js","webpack://balafon-formatters/./src/lib/EndMissingEngine/engines.js","webpack://balafon-formatters/./src/lib/FormatterBuffer.js","webpack://balafon-formatters/./src/lib/FormatterBufferUtils.js","webpack://balafon-formatters/./src/lib/FormatterCloseParentInfo.js","webpack://balafon-formatters/./src/lib/FormatterDebugger.js","webpack://balafon-formatters/./src/lib/FormatterEndMissingEngine.js","webpack://balafon-formatters/./src/lib/FormatterEndMissingExpression.js","webpack://balafon-formatters/./src/lib/FormatterErrors.js","webpack://balafon-formatters/./src/lib/FormatterLineMatcher.js","webpack://balafon-formatters/./src/lib/FormatterLineSegment.js","webpack://balafon-formatters/./src/lib/FormatterLintError.js","webpack://balafon-formatters/./src/lib/FormatterListener.js","webpack://balafon-formatters/./src/lib/FormatterMarkerInfo.js","webpack://balafon-formatters/./src/lib/FormatterMatchTreatment.js","webpack://balafon-formatters/./src/lib/FormatterOptions.js","webpack://balafon-formatters/./src/lib/FormatterPatternException.js","webpack://balafon-formatters/./src/lib/FormatterSegmentInfo.js","webpack://balafon-formatters/./src/lib/FormatterSegmentJoin.js","webpack://balafon-formatters/./src/lib/FormatterSetting.js","webpack://balafon-formatters/./src/lib/FormatterStreamBuffer.js","webpack://balafon-formatters/./src/lib/FormatterSyntaxException.js","webpack://balafon-formatters/./src/lib/FormatterToken.js","webpack://balafon-formatters/./src/lib/Formatters.js","webpack://balafon-formatters/./src/lib/FormattingCodeStyles.js","webpack://balafon-formatters/./src/lib/Formattings/FormattingBase.js","webpack://balafon-formatters/./src/lib/Formattings/FormattingMode.js","webpack://balafon-formatters/./src/lib/Formattings/KAndRFormatting.js","webpack://balafon-formatters/./src/lib/JSonParser.js","webpack://balafon-formatters/./src/lib/NativeRegExp.js","webpack://balafon-formatters/./src/lib/PatterMatchErrorInfo.js","webpack://balafon-formatters/./src/lib/PatternFormattingOptions.js","webpack://balafon-formatters/./src/lib/PatternMatchInfo.js","webpack://balafon-formatters/./src/lib/Patterns.js","webpack://balafon-formatters/./src/lib/RefPatterns.js","webpack://balafon-formatters/./src/lib/RegexEngine.js","webpack://balafon-formatters/./src/lib/RegexUtils.js","webpack://balafon-formatters/./src/lib/ReplaceWithCondition.js","webpack://balafon-formatters/./src/lib/TransformEngine.js","webpack://balafon-formatters/./src/lib/Utils.js","webpack://balafon-formatters/./src/web/Utils.js","webpack://balafon-formatters/webpack/bootstrap","webpack://balafon-formatters/webpack/runtime/hasOwnProperty shorthand","webpack://balafon-formatters/./src/formatter.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bformatter\"] = factory();\n\telse\n\t\troot[\"bformatter\"] = factory();\n})(self, () => {\nreturn ","var map = {\n\t\"./bcss-inline.markdown.btm-syntax.json\": 1044,\n\t\"./bcss-provide-colors.btm-syntax.json\": 1006,\n\t\"./bcss.btm-syntax.json\": 4191,\n\t\"./bcss.inline.btm-syntax.json\": 5202,\n\t\"./bhtml.btm-syntax.json\": 655,\n\t\"./bview.btm-syntax.json\": 103,\n\t\"./csharp.btm-syntax.json\": 9429,\n\t\"./css-transform.btm-syntax.json\": 8252,\n\t\"./demodata.btm-syntax.json\": 769,\n\t\"./fbcolor.btm-syntax.json\": 4143,\n\t\"./features.btm-syntax.json\": 8469,\n\t\"./format-only.btm-syntax.json\": 5866,\n\t\"./js.btm-syntax.json\": 4249,\n\t\"./markdown.btm-syntax.json\": 935,\n\t\"./pascal.btm-syntax.json\": 7224,\n\t\"./pcss.btm-syntax.json\": 493,\n\t\"./php.btm-syntax.json\": 5286,\n\t\"./python.btm-syntax.json\": 722,\n\t\"./vbmacros.btm-syntax.json\": 8779\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 3323;","\"use stricts;\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n\n/**\n * used to handle block definition\n */\nclass BlockInfo{\n    /**\n     * @var {?number | 'inline'}\n     */\n    mode;\n}\n\nexports.BlockInfo = BlockInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\nconst { Utils } = require(\"./Utils\");\nclass CaptureInfo{\n    /**\n     * string name of the capture info used in token\n     * @var {?string}\n     */\n    name;\n\n    /**\n     * id used to setup rendering definition\n     */\n    tokenID;\n    /**\n     * extra patterns definition \n     * @var {null|[{include:string}|{extends: string}|Pattern]}\n     */\n    patterns;\n\n    /**\n     * transformation to apply to this element before send it to patterns list in case this patterns is set\n     * @var {null|string|string[]|(v:string):string}\n     */\n    transform;\n    /**\n     * description of this \n     */\n    comment;\n    /**\n     * replace with \n     */\n    replaceWith;\n\n    /**\n     * transformat option \n     * @var {bool}\n     */\n    nextTrimWhiteSpace;\n\n    /**\n     * list of capture info \n     */\n    captures;\n\n    /**\n     * format object \n     * @var {*} \n     */\n    format;\n\n    /**\n     * throw error on capture detection\n     * @var {string|{message: string, match:regularExpression|string}}\n     */\n    throwError;\n\n    constructor(parent){ \n\n        Object.defineProperty(this, 'parent', {get(){return parent;}})\n    }\n\n    json_parse(parser, fieldname, data, refKey, refObj){\n        const q = this;\n        const { Patterns, RefPatterns } = Utils.Classes;\n        const patterns = Utils.ArrayPatternsFromParser(parser, Patterns, RefPatterns);\n        const transform = Utils.TransformPropertyCallback();\n        const _regex_parser = (s)=>{\n            return Utils.RegexParse(s, 'd'); \n        };\n        const captures = Utils.JSONInitCaptureField(q);\n        const parse = {\n            patterns(n,parser, refKey, refObj){\n                let d = patterns.apply(q, [n,parser, refKey, refObj]);\n                d.forEach((s)=>{\n                    // attach the pattern to the capture parent \n                    s.parent = q.parent;\n                });\n                return d;\n            }, // update with parent\n            begin: _regex_parser,\n            end: _regex_parser,\n            match: _regex_parser,\n            replaceWith: _regex_parser,\n            replaceWithCondition(n, parser){\n                let m = new ReplaceWithCondition; \n                JSonParser._LoadData(parser, m, n, refObj);  \n                return m;\n            },\n            transform,\n            captures,\n            matchTransform(){                \n                throw new Error('match transform not handled');\n            }\n        };\n        let fc = parse[fieldname];\n        if (fc){\n            return fc.apply(q, [data, parser, refKey, refObj]);\n        }\n        return data;\n    }\n}\n\nexports.CaptureInfo = CaptureInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { FormatterMatchTreatment } = require('./FormatterMatchTreatment');\nconst { FormatterOptions } = require('./FormatterOptions');\nconst { FormatterSyntaxException } = require('./FormatterSyntaxException');\nconst { Utils } = require('./Utils');\nclass CaptureRenderer{\n    matches;\n    roots;\n    subcaptures;\n    token;\n    /**\n     * null or capture renderer\n     * @param {*} matches \n     * @param {string} token base token name\n     * @returns {null|CaptureRenderer}\n     */\n    static CreateFromGroup(matches, token='constant'){\n        function get_matche_token_info(matches, token='constant'){\n            if (!matches){\n                throw new Error('matches missing')\n            } \n            let _t = matches[0]; \n            if (matches.length<1){\n                return {value:_t, token: token};\n            }\n            const {indices} = matches;\n            if (typeof(indices) == 'undefined'){\n                console.log(\"missing [d] flag\");\n                return null;\n            }\n            let _startIndex = indices[0][0];\n            let rootgroup = {};\n            let subcaptures = {};\n            let _troot = null;\n            let _offset = 0;\n            let _info = null;\n            let chain_root = function(_troot, i){\n                subcaptures[i] = _troot;\n                rootgroup[i] = _troot;\n            }\n            let begin_root = function(idx, v, range, i){\n                _offset = idx+v.length;\n                _troot = def_info(range, v, null, i); \n                chain_root(_troot, i);\n                _info = null;\n            }\n            let info_contains = function (s, d){\n                return ((s.start<=d.start)&&(s.end>=d.end));\n            }\n            let def_info = function(range, v, parent, id){\n                return {...range, value:v,id, get index(){ return this.start + matches.index; }, parent: parent, childs:[]};\n            }\n            let lp;\n            let range;\n         \n            for(let i = 1; i < matches.length; i++){\n                lp = indices[i];\n                if (typeof(lp)=='undefined'){\n                    subcaptures[i] = {value: undefined};\n                    continue;\n                }\n                let v = matches[i];\n                range = {start:lp[0] - _startIndex,end:lp[1] - _startIndex}; // range to litteral captured string\n                let idx = _t.indexOf(v, _offset); \n                if (_troot==null){ \n                    // first root \n                    begin_root(idx,v, range, i);\n            \n                }else{\n                    // check for group\n                    if((_troot.start == range.start) && (_troot.end==range.end))\n                    {\n                        // skip the same root capture property \n                        subcaptures[i] = _troot;\n                    } else {\n                        if ((_troot.start<= range.start) && (_troot.end>=range.end)){\n                            if (_info && info_contains(_info, range)){\n                                // create and info with\n                                let _minfo = def_info(range, v, _info, i);\n                                _info = _minfo;\n                            }else{\n                                _info = def_info(range, v, _troot, i); // {...range, value:v, get index(){ return this.start - matches.index; }, parent: _troot};\n                                _troot.childs.push(_info);\n                            }\n        \n                            subcaptures[i] = _info;\n                        }else{\n                            // begin a new root\n                            begin_root(idx,v, range, i);\n                        }\n                    }\n                }\n            }\n            // register to group top group\n            if (_t.length>0){\n                lp = indices[0];\n                range = {start:lp[0] - _startIndex,end:lp[1] - _startIndex};\n                chain_root (def_info(range, matches[0], null, 0), 0); \n            }\n            return {matches, roots: rootgroup, subcaptures: subcaptures};\n        }\n        const _info = get_matche_token_info(matches, token);\n        if(!_info){\n            return null;\n        }\n        const { roots , subcaptures } = _info;\n        let _o = new CaptureRenderer;\n        _o.roots = roots;\n        _o.matches = _info.matches;\n        _o.subcaptures = subcaptures;\n        _o.token = token;\n        return _o;\n    }\n    /**\n     * \n     * @param {*} listener \n     * @param {*} captures \n     * @param {false|(rf, cap, id, listener):string} end \n     * @param {*} tokens \n     * @param {*|{debug:bool}} option \n     * @param {*|{treat:bool}} params \n     * @returns \n     */\n    render(listener, captures, end, tokens, option, outdefine, treat=true){ \n        if (!captures){\n            throw new Error('missing captures info');\n        }\n        if (!outdefine){\n            throw new Error('missing outdefine info');\n        }\n        const self = this;\n        const { matches, roots } = self;\n        const { debug, engine} = option;\n        let _input = matches[0];// .input.substring(matches.index);\n        let _begin = 0;\n        let _output = ''; \n        let _formatter = option.formatter;\n        let treat_root = function (_input, root, listener, captures, tokens, refData){\n            // treat rf value\n            let rf = root.value;\n            let rd = rf;\n            let subchilds = [{root, output:[], treat:false, sub:false}];\n            let _end = false;\n            while(subchilds.length>0){\n                let q = subchilds.shift();\n                let {id}= q.root;\n                if (q.treat){\n                    continue;\n                }\n                _end = false;\n                if (!q.sub && q.root.childs.length>0){  \n                    const childrens = q.root.childs.slice(0);\n                    q.sub = true;\n                    subchilds.unshift(q);\n                    while(childrens.length>0){\n                        let croot = childrens.pop();\n                        subchilds.unshift({parent: q, treat:false, root: croot, sub:false});\n                    }\n                }else{\n                    rf = q.sub ? q.output : q.root.value;\n                    tokens = tokens ? tokens.slice(0) : [];// default constant \n                    let tokenID = null;\n                    let cap = null;\n                   \n                    if (Array.isArray(rf)){\n                        // + | transform reference to rf \n                        const nv = q.root.value;\n                        let offset = 0;\n                        let _out = '';\n                        let c = '';\n                        // + | glue value to for rendering\n                        rf.forEach(s=>{\n                            // c = treat_constant(nv.substring(offset, s.range[0]), listener);\n                            c = nv.substring(offset, s.range[0]);//, listener);\n                            let dt = c+s.rf;\n                            offset = s.range[0]+s.range[1];\n                            _out +=dt;\n                        });\n                        // _out+= treat_constant(nv.substring(offset), listener);\n                        _out+= nv.substring(offset);//, listener);\n                        rf = _out;\n                    }\n                    let _treat_pattern = false;\n                    const _op = FormatterMatchTreatment.Init(rf);\n                    if (id in captures){\n                        cap = captures[id];\n                        if (cap.throwError){\n                            //+ | use match to handle throw error\n                            let e_obj = CaptureRenderer.CheckError(cap.throwError, rf, option); \n                            if (e_obj){\n                                throw e_obj;\n                            }\n                        } \n                        if (cap.name){\n                            Utils.StoreTokens(cap.name, tokens);\n                        }\n                        if (cap.tokenID){\n                            tokenID = cap.tokenID;\n                        }\n                        // treat pattern or other stuff \n                        if (end){\n                            // special treatment for end captures\n                            rd = rf;\n                            rf = end(rf, cap, id, listener, {tokens, engine, debug, tokenID});\n                            _end = true; \n                        } else {\n                            // treat value. cap\n                            if(_formatter){\n                                rf = _formatter.treatMarkerValue(cap, rf, _op, option, self.matches);\n\n                            }else{\n                                if (cap.transform){\n                                    rf = Utils.StringValueTransform(rf, cap.transform); \n                                }  \n                            }  \n                            if (cap.patterns?.length>0){\n                                const _bckTokens = option.tokenList.slice(0);\n                                option.tokenList = tokens.slice(0, tokens.length-1);\n                                rf = Utils.TreatPatternValue(rf, cap.patterns, \n                                    self.matches, option);\n                                _treat_pattern = true;\n\n                                option.tokenList = _bckTokens;\n                            }\n                        }\n                    } \n                    if (listener && !_treat_pattern && listener.renderToken){\n                        \n                        rd = rf;\n                        rf = _end || !rf ? rf : rf.length>0? listener.renderToken(rf, tokens, tokenID, engine, debug, cap, option) : ''; \n                    }\n                    if (q.parent){\n                        // update parent value.\n                        let s =  q.root.start - q.parent.root.start;\n                        let e =  q.root.end - q.root.start;\n                        // + | transform to range - at [start_index, length] of nv to replace\n                        if (rf.length>0){\n                            q.parent.output.push({range:[s,e], rf, rd}); \n                        }\n                    }\n                    q.treat = true;\n                }\n            }\n            refData.data = rd;\n            return rf;\n        };\n        let treat_constant = function(c, listener){\n            if (treat && (c.length>0)){\n                if (listener){\n                    c = listener.renderToken(c, ['constant.definition'], 'constant', engine, debug, null, option);\n                }\n            }\n            return c;\n        }\n        let c = '';\n        let d = '';\n        let _keys = Object.keys(roots);\n        let _Capkeys = Object.keys(captures);\n        let _root_only = ( 0 in captures) && (_Capkeys.length==1);\n        let _ref_data = {data:null, input:_input, bufferSegment:[],dataSegment:[]};\n        for(let j in roots){ \n            if ( !_root_only && ((j==0)&&(_keys.length>1))){\n                continue;\n            }\n            let rt = roots[j];\n\n            c = _input.substring(_begin, rt.start);\n            if (c.length>0){\n                d += c; \n                _ref_data.dataSegment.push(c);\n                c = treat_constant(c, listener); \n                _output += c;   \n                _ref_data.bufferSegment.push(c);\n            }         \n            c = treat_root(_input, rt,listener,captures,tokens,_ref_data);\n            _output += c;\n            _begin = rt.end;\n            d+=_ref_data.data;\n            _ref_data.dataSegment.push(_ref_data.data);\n            _ref_data.bufferSegment.push(c);\n            if (_root_only)\n                break;\n        }\n        if (_begin < _input.length){\n            let l = _input.substring(_begin);\n            d+= l;\n            _ref_data.dataSegment.push(l);\n            c = treat_constant(l, listener); \n            _output += c;\n            _ref_data.bufferSegment.push(c);\n        } \n        if (outdefine){ \n            outdefine.bufferSegment = _ref_data.bufferSegment;\n            outdefine.dataSegment = _ref_data.dataSegment;\n        }\n        return _output;\n    }\n    /**\n     * \n     * @param {*} error \n     * @param {string} rf \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static CheckError(error, rf, option){\n        let e_obj = null;\n        let message = null , match = null;\n        let _error = true;\n        if (typeof(error) == 'object'){\n            ({message, match} = error);\n        } else{\n            message = error;\n        }\n        if (match){\n            const regex = typeof(match)=='string'? new RegExp(match) : match;\n            _error = regex.test(rf);\n        }  \n        if (_error){ \n            e_obj= new FormatterSyntaxException(message, option);\n        }\n        return e_obj;\n    }\n}\nexports.CaptureRenderer = CaptureRenderer;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst LOG_NAME = '[igk-formatters]'\nclass Debug{\n    static LogLevel = 3;\n    static #Enabled = false;\n    \n    static get IsEnabled(){\n        return Debug.#Enabled;\n    }\n    static log(msg, level){\n        if (level){\n            if (level < Debug.LogLevel){\n                return;\n            }\n        }\n        if (typeof(msg)=='object'){\n            msg = JSON.stringify(msg, (k, v)=>{\n                if (k.length==0){\n                    return v;\n                }\n                if (typeof(v)=='object'){\n                    return {};//'[object]';\n                }\n                if (typeof(v)=='array'){\n                    return [];//'[array]';\n                }\n                return v;\n            });\n        }\n        let args = [];\n        if (arguments){\n            for(let i = 1; i < arguments.length; i++){\n                args.push(arguments[i]);\n            }\n        }\n        console.log(`${LOG_NAME} - ${msg}`, ...args);\n    }\n    /**\n     * enable debug globally\n     * @param {?bool} enable \n     */\n    static Enable(enable){\n        Debug.#Enabled = enable;\n    }\n}\n\nexports.Debug = Debug;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterOptions } = require(\"../FormatterOptions\");\nconst { Utils } = require(\"../Utils\");\n\nconst auto_closed = 'link|img|input';\nclass bhtml {\n    isAutoCloseTag(target, value) {\n        return auto_closed.split('|').indexOf(target) != -1;\n    }\n    /**\n     * auto close tagreturn buffer content\n     * @param {string} target - tag name \n     * @param {*} value - data baleur\n     * @param {*} marker - source marker\n     * @param {FormatterOptions} option - formatting option\n     * @returns {string}\n     */\n    autoCloseTagValue(target, value, marker, option, captures) {\n        let _value = value;\n        let _lastData = _value.dataSegment.pop();\n        let _lastBuffer = _value.bufferSegment.pop();\n        let _load_data = (_cp) => {\n            _value.dataSegment.push(_cp.data);\n            _value.bufferSegment.push(_cp.buffer);\n        };\n\n        let _captures = captures || marker.endCaptures || marker.captures; //[]; //marker.endMissingCaptures || marker.endCaptures || marker.captures;\n        let _is_closed = />\\s*$/.test(_lastData) || /^>/.test(_lastData);\n        let _close_tag = \"</\" + target + \">\";\n        let _is_auto_closed = this.isAutoCloseTag(target, value);\n        if (_is_auto_closed) {\n            _close_tag = \"/>\";\n        }\n        _load_data({ buffer: _lastBuffer, data: _lastData });\n        if (_lastData != _close_tag) { \n            let _p = Utils.CreateEndMatch(_close_tag); \n            let tp = option.treatEndCaptures(marker, _p, _captures);\n            //let cp = Utils.RenderToBuffer(_close_tag, marker, _captures, option);\n            // _load_data({ buffer: _lastBuffer, data: _lastData });\n            if (!_is_closed) {\n                if (!_is_auto_closed) {\n                    const _tdp = Utils.RenderToBuffer('>', marker, _captures, option);\n                    _load_data(_tdp);\n                }\n            }\n            if ((marker.childs.length > 0) && this._isChildBlock(marker.childs)) {\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.appendExtraOutput();\n                let refData = {};\n                const _rbuffer = option.flush(true, refData);\n                option.restoreSavedBuffer();\n                _load_data({ buffer: _rbuffer, data: refData.data });\n            } else {\n                _load_data({ buffer: tp, data: _close_tag });\n            }\n        }\n        return value.bufferSegment.join('');\n    }\n    _isChildBlock(childs) {\n        const { Formatters } = Utils.Classes;\n        return Formatters.IsChildBlock(childs);\n    }\n}\n\nexports.bhtml = bhtml;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { bhtml }  = require(\"./bhtml\")\n\nconst engines = {\n    bhtml\n}\n \nexports.engines = engines","\"use strict\";\n\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nlet Joiner = null;\n/**\n * @import (./IBufferData)\n */\n\n/**\n * class that help to manibule buffer by segment\n * @property {string[]} output \n * @property {string[]} dataOutput \n * @property {string[]} bufferSegments \n * @property {string[]} dataSegments \n */\nclass FormatterBuffer {\n    static DEBUG = false;\n    /**\n     * set the formatter buffer identification \n     */\n    id;\n    constructor() {\n        var m_output = [];\n        var m_bufferSegments = [];\n        var m_dataSegments = [];\n        var m_dataOutput = [];\n        \n        m_bufferSegments.marked = FormatterBuffer.InitMarkedSegment();\n        /*\n        arry of buffer segment\n         */\n        Object.defineProperty(this, 'bufferSegments', { get() { return m_bufferSegments; } });\n        Object.defineProperty(this, 'dataSegments', { get() { return m_dataSegments; } });\n        Object.defineProperty(this, 'output', { get() { return m_output; } });\n        Object.defineProperty(this, 'dataOutput', { get() { return m_dataOutput; } });\n        Object.defineProperty(this, 'length', { get() { return m_bufferSegments.length; } });\n\n    }\n    get isEmpty() {\n        return this.bufferSegments.length == 0;\n    }\n\n    static InitBufferMarkedSegment(bufferSegment){ \n        if (bufferSegment && !('marked' in bufferSegment)){\n            bufferSegment.marked = FormatterBuffer.InitMarkedSegment();\n        } \n    }\n\n    static CopyMarkedSegment(bufferSegment){\n        return bufferSegment.marked ? ((a)=>{\n            let marked = a.slice(0);\n            if('op' in a)\n                marked.op = JSON.parse(JSON.stringify(a.op));\n            else \n                marked.op = FormatterBuffer.InitOpMarkedSegment();\n            return marked;\n        })(bufferSegment.marked) : \n            FormatterBuffer.InitMarkedSegment(); \n    }\n\n    /**\n     * prepend value on segments\n     * @param {string|{buffer:string, data:string}} value \n     */\n    prepend(value){\n        let buffer = null;\n        let data = null;\n        if (typeof(value)=='object'){\n            ({buffer, data}= value);\n            if (!buffer || !data){\n                throw new Error('invalid data');\n            }\n        } else {\n            if (typeof(value)=='string'){\n            buffer = data = value;\n            }\n            else \n                throw new Error('not a string data'); \n        } \n        this.bufferSegments.unshift(buffer);\n        this.dataSegments.unshift(data); \n    }\n    /**\n     * get the buffer offset content\n     * @param {number} offset \n     * @param {string} join \n     * @returns {string}\n     */\n    getContent(offset, join = '') {\n        return this.bufferSegments.slice(offset).join(join || '');\n    }\n    /**\n     * get data segment offset\n     * @param {*} offset \n     * @param {*} join \n     * @returns \n     */\n    getData(offset, join = '') {\n        return this.dataSegments.slice(offset).join(join || '');\n    }\n    /**\n     * get buffer segment\n     * @var {string}\n     */\n    get buffer() {\n        return this.bufferSegments.join('');\n    }\n    /**\n     * retrieve data\n     * @var {string}\n     */\n    get data() {\n        return this.dataSegments.join('');\n    }\n    /**\n     * join the buffer segments\n     * @param {null|string} join \n     * @returns string\n     */\n    join(join) {\n\n        return this.bufferSegments.join(join || '');\n    }\n    /**\n     * join segment \n     */\n    joinSegments(join = '') {\n        const { bufferSegments, dataSegments } = this;\n        return FormatterBuffer.JoinSegments(bufferSegments, dataSegments); \n     }\n    /**\n     * copy join segment\n     * @param {*} bufferSegments \n     * @param {*} dataSegments \n     * @param {string} join \n     * @returns \n     */\n    static JoinSegments(bufferSegments, dataSegments, join = '') {\n        let ch = null;\n        let _bufferS = [];\n        let _dataS = [];\n        if (bufferSegments.marked) {\n            const q = bufferSegments.marked;\n            q.sort();\n            const _OP = q.op || {};\n            let _call = (tab, q, marked) => {\n                let c = 0;\n                let t = [];\n                const _bufferS = [];\n                const _marked = FormatterBuffer.InitMarkedSegment();\n                tab.forEach(a => {\n                    if ((q.length > 0) && (q[0] == c)) {\n                        if (t.length > 0) {\n                            _bufferS.push(t.join(join));\n                            t.length = 0;\n                        }\n                        _bufferS.push(a);\n                        q.shift();\n                        let _idx = _bufferS.length - 1;\n                        if (c in _OP) {\n                            // + | update marker optionration  \n                            Utils.UpdateSegmentMarkerOperation(_marked, _idx, _OP[c]);\n                        }\n                        _marked.push(_idx);\n                    } else {\n                        t.push(a);\n                    }\n                    c++;\n                });\n                if (t.length > 0) {\n                    _bufferS.push(t.join(join));\n                    t.length = 0;\n                }\n                if (marked) {\n                    _bufferS.marked = _marked;\n                }\n                return _bufferS;\n            };\n\n            _bufferS = _call(bufferSegments, q.slice(0), true);\n            _dataS = _call(dataSegments, q.slice(0));\n\n        } else {\n            _bufferS.push(bufferSegments.join(join));\n            _dataS.push(dataSegments.join(join));\n        }\n        return { bufferSegment: _bufferS, dataSegment: _dataS };\n    }\n    /**\n     * init marked segment\n     * @returns \n     */\n    static InitMarkedSegment(){\n        const _g = []; \n        FormatterBuffer.InitOpMarkedSegment(_g);\n        return _g;\n    }\n    static InitOpMarkedSegment(d){\n        d.op = {};\n    }\n    /**\n     * append value to buffer segment\n     * @param {string|{buffer:string, data: string, marked: boolean|{}}} v \n     */\n    appendToBuffer(v) {\n        if (typeof (v) == 'string') {\n            this.bufferSegments.push(v);\n            this.appendToData(v);\n        } else {\n            const { buffer, data, marked, dataSegments, bufferSegments } = v;\n            if (dataSegments && bufferSegments) {\n                this._joinWith({ bufferSegment: bufferSegments, dataSegment: dataSegments });\n            }\n            else //if (buffer && data)\n                {\n                this.bufferSegments.push(buffer);\n                this.appendToData(data);\n                if (marked) {\n                    if (!('marked' in this.bufferSegments)) {\n                        this.bufferSegments.marked = FormatterBuffer.InitMarkedSegment();\n                    }\n                    const _idx = this.bufferSegments.length - 1;\n                    this.bufferSegments.marked.push(_idx);\n                    if (typeof (marked) == 'object') {\n                        if (!('op' in this.bufferSegments.marked)){\n                            FormatterBuffer.InitOpMarkedSegment(this.bufferSegments.marked);\n                        }\n                        Utils.UpdateSegmentMarkerOperation( this.bufferSegments.marked, _idx, marked);\n                     \n                    }\n                }\n            }\n        }\n    }\n    /**\n     * push data segment\n     * @param {*} v \n     */\n    appendToData(v) {\n        this.dataSegments.push(v);\n    }\n    /**\n     * store to buffer\n     * @param {string|{_buffer:string, _data:{bufferSegment:[*], dataSegment:[*]}}} buffer \n     * @param {*} param1 \n     */\n    storeToBuffer(buffer, { lastDefineStates }) {\n        if (typeof (buffer) == 'string') {\n            if (lastDefineStates && (buffer == lastDefineStates.bufferSegment.join(''))) {\n                this.appendToBuffer({ buffer, data: lastDefineStates.dataSegment.join('') });\n            }\n            else {\n                // + | just store to buffer \n                this.appendToBuffer(buffer);\n            }\n        } else {\n            const { _buffer, _data } = buffer;\n            if (!_data?.bufferSegment){\n                // + | missing buffer segment\n                this.appendToBuffer(_buffer);\n                return;\n                // throw new Error('missing buffer segment');\n            }\n            let rs = _data.bufferSegment.join('');\n            if (_buffer != rs) {\n                // TODO : update list of item to join operation and trim line\n                this.appendToBuffer({ buffer:_buffer, data: '-nop-'}); // lastDefineStates.dataSegment.join('') });\n                return;\n                throw new Error('invalid buffer mismatch segments');\n            }\n            this._joinWith(_data);\n\n        }\n    }\n    static ClearSegments({dataSegment, bufferSegment}){\n        dataSegment.length = 0;\n        bufferSegment.length = 0;\n        if ('marked' in bufferSegment){ \n            bufferSegment.marked.length = 0;\n            FormatterBuffer.InitOpMarkedSegment(bufferSegment.marked);\n        }\n    }\n    /**\n     * reduce buffer segment index\n     * @param {number} count \n     * @param {*} bufferSegment \n     */\n    static ReduceBufferSegmentIndex(count, bufferSegment){\n          // + | reduce index \n          const TS = [];\n          bufferSegment.marked?.forEach(v=>{\n              const _op = bufferSegment.marked.op[v];\n              const _new_idx = v-count;\n              if (_op){\n                  delete(bufferSegment.marked.op[v]); \n                  Utils.UpdateSegmentMarkerOperation(bufferSegment.marked, _new_idx,_op);  \n              }\n              TS.push(_new_idx);  \n          }); \n          bufferSegment.marked.length = 0;\n          bufferSegment.marked.push(...TS);\n    }\n    /**\n     * join with segment\n     * @param {{bufferSegment:[*], dataSegment:[*]}} param0 \n     */\n    _joinWith({ bufferSegment, dataSegment }) {\n        const { FormatterSegmentJoin} = Utils.Classes;\n\n        let join = Joiner || (() => { Joiner = new FormatterSegmentJoin(); return Joiner })();\n        join.bufferSegment = bufferSegment;\n        join.dataSegment = dataSegment;\n        join.updateData({ bufferSegment: this.bufferSegments, dataSegment: this.dataSegments });\n    }\n    /**\n     * clear segments\n     */\n    clear() {\n        const { bufferSegments, dataSegments } = this;\n        bufferSegments.length = 0;\n        dataSegments.length = 0;\n        bufferSegments.marked = [];\n    }\n    /**\n     * clear outputs\n     */\n    clearOutput() {\n        this.output.length = 0;\n        this.dataOutput.length = 0;\n    }\n    /**\n     * clear all \n     */\n    clearAll() {\n        this.clear();\n        this.clearOutput();\n    }\n    /**\n     * trim end data\n     */\n    trimEnd() {\n        const { bufferSegments, dataSegments } = this;\n        let q = null;\n        [bufferSegments, dataSegments].forEach(segment => {\n            while (segment.length > 0) {\n                q = segment.pop();\n                q = q.trimEnd();\n                if (q.length > 0) {\n                    segment.push(q);\n                    break;\n                }\n            }\n        });\n    }\n    trimStart() {\n        const { bufferSegments, dataSegments } = this;\n        let q = null;\n        [bufferSegments, dataSegments].forEach(segment => {\n            while (segment.length > 0) {\n                q = segment.unshift();\n                q = q.trimEnd();\n                if (q.length > 0) {\n                    segment.push(q);\n                    break;\n                }\n            }\n        });\n    }\n    trim() {\n        this.trimStart();\n        this.trimEnd();\n    }\n    /**\n     * last segment value\n     * @returns {null|string}\n     */\n    lastSegment() {\n        const { bufferSegments } = this;\n        if (bufferSegments.length > 0) {\n            return bufferSegments[bufferSegments.length - 1];\n        }\n        return null;\n    }\n    lastDataSegment() {\n        const { dataSegments } = this;\n        if (dataSegments.length > 0) {\n            return dataSegments[dataSegments.length - 1];\n        }\n        return null;\n    }\n    /**\n     * retrieve last segment info\n     */\n    lastSegmentInfo(){\n        const { bufferSegments } = this;\n        if (bufferSegments.length > 0) {\n            const idx = bufferSegments.length - 1;\n            const _buffer =  bufferSegments[idx];\n            const op = FormatterBuffer.GetBufferMarkedOperation(bufferSegments, idx); \n            return new FormatterSegmentInfo(_buffer, op);\n        }\n        return null;\n    }\n    /**\n     * get buffer sement\n     * @param {*} bufferSegments \n     * @param {*} idx \n     */\n    static GetBufferMarkedOperation(bufferSegments, idx){\n        let op = null;\n        const { marked } = bufferSegments;\n        if (marked){\n            let _op  = marked.op;\n            if (idx in bufferSegments.marked){\n                let l = bufferSegments.marked[idx];\n\n                if (op && (l in _op)){\n                    op =op[l];\n                }\n            }\n        }\n        return op;\n    }\n    /**\n     * replace last segment with new value\n     * @param {*} newValue \n     */\n    replaceLastSegment(newValue) {\n        const { bufferSegments } = this;\n        bufferSegments.pop();\n        bufferSegments.push(newValue);\n    }\n\n    /**\n     * \n     * @param {{ bufferSegment:[], dataSegment:[] }} bufferData \n     * @param {*|'*'|'trimmed'|(a)=>boolean} op \n     * @returns \n     */\n    static TreatMarkedSegments(bufferData, op = '*') {\n        const { bufferSegment, dataSegment } = bufferData;\n        const q = bufferSegment.slice(0);\n        let _idx = -1;\n        switch (op) {\n            case '*': {\n                // remove all marked segments\n                while (bufferSegment.marked.length > 0) {\n                    _idx = bufferSegment.marked.shift();\n                    delete (q[_idx]);\n                    delete (dataSegment[_idx]);\n                }\n            }\n                break;\n            case 'trimmed':\n\n                Utils.TrimBufferSegment(bufferSegment, dataSegment);\n                Utils.ReorderBufferSegment(bufferSegment);\n                let elt = dataSegment.filter(o => o!== undefined);\n                dataSegment.length = 0;\n                dataSegment.push(...elt);\n                return dataSegment;\n                // const _tlist = bufferSegment.marked.slice(0);\n                // let _count = 0;\n                // let _dir = 0;\n\n\n\n                // while (_tlist.length > 0) {\n                //     _idx = _dir == 0 ? _tlist.shift() : _tlist.pop();\n                //     let _top = bufferSegment.marked.op[_idx] || null;\n                //     let _trim = _dir == 0 ? _idx == _count : false;\n                //     if (_top && _trim && _top.trimmed) {\n                //         //let _ts = q[_idx];\n                //         delete (q[_idx]);\n                //         delete (dataSegment[_idx]);\n                //         delete (bufferSegment.marked.op[_idx]);\n                //         delete (bufferSegment.marked[_count])\n                //     }\n                //     if (_dir==1){\n                //         if (!_trim){\n                //             break;\n                //         }\n                //     } else {\n                //         if (!_trim){\n                //             _dir = 1;\n                //         }\n                //     }\n                //     _count++;\n                // }\n                // const _marked = bufferSegment.marked.filter(o => o);\n                // bufferSegment.marked.length = 0;\n                // bufferSegment.marked.push(..._marked);\n                break;\n            default:\n                if (typeof (op) == 'function') {\n                    while (bufferSegment.marked.length > 0) {\n                        _idx = bufferSegment.marked.shift();\n                        s = q[_idx];\n                        if (op(s)) {\n                            delete (q[_idx]);\n                            delete (dataSegment[_idx]);\n                        }\n                    }\n\n                }\n        }\n\n        let elt = dataSegment.filter(o => o);\n        dataSegment.length = 0;\n        dataSegment.push(...elt);\n\n        bufferSegment.length = 0;\n        elt = q.filter(o => o);\n        bufferSegment.push(...elt);\n        return bufferData;\n    }\n}\n\nconst { FormatterSegmentInfo } = require(\"./FormatterSegmentInfo\");\nconst { FormatterSegmentJoin } = require(\"./FormatterSegmentJoin\");\nconst { Utils } = require(\"./Utils\");\n\nexports.FormatterBuffer = FormatterBuffer;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\nclass FormatterBufferUtils{\n\n    /**\n     * just treat formatter value\n     * @param formatter \n     * @param value \n     * @param marker \n     * @param option \n     * @return {{buffer:string, data:string}}\n     */\n    static TreatValue(formatter, value, marker, option){\n        option.saveBuffer();\n        option.appendToBuffer(value, marker);\n        let _value = option.buffer;\n        let _data = option.data;\n        option.restoreSavedBuffer();\n\n        return {buffer:_value, data:_data};\n    }\n}\n\nexports.FormatterBufferUtils = FormatterBufferUtils;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\nclass FormatterCloseParentInfo{\n    /**\n     * value used to close \n     * @var {string}\n     */\n    value;\n    /**\n     * extra type to attach to parent\n     * @var {?string}\n     */\n    type;\n\n    /**\n     * define name of this close parent info\n     * @var {?string}\n     */\n    name;\n}\n\nexports.FormatterCloseParentInfo = FormatterCloseParentInfo;","\"use strict\";\n\nconst { FormatterBuffer } = require(\"./FormatterBuffer\");\n\nObject.defineProperty(exports, \"__ESModule\", { value: true });\n\nclass FormatterDebugger {\n    constructor(all) {\n        const q = this;\n        this.feature = (name) => {\n            if (all) {\n                return true;\n            }\n            if (name in q) {\n                return q[name];\n            }\n            return false;\n        }\n    }\n    static DebugAll() {\n        return DEBUG_ALL;\n    }\n    static Load(data) {\n        let c = new FormatterDebugger;\n        let top_keys = {};\n        Object.keys(data).forEach((i) => {\n            let r = data[i];\n            let tp = ((i)=>{i = i.split('.'); i.pop(); return i.join('.'); })(i);\n            if (tp.length>0){\n                top_keys[tp] = 1;\n            }\n\n            Object.defineProperty(c, i, {\n                get: function () {\n                    if (typeof (r) == \"function\") {\n                        return r();\n                    }\n                    return r;\n                }\n            });\n        });\n        for(let i in top_keys){\n            if (i in c )\n                continue;\n            Object.defineProperty(c, i, { value: true}); \n        }\n        return c;\n    }\n\n}\n\nconst DEBUG_ALL = new FormatterDebugger(true);\n\n\nexports.FormatterDebugger = FormatterDebugger;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { engines }  = require(\"../lib/EndMissingEngine/engines\")\nconst { bhtml } = engines;\nconst ENGINES = {\n    'source.bhtml': bhtml\n}\nconst REF = {};\nclass FormatterEndMissingEngine{\n    static Get(scopeName){\n        if (!(scopeName in REF)){\n            const  d  = ENGINES[scopeName]\n            REF[scopeName] = new d();\n        }\n        return REF[scopeName];\n    }\n}\n\nexports.FormatterEndMissingEngine = FormatterEndMissingEngine;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass FormatterEndMissingExpression{\n    #expression;\n    #captures;\n\n    constructor(expression,captures){\n        this.#expression = expression;\n        this.#captures = captures;\n    }\n    get expression(){\n        return this.#expression;\n    }\n    get captures(){\n        return this.#captures;\n    }\n    /**\n     * \n     * @param {*} group \n     */\n    load(group, transform, engine, value, marker, option, captures){\n        let _e = this.expression;\n        let _ret = null;\n        let _p = transform(new RegExp(_e), group); \n        let _captures = captures ||  this.captures;\n        let _args = [engine, value, marker, option, _captures];\n        let _cp = (new Function('engine', \"return \"+_p)).apply(null, _args);\n        if (Array.isArray(_cp)){\n            _p = _cp.shift();\n            _args.shift();\n            _args.unshift(..._cp);\n            _args.unshift(engine);\n            _ret = _p.call(..._args);\n            \n        }else{\n            _args = [engine, value, marker, option, captures];\n            let _fc = new Function('engine','value', 'marker', 'option', 'return (()=>'+_p+')();');\n            _ret = _fc.call(null, _args);\n        }\n        return _ret;\n    }\n}\nexports.FormatterEndMissingExpression = FormatterEndMissingExpression;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst Errors = {\n     101: 'not in capture.' ,\n     102: 'not define.' ,\n     103: 'invalid syntax.' ,\n};\nexports.FormatterErrors = Errors;","\"use strict\";\nObject.defineProperty(exports, '__ESModule', { value: true });\n\nconst { Debug } = require('./Debug');\nconst { RegexUtils } = require('./RegexUtils')\n/**\n * use to operate on line matching \n */\nclass FormatterLineMatcher {\n    /**\n     * start line flag\n     * @var {?boolean} \n     */\n    #m_startLine;\n\n    /**\n     * flag: middle pos when ending - must consider hown element\n     */\n    #m_middelPos;\n    /**\n     * source line\n     * @type {?string}\n     */\n    #m_soureLine;\n    /**\n     * current line\n     * @type {?string}\n     */\n    #m_line;\n    /**\n     * current offset \n    * @type {?number}\n     */\n    #m_offset;\n    /**\n     * expected next position\n     * @type {?number}\n     */\n    #m_nextPosition;\n\n\n    /**\n     * \n     */\n    constructor() {\n        const MATCHER_STATES = [];\n\n        this.save = function (new_value) {\n            const { sourceLine, line, offset, position } = this;\n            MATCHER_STATES.push({ sourceLine, line, offset, position });\n            if (typeof (new_value) == 'string') {\n                this.sourceLine = new_value;\n            }\n        }\n        this.restore = () => {\n            const def = MATCHER_STATES.pop();\n            if (def) {\n                const { sourceLine, line, offset, position } = def;\n                this.sourceLine = sourceLine;\n                this.#m_line = line;\n                this.#m_offset = offset;\n                this.#m_nextPosition = position;\n            }\n        }\n    }\n\n    /**\n     * get the start line flag\n     */\n    get startLine() {\n        return this.#m_startLine;\n    }\n    /**\n     * set the start line flag\n     */\n    set startLine(v) {\n        this.#m_startLine = v;\n    }\n\n    /**\n     * define source line\n     * @param {?string} v \n     */\n    set sourceLine(v) {\n        if (v == undefined) throw new Error('value not allowed');\n        // + | setup source file\n        this.#m_soureLine = v;\n        this.#m_line = v;\n        this.#m_offset = 0;\n        this.#m_nextPosition = 0;\n    }\n    get sourceLine() {\n        return this.#m_soureLine;\n    }\n    get line() {\n        return this.#m_line;\n    }\n    set line(v) {\n        this.#m_line = v;\n    }\n    get subLine() {\n        return this.#m_soureLine.substring(this.#m_offset);\n    }\n    get nextLine() {\n        return this.#m_soureLine.substring(this.#m_nextPosition);\n    }\n    /**\n     * get current offset\n     */\n    get offset() {\n        return this.#m_offset;\n    }\n    get position() {\n        return this.#m_nextPosition;\n    }\n    set offset(v) {\n        this.#m_offset = v;\n    }\n    /**\n     * chang the position\n     */\n    set position(v) {\n        const _np = this.#m_nextPosition;\n        if (v != _np) {\n            if (v < _np) {\n                throw new Error('next position not allowed ' + v + ' < ' + _np);\n            }\n            this.#m_offset = this.#m_nextPosition;\n            this.#m_nextPosition = v;\n        }\n    }\n    reset() {\n        this.#m_offset = 0;\n        this.#m_nextPosition = 0;\n    }\n    /**\n  * set position and offset \n  * @param {number} position \n  * @param {undefined|number} offset \n  */\n    setPosition(position, offset) {\n        if (offset) {\n            if (offset > position) {\n                throw new Error(\"offset must not be greater than position\");\n            }\n        } else {\n            offset = position;\n        }\n        this.#m_offset = offset;\n        this.#m_nextPosition = position;\n    }\n    /**\n     * and and return regex result\n     * @param {*} regex \n     * @returns {null|IRegexResult} regex result\n     */\n    check(regex, option) {\n        const _has_movement = RegexUtils.HasBackyardMovementCapture(regex);\n        const _has_startLine = RegexUtils.CheckRequestStartLine(regex);\n        const { subLine, nextLine, sourceLine, position, startLine, offset } = this;\n        const { debug } = option || { debug: false };\n        let _p = null;\n        if (_has_startLine) {\n            if (startLine && (position == 0)) {\n                _p = regex.exec(sourceLine);\n                if (_p) {\n                    _p.move = false;\n                    return _p;\n                }\n            }\n            if (!startLine) {\n                debug && Debug.log('--::: skip: not on start line :::--')\n                return _p;\n            }\n        }\n        if (_has_movement) {\n            _p = regex.exec(subLine);\n            if (_p) {\n                _p.move = true;\n                _p.index += offset;\n                let _idx = _p.index;\n                let cp = null;\n                let _mark = false;\n                while (_idx < position) {\n                    _mark = true;\n                    _idx++;\n                    let new_s = sourceLine.substring(_idx);\n                    cp = regex.exec(new_s);\n                    if (cp) {\n                        _idx += cp.index;\n                        cp.index = _idx;\n                        cp.input = sourceLine;\n                        cp.move = true;\n                    } else {\n                        break;\n                    }\n                }\n                if (_mark) {\n                    if (!cp) {\n                        _p = null;\n                    } else {\n                        _p = cp;\n                    }\n                }\n                if (_p) {\n                    _p.index += -position;\n                }\n            }\n        } else if (!_p) {\n            _p = regex.exec(nextLine);\n        }\n        if (_p) {\n            _p.index += position;\n            _p.input = sourceLine;\n            if (_p.index < position) {\n                _p = null;\n            }\n        }\n        return _p;\n    }\n}\n\nexports.FormatterLineMatcher = FormatterLineMatcher;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * formatter line segment\n */\nclass FormatterLineSegment extends Array {\n    constructor(){\n        super();\n        let m_states = [];\n\n        this.save = ()=>{\n            m_states.push(this.slice(0));\n            this.clear();\n        };\n        this.restore=()=>{\n            let mps = m_states.pop();\n            if (mps){\n                this.clear();\n                super.push(...mps);\n            }\n        };\n    }\n    store(segment, option) {\n        if (!option.isCapturing) {\n            super.push(segment);\n        }\n    }\n    push(segment, option) {\n        if (!option) {\n            throw new Error('require option');\n        }\n        if (!option.isCapturing) {\n            super.push(segment);\n        }\n    }\n    unshift(segment, option) {\n        if (!option) {\n            throw new Error('require option');\n        }\n        if (!option.isCapturing) {\n            super.unshift(segment);\n        }\n    }\n    clear() {\n        this.length = 0;\n    }\n}\n\n\nexports.FormatterLineSegment = FormatterLineSegment;\n","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass FormatterLintError{\n    message;\n    code;\n    constructor(){\n        \n    }\n}\n\nexports.FormatterLintError = FormatterLintError;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\nconst { Debug } = require(\"./Debug\");\nconst { Patterns } = require(\"./Patterns\");\nconst { Utils } = require(\"./Utils\");\n\n/**\n * @type IFormatterListener\n * @method renderToken - render token\n * @method store - store to buffer\n * @method onEndHandler - marker end with content value\n */\n\n\n/**\n * formatter listener\n * @extends IFormatterListener\n */\nclass FormatterListener {  \n\n    constructor() {\n        var m_lastToken;\n        /**\n         * get last evaluated marker\n         */\n        Object.defineProperty(this, 'lastMarker', { get() { return m_lastToken } }); \n        this.setLastMarker = function (token) {\n            m_lastToken = token;\n        };\n    }\n    /**\n     * append new line to buffer\n     * @param {string} line_feed \n     * @param {FormatterBuffer} buffer \n     */\n    appendLine(line_feed, buffer, option){\n        option.saveBuffer();\n        option.appendExtraOutput();\n        const _cbuffer = option.flush(true);\n        option.restoreSavedBuffer();\n        buffer.appendToBuffer(_cbuffer);\n    }\n    /**\n     * call to add a new block\n     * @var {{formatterBuffer: FormatterBuffer, tabStop:string, depth:number}} param\n     */\n    startNewBlock({formatterBuffer, tabStop, depth}){ \n        // override to mark start new block\n    } \n    /**\n     * override en output\n     * @param {*} param0 \n     */\n    endOutput({lineFeed}){\n\n    }\n    /**\n     * override end content\n     */\n    endContent(){\n\n    }\n    /**\n     * treat current buffer and store it to option \n     * buffer to ouput . \n     */\n    store({buffer, data, output, dataOutput, depth, tabStop, startBlock}) { \n        let s = buffer;\n        let d = depth; \n        if (s.length > 0){\n            if (startBlock){\n                output.unshift('');\n                dataOutput.unshift('');\n            }\n            let _tab = d > 0 ? tabStop.repeat(d) : '';\n            output.push(_tab + s);\n            dataOutput.push(_tab+data);\n        } \n    }\n    /**\n     * use this to join everything that as represent in buffer with the lineFeed data\n     * @param {bool} clear \n     * @param {{output:string[], lineFeed:string}} param1 \n     * @returns {string}\n     */\n    output({output, lineFeed}) { \n        let _s = output.join(lineFeed); \n        return _s;\n    }  \n    /**\n     * transform value depending on token definition \n     * @param {string} value \n     * @param {null|string|string[]} tokens \n     * @param {null|string} tokenID \n     * @param {null|FormatterEngine} engine \n     * @param {?bool} debug \n     * @param {*} marker parent marker  \n     * @returns {string}\n     */\n    renderToken(value, tokens, tokenID, engine, debug, marker, option){\n        const { FormatterToken } = Utils.Classes;\n        const rt = new FormatterToken();\n        rt.tokens = tokens;\n        rt.tokenID = tokenID;\n        rt.value =  value;\n        option.lastToken = rt;\n        debug?.feature(\"render-token\") && Debug.log(\"render token\", JSON.parse(JSON.stringify(rt)));\n        if (engine){\n            return engine.renderToken(value, tokens, tokenID, marker);\n        } \n        return value;\n    } \n}\n\nexports.FormatterListener = FormatterListener;","\"use strict\"; \nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { Debug } = require('./Debug');\nconst { FormatterBuffer } = require('./FormatterBuffer');\n\n/**\n * formatter marker info setting\n * @property {number} currentMode\n */\nclass FormatterMarkerInfo{\n    /**\n     * buffering buffer start\n     */\n    start = false;\n    /**\n     * backup state\n     */\n    state;\n    /**\n     * flag: indicate newly start block\n     * @var {bool}\n     */\n    startBlock;\n\n    oldBlockStart;\n    blockStarted;\n    useEntry = true;\n    \n   \n\n    /**\n     * use to capture entry \n     * @var {?string}\n     */\n    captureEntry;\n\n    /**\n     * store context join with\n     */\n    joinWith;\n\n    /**\n     * data stored\n     */\n    prependExtra;\n\n    storePrependExtra(data){\n        if (!this.prependExtra && data){\n            if (!Array.isArray(this.prependExtra)){\n                this.prependExtra = [this.prependExtra]\n            }\n            this.prependExtra.push(data);\n            return;\n        }\n        this.prependExtra = data;\n    }\n\n    toString(){\n        return 'FormatterMarkerInfo#'+this.marker.toString();\n    }\n\n    /**\n     * update marker info\n     * @param {*} data \n     */\n    updateDataSegments(data){\n        const {bufferSegment, dataSegment} = data;\n        const _data = this.data;\n        const ic = _data.bufferSegment.length;\n        _data.bufferSegment.push(...bufferSegment);\n        _data.dataSegment.push(...dataSegment);\n\n        const _marked = bufferSegment.marked?.slice(0);\n        if (_marked){\n            for(let c = 0; c <  _marked.length; c++){\n                let _new_id =    _marked[c] + ic;\n                _marked[c] += ic;\n                if (c in bufferSegment.marked.op){\n                    let _op = bufferSegment.marked.op[c];\n                    delete(bufferSegment.marked.op[c]); \n                    Utils.UpdateSegmentMarkerOperation(bufferSegment.marked, _new_id, _op);  \n                }\n            }\n            if ( !_data.bufferSegment.marked )\n                _data.bufferSegment.marked  = [];\n            _data.bufferSegment.marked.push( ..._marked);\n            _data.bufferSegment.marked.op = { ... _data.bufferSegment.marked.op, ... bufferSegment.marked.op };\n        }\n\n    }\n    /**\n     * create a formatter marker info \n     * @param {*} formatter \n     * @param {*} _marker \n     * @param {*} entry \n     * @param {*} _endRegex \n     * @param {*} option \n     */\n    constructor(formatter, _marker, entry, _endRegex, option){  \n        this.startBlock = _marker.isBlock ? 1 : 0;\n        this.oldBlockStart = _marker.isBlock;\n        this.blockStarted = false;\n        let m_currentMode = _marker.mode;\n        \n\n        Object.defineProperty(this, 'formatter', {get(){return formatter;}}); \n        Object.defineProperty(this, 'marker', {get(){return _marker;}});\n        Object.defineProperty(this, 'endRegex', {get(){return _endRegex;}});\n        Object.defineProperty(this, 'currentMode', {get(){return m_currentMode;},\n        set(v){\n            if (v==2){\n                if (this.marker.name == 'meta.function.sub-definition.vbmacros'){\n                    console.log(\"changin mode ....\");\n                }\n            }\n            m_currentMode = v;\n        }});\n\n\n\n        \n    \n        (function (entry, _marker_info) {\n            var _content = entry;\n            var _isNew  = true;\n            // + | static storage - presentation value \n            var _data = null;\n\n            //_marker_info.updateStore\n\n            if (option?.lastDefineStates?.bufferSegment.join('')==entry){\n                const { dataSegment, bufferSegment } = option.lastDefineStates;\n                _data = { dataSegment: dataSegment.slice(0), bufferSegment : bufferSegment.slice(0) };\n                // + | copy marked segment  \n                _data.bufferSegment.marked = FormatterBuffer.CopyMarkedSegment(bufferSegment);\n            }else{\n                let e = [];\n                let d = [];\n                if (entry.length>0){\n                    e.push(entry);\n                    d.push(entry);\n                }\n                _data = {dataSegment: e, bufferSegment:d}\n            }\n            if (!('marked' in _data.bufferSegment))\n                 _data.bufferSegment.marked = FormatterBuffer.InitMarkedSegment();\n\n\n\n            _marker_info.set = function(){\n                _isNew = false;\n            };\n            /**\n             * get stored data segment\n             */\n            Object.defineProperty(_marker_info, 'data', {get(){\n                return _data;\n            }});\n            /**\n             * is new marker info \n             */\n            Object.defineProperty(_marker_info, 'isNew', {get(){\n                return _isNew;\n            }});\n            Object.defineProperty(_marker_info, 'entryBuffer', {\n                get() {\n                    return entry;\n                }\n            });\n            Object.defineProperty(_marker_info, 'content', {\n                get() {\n                    return _content;\n                },\n                set(v) {\n                    \n                    if (v != _content) {\n                        option.debug?.feature(\"store-content\") && (()=>{\n                            Debug.log(\"---::store content ::---\\n[value::'\" + v+\"']\"); \n                            console.log({newValue: v, oldValue:_content});\n                        })();\n                        _content = v;\n                    } \n                }\n            });\n            Object.defineProperty(_marker_info, 'childs', {\n                get() {\n                    return _marker_info.marker.childs;\n                }\n            });\n        })(entry, this); \n    } \n    /**\n     * save state \n     * @param {*} option mode definition \n     * @param {number} mode formatting mode\n     */\n    saveState(option, mode){\n        // + | save buffer state \n        this.state = {\n            buffer: option.formatterBuffer.buffer, // store old buffer\n            output: option.output,\n            formatterBuffer: option.formatterBuffer,\n            get currentBufferContent(){\n                return this.formatterBuffer.buffer;\n            },\n            get mode(){\n                return mode;\n            }\n        }; \n    }\n\n}\n\nexports.FormatterMarkerInfo = FormatterMarkerInfo;","\"use strict\";\nObject.defineProperty(exports, 'enModule', { value: true });\n\n\nclass FormatterMatchTreatment{\n    static Init(source){\n        const _op = [];\n        let _data = undefined;\n        _op.treatment = new FormatterMatchTreatment;\n        Object.defineProperty(_op, 'treated', { get(){\n            return (_op.indexOf('replaceWith')!=-1);\n        } });\n        Object.defineProperty(_op, 'source', { get(){\n            return source;\n        } });\n        Object.defineProperty(_op, 'data', { get(){\n            return _data;\n        }, set(v) {\n            _data = v;\n        } });\n        return _op;\n    }\n}\n\nexports.FormatterMatchTreatment = FormatterMatchTreatment;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\nconst { Utils } = require(\"./Utils\");\nconst { Debug } = require(\"./Debug\");\nconst { FormatterBuffer } = require(\"./FormatterBuffer\");\nconst { FormatterLineMatcher } = require(\"./FormatterLineMatcher\");\nconst { FormatterLineSegment } = require(\"./FormatterLineSegment\");\nconst { FormatterListener } = require(\"./FormatterListener\");\n\n/**\n * @typedef IFormatSourceOption\n * @type\n * @property {?string} name\n * @property {?string} constantName\n * @property {?number} depth\n */\n\n/**\n * @typedef IFormatterOptions\n * @funcion newBuffer \n * @property {string} line current line definition\n * @property { boolean } isEOL detect that is end off line; \n */\n\n/**\n * class used to expose formatter option \n * @type IFormatterOptions\n * @property {FormatterLineMatcher} lineMatcher \n * @function joinBuffer\n */\nclass FormatterOptions {\n    // private \n    #m_lineSegments;\n\n    // sourceLine;\n    // line;\n\n    /**\n     * position on operate line \n     */\n    // pos = 0;\n    /**\n     * current line cursor\n     */\n    lineCount = 0;\n\n    /**\n     * line offset\n     */\n    lineOffset = 0;\n    \n    continue = false;\n    lineJoin = false;\n    skipTreatEnd = false;\n    skipTreatWhile = false;\n    markerDepth = 0; // store handleMarker stack\n    loopInfo;\n\n    /**\n     * get or set last marker depth\n     * @var {*}\n     */\n    lastMarker;\n\n    /**\n     * format source option\n     * @var {undefined|IFormatSourceOption}\n     */\n    sourceOption;\n    /**\n     * join with flag string\n     * @var {?string}\n     */\n    joinWith;\n    /**\n     * flag to call on end of file\n     */\n    EOF = false;\n    /**\n     * flag to set on en of line\n     */\n    EOL = false;\n\n    TOEND = false;\n    /**\n     * store global output result \n     */\n    // output = [];   // output result global output result \n    tokenList = [];// store entry token list\n    /**\n     * line feed flag in order to store on next root operation\n     * @var {?boolean} \n     */\n    lineFeedFlag = false;\n    state = ''; // current state mode \n    range = {\n        start: 0, // start position\n        end: 0    // number end position range\n    };\n    /**\n     * get or set the current stream option\n     */\n    stream;\n    /**\n     * store chain of new created OldBuffers\n     */\n    newOldBuffers = [];\n\n    /**\n     * activate the hold buffer list \n     */\n    holdBufferState = false;\n    /**\n     * flag for glue value : used to skip entry data for match.\n     */\n    glueValue = null;\n\n    /**\n     * flag formatter skip start empty line flag\n     */\n    skipEmptyMatchValue = false; \n\n    /**\n     * flag to skip update start line logic\n     */\n    skipUpdateStartLine = false;\n\n    /**\n     * on stream buffer handler skip marker flag\n     */\n    skipMarkerFlag = false;\n\n    /**\n     * next mode\n     * @var {number}\n     */\n    nextMode = 1;\n\n    /**\n     * last rendered token \n     */\n    lastToken;\n\n    /**\n     * last segment\n     */\n    lastSegment;\n\n    /**\n     * flag to store last define\n     */\n    lastDefineStates;\n\n    /**\n     * flag: use to indicate the line is starting\n     * @var {boolean}\n     */\n    startLine; \n\n    /**\n     * flag : skip end of line\n     */\n    skipEndOfLine;\n\n    /**\n     * flag: start line reading \n     */\n    get startReading(){\n        return this.formatter?.startReading;\n    }\n\n    /**\n     * flag: newly block start\n     * @var {null|undefined|bolean}\n     */\n    startBlock;\n\n    /**\n     * transform marker style\n     * @var {*}\n     */\n    matchTransformFlag; \n \n    /**\n     * get or set last marker Pattern - to skip for next get global pattern loop. skip only one\n     */\n    lastEmptyMarkerPattern;\n\n    /**\n     * flag: value used to glue with next trimmed line;\n     * @var {undefined|string}\n     */\n    nextGlueValue; \n\n \n    get lineSegments(){\n        return this.#m_lineSegments;\n    }\n\n    /**\n     * \n     * @param {*} marker \n     * @returns \n     */\n    pushConditionalContainer(marker){\n        const { conditionalContainer } = this;\n        if (marker.isBlockConditionalContainer){\n            conditionalContainer.push({marker, start:true});\n            return true;\n        }\n        return false;\n    }\n    popConditionalContainer(){\n        const { conditionalContainer } = this;\n        return conditionalContainer.pop();\n    }\n\n    /**\n     * @var {boolean}\n     */\n    isConditionalBlockStart(){\n        const { conditionalContainer } =  this;\n        if (conditionalContainer.length>0){\n            let i = conditionalContainer[conditionalContainer.length-1];\n            return i.start;\n        }\n        return false;\n    }\n\n    /**\n     * top conditional block container\n     * @returns \n     */\n    topConditionalBlockContainer(){\n        const { conditionalContainer } =  this;\n        if (conditionalContainer.length>0){\n            return conditionalContainer[conditionalContainer.length-1];\n        }  \n        return null;\n    }\n \n    /**\n     * .ctr\n     * @param {*} _formatter \n     * @param {*} _formatterBuffer \n     * @param {*} _listener \n     * @param {*} m_constants_def \n     * @param {*} _rg \n     */\n    constructor(_formatter, _formatterBuffer, _listener, m_constants_def, _rg) {\n        const { debug } = _formatter;\n        const c_lineMatcher = new FormatterLineMatcher(this);\n        const c_conditionalContainer = [];\n        // initialize conditional field\n        let { lineFeed, tabStop } = {lineFeed:_rg?.lineFeed || _formatter.info.lineFeed || \"\\n\", \n            tabStop: _rg?.tabStop || _formatter.info.tabStop || \"\\t\"};\n        this.#m_lineSegments = new FormatterLineSegment;\n        let m_isCapturing = false;\n\n        \n        let m_depth = _rg?.depth || 0;\n        let _blockStarted = false;\n        const _bufferState = [];\n        const _markerInfo = [];\n        const _states = [];\n        const { CaptureRenderer, FormatterBuffer, Debug } = Utils.Classes;\n        let m_appendToBufferListener = null;\n        let _outputBufferInfo = {\n            line: 0,\n            start: 0,\n            end: 0,\n            /**\n             * update number information\n             * @param {number} lineCount number info\n             */\n            updateLine(lineCount) {\n                this.line = lineCount;\n                this.start = this.end = 0;\n            },\n            /**\n             * update range\n             * @param {number} start \n             * @param {undefined|number} end \n             */\n            updateRange(start, end) {\n                this.start = start;\n                this.end = typeof (end) == 'undefined' ? start : end;\n            }\n        }\n        const option = this;\n        let m_saveCount = 0;\n        let m_formatterListener = null;\n        // inject setting property\n        for (let i in _rg) {\n            if (['depth', 'line', 'tabStop', 'lineFeed'].indexOf(i) != -1) {\n                continue;\n            }\n            Object.defineProperty(this, i, {\n                get() {\n                    return _rg[i];\n                }\n            });\n        }\n        this.resetRange = function () {\n            this.storeRange(0, 0);\n        }\n        this.storeRange = function (start, end) {\n            this.range.start = start;\n            this.range.end = typeof (end) == 'undefined' ? start : end;\n        }\n        this.isRootFormatterBuffer = function (formatter_buffer) {\n            return formatter_buffer === _formatterBuffer;\n        }\n        Object.defineProperty(option, 'isCurrentFormatterBufferIsRootBuffer', {\n            get() {\n                return this.isRootFormatterBuffer(this.formatterBuffer);\n            }\n        });\n        \n\n        Object.defineProperty(option, 'conditionalContainer', {get(){return c_conditionalContainer; }});\n        Object.defineProperty(option, 'lineMatcher', {get(){return c_lineMatcher; }});\n        Object.defineProperty(option, 'sourceLine', {get(){return c_lineMatcher.sourceLine; }});\n        Object.defineProperty(option, 'line', {get(){\n            return c_lineMatcher.line; \n        }, set(v){ c_lineMatcher.line = v;}});        \n        Object.defineProperty(option, '_saveCount', { get: function () { return m_saveCount; } })\n        Object.defineProperty(option, 'streamBuffer', { get: function () { return this.stream?.buffer; } })\n        Object.defineProperty(option, 'listener', { get: function () { return _listener; } })\n        Object.defineProperty(option, 'formatter', { get: function () { return _formatter; } })\n        Object.defineProperty(option, 'formatterBuffer', { get: function () { return _formatterBuffer; } })\n        Object.defineProperty(option, 'blockStarted', {\n            get: function () { return _blockStarted; }, set(v) {\n                _blockStarted = v;\n            }\n        });\n        Object.defineProperty(option, 'isEOL', { \n            get(){\n                return this.pos >= this.length;\n            }\n        } );\n        Object.defineProperty(option, 'isCapturing', {\n            get: function () { return m_isCapturing; }\n        });\n\n        Object.defineProperty(option, 'buffer', { get: function () { return _formatterBuffer.buffer; } })\n        Object.defineProperty(option, 'data', { get: function () { return _formatterBuffer.data; } })\n        Object.defineProperty(option, 'outputBufferInfo', { get() { return _outputBufferInfo; } })\n        Object.defineProperty(option, 'tokenChains', {\n            get() {\n                const _tokens = _formatter.getTokens();\n                let r = _tokens;\n                if (this.tokenList?.length > 0) {\n                    r = this.tokenList.concat(_tokens);\n                }\n                return r;\n            }\n        });\n        Object.defineProperty(option, 'length', { get: function () { return this.line.length; } })\n        Object.defineProperty(option, 'debug', { get: function () { return debug; } })\n        Object.defineProperty(option, 'markerInfo', { get: function () { return _markerInfo; } })\n        Object.defineProperty(option, 'constants', { get: function () { return m_constants_def; } })\n        Object.defineProperty(option, 'pos', {\n            get: function () { \n                return c_lineMatcher.position; \n            }, \n            set(v){\n                c_lineMatcher.position = v;\n            }\n        });\n        /**\n         * debug offset \n         */\n        Object.defineProperty(option, 'offset', {\n            get: function () { \n                return c_lineMatcher.offset; \n            }\n        });\n        /**\n         * append to buffer listener callback\n         * @var {null|(value:string)} \n         */\n        Object.defineProperty(option, 'appendToBufferListener', {\n            get: function () { return m_appendToBufferListener; }, set(v) {\n                m_appendToBufferListener = v;\n            }\n        });\n        Object.defineProperty(option, 'output', {\n            get: function () { return _formatterBuffer.output; },\n        });\n        Object.defineProperty(option, 'dataOutput', {\n            get: function () { return _formatterBuffer.dataOutput; },\n        });\n        Object.defineProperty(option, 'depth', {\n            get() { return m_depth; },\n            /**\n             * set the depth\n             * @param {number} v depth \n             */\n            set(v) {\n                m_depth = v;\n            }\n        });\n        option.getLineRangeContent = function () {\n            const q = this;\n            return q.line.substring(q.range.start, q.range.end);\n        };\n        option.unshiftMarker = (o) => { \n            _markerInfo.unshift(o);\n        };\n        option.shiftMarker = () => { \n            return _markerInfo.shift();\n        };\n        option.empty = empty;\n\n        Object.defineProperty(option, 'lineFeed', {get(){\n            return lineFeed;\n        }});\n\n        function empty(l) {\n            return (!l && l.length == 0)\n        }\n        function is_emptyObj(q) {\n            return Object.keys(q).length == 0\n        }\n        /**\n         * push object state\n         */\n        function pushState() {\n            let _keys = Object.keys(option);\n            let _state = {};\n            _keys.forEach(i => {\n                let t = typeof (option[i]);\n                if (/function|object/.test(t))\n                    return;\n                let _i = Object.getOwnPropertyDescriptor(option, i);\n                if (!_i || (_i.get && _i.set)) {\n                    _state[i] = option[i];\n                }\n            })\n            _states.unshift({ ..._state });\n        }\n        /**\n         * pop object state\n         */\n        function popState() {\n            let s = _states.shift();\n            if (s) {\n                for (let i in s) {\n                    option[i] = s[i];\n                }\n            }\n        }\n\n        option.pushState = pushState;\n        option.popState = popState;\n        /**\n         * treat how to update the current buffer before add it to listener\n         * @param {string} s \n         * @param {*} value \n         * @param {*} _marker \n         * @returns new buffer value\n         */\n        option.updateBufferValue = function (s, value, _marker) {\n            // allow listener to treate buffer value\n            // + | tranform before update \n            if (empty(value)) {\n                return s;\n            }\n            const { listener } = this;\n            if (listener?.joinBuffer) {\n                return listener.joinBuffer(s, value, _marker);\n            }\n            return this.joinBuffer(s, value);\n        };\n\n        /**\n         * \n         * @param {*} buffer \n         * @param {*} value \n         * @returns \n         */\n        option.joinBuffer = function (buffer, value) {\n            const { lineJoin, noSpaceJoin } = this;\n            let s = buffer;\n            if (lineJoin) {\n                let join = ' ';\n                if (noSpaceJoin) {\n                    join = '';\n                }\n                s = [s.trimEnd(), value.trimStart()].join(join);\n                this.lineJoin = false;\n            } else {\n                s += value;\n            }\n            return s;\n        }\n        function _shiftMarkerInfo(marker, tokenChains) {\n            if (_formatter.isSpecialMarker(marker)) {\n                if ((typeof (marker.shiftIdConstant) == 'function') && marker.shiftIdConstant())\n                    tokenChains.shift();\n            }\n        }\n        function getTokenID(marker) {\n            while (marker) {\n                if (marker.tokenID) {\n                    return marker.tokenID;\n                }\n                if (marker.fromGroup) {\n                    if (marker.fromGroup.tokenID) {\n                        return marker.fromGroup.tokenID;\n                    }\n                }\n\n                marker = marker.parent;\n            }\n            return null;\n        }\n     \n        /**\n         * append to buffer\n         * @param {string|{buffer:string, data:string}} value \n         * @param {PatternMatchInfo} _marker \n         * @param {?boolean} treat render token with listener  \n         * @param {*} _marker \n         */\n        option.appendToBuffer = function (value, _marker, treat = true, raise=true) {\n            \n            if (!value){\n                // buffer is undefined or null\n                return;\n            }\n            \n            const { debug, formatterBuffer } = this;\n            debug?.feature('append-to-buffer') && (()=>{\n                Debug.log(\"[append to buffer] - \");\n                console.log(value);\n            });\n            let _buffer = value;\n            let _storeBuffer = (value, data, _marker, treat)=>{\n                let _buffer = value;        \n                let _data = data;        \n                if (m_appendToBufferListener) {\n                    value = m_appendToBufferListener(value, _marker, treat, this);\n                }\n                else {\n                    if (treat){\n                        _buffer = this.treatValueBeforeStoreToBuffer(_marker, _buffer);\n                    } \n                    const marked = _marker.markedInfo();\n                    formatterBuffer.appendToBuffer({\n                        buffer: _buffer, data: _data, marked});\n                }\n            };\n            let _def_value = null;\n\n            if (typeof(value) == 'object' ){\n                // passing object \n                // encapsulate buffer but not data\n                _storeBuffer(value.buffer, value.data, _marker, false); \n                _buffer = option.buffer;\n                _def_value = {source: value.data, value: value.buffer};\n            }\n            else if (value.length > 0) {\n                if (m_appendToBufferListener) {\n                    value = m_appendToBufferListener(value, _marker, treat, this);\n                }\n                else {\n                    if (treat){\n                        _buffer = this.treatValueBeforeStoreToBuffer(_marker, _buffer);\n                    } \n                    // TODO: update marker info\n                    const marked =  _marker.markedInfo();\n\n                    formatterBuffer.appendToBuffer({\n                        buffer: _buffer, data: value, marked});\n                }\n            }\n            _marker.value = _def_value || { source: value, value: _buffer };\n            if (raise)\n                _formatter.onAppendToBuffer(_marker, _buffer, option);\n            if (_buffer?.trim().length>0){\n                option.glueValue = null;\n            }\n        };\n\n        option.useGlue = (_marker, _cm_value)=>{\n             // + | update or reset glue value\n             if (_marker.isGlueValue && _cm_value) {\n                option.glueValue = _cm_value;\n            } else {\n                option.glueValue = null;\n            }\n        };\n        option.treatValueBeforeStoreToBuffer = function (_marker, _buffer){\n            const { listener, tokenChains, engine } = this;\n            if (listener?.renderToken) {\n                _shiftMarkerInfo(_marker.marker, tokenChains);\n                // + | shift to token marker info \n                (()=>{\n                    // + | add extra to to token chains\n                    _marker.name && !_marker.isShiftenName && tokenChains.unshift(_marker.name);\n                    \n                })()\n                const tokenID = getTokenID(_marker);\n                _buffer = listener.renderToken(_buffer, tokenChains, tokenID, engine, debug, _marker, option);\n            }\n            return _buffer;\n        }\n        /**\n         * treat begin captures\n         * @param {*} _marker \n         * @param {*} matches \n         * @returns \n         */\n        option.treatBeginCaptures = function (patternInfo, _captures, _outdefine) {\n            const { marker, group } = patternInfo; \n            // + | do capture treatment \n            let _cap = _captures || Utils.BeginCaptures(marker);\n            if (is_emptyObj(_cap)) {\n                return;\n            } \n            let _s = null;  \n            // + | use capture to treat and pattern to continue reading\n            // + | clone and reset indices before generate  \n            _s = CaptureRenderer.CreateFromGroup(group, marker.name);\n            if (_s) {\n                _outdefine =_outdefine || {};\n                let _g = _renderCaptures( ()=>{\n                    return  _s.render(this.listener, _cap, false, this.tokenChains, this, _outdefine);\n                });\n                patternInfo.startOutput = _g;\n                this.lastDefineStates = _outdefine;\n                return _g;\n            }\n            return null;\n        };\n        option.treatEndCaptures = function (markerInfo, endMatch, captures, _outdefine) {\n            let _cap = captures || { ...markerInfo.captures, ...markerInfo.endCaptures };\n            if (is_emptyObj(_cap)) {\n                if (endMatch[0].length>0)\n                    return option.treatValueBeforeStoreToBuffer(markerInfo, endMatch[0]);\n                return;\n            }\n            const { marker } = markerInfo;\n            const { debug } = this;\n            const q = this;\n            const fc_handle_end = function (value, cap, id, listener, option) {\n                const { tokens, engine, debug, tokenID } = option;\n                if (cap.patterns) {\n                    value = Utils.TreatPatternValue(value, cap.patterns, markerInfo.group, q);\n                } else {\n                    // treat buffer marker \n                    const op = [];\n                    value = _formatter.treatMarkerValue(cap, value, op);\n                    value = listener.renderToken(value, tokens, tokenID, engine, debug, cap,q);\n                }\n                return value;\n\n            };\n            debug?.feature('treat-capture') && Debug.log('--:::TreatEndCapture:::--' + marker);\n            let def = endMatch;\n            let _s = CaptureRenderer.CreateFromGroup(def, marker.name);\n            if (_s) { \n                _outdefine = _outdefine || {};\n                let _g = _renderCaptures(()=>{\n                    let _g = _s.render(this.listener, _cap, fc_handle_end, this.tokenChains,\n                        q, _outdefine\n                    );\n                    return _g;\n                }); \n                markerInfo.endOutput = _g;\n                this.lastDefineStates = _outdefine;\n                debug?.feature('treat-capture') && (()=>{\n                    Debug.log('--::: end captures result :::--');\n                    console.log({endOuput:_g});\n                })();\n                return _g;\n            }\n            return null; \n        }\n\n        /**\n         * \n         */\n        function _renderCaptures(callback){\n            let q = option;\n            let _bck = q.skipEmptyMatchValue;\n            q.skipEmptyMatchValue = false;\n            m_isCapturing= true;\n            let _g = callback();\n            m_isCapturing = false;\n            q.skipEmptyMatchValue = _bck;\n            return _g;\n        }\n      \n    \n\n        /**\n         * deprecated use only renderer to treat value \n         * @param {*} _cap \n         * @param {*} _marker \n         * @param {*} endMatch \n         * @deprecated\n         * @returns \n         */\n        option.treatCaptures = function (_cap, _marker, endMatch) {\n            // let transformed = _marker.endRegex(_marker.group); \n            // use replaceWith to change the value at specied capture \n            let list = [];\n            list.markers = {};\n            let prop = null;\n            for (let i in _cap) {\n                list.push(i);\n                let d = _cap[i];\n                if (!(i in endMatch)) {\n                    _formatter.pushError(101);\n                    continue;\n                }\n                let value = endMatch[i];\n\n\n                if (d.transform) {\n                    value = Utils.StringValueTransform(value, d.transform);\n                }\n                if (d.name) {\n                    prop = new NameOnlyConstantPattern();\n                    prop.name = d.name;\n                    list.markers[i] = {\n                        marker: prop,\n                        value: value\n                    };\n                }\n                endMatch[i] = value;\n            }\n            return list;\n        }\n\n        /**\n         * move to this location\n         * @param {number} newPosition \n         */\n        option.moveTo = function (newPosition, newOffset) { \n            if (newOffset){\n                this.lineMatcher.setPosition(newPosition, newOffset)\n            } else {\n                this.pos = newPosition;\n            }\n        }\n        /**\n         * restore buffer \n         * @param {*} param0 \n         */\n        option.restoreBuffer = function ({ state }) {\n            _formatterBuffer = state.formatterBuffer;\n        };\n        option.newBuffer = function (id) {\n            _formatterBuffer = new FormatterBuffer;\n            _formatterBuffer.id = id;\n        };\n        /**\n         * save buffer\n         */\n        option.saveBuffer = function () {\n            m_saveCount++;\n            _bufferState.push({\n                output: this.output,\n                formatterBuffer: this.formatterBuffer\n            });\n            this.newBuffer('_save_buffer_');\n        };\n\n        /**\n         * restore saved buffer\n         */\n        option.restoreSavedBuffer = function () {\n            let buffer = _bufferState.pop();\n            if (buffer) {\n                this.restoreBuffer({ state: buffer });\n                m_saveCount--;\n            }\n        };\n\n        /**\n         * store definition\n         * @param {*} startBlock \n         */\n        option.store =\n            /**\n             * store and clear formatter buffer  \n             * @param {bool} startBlock \n             */\n            function (startBlock = false){\n                const _ctx = this;\n                const { buffer, data, output, dataOutput, depth, formatterBuffer, listener } = _ctx;\n                const _args = { buffer, output,data, dataOutput, depth, tabStop, formatterBuffer, _ctx, startBlock };\n                if (listener?.store) {\n                    listener.store.apply(null, [_args]);\n                } else {\n                    if (!m_formatterListener){\n                        m_formatterListener = new FormatterListener;\n                    }\n                    m_formatterListener.store(_args);\n                }\n                _formatterBuffer.clear();\n            };\n\n        option.flush =\n           /**\n           * flush with what is in the buffer - and clear buffer \n           * @param {bool} clear clear buffer list \n           * @param {{dataOutput:string, buffers: { bufferSegments: [*], dataSegments: [*]} }} refdata reference data return on buffer clear \n           * @returns \n           */\n            function (clear, refdata) {\n                const _ctx = this;\n                const { buffer, output, listener, dataOutput, formatterBuffer} = _ctx;\n                let l = '';\n                let data = null;\n                if (listener?.output) {\n                    l = listener.output.apply(null, [{ buffer, output, dataOutput, lineFeed, _ctx }]);\n                } else {\n                    l = output.join(lineFeed);\n                }\n                data = dataOutput.join(lineFeed);\n                //+| clear output and buffer \n                if (clear) {\n                    if (refdata){\n                        refdata.dataOutput = data;\n                        refdata.buffers = formatterBuffer.joinSegments();\n                    }\n                    formatterBuffer.clearAll();\n                    output.length = 0;\n                }\n                return l;\n            }\n        option.appendLine = \n            /**\n             * \n             * @returns \n             */\n            function () {\n            const { listener } = this; \n            const { lineFeed } = _formatter.settings;\n            if (listener?.appendLine) {\n                return listener.appendLine(lineFeed,\n                    this.formatterBuffer, this, {\n                    store: () => {\n                        this.store();\n                    }\n                });\n            } else {\n                return _formatter.appendToBuffer(lineFeed, this);\n            }\n        };\n    }\n\n    /**\n     * \n     * @param {PatternMatchInfo} sourcePattern \n     * @param {string} buffer \n     * @returns {_gbuffer:string, _cpos:number}\n     */\n    treatAndFormat(sourcePattern, buffer){\n        let _cpos = buffer.length;\n        const _s = sourcePattern.streamFormatter;\n        if (_s){\n            if (typeof(_s)=='function'){\n                buffer = formatter(buffer);\n            } else if ((typeof(_s) == 'object') && _s.format){\n                buffer = _s.format(buffer);\n            } \n            // update the new line\n            this.line = buffer + option.line.substring(_cpos);\n        }\n        return {_gbuffer: buffer, _cpos: buffer.length};\n    }\n    /**\n     * start loop detected \n     */\n    loopStart(){\n        if (this.loopInfo == null){\n            // + | init loop start\n            this.loopInfo = {\n                position: 0,\n                matcher: null,\n                count: 0\n            };\n        } else {\n            // + | reset loop start\n            this.loopInfo.position = 0;\n            this.loopInfo.matcher= null;\n            this.loopInfo.count = 0;\n        }\n    }\n    get sourceOffset(){\n        return this.lineOffset + this.offset;\n    }\n    /**\n     * reset flags definition\n     */\n    reset(){\n        this.lineJoin = \n        this.skipEmptyMatchValue = \n        this.holdBufferState = \n        this.EOF=\n        this.EOL=\n        this.startLine=\n        this.lineFeedFlag =\n        this.skipTreatEnd = \n        this.skipTreatWhile = \n        false;\n        this.lineCount = 0;\n        this.markerDepth = 0;\n        this.nextMode = 1;\n        // reset glue flags\n        this.joinWith = null;\n        this.lastDefineStates = null;\n        this.transformMarker = null;\n        this.lineSegments.clear();\n        this._resetFlags();\n    }\n    cleanNewOldBuffers() {\n        const option = this;\n        if (this.holdBufferState && option.newOldBuffers.length > 0) {\n            // On this Process handling clean all new Buffers\n            let count = option.newOldBuffers.length;\n            while (count > 0) {\n                let tq = option.shiftMarker();\n                let q = option.newOldBuffers.pop();\n                if (tq !== q) {\n                    throw new Error('invalid configuration');\n                }\n                count--;\n                let bf = option.buffer;\n                option.restoreBuffer(q);\n                if (bf.length > 0) {\n                    option.appendToBuffer(bf);\n                }\n            }\n        }\n    }\n    _resetFlags(){\n        this.glueValue = null;\n        this.lastEmptyMarkerPattern = null;\n        this.skipEndOfLine = false;\n    }\n    /**\n     * set source line \n     * @param {*} v \n     * @param {undefined|number} position \n     * @param {undefined|number} offset \n     */\n    setSourceLine(v, position, offset){\n        this.lineMatcher.sourceLine = v;\n        if ((position != undefined) && (position>=0)){\n            this.setPosition(position, offset);\n        }\n    }\n\n    /**\n     * set position and offset \n     * @param {number} position \n     * @param {undefined|number} offset \n     */\n    setPosition(position, offset){ \n        this.lineMatcher.setPosition(position, offset);\n    }\n    /**\n     * \n     * @param {*} _marker \n     * @param {*} _old \n     */\n\n    onBeginEndFound(_marker, _old){\n        this._resetFlags();\n        this.cleanNewOldBuffers();\n        // set the nextGlueValue to use.\n        if (_marker.nextGlueValue){\n            this.nextGlueValue = _marker.nextGlueValue;\n        }\n        if (_marker.isBlockConditionalContainer){\n            if (this.topConditionalBlockContainer()==_marker){\n\n                this.popConditionalContainer();\n            }\n        }\n    }\n    onBeginWhileFound(){\n\n    }\n\n    /**\n     * shift and restore from\n     * @param {*} from \n     * @param {*} throwError \n     * @returns \n     */\n    shiftAndRestoreFrom(from, throwError){\n        const option = this;\n        let _old = option.shiftFromMarkerInfo(from, throwError);\n        if (_old) {\n            // unshif and restore buffer \n            let _rbuffer = option.buffer;\n            let _rdata = option.data;\n            option.restoreBuffer(_old);\n            if (_rbuffer) {\n                option.formatterBuffer.appendToBuffer(\n                    {\n                    source:_rbuffer, data: _rdata});\n            }\n        }\n        return _old;\n    }\n    /**\n     * get if reading is in real start line\n     * @var {boolean}\n     */\n    get startLineReading(){\n        return this.startLine && (this.line == this.sourceLine);\n    }\n    /**\n     * return shift markerInfo from list\n     * @param {PatternMatchInfo} marker \n     * @param {bool} throwError \n     * @returns \n     */\n    shiftFromMarkerInfo(marker, throwError = true) {\n        if (this.markerInfo.length > 0) {\n            if (this.markerInfo[0].marker === marker) {\n                return this.markerInfo.shift();\n            }\n            if (throwError) {\n                throw new Error('missing markerInfo [shift Marker Info] ');\n            }\n        }\n        return null;\n    }\n    storeAndUpdateBuffer() {\n        this.store();\n        let _buffer = this.flush(true);\n        if (_buffer.length > 0) {\n            this.formatterBuffer.appendToBuffer(_buffer);\n        }\n    }\n    getBufferContent(clear, refData){\n        const option = this;\n        let _buffer = option.buffer;\n        let _cm = option.flush(true, refData);\n        if (clear){\n            option.formatterBuffer.clear();\n        }\n        return _cm+_buffer;\n    }\n    peekFirstMarkerInfo() {\n        if (this.markerInfo.length > 0) {\n            return this.markerInfo[0];\n        }\n        return null;\n    }\n    /**\n     * store current buffer to output\n     * @param {*} useDepth \n     * @param {*} blockStarted \n     */\n    storeToOutput({ buffer = null, useDepth = false, blockStarted = false, clear = false }) {\n        buffer = buffer || this.buffer;\n        if (buffer && (buffer.length > 0)) {\n            if (useDepth)\n                this.store(blockStarted);\n            else {\n                let l = this.buffer;\n                if (l.length) {\n                    this.output.push(l);\n                }\n            }\n        }\n        if (clear) {\n            this.formatterBuffer.clear();\n        }\n    }\n    /**\n     * get marker info\n     */\n    get peekMarkerInfo(){\n        return this.markerInfo.length>0? this.markerInfo[0] : null;\n    }\n\n    appendExtraOutput() {\n        this.debug?.feature('append-extra-prefix-line') && Debug.log('---:append extra output:---');\n        const { listener, output , dataOutput} = this;\n        FormatterOptions.AppendExtraLiveOutput({ listener, output, dataOutput });\n    }\n    /**\n     * flush and get data\n     * @param {*} clear \n     * @returns {{buffer:string, data: string}}\n     */\n    flushAndData(clear){\n        const _refData = {};\n        const _buffer = this.flush(clear, _refData);\n        return {buffer: _buffer, data: _refData.dataOutput };\n    }\n    static AppendExtraLiveOutput({ listener, output, dataOutput }) {\n        if (listener?.appendExtraOutput) {\n            listener.appendExtraOutput({ output: output });\n        } else{\n            output.push('');\n            dataOutput.push('');\n        }\n    }\n    get bufferSegmentState(){\n        const { formatterBuffer } = this;\n        return {\n            bufferSegment : formatterBuffer.bufferSegment,\n            dataSegment : FormatterBuffer.dataSegment\n        };\n    }\n    /**\n     * get buffer states\n     */\n    get bufferState(){\n        return {\n            buffer: this.buffer,\n            data : this.data,\n            output:  this.output.slice(0),\n            dataOutput:  this.dataOutput.slice(0),\n            bufferSegments : this.formatterBuffer.bufferSegments,\n            dataSegments : this.formatterBuffer.dataSegments,\n        };\n    }\n\n    constantPattern(){\n        let _c =  this.sourceOption?.constantName || this.sourceOption?.name;\n        if (_c){\n\n            let _g = this.constants.refConstantClass;\n\n            return new _g(_c); \n        }\n        return this.constants.GlobalConstant; \n    }\n}\n\n\n\nexports.FormatterOptions = FormatterOptions;","\"use strict\";\nObject.defineProperty(exports, 'enModule', { value: true });\n\n\n\nclass FormatterPatternException extends Error{\n    constructor(msg, pattern, match, line){\n        if (line){\n            msg += ' At '+line;\n        }\n        super(msg);\n        Object.defineProperty(this, 'pattern', {get(){return pattern}});\n        Object.defineProperty(this, 'match', {get(){return match}});\n    }\n}\n\n\nexports.FormatterPatternException = FormatterPatternException;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n\n/**\n * formatter buffer setting\n */\nclass FormatterSegmentInfo{\n    #m_buffer;\n    #m_op;\n\n    constructor(buffer, op){\n        this.#m_buffer = buffer;\n        this.#m_op = op;\n    }\n    toString(){\n        return this.#m_buffer;\n    }\n    get buffer(){\n        return this.#m_buffer;\n    }\n    get isMarked(){\n        return this.#m_op != null;\n    }\n    get info(){\n        if (this.isMarked){\n            return this.#m_op;\n        }\n        return null;\n    }\n}\n\n\nexports.FormatterSegmentInfo = FormatterSegmentInfo;","\"use strict\";\n\nconst { Utils } = require(\"./Utils\");\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\n\nclass FormatterSegmentJoin{\n    /**\n     * \n     */\n    dataSegment;\n    /**\n     * \n     */\n    bufferSegment;\n\n    constructor(){\n    }\n\n    /**\n     * update segment data\n     * @param {*} segments \n     * @param {*} param1 \n     */\n    static UpdateSegmentData(segments,{dataSegment, bufferSegment}){\n        let joiner = new FormatterSegmentJoin();\n        joiner.dataSegment = dataSegment;\n        joiner.bufferSegment = bufferSegment;\n        joiner.updateData(segments);\n    }\n    /**\n     * \n     * @param {{bufferSegment:[], dataSegment:[]}} segments segment list to update\n     */\n    updateData(segments){\n        const {dataSegment, bufferSegment} = this;\n        const _length = segments.bufferSegment.length;\n        segments.bufferSegment.push(...bufferSegment);\n        segments.dataSegment.push(...dataSegment);\n        const { marked }  = bufferSegment;\n        const { FormatterBuffer } = Utils.Classes;\n\n        if (marked){\n            if(!('op' in marked)){\n                FormatterBuffer.InitOpMarkedSegment(marked);\n            }\n            // + | -------------------------\n            // + | - to - \n            // + | -------------------------            \n            if (!('marked' in segments.bufferSegment)){ \n                segments.bufferSegment.marked = FormatterBuffer.InitMarkedSegment();\n            }\n            let _i = 0;\n            let _d = segments.bufferSegment.marked;\n            marked.forEach(element => {\n                const _idx = element + _length;\n                if (!('op' in _d)){\n                    FormatterBuffer.InitOpMarkedSegment(_d);\n                }\n                _d.push(_idx);\n                let _ts = element in marked.op? marked.op[element] : null;\n                Utils.UpdateSegmentMarkerOperation(_d, _idx, _ts);  \n                _i++;\n            });\n        }\n    }\n   \n}\n \n\nexports.FormatterSegmentJoin =FormatterSegmentJoin","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', { value: true });\nconst { FormattingCodeStyles } = require('./FormattingCodeStyles');\nconst { FormattingBase } = require('./Formattings/FormattingBase');\nconst { TransformEngine } = require('./TransformEngine');\n\nclass FormatterSetting {\n    tabStop = \"\\t\";\n    lineFeed = \"\\n\";\n    blockOnSingleLine = true;\n    noSpaceJoin = false;\n    codingStyle = FormattingCodeStyles.K_R;\n    /**\n     * use source indent\n     * @var {boolean} \n     */\n    useIndent = false;\n    depth = 0;\n    line = 0;\n    /**\n     * depending on lanuage instruction separator can be a value \n     */\n    instructionSeparator = ';';\n    /**\n     * by default use the current  formatter instance\n     */\n    useCurrentFormatterInstance = true;\n\n    /**\n     * setup engine used to transform tokenID or captured expression - setting\n     * @var {?TransformEngine}\n     */\n    transformEngine\n\n\n    /**\n     * support end match logic technique\n     * @var {'before'|'after'} \n     */\n    endMatchLogic = 'before';\n\n    /**\n     * \n     * @param {*} parser\n     * @param {*} fieldname\n     * @param {*} data \n     * @param {*} refKey \n     * @param {*} refObj \n     */\n    json_parse(parser, fieldname, data, refKey, refObj) {\n        switch (fieldname) {\n            case 'codingStyle':\n                if (FormattingCodeStyles.Support(data)) {\n                    return data;\n                }\n                throw new Error(fieldname + ' not supported');\n            case 'transformEngine': \n                let engine = null;\n                if (data instanceof TransformEngine){\n                    engine = data;\n                }\n                if (typeof(data) == 'string'){\n                    engine = TransformEngine.CreateEngine(data);\n                } else {\n                    const {id, engine} = data;\n                    // init transform engine \n                    engine = TransformEngine.CreateEngine(data);\n                } \n                return engine;\n        }\n        return data;\n    }\n    /**\n     * get code style formattings\n     * @returns \n     */\n    getCodingStyleFormatting() {\n        return FormattingBase.Factory(this.codingStyle);\n    }\n    /**\n     * \n     * @param {*} ch \n     * @returns \n     */\n    isInstructionSeperator(ch) {\n        let g = this.instructionSeparator;\n        if (typeof (g) == 'string') {\n            g = g.split('|');\n        }\n        return g.indexOf(ch) != -1;\n\n    }\n}\nexports.FormatterSetting = FormatterSetting;","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterBuffer } = require('./FormatterBuffer');\nconst { SpecialMeaningPatternBase, Patterns } = require('./Formatters');\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\nconst { Utils } = require(\"./Utils\");\nconst { FormattingMode } = require(\"./Formattings/FormattingMode\");\nconst { Debug } = require(\"./Debug\");\n\nconst FORMATTER_ID = '_formatter_buffer_';\n/**\n * use to read stream buffer\n */\nclass FormatterStreamBuffer extends SpecialMeaningPatternBase {\n    name = 'system.formatter.stream.buffer';\n    formatterBuffer;\n    from;\n    initialMode = 1;\n    startPosition;\n    started = false;\n    closed = false;\n    marked = false;\n    endFoundListener;\n    /**\n  * backup source marker info\n  */\n    sourceMarkerInfo;\n    /**\n     * backup stream token list\n     */\n    sourceTokenList;\n\n\n\n    get matchType() {\n        return 4;\n    }\n    constructor() {\n        super();\n        this.formatterBuffer = new FormatterBuffer;\n        this.formatterBuffer.id = FORMATTER_ID;\n        let m_saved = { saved: false, started: false };\n        const self = this;\n\n        this.appendToBuffer = function (v, def) {\n            if (def) {\n                const {_marker, formatting} = def;\n                if (_marker && formatting && (_marker.mode != 1) ){\n                    let _buffer = this.formatterBuffer.buffer;\n                    v = formatting.joinStreamBuffer(_marker.mode, _buffer, v);\n                    this.formatterBuffer.clear();\n                }\n            }\n            this.formatterBuffer.appendToBuffer(v);\n            return v;\n        }\n        this.clear = function () {\n            this.formatterBuffer.clear();\n        }\n        Object.defineProperty(this, 'saved', { get() { return m_saved; } });\n        Object.defineProperty(this, 'buffer', { get() { return this.formatterBuffer.buffer; } });\n        Object.defineProperty(this, 'begin', { get() { return this.from?.begin; } });\n        Object.defineProperty(this, 'end', { get() { return this.from?.end; } });\n        Object.defineProperty(this, 'comment', { get() { return this.from?.comment; } });\n        Object.defineProperty(this, 'index', { get() { return this.from?.index; } });\n        Object.defineProperty(this, 'patterns', {\n            get() {\n                return this.from?.patterns;\n            },\n            set(v) {\n                throw new Error('failed to set patterns not allowed');\n            }\n        });\n\n        // Object.defineProperty(this, 'comment', {get:function(){\n        //     return \"Hello\";\n        // }});\n        const q = this;\n        Object.keys(FormatterStreamBuffer.prototype).forEach(a => {\n            if (/(from)/.test(a))\n                return;\n            Object.defineProperty(q, a, {\n                get: function () {\n                    // console.log(\"this from \", q.from?.marker.comment);\n                    return q.from ? q.from[i] : undefined;\n                }\n            });\n        });\n\n    }\n    get newLineContinueState() {\n        return false;\n    }\n    get throwErrorOnEndSyntax() {\n        return true;\n    }\n    get isEndCaptureOnly() {\n        return this.from.isEndCaptureOnly;\n    }\n    get isWhileCaptureOnly() {\n        return this.from.isWhileCaptureOnly;\n    }\n    get isBeginCaptureOnly() {\n        return this.from.isBeginCaptureOnly;\n    }\n    get patterns() {\n        return this.from?.patterns;\n    }\n    get indexOf() {\n        return this.from?.indexOf;\n    }\n    get endRegex() {\n        return this.from?.endRegex;\n    }\n\n    get marker() {\n        return this.from?.marker;\n    }\n\n    // class on end of file \n    stopAndExitStream(patternInfo, option, _bck, _restoreState, _old) {\n        const { from, parent } = this;\n        const { formatter, markerInfo } = option;\n\n        const _line = this.buffer;\n        let ret = null;\n        let bck = { line: option.line, pos: option.pos };\n        _restoreState(option, _bck);\n        formatter._onEndHandler(from, option);\n\n        if (bck.line.length == 0) {\n            option.formatterBuffer.appendToBuffer(_line);\n            this.clear();\n            return null;\n        }\n\n\n        option.setSourceLine(_line,0);\n\n        if (parent != null) {\n            throw new Error(\"not implement exit parent.\");\n        } else {\n            ret = this.moveToNextPattern(patternInfo, option, _old, from);\n        }\n        option.line = bck.line;\n        option.pos = bck.pos;\n        if (_old?.marker != from)\n        option.shiftAndRestoreFrom(from);\n        return ret;\n    }\n    /**\n     * \n     * @returns \n     */\n    handleMarkerListener(option) {\n        const q = this;\n        let _restored = false;\n        let _topStreamRemoved = false;\n        function _restoreSavedBuffer(option) {\n            let _nbuffer = option.buffer;\n            if (!_restored && (_nbuffer.length > 0)) {\n                q.appendToBuffer(_nbuffer);\n                //option.formatterBuffer.clear();\n            }\n        }\n        function _restoreState(option, _bck) {\n            if (_restored) {\n                return;\n            }\n            _restoreSavedBuffer(option);\n            option.appendToBufferListener = _bck.option.listener;\n            _restored = true;\n        };\n        function _restoreBackupState(parent) {\n            /**\n             * restore backup state mode \n             */\n            parent.mode = _bck.parentMode;\n        }\n        const _bck = q.saved;\n        if (!q.started) {\n            // save backup mode \n            q.started = true;\n            const { parent } = q.from;\n            if (parent) {\n                _bck.parent = parent;\n                //backup parent definition \n                _bck.parentMode = parent.mode;\n            }\n        } else {\n            if (_bck.parent) {\n                _bck.parent.mode = FormattingMode.FM_APPEND;\n            }\n        }\n\n        return function (markerInfo, option) {\n            // + | -----------------------------------------\n            // + | handle streaming buffer\n            option.stream = q;\n            const { debug } = option;\n            const _formatter = this;\n            let _next_position = option.pos;\n            let _buffer = q.buffer;\n            const { from } = q;\n            const _line = option.line.substring(option.pos);\n            let _p, _matcher;\n            const _markerInfo = option.markerInfo;\n            debug && Debug.log(\"::- HANDLE STREAMING -::\");\n            try {\n                if (!_bck.started) {\n                    // + | ------------------------------------------------------------------------\n                    // + |  move cursor in order to detect only children with pattern because buffered stream have no capture defined\n                    // + | \n\n                    _bck.started = true;\n                    //option.pos++;\n                }\n                ({ _p, _matcher } = _formatter.detectPatternInfo(_line, markerInfo, option, markerInfo));\n            } catch (e) {\n                // invalid stream tag selection \n                const cp = _markerInfo.shift();\n                if (_bck.saved) {\n                    _restoreState(option, _bck);\n                }\n                option.line = q.buffer + option.line.substring(option.pos);\n                throw e;\n            }\n            // + | REMOVE TOP STREAM MARKER \n            let _old = option.shiftAndRestoreFrom(markerInfo, false);\n            if (_old) {\n                _topStreamRemoved = true;\n            }\n            // + | here must get the definition for the parent - to update if required\n            _old = (_markerInfo.length > 0) ? option.shiftFromMarkerInfo(from, false) : null;\n            if (!_bck.saved) {\n                _bck.option = {\n                    listener: option.appendToBufferListener\n                };\n                // + | Set add to buffer listener : data\n                option.appendToBufferListener = (v, _marker, treat, option) => {\n                    let _buffer = option.buffer;\n                    const { formatting } = option.formatter;\n                    const _def = {_marker, formatting} ;\n                    if (treat && !q.from.formatter){\n                        v = option.treatValueBeforeStoreToBuffer(_marker, v);\n                    }\n\n\n                    if (_buffer.length > 0) {\n                        if (_buffer != option.glueValue){\n                        q.appendToBuffer(_buffer, _def);\n                        option.formatterBuffer.clear();\n                        }\n                    }\n                    if (v.length > 0)\n                        q.appendToBuffer(v, _def);\n                    return v;\n                };\n                _bck.saved = true;\n            }\n\n            option.storeRange(option.pos);\n            let r = null;\n            const endFound = FormatterStreamBuffer.HandleStreamEndFound(q, markerInfo, _bck, _formatter, _restoreState, _restoreBackupState);\n            q.endFoundListener = (_buffer, _line, patternInfo, _p, option, _old) => {\n                const g = endFound(_buffer, _line, patternInfo, _p, option, _old);\n                _restoreSavedBuffer(option);\n                return g;\n            };\n\n            if (option.EOF && (_p == null) && (_matcher == null)) {\n                return q.stopAndExitStream(markerInfo, option, _bck, _restoreState, _old);\n            }\n            if (option.TOEND) {\n                //return q.stopAndExitStream(markerInfo, option, _bck, _restoreState, _old);\n\n                let _ret = endFound.apply(option.formatter, [_buffer, _line, markerInfo, _p, option, _old]);\n\n                return _ret;\n            }\n\n\n            try {\n                if ((_old == null) && (_buffer.length > 0)) {\n                    // + | just start stream buffer \n                    _buffer = '';\n                }\n                if (!q.marked) {\n                    const _stream_old = _formatter._updateMarkerOldContentOrSwapBuffer(markerInfo, null, '', null, option);\n                    q.marked = true;\n                    _stream_old.endFound = endFound;\n                }\n\n                r = _formatter.handleMatchLogic({\n                    _p,\n                    _old,\n                    _matcher,\n                    _line,\n                    patternInfo: from,\n                    option: option,\n                    _buffer,\n                    endFound,\n                    handleConstant(patternInfo, _line, option) {\n                        if (_line.trim().length > 0) {\n                            option.appendToBuffer(_line, patternInfo);\n                        }\n                        option.pos += _line.length;\n                        if (_old) {\n                            option.unshiftMarker(_old);\n                            return _old.marker;\n                        }\n                        return markerInfo;// q.from;\n                    }\n                });\n\n                if (q.closed && q.marked) {\n                    option.shiftAndRestoreFrom(markerInfo, false);\n                }\n\n            } catch (e) {\n                // update buffer \n                console.log(\"End buffer..... \", e);\n                _restoreSavedBuffer(option);\n                _formatter.skipFormat();\n                return null;\n            }\n            _restoreSavedBuffer(option);\n            option.stream = null;\n            if (r && !(r instanceof PatternMatchInfo)) {\n                throw new Error(\"pattern not valid\");\n            }\n            if (!q.closed) {\n                if (r === q.from) {\n                    return markerInfo;\n                }\n            }\n\n            return r;\n        };\n    }\n\n    /**\n     * \n     * @param {*} patternInfo \n     * @param {*} option \n     * @param {*} _old \n     * @param {*} markerInfo \n     * @param {*} next_position \n     * @param {*} length \n     * @param {*} _tline \n     * @returns \n     */\n    moveToNextPattern(patternInfo, option, _old, markerInfo, next_position, length, _tline) {\n        const { parent, hostPatterns, streamAction, indexOf } = patternInfo;\n        const { lineMatcher } = option;\n        lineMatcher.reset();\n        lineMatcher.sourceLine = _tline || '';\n\n        option.storeRange(option.pos);\n        let _patterns = hostPatterns ?\n            Utils.GetPatternsList(hostPatterns, indexOf, streamAction) : [];\n\n        if (_patterns.length > 0) {\n            // + | handle matcher to line\n            let g = Utils.GetPatternMatcherInfoFromLine(option.line, _patterns, option, parent);\n            if (_old) {\n                if (_old?.marker == markerInfo) {\n                    option.restoreBuffer(_old);\n                }\n            }\n            if (g) {\n                // + | exit from - top pattern Info \n                _old = //option.shiftFromMarkerInfo(patternInfo);\n                    option.shiftAndRestoreFrom(patternInfo, false);\n                return g;\n            }\n            // skip to next position \n            if (parent === null) {\n                // + | ------------------------------------------------------------\n                // + | skip and continue\n                let _rindex = next_position - length;\n                let _append = option.line.substring(0, _rindex);\n                option.appendToBuffer(_append, option.constants.StreamLineConstant);\n                option.line = option.line.substring(_rindex);\n                option.pos = 0;\n                return null;\n            }\n\n        }\n        if (parent === null) {\n            // + | just append to buffer              \n            option.appendToBuffer(option.line, option.constants.StreamLineConstant);\n            option.pos = option.length;\n            return null;\n        }\n        return parent;\n    }\n    /**\n     * get marker end buffers \n     * @param {*} q \n     * @param {*} markerInfo \n     * @param {*} _bck \n     * @param {*} _formatter \n     * @param {*} _restoreState \n     * @param {*} _restoreBackupState \n     * @returns \n     */\n    static HandleStreamEndFound(q, markerInfo, _bck, _formatter, _restoreState, _restoreBackupState) {\n        return (_buffer, _line, patternInfo, _p, option, _old) => {\n            const { parent } = patternInfo;\n            const { formatter } = option;\n            const { endRegex } = markerInfo;\n            q.closed = true;\n            // + backup line \n            let _cpos = option.pos;\n\n            let _cbuffer = q.buffer;\n            let _nextCapture = null;\n            let _next_position = 0;\n            option.lineMatcher.reset()\n            //option.pos = 0;\n            _nextCapture = Utils.GetNextCapture(_line, endRegex, option);\n            option.storeRange(option.pos);\n            _next_position = _nextCapture.index + _nextCapture.offset;\n            if (!_nextCapture) {\n                throw new Error('missing capture');\n            }\n            const _end = _nextCapture[0];\n            const _sline = _line.substring(0, _nextCapture.index);\n            _line = _line.substring(_nextCapture.index + _end.length);\n            const _gline = _cbuffer + _sline + _end;\n            const _tline = FormatterStreamBuffer.GetBufferedLine(formatter,\n                _gline, option, patternInfo);\n            option.line = _tline + _line;\n            _restoreState(option, _bck);\n\n            // + | move buffer to parrent \n            _buffer = option.getBufferContent(true);\n            _old && option.restoreBuffer(_old);\n            if (_buffer.length > 0)\n                option.formatterBuffer.appendToBuffer(_buffer);\n            // + | unset marker option \n            formatter._onEndHandler(patternInfo, option);\n            if (parent) {\n                // + | end handler before handle parent\n                _restoreBackupState(parent);\n                const _idx = patternInfo.indexOf;\n                if (_idx === -1) {\n                    throw new Error('missing component. use index not valid');\n                }\n                // + | depend on streamAction passing to content to next|parent \n                // + | next: mean to child process\n                // + | parent: to parent buffer \n\n                // restart on parent by removing to handle logic\n                // let _patterns = Utils.GetPatternsList(patternInfo.hostPatterns, _idx, streamAction);\n                // if (streamAction == 'parent') {\n                //     return parent;\n                // }\n                // let g = Utils.GetPatternMatcherInfoFromLine(option.line, _patterns, option, parent);\n                // if (g) { // continue to cp\n                //     let cp = _formatter._handleMarker(g, option); \n                //     return cp;\n                // }\n                // move cursor \n                _cpos = _tline.length - _next_position;\n                let _gbuffer = _tline.substring(0, _cpos);\n                ({ _gbuffer, _cpos } = option.treatAndFormat(q, _gbuffer));\n                // update stored definition and move cursor to next\n                option.pos = _cpos;\n                option.storeRange(option.pos);\n                option.appendToBuffer(_gbuffer, option.constants.StreamBufferConstant);\n\n                // passing children to parent\n                if (parent && (patternInfo.childs.length > 0)) {\n                    patternInfo.childs.forEach(a => parent.childs.push(a));\n                }\n                return parent;\n            }\n            // + | put this line to buffer and skip   \n            return q.moveToNextPattern(patternInfo, option, _old, markerInfo,\n                _next_position,\n                _end.length, _tline);\n        }\n    }\n    /**\n     * \n     * @param {*} formatter \n     * @param {*} _src_line \n     * @param {*} option \n     * @param {*} patternInfo \n     * @returns \n     */\n    static GetBufferedLine(formatter, _src_line, option, patternInfo) {\n        const op = [];\n        const _group = [_src_line];\n        let _line = formatter.treatMarkerValue(patternInfo, _src_line, op, option, _group);\n        const _captures = patternInfo.streamCaptures || patternInfo.captures;\n        if (_captures) {\n            _line = Utils.TreatCapture(patternInfo, _captures, _line, [], option);\n        }\n        return _line;\n    }\n\n    /**\n     * \n     * @param {*} option \n     */\n    start(option) {\n        this.initialMode = option.nextMode;\n    }\n}\n\nexports.FormatterStreamBuffer = FormatterStreamBuffer;\n","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {value:true});\n\nclass FormatterSyntaxException extends Error{\n    At;\n\n    constructor(message, {lineCount}){\n        super(message);\n        this.At = lineCount;\n    }\n}\nexports.FormatterSyntaxException = FormatterSyntaxException;","\"use strict\";\nObject.defineProperty(exports, '__ESModule', {value: true});\n\nclass FormatterToken{\n    tokens;\n    tokenID;\n    value;\n    /**\n     * @var {boolan}\n     */\n    isRendered;\n};\nexports.FormatterToken = FormatterToken;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { NativeRegExp } = require('./NativeRegExp');\nconst { FormatterCloseParentInfo } = require('./FormatterCloseParentInfo');\nconst { Utils } = require(\"./Utils\");\nconst { Patterns } = require(\"./Patterns\");\nconst { RefPatterns } = require(\"./RefPatterns\");\nconst { JSonParser } = require(\"./JSonParser\");\nconst { Debug } = require(\"./Debug\");\nconst { FormatterListener } = require(\"./FormatterListener\");\nconst { FormatterSetting } = require(\"./FormatterSetting\");\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\nconst { CaptureInfo } = require(\"./CaptureInfo\");\nconst { CaptureRenderer } = require(\"./CaptureRenderer\");\nconst { FormatterBuffer } = require(\"./FormatterBuffer\");\nconst { FormatterOptions } = require(\"./FormatterOptions\");\nconst { FormattingCodeStyles } = require(\"./FormattingCodeStyles\");\nconst { HandleFormatting, FormattingMode, formattingSetupPatternForBuffer } = require(\"./Formattings/FormattingMode\");\nconst { FormatterMarkerInfo } = require(\"./FormatterMarkerInfo\");\nconst { RegexUtils } = require(\"./RegexUtils\");\nconst { BlockInfo } = require(\"./BlockInfo\");\nconst { FormatterPatternException } = require(\"./FormatterPatternException\");\nconst { FormatterToken } = require(\"./FormatterToken\");\nconst { FormatterDebugger } = require(\"./FormatterDebugger\");\nconst { FormatterEndMissingExpression } = require(\"./FormatterEndMissingExpression\");\nconst { FormatterEndMissingEngine } = require(\"./FormatterEndMissingEngine\");\nconst { FormatterSegmentJoin } = require(\"./FormatterSegmentJoin\");\nconst { FormatterErrors } = require(\"./FormatterErrors\");\n\n\n/**\n * @type IFormatterListener\n * @function renderToken\n * @params (value:string, tokenList:string, tokenId:string[]);\n */\n\n\n// + | --------------------------------------------------------\n// + | export pattern match information \n// + | --------------------------------------------------------\nUtils.Classes = {\n    RefPatterns,\n    Patterns, // replacement \n    PatternMatchInfo, // \n    CaptureInfo, // replacement\n    CaptureRenderer,\n    FormatterBuffer,\n    FormatterOptions,\n    FormattingCodeStyles,\n    Debug,\n    RegexUtils,\n    BlockInfo,\n    FormatterPatternException,\n    FormatterCloseParentInfo,\n    FormatterToken,\n    FormatterDebugger,\n    FormatterEndMissingExpression,\n    FormatterSegmentJoin\n};\n\nlet sm_globalEngine;\n/**\n * @var engine formatter\n */\nlet sm_engine_formatter;\n/**\n * formatters entry point\n */\nclass Formatters {\n    /**\n     * store object reference of lint errors\n     * @type {any}\n     */\n    lintErrors;\n    /**\n     * array of patterns to inject\n     */\n    patterns;\n    /**\n     * repository to inject\n     */\n    repository;\n    /**\n     * @type {?string}\n     */\n    scopeName;\n\n    /**\n     * selector definition to implements\n     * @type {?string}\n     * \"L:source.language\"\n     */\n    injectionSelector;\n    /**\n    * @type {?boolean}\n    */\n    debug; // allow debug\n    /**\n     * use to configure general setting\n     * @type {{}| undefined | null}\n     */\n    settings;\n\n    /**\n     * comment description \n     * @type {string}\n     */\n    comment;\n\n    /**\n     * array to declare used token id.\n     * @type {?string[]}\n     */\n    tokens;\n\n    foldingStartMarker;\n\n    foldingStopMarker;\n\n    fileTypes;\n\n    /**\n     * @type {string?}\n     */\n    uuid;\n\n    /**\n     * @type {string?}\n     */\n    firstLineMatch;\n\n    /**\n     * @type {?string}\n     */\n    data;\n\n    /**\n     * @type {?string}\n     */\n    buffer;\n\n\n    /**\n     * get engine formatter\n     * @var {null|{resolve(name:string):PatterMatchErrorInfo}}\n     */\n    static get EngineFormatter() {\n        return sm_engine_formatter;\n    }\n    /**\n     * set the engine formatter\n     */\n    static set EngineFormatter(value) {\n        sm_engine_formatter = value;\n    }\n\n    /**\n     * set global engine\n     */\n    static get GlobalEngine() {\n        return sm_globalEngine;\n    }\n    /**\n     * set global engine\n     */\n    static set GlobalEngine(v) {\n        sm_globalEngine = v;\n    }\n    static EndListenerArguments(marker, option){\n        return {\n            tokenID: marker.tokenID,\n            tokenList: option.tokenChains,\n            offset: option.offset,\n            sourceOffset: option.sourceOffset,\n            value: marker.value || (() => ({ value: option.buffer, source: option.data }))()\n        };\n    }\n    /**\n     * @type {IFormattersListener | undefined }\n     */\n    listener;\n\n    /**\n     * object setting definition \n     * @type {null| {}} \n     */\n    objClass;\n\n    /**\n     * info definition \n     * @type {null|{isSubFormatting:number, captureGroup:[]}}\n     */\n    info;\n\n    /**\n     * .ctr\n     */\n    constructor() {\n        /**\n         * @var {null|IFormatterListener}\n         */\n        let m_listener;\n        let m_objClass;\n        let m_info = {\n            isSubFormatting: 0,\n            captureGroup: null\n        };\n        this.debug = false;\n        this.patterns = [];\n        this.repository = {};\n\n        /**\n         * get or set the listener info\n         * @type {*}\n         */\n        Object.defineProperty(this, 'listener', { get() { return m_listener; }, set(value) { m_listener = value } })\n        /**\n             * get format info : use to update some current state\n             */\n        Object.defineProperty(this, 'info', { get() { return m_info; } })\n        Object.defineProperty(this, 'objClass', { get() { return m_objClass; } })\n\n\n        this.pushError = (e) => {\n            this.m_errors.push(\n                FormatterErrors[e]\n            );\n        }\n        this._storeObjClass = function (s) {\n            m_objClass = s;\n            delete this._storeObjClass;//  = null;\n        };\n\n\n    }\n\n    skipFormat() {\n\n        if (!('skip_r' in this)) {\n            const q = this;\n            (function () {\n                let _skip = true;\n                Object.defineProperty(q, 'skip_r', {\n                    get() {\n                        return _skip;\n                    },\n                    set(v) {\n                        _skip = v;\n                    }\n                });\n            })();\n        }\n\n    }\n    // + | ------------------------------------------------------------------------\n    // + | raise event \n    // + | \n    onAppendToBuffer(_marker, _buffer, option) {\n        this.formatting?.onAppendToBuffer(this, _marker, _buffer, option);\n        // + | ---------------------------------------------------------------------\n        // + | reset flag every time something append to buffer - update line segment\n        // + |\n        option.startLine = false;\n        option.lineFeedFlag = false;\n        option.blockStart = false;\n        option.matchTransform = null;\n        option.lastSegment = option.formatterBuffer.lastSegmentInfo();\n\n        option.lineSegments.push(option.lastSegment, option);\n    }\n    /**\n     * get the line feed\n     */\n    get lineFeed() {\n        return this.m_option.lineFeed;\n    }\n    /**\n     * set the line feed\n     */\n    set lineFeed(value) {\n        this.m_option = value;\n    }\n    json_keys() {\n        const n = 'repository';\n        let tab = Object.keys(this);\n        let idx = tab.indexOf(n);\n        delete (tab[idx]);\n        tab.unshift(n);\n        return tab;\n    }\n    /**\n     * validate current field name\n     * @param {*} field_name \n     * @param {*} d \n     * @returns bool\n     */\n    json_validate(field_name, d, throw_on_error) {\n        const validator = {\n            patterns(d) {\n                return Array.isArray(d);\n            },\n            repository(d) {\n                return typeof (d) == 'object';\n            },\n            debug(d) {\n                return typeof (d) == 'boolean' || /(yes|no|1|0)/.test(d);\n            },\n            settings(d) {\n                return (d == null) || typeof (d) == 'object';\n            },\n            scopeName(d) {\n                return (d == null) || typeof (d) == 'string';\n            }\n        };\n        let f = validator[field_name];\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * \n     * @param {*} parser \n     * @param {*} fieldname \n     * @param {*} data \n     * @param {*} refKey \n     * @returns \n     */\n    json_parse(parser, fieldname, data, refKey) {\n        const _pattern_class = parser.patternClassName || Patterns;\n        const patterns = Utils.ArrayPatternsFromParser(parser, Patterns, RefPatterns);\n        const parse = {\n            debug(d) {\n                if (typeof (d) == 'boolean') {\n                    if (d) {\n                        return FormatterDebugger.DebugAll();\n                    }\n                    return null;\n                }\n                return FormatterDebugger.Load(d);\n            },\n            lintErrors(d, parser) {\n                const _lints = {};\n                for (let i in d) {\n                    let s = d[i];\n                    let lint = new FormatterLintError;\n                    lint.code = parseInt(i);\n                    if (typeof (s) == 'string') {\n                        lint.message = s;\n                    } else {\n                        const { message, fix, concept } = s;\n                        lint.fix = fix;\n                        lint.message = message;\n                        lint.concept = concept;\n                    }\n                    _lints[i] = lint;\n                }\n                return _lints;\n            },\n            patterns,\n            repository(d, parser) {\n                let _out = {};\n                let _o = null;\n                const { registry } = parser;\n                for (let i in d) {\n                    _o = new _pattern_class();\n                    JSonParser._LoadData(parser, _o, d[i], i, _o);\n                    parser.initialize(_o);\n                    _out[i] = _o;\n                }\n                parser.repositoryKey = null;\n                return _out;\n            },\n            debug(d) {\n                if (typeof (d) == 'boolean') {\n                    return d;\n                }\n                return !(!d);\n            },\n            settings(d, parser) {\n                if (d == null) {\n                    return null;\n                }\n                let m = JSonParser._LoadData(parser, new FormatterSetting, d);\n                return m;\n            },\n            tokens(d, parser) {\n                if (Array.isArray(d)) {\n                    return d;\n                }\n                return null;\n            }\n        };\n        let fc = parse[fieldname];\n        if (fc) {\n            return fc(data, parser, refKey);\n        }\n        return data;\n    }\n    /**\n     * create and load the formatting marker \n     * @param {string} name \n     * @param {undefined|string|InjectedClass} pattern_class_name \n     * @returns {null|Formatters}\n     */\n    static Load(name, pattern_class_name) {\n        const data = require(\"../formatters/\" + name + \".btm-syntax.json\");\n        if (data) {\n            return Formatters.CreateFrom(data, pattern_class_name)\n        }\n        return null;\n    }\n    /**\n     * create module from btm-format\n     * @param {*} data btn-format data \n     * @param {undefined|string|InjectedClass} pattern_class_name \n     * @returns {null|Formatters}\n     */\n    static CreateFrom(data, pattern_class_name) {\n        const _names = {};\n        let _registryExpression = null;\n        NativeRegExp.Save();\n        const formatter = Utils.JSonParseData(Formatters, data, {\n            initialize(m) {\n                if (((m instanceof Patterns) || (m instanceof CaptureInfo)) && (m.name)) {\n                    this.registerName(m.name);\n                }\n            },\n            registerName(n) {\n                if (n.length <= 0) return;\n                _names[n] = 1;\n            }\n        }, pattern_class_name);\n        Object.defineProperty(formatter, 'registerNames', { get() { return _names; } });\n        formatter._funcRegistryExpression = function () {\n            if (_registryExpression != null) {\n                return _registryExpression;\n            }\n            let registry = {};\n            let _entry = [];\n            for (let i in _names) {\n                if (i == 'global') {\n                    throw new Error('global is reserved');\n                }\n                i.split(' ').forEach(m => {\n\n                    Utils.DefineProp(m, undefined, registry);\n                    let n = m.split('.')[0];\n                    if (_entry.indexOf(n) == -1) {\n                        _entry.push(n);\n                    }\n                });\n            }\n            _registryExpression = { namespaces: _entry, registry };\n            return _registryExpression;\n        };\n        if (!formatter.settings) {\n            formatter.settings = new FormatterSetting();\n        }\n\n        Object.defineProperty(formatter, 'formatting', { get() { return formatter.settings.getCodingStyleFormatting(); } });\n        Object.defineProperty(formatter, 'registryClassName', { get() { return pattern_class_name; } });\n        NativeRegExp.Restore();\n        return formatter;\n    }\n    static CreateDefaultOption() {\n        return new FormatterSetting;\n    }\n    #createListener() {\n        const { listener } = this;\n        let _o = null;\n        if (listener) {\n            if (typeof (listener) == 'function')\n                // + | invoke function listener creator\n                _o = listener.apply(this);\n            else\n                _o = listener;\n        }\n        return _o || new FormatterListener();\n    }\n    /**\n     * init marker definition\n     * @param {*} option \n     * @returns \n     */\n    #initDefinition(option) {\n        const _rg = option || this.settings || Formatters.CreateDefaultOption();\n\n        let _listener = this.#createListener();\n\n        let _formatterBuffer = new FormatterBuffer;\n        _formatterBuffer.id = '_global_';\n        const m_constants_def = {\n            PrevLineFeedConstant: new PrevLineFeedConstantPattern,\n            PrevConstant: new PrevConstantPattern,\n            GlobalConstant: new GlobalConstantPattern,\n            StreamLineConstant: new StreamLineConstantPattern,\n            StreamBufferConstant: new StreamBufferConstantPattern,\n            TrimmedPrevLineFeedConstant: new TrimmedPrevLineFeedConstant,\n            refConstantClass: RefConstantPattern\n        };\n        let objClass = new FormatterOptions(this, _formatterBuffer, _listener, m_constants_def, _rg);\n        this._storeObjClass(objClass);\n        return objClass;\n    }\n    /**\n     * transform data to \n     * @param {string|string[]} data \n     * @param {string} target\n     * @param {*} option \n     */\n    transformTo(data, target, option) {\n        throw new Error('transform not implement');\n    }\n    _initDebug() {\n        let { debug } = this;\n        if ((!debug === null) || (debug == undefined) || (debug instanceof FormatterDebugger))\n            return;\n        if (typeof (debug) == 'boolean') {\n            debug = debug ? FormatterDebugger.DebugAll() : null;\n        } else if (debug && !(debug instanceof FormatterDebugger)) {\n            debug = FormatterDebugger.Load(debug);\n        } else\n            debug = null;\n        this.debug = debug;\n    }\n    /**\n     * format the data\n     * @param {string|string[]} data \n     * @param {null|undefined|{name:string, constantName:string, depth:number, complete: null|()=>* = null}} option format option \n     * @returns \n     */\n    format(data, option=null) {\n        this._initDebug();\n        NativeRegExp.Save();\n        \n\n        if (!Array.isArray(data)) {\n            if (typeof (data) == 'string') {\n                data = data.split(\"\\n\");\n            }\n            else throw new Error('argument not valid');\n        }\n        if (typeof (this.scopeName) == 'undefined') {\n            throw new Error('scopeName is not defined');\n        }\n        let { objClass, info} = this;\n        /**\n         * @type {FormatterOptions}\n         */\n        //let objClass = this.objClass;\n        if (!objClass) {\n            objClass = this.#initDefinition(option);\n        } else {\n            if (info.isSubFormatting == 0) {\n                objClass.reset();\n            }\n        }\n        // setup source option\n        objClass.sourceOption = option;\n\n\n        let _matcherInfo = null;\n        let _formatter = this;\n        let _trimStart = true;\n        // let pos = 0;\n        const { debug, lineFeed } = objClass;\n        const { tabStop, useIndent } = this.settings;\n\n        if (!this.info?.isSubFormatting) {\n            objClass.blockStarted = false;\n        }\n        if (this.info?.isSubFormatting) {\n            _trimStart = false;\n        }\n\n        const _trimEndOutput = (_output, option) => {\n            if (option.lastSegment?.info?.trimmed) {\n                const g = option.lastSegment.toString();\n                // + | trim last segment  \n                while (_output.length > 0 && (_output.endsWith(g))) {\n                    _output = _output.substring(0, _output.length - g.length - 1).trimEnd();\n                }\n            }\n            return _output;\n        };\n        // option = objClass;\n        // + | ------------------------------------------------------------\n        // + | START : FORMATTER LOGIC\n        // + | ------------------------------------------------------------\n        const _output_fc = () => {\n            const { formatting } = _formatter;\n\n            function _update_start_line_flag(_start_line_flag, option) {\n                const { pos } = option;\n                if (!_start_line_flag && option.skipMarkerFlag && (option.range.start < pos)) {\n                    let _l = option.line.substring(option.range.start, pos);\n                    if (_l.trim().length > 0)\n                        option.appendToBuffer(_l, option.constantPattern());\n                    option.storeRange(pos);\n                    option.skipMarkerFlag = false;\n                }\n            }\n            const _is_sub_formatting = _formatter.info.isSubFormatting > 0;\n            const { lineMatcher, lineSegments } = objClass;\n            let _nextLineOffset = 0;\n\n            data.forEach((line) => {\n                // + | update next line offset\n                objClass.lineOffset = _nextLineOffset;\n                _nextLineOffset += line.length + 1; \n                // + | start \n                let _start_line_flag = false; // flag to handle end streaming content\n                lineSegments.clear(); // reset line segments\n                if (this.skip_r) {\n                    return;\n                }\n                /**\n                 * @type {FormatterOptions} \n                 */\n                const option = objClass;\n                debug?.feature('read-line') && Debug.log('read:[' + objClass.lineCount + \"]:::\" + line);\n                objClass.resetRange();\n                lineMatcher.sourceLine = line;\n                objClass.continue = false;\n                objClass.lineCount++;\n                objClass.markerDepth = 0;\n                objClass.startLine = true;\n                if (_matcherInfo) {\n                    if (!_matcherInfo.marker.allowMultiline) {\n                        throw new Error(`marker '${_matcherInfo.name}' do not allow multi line.`);\n                    }\n                    objClass.continue = _matcherInfo.marker.newLineContinueState;\n                    objClass.lineJoin = false;\n                    _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n\n                } else {\n                    let _nextLine = (_trimStart && !useIndent ? objClass.line.trimStart() : objClass.line);\n                    if (objClass.nextGlueValue) {\n                        _nextLine = objClass.nextGlueValue + _nextLine;\n                        objClass.nextGlueValue = null;\n                    }\n                    // + | update offset line \n                    let _nextPosOffset = objClass.line.length - _nextLine.length;\n                    //_nextLineOffset+= _nextPosOffset;\n                    objClass.lineOffset += _nextPosOffset;\n                    // update the source line\n                    lineMatcher.sourceLine = _nextLine;\n                    _trimStart = true;\n                }\n                if (line.length <= 0) {\n                    return;\n                }\n                let ln = objClass.length;\n                let pos = objClass.pos;\n                _formatter._updateLineFeed(objClass, (pos == 0) && !objClass.lineFeedFlag);\n                objClass.loopStart();\n                let _lastPost = pos;\n                while (pos < ln) {\n                    objClass.continue = false;\n                    _start_line_flag = true;\n                    objClass.markerDepth = 0;\n                    _lastPost = pos;\n                    if (_matcherInfo) {\n                        objClass.continue = true;\n                        objClass.storeRange(objClass.pos);\n                        _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                    } else {\n                        _matcherInfo = Utils.GetPatternMatcher(this.patterns, objClass);\n                        if (_matcherInfo) {\n                            this._updateLineFeed(objClass, objClass.startLine);\n                            objClass.storeRange(pos, _matcherInfo.index);\n                            _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                            _update_start_line_flag(false, objClass);\n                        } else {\n                            objClass.markerDepth = 0;\n                            let p = objClass.line.substring(objClass.pos);\n                            if (!_is_sub_formatting)\n                                p = p.trimEnd();\n                            if (objClass.lineFeedFlag) {\n                                p = _trimStart && !useIndent ? p.trimStart() : p;\n                            }\n                            if (p.length > 0) {\n                                this._updateLineFeed(objClass, objClass.startLine);\n                                objClass.appendToBuffer(p, objClass.constantPattern());\n                            }\n                            objClass.pos = ln;\n                        }\n                    }\n                    pos = objClass.pos;\n                    ln = objClass.length;\n                    ((option) => {\n                        const { loopInfo } = option;\n                        if (_lastPost == pos) {\n                            // + | possibility of infine loop detection\n                            if (loopInfo.matcher != _matcherInfo) {\n                                loopInfo.matcher = _matcherInfo;\n                            }\n                            loopInfo.position = pos;\n                            if (loopInfo.count > 1) {\n                               throw new Error('infine loop detected : ' + JSON.stringify(loopInfo));\n                               //console.log(\"apply ... \", {ln, pos,  count: loopInfo.count });\n                            }\n                            loopInfo.count++\n                        } else {\n                            loopInfo.count = 0;\n                        }\n                    })(objClass);\n                    if (this.skip_r) {\n                        return;\n                    }\n                    _update_start_line_flag(_start_line_flag, objClass);\n                }\n                _update_start_line_flag(_start_line_flag, objClass);\n\n                objClass.lineJoin = true;\n                if (_matcherInfo) {\n                    if (ln >= pos) {\n                        if (1 || !objClass.skipEndOfLine) {\n\n                            objClass.EOL = true;\n                            if (_matcherInfo.isCaptureToEndLine(objClass)) {\n                                objClass.lineMatcher.setPosition(pos, pos);\n                            }\n                            _matcherInfo = _formatter._handleCheckCloseMarker(_matcherInfo, objClass);\n                            objClass.EOL = false;\n                        } else {\n\n                            objClass.skipEndOfLine = false;\n                        }\n                    } else {\n                        this._updateMarkerFormatting(_matcherInfo, objClass);\n                    }\n                }\n                formatting.updateEndLineUpdateMode(_matcherInfo, option);\n            });\n            if (this.skip_r) {\n                this.skip_r = false;\n                return null;\n            }\n            ((option) => {\n                // + | close matcher \n                if (_matcherInfo) {\n                    if (!this.info.isSubFormatting) {\n                        debug && Debug.log('...EOF...' + _matcherInfo.toString());\n                        option.EOF = true;\n                        option.lineMatcher.reset();\n                        // option.lineMatcher.offset = 61;\n                        //option.lineMatcher.setPosition(option.length);\n                        while (_matcherInfo) {\n                            //\n                            // + | close matcher - handle \n                            //\n                            _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                            option.lineMatcher.reset();\n                        }\n                        option.EOF = false;\n                    } else {\n                        if (_matcherInfo.parent)\n                            throw new Error('missing close definition');\n                    }\n                }\n            })(objClass);\n\n            debug?.feature('end') && (() => {\n                Debug.log('...end...');\n                console.log({\n                    depth: objClass.depth\n                });\n            })();\n            if ((objClass.markerInfo.length > 0) && (this.info.isSubFormatting == 0)) {\n                const _formatting = this.formatting;\n                // missing close marker info \n                while (objClass.markerInfo.length > 0) {\n                    let _old = objClass.shiftMarker();\n                    this._handleLastExpectedBlock(_old, objClass, _formatting);\n                }\n\n            } else {\n                objClass.markerInfo.length = 0;\n            }\n            objClass.store();\n            let _output = \"\";\n\n            if (!this.info?.isSubFormatting && (objClass.tokenList.length > 0)) {\n                throw new Error('token list have childs');\n            }\n            if (!this.info?.isSubFormatting && this.listener) {\n                // + | call end listener \n                const { listener } = this.objClass;\n                const { endContent, endOutput, treatOutput } = listener;\n                if (treatOutput) {\n                    _output = listener.treatOutput({ output: objClass.output, lineFeed, tabStop, option: this.objClass });\n                } else {\n                    _output = objClass.output.join(lineFeed).trimEnd();\n                    _output = _trimEndOutput(_output, objClass);\n\n                }\n                if (endOutput) {\n                    _output += listener.endOutput({ lineFeed });\n                }\n                if (endContent) {\n                    _output += listener.endContent();\n                }\n            } else {\n                _output = objClass.output.join(lineFeed);\n                if (!this.info?.isSubFormatting) {\n                    _output = _output.trimEnd();\n                    _output = _trimEndOutput(_output, objClass);\n                }\n            }\n            // + | clear buffer list  \n            this.objClass.formatterBuffer.clearAll();\n            return _output;\n        };\n        let _output = null;\n        try {\n            _output = _output_fc();\n            if ((this.info.isSubFormatting == 0) && (typeof (option?.complete) == 'function')) {\n                option.complete({ formatter: this });\n            }\n        } catch (e) {\n            if (this.error) {\n                if (!Array.isArray(this.error)) {\n                    this.error = [this.error];\n                }\n                this.error.push(e.message);\n            }\n            else {\n                this.error = e.message;\n            }\n            debug && console.error('Error : ' + e.message);\n        }\n        NativeRegExp.Restore();\n        return _output;\n    }\n    _updateLineFeed(option, startLine = false) {\n        if (option.skipUpdateStartLine) {\n            option.skipUpdateStartLine = !1;\n            return;\n        }\n        option.startLine = startLine;\n        if (option.lineFeedFlag) {\n            if (!option.formatterBuffer.isEmpty) {\n                option.store();\n                option.lineFeedFlag = !1;\n            }\n            option.startLine = true;\n        }\n    }\n    /**\n     * check for closing do not update markerInfo - specification \n     * @param {*} patternInfo \n     * @param {FormatterOptions} option \n     */\n    _handleCheckCloseMarker(patternInfo, option) {\n        const { debug } = option;\n        debug && Debug.log(\"---::check close marker::---\" + patternInfo.toString());\n        let _p = null;\n        let _matcher = null;\n        let _line = option.line.substring(option.pos);\n        // for check get and check if _old is avaiable \n        // let _old = (markerInfo.length > 0) && (markerInfo[0].marker == patternInfo) ? markerInfo[0] : null;\n        ({ _p, _matcher } = this.detectPatternInfo(_line, patternInfo, option));\n        if (_p && (_matcher == null)) {\n            return this._handleMarker(patternInfo, option);\n        }\n        if (_p && _matcher) {\n            if (_matcher.group.index == _p.index) {\n                // + | priority to pattern info\n                // + | ---------------------\n                let _tpret = this._handleMarker(patternInfo, option);\n                // + | same group end -\n                return _tpret;\n            }\n        }\n        if (_matcher) {\n            // + | a matcher that target end on line\n            if (_matcher.isStreamCapture) {\n                // + | start new stream capture \n                const cp = this._startStreamingPattern(_matcher, '', null, option, null, null, '', true);\n                return cp;\n            }\n            return this._handleMarker(_matcher, option);\n        }\n        return patternInfo;\n    }\n    _handleSameGroupMatch(_matcher, option) {\n        this._checkStartBlockDefinition(_matcher, option);\n        let _ref = this._handleMarker(_matcher, option);\n        return _ref;\n    }\n    /**\n     * update marker formatting mode\n     * @param {*} _marker \n     * @param {*} option \n     * @param {*} force \n     */\n    _updateMarkerFormatting(_marker, option, force = false) {\n        // | update formatting \n        const { formatting } = this;\n        if (_marker.formattingMode) {\n            formatting.formatBufferMarker(this, _marker, option, force);\n        } else {\n            this._updateNextMode(option, _marker, force);\n        }\n    }\n    updateBuffedValueAsToken(_buffer, _marker, option) {\n        option.formatterBuffer.clear();\n        option.appendToBuffer(_buffer, _marker);\n        option.store();\n        _buffer = option.flush(true);\n        option.formatterBuffer.appendToBuffer(_buffer, _marker);\n    }\n    /**\n     * check for last missing value - \n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _old \n     * @returns \n     */\n    _lastExpectedMatchResult(marker, option, _old) {\n        // +| check for last missing value\n        // const _formatting = this.formatting;\n        const { endMissingValue, group, isEndCaptureOnly } = marker;\n        let _p = [];\n        let regex = '';\n        if (!isEndCaptureOnly) {\n            if ((endMissingValue != undefined) && (endMissingValue !== null)) {\n\n                if (endMissingValue instanceof FormatterEndMissingExpression) {\n                    const engine = FormatterEndMissingEngine.Get(this.scopeName);\n                    // _value = _old?.data.dataSegment.join('') || group[0];\n                    let _cvalue = endMissingValue.load(group,\n                        (s) => Utils.ReplaceRegexGroup(Utils.RegExToString(s), group),\n                        engine, _old?.data, marker, option);\n                    if (_old) {\n                        // + update value - content value\n                        _old.content = _cvalue;\n                        _p = Utils.CreateEndMatch('');\n                        return _p;\n                    }\n                } else {\n                    regex = Utils.ReplaceRegexGroup(endMissingValue, group);\n                }\n            } else {\n                if (_old && (_old.marker.end.toString() != \"/$/d\"))\n                    regex = Utils.ReplaceRegexGroup(Utils.RegExToString(marker.end), group);\n            }\n            //remove escaped litteral\n            regex = regex ? regex.replace(/\\\\/g, \"\") : '';\n        }\n        _p.push(regex);\n        _p.indices = [[0, regex.length]];\n        _p.index = 0;\n        _p.input = '\\0';\n        return _p;\n    }\n    _handleLastExpectedBlock(_old, option, _formatting) {\n\n        const { marker } = _old;\n        const _group = marker.group;\n        if (marker.marker.throwErrorOnEndSyntax) {\n            throw new Error('invalid syntax');\n        }\n        if (marker.isEndCaptureOnly) {\n            return;\n        }\n        let regex = '';\n        const line = option.line;\n        let _append = line.substring(_group.index);\n\n        if (_old.marker.end.toString() != \"/$/d\")\n            regex = Utils.ReplaceRegexGroup(Utils.RegExToString(marker.end), _group, 'end');\n        regex = regex.replace(/\\\\/g, \"\"); //remove escaped litteral\n        _formatting.onLastExpectedBlockStart({ option, _old });\n        let _p = [];\n        let f = null;\n        _p.push(regex);\n        _p.indices = [[0, regex.length]];\n        _p.index = 0;\n        if (marker.isBlock) {\n            option.line = regex;\n            option.pos = 0;\n            let _buffer = option.buffer;\n            f = _formatting.onLastExpectedBlock({\n                mode: marker.mode,\n                buffer: _buffer,\n                option: option,\n                formatter: this\n            });\n\n            f = f == null ? _old.content + option.flush(true) : f;\n            return this._handleFoundEndPattern(f, regex, marker, _p, option, _old);\n        }\n\n        const _ln = _append.length;\n        _p.index = _ln;\n        _append += regex;\n        option.pos = _ln;\n        option.storeRange(_ln);\n        return this._handleFoundEndPattern('', _append, marker, _p, option, _old);\n    }\n\n    _isBlockAndStart(_marker, option) {\n        return _marker.isBlock && !option.continue;\n    }\n\n    /**\n     * \n     * @param {FormatterOptions} option \n     */\n    _startBlock(option) {\n        option.depth++;\n        const { output, tabStop, depth, formatterBuffer, listener } = option;\n        if (typeof (listener?.startNewBlock) == 'function') {\n            listener.startNewBlock({ buffer: '', formatterBuffer, output, tabStop, depth });\n        }\n        // + | \n        // + | begin start block \n        // + | \n        option.startBlock = true;\n    }\n    /**\n     * get new tokens array \n     * @returns \n     */\n    getTokens() {\n        return [this.scopeName];\n    }\n    /**\n     * get Marker captures depending on markerInfo\n     * @param {CaptureInfo|PatternMatchInfo} _markerInfo \n     * @param {*} end \n     * @returns \n     */\n    getMarkerCaptures(_markerInfo, end = false) {\n\n        if (_markerInfo instanceof CaptureInfo) {\n            return _markerInfo.captures;\n        }\n        const { marker } = _markerInfo;\n        if (!marker) {\n            return null;\n        }\n        const _type = marker.matchType;\n        if (_type == 0) {\n            const s = end ? marker.endCaptures : marker.beginCaptures;\n            return { ...marker.captures, ...s };\n        }\n        return { ...marker.captures };\n    }\n\n    /**\n     * register token name\n     * @param {PatternMatchInfo} marker \n     * @param {FormatterOptions} option \n     */\n    _registerTokenName(marker, option) {\n        const { name, isShiftenName, matchType } = marker;\n        const { tokenList } = option;\n        //+ | add token to global token list \n        if (name && (matchType == 0) && (!isShiftenName)) {\n            Utils.StoreTokens(name, tokenList);\n            marker.isShiftenName = true;\n        }\n    }\n    _updatePrevPatternPrevConstant(_marker, option) {\n        this._updatePatternPrevConstant(_marker, option);\n        option.storeRange(option.pos);\n    }\n    /**\n     * core handle marker handle marker \n     * @param {PatternMatchInfo} _marker \n     * @param {*} option \n     */\n    _handleMarker(_marker, option) {\n        if (!_marker) return;\n        if (!option.continue) {\n            this._updatePrevPatternPrevConstant(_marker, option);\n        }\n\n        const { matchType } = _marker.marker;\n        this._registerTokenName(_marker, option);\n        option.markerDepth++;\n        // + | each callback must return a marker or null \n        const handle = this._handleCallback(matchType, option) ||\n            ((m, option) => m.handleMarkerListener ? m.handleMarkerListener(option) : null)(_marker.marker, option);\n        if (!handle || (typeof (handle) != \"function\")) {\n            throw new Error(\"marker type handler is not a valid callback.\" + matchType);\n        }\n        let ret = handle.apply(this, [_marker, option]);\n        this._updateFormatModeFromTo(_marker, ret, option);\n        return ret;\n    }\n    /**\n     * replace with condition \n     * @param {PatternMatchInfo} _marker \n     * @param {*} value \n     * @param {*} group \n     * @param {*} option \n     * @param {*} _refObj \n     * @param {boolean} treat \n     * @returns \n     */\n    _operationReplaceWith(_marker, value, group, option, _refObj, treat = true) {\n        let _formatter = this;\n        const { replaceWith, replaceWithCondition } = _marker;\n        let g = group;\n        _refObj = _refObj || {};\n        if (!replaceWith) {\n            _refObj.replaced = false;\n            return value;\n        }\n        let _tab = replaceWith;\n\n        if (_tab instanceof ReplaceWithCondition) {\n            _tab = [_tab];\n        }\n        if (Array.isArray(_tab)) {\n            _tab = _tab.slice(0);\n\n            // + array of replace with conditions\n            while (_tab.length > 0) {\n                const q = _tab.shift();\n                const { expression, match, captures } = q;\n                if (!expression) {\n                    // + | skip missing expression\n                    continue;\n                }\n                if (match) {\n                    const _p = { replaced: true, g, _rpw: null };\n                    const tvalue = Utils.ReplaceWithCheck(expression, value, q, _p);\n                    if (_p.replaced) {\n                        const { _rpw } = _p;\n                        value = Utils.DoReplaceWith(tvalue, _formatter, _rpw, g, _marker, option, captures, treat);\n\n                        return value;\n                    }\n                }\n            }\n        }\n        else {\n            let _rpw = Utils.RegExToString(replaceWith);\n            const _cond = replaceWithCondition;\n            let match = _cond?.match;\n            const _captures = _cond?.captures;\n\n            if (match) {\n                let _op = _cond.operator || '=';\n                let _s = Utils.ReplaceRegexGroup(_cond.check, g);\n                if (/(!)?=/.test(_op)) {\n                    let r = match.test(_s);\n                    if (_op) {\n                        if (((_op == '=') && !r) || ((_op == '!=') && (r))) {\n                            _refObj.replaced = false;\n                            return value;\n                        }\n                    }\n                } else if (/(\\<\\>)=/.test(_op)) {\n                    let _ex = match.toString().replace(/\\\\\\//g, '');\n                    if (\n                        ((_op == \">=\") && (_s >= _ex)) ||\n                        ((_op == \"<=\") && (_s <= _ex))\n                    ) {\n                        if (_s >= _ex) {\n                            _refObj.replaced = false;\n                            return value;\n                        }\n                    }\n                }\n            }\n\n            value = Utils.DoReplaceWith(value, _formatter, _rpw, g, _marker, option, _captures, treat);\n            return value;\n        }\n        _refObj.replaced = false;\n        return value;\n    }\n    /**\n     * from type retrieve the handler type \n     * @param {*} type \n     * @returns \n     */\n    _handleCallback(type, option) {\n        // + handle callback\n        return {\n            \"0\": option.listener?.handleBeginEndMarker || this._handleBeginEndMarker,\n            \"1\": option.listener?.handleMatchMarker || this._handleMatchMarker,\n            \"2\": option.listener?.handleBeginWhile || this._handleBeginWhile,\n            \"3\": option.listener?.handleMatchTransform || this._handleMatchTransform,\n        }[type]\n    }\n    _handleMatchTransform(marker, option) {\n        const { parent } = marker;\n        let _cm_value = marker.group[0];\n        let op = [];\n        this._registerTokenName(marker, option);\n        _cm_value = this.treatMarkerValue(marker, _cm_value, op, option, marker.group, true);\n        if (_cm_value.length > 0) {\n            if (op.data) {\n                option.formatterBuffer.appendToBuffer({\n                    dataSegments: op.data.dataSegment,\n                    bufferSegments: op.data.bufferSegment\n                });\n            } else\n                option.appendToBuffer(op.data, marker);\n        }\n        option.matchTransform = marker;\n        return parent;\n\n    }\n    _onStartMarker(markerInfo, option, { type }) {\n        const { listener } = this;\n        if (listener?.onStartHandler)\n            listener.onStartHandler(markerInfo, option, { type,\n         formatter: this ,\n         isSubFormatting: this.info.isSubFormatting > 0});\n\n    }\n    /**\n     * on end handler\n     * @param {PatternMatchInfo} markerInfo \n     * @param {FormatterOptions} option \n     */\n    _onEndHandler(markerInfo, option) {\n        const { tokenList } = option;\n        const { listener } = this;\n\n        if (listener?.onEndHandler)\n            listener.onEndHandler(markerInfo, option,{\n        isSubFormatting: this.info.isSubFormatting > 0,\n        ...Formatters.EndListenerArguments(markerInfo, option)\n        }, this);\n\n        if (markerInfo.isShiftenContentName) {\n            this._shiftPatternContentName(markerInfo, option);\n        }\n        if ((markerInfo.isShiftenName) && (tokenList.length > 0)) {\n            Utils.UnshiftTokens(markerInfo.name, tokenList);\n            markerInfo.isShiftenName = false;\n        }\n        // reset option flag\n        if (option.isGlueValue) {\n            console.log(\"glue value\");\n        }\n    }\n    /**\n     * \n     * @param {*} _cm_value \n     * @param {*} _marker \n     * @param {*} option \n     * @param {FormatterMatchTreatment} _op \n     * @param {*} group \n     * @param {boolean} group match treatment\n     * @param {boolean} treat treatement\n     * @returns \n     */\n    _treatMatchValue(_cm_value, _marker, option, _op, group, treat = true) {\n        group = group || _marker.group;\n        const _ref_segment = treat ? {} : true;\n        _cm_value = this.treatMarkerValue(_marker, _cm_value, _op, option, this._getMatchGroup(group), _ref_segment);\n        if (treat) {\n            if (_op.treated) {\n                _op.data = _ref_segment.segments.dataSegment.join('');\n                _op.segments = _ref_segment.segments;\n                return _cm_value;\n            }\n            const _bck = _cm_value;\n            _cm_value = this._treatMatchResult(_cm_value, _op, _marker, option);\n            // + | update op.data  to store data to store after match treated\n            if ((_op.indexOf('replaceWith') != -1) || (_cm_value != _bck)) {\n                _op.data = _bck;\n            }\n        }\n        return _cm_value;\n    }\n    /**\n     * treat transform capture\n     * @param {*} _cm_value \n     * @param {*} _marker \n     * @param {*} _captures \n     * @returns \n     */\n    _treatTransform(_cm_value, _marker, _captures) {\n        const _tmatch = _marker.transformMatch || _marker.match;\n        _captures = _marker.transformCaptures || _captures;\n        if ((_cm_value.length > 0) && (_captures)) {\n\n            // + passing transformed to data\n            const _group = _tmatch ? _tmatch.exec(_cm_value) : null;\n            if (_group) {\n                // copy groups\n                _group.index = _marker.group.index;\n                _marker.group.length = 0;\n                _marker.group.indices = _group.indices;\n                _group.forEach(a => _marker.group.push(a));\n            } else {\n                if (_marker.matchType == 1)\n                    throw new Error(\"failed transform error match error. use transform capture to handle\")\n            }\n        }\n        return { _captures };\n    }\n    _treatMatchResult(_cm_value, _op, _marker, option) {\n        let _captures = _marker.captures;\n        if (_op.indexOf('transform') != -1) {\n            ({ _captures } = this._treatTransform(_cm_value, _marker, _captures));\n        }\n        if (_op.indexOf('replaceWith') == -1) {\n            if (_captures) {\n                _cm_value = option.treatBeginCaptures(_marker, _captures);\n            }\n        }\n        if (_marker.patterns?.length > 0) {\n            const new_value = Utils.TreatPatternValue(_cm_value, _marker.patterns, _marker.group, option);\n            _cm_value = new_value || _cm_value;\n        }\n        return _cm_value;\n    }\n\n    _getMatchGroup(group) {\n        const _formatter = this;\n        return (_formatter.info.isSubFormatting > 0) ?\n            _formatter.info.captureGroup : group;\n    }\n    _operateOnFramebuffer(_marker, option, _old) {\n        return HandleFormatting.apply(this, [_marker, option, _old]);\n    }\n    /**\n     * handle to end \n     */\n    _handleToEndPattern(_marker, line, option) {\n        const bck = { line: option.line, pos: option.pos };\n        let _ret = null;\n\n        if (_marker.isStreamCapture) {\n            // + | Update Stream Marker Info\n            this._updateMarkerOldContentOrSwapBuffer(_marker, null, '', _marker.endRegex, option);\n        }\n        option.setSourceLine(line);\n        option.TOEND = true;\n        _ret = this._handleMarker(_marker, option);\n        option.TOEND = false;\n        option.setSourceLine(bck.line, bck.pos + option.pos);\n        return _ret;\n    }\n    /**\n     * detected array operation\n     * @param {{replaceWith:string|RegExp, transform:string|string[]}} _marker \n     * @param {string} c value \n     * @param {string[]} op detected operatrion\n     * @param {*} option to handle start line transform \n     * @param {*} group to handle start line transform \n     * @param {?boolean} treat to handle start line transform \n     * @returns \n     */\n    treatMarkerValue(_marker, c, op, option, group, treat = true) {\n        if (_marker.replaceWith) {\n            // + | do replaceWith - replace \n            const _refObj = { replaced: true };\n            const _treat = treat === true ? {} : treat;\n            c = this._operationReplaceWith(_marker, c, group || _marker.group, option, _refObj, _treat);\n            if (_refObj.replaced) {\n                op.push('replaceWith');\n                op.data = _treat.segments;\n            }\n        }\n        if (_marker.transform && (op.indexOf('replaceWith') == -1)) {\n            // + | do transform\n            c = Utils.StringValueTransform(c, _marker.transform);\n            op.push('transform');\n        }\n        if (option && (option.startLine) && _marker.startLineTransform) {\n            c = Utils.StringValueTransform(c, _marker.startLineTransform);\n            op.push('startLineTransform');\n        }\n        return c;\n    }\n    treatEndMarkerValue(marker, option ){\n        const c = marker.value.source;\n        const group = [c];\n        const op = [];\n        if (marker.replaceWith){\n\n            let r = this.treatMarkerValue(marker, c, op, option, group, true);\n\n           // console.log(\"sample \", c, r);\n            // marker.value = {\n            //     'source':r,\n            //     'data':r\n            // };\n            option.formatterBuffer.clear(); \n            option.formatterBuffer.appendToBuffer(r);\n            \n        }\n    }\n    /**\n     * append constant\n     * @param {*} patternInfo \n     * @param {string} value \n     * @param {FormatterOptions} option \n     * @param {bool} append_child append to child \n     * @param {*} constant_type_marker type matcher\n     */\n    _appendConstant(patternInfo, value, option, append_child = true, constant_type_marker = null) {\n        let { debug, listener } = option;\n        let { formatting } = this;\n        debug?.feature('render/constant') && Debug.log('--::appendConstant::--[' + value + ']');\n        let _fempty = (value.trim().length == 0);\n        if (option.startBlock && _fempty) {\n            return;\n        }\n\n        let _def_type = option.constants.PrevLineFeedConstant;\n        value = formatting.treatConstantValue(value, patternInfo, option);\n        if (_fempty) {\n            // + | can be trimmed\n            _def_type = option.constants.TrimmedPrevLineFeedConstant;\n        }\n        let _inf = new PatternMatchInfo;\n        _inf.use({ marker: constant_type_marker || _def_type, line: option.line, index: -2, formatting });\n\n        formattingSetupPatternForBuffer(patternInfo, option);\n        const fc_update = () => {\n            formatting.updateBufferConstant(value, patternInfo.mode, _inf, option);\n        }\n        if (append_child) {\n            patternInfo.childs.push(_inf);\n        }\n        if (listener?.appendConstant) {\n            listener.appendConstant({ update: fc_update, patternInfo, data: value, option, _inf });\n        } else {\n            fc_update();\n        }\n        // + | \n        // + | missing update pattern mode from constant logic\n        // + |\n        patternInfo.mode = _inf.mode;\n    }\n\n    /**\n     * detect an start streaming pattern \n     * @param {*} patternInfo \n     * @param {*} _line \n     * @param {*} _endRegex \n     * @param {*} option \n     * @returns \n     */\n    _startStreamingPattern(patternInfo, _line, _endRegex, option, _error, _old, _buffer, end_line = false) {\n        const { debug } = option;\n        const { group } = patternInfo;\n        const { formatting } = this;\n        let _nextOffset = option.line.length;\n\n        debug?.feature('stream-start') && Debug.log(\"---::: START STREAMING :::--\" + patternInfo.toString());\n        // + switch depending on formatting mode\n        if (patternInfo.formattingMode == 4) {\n            // + | start formatting with streaming object \n            option.pos = patternInfo.index;\n            const _streaming = this._createStreamConstantPattern(patternInfo, '', _endRegex, option);\n            // this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);            \n            return _streaming;\n        }\n        // start streaming need to catch startLine before swapping buffer\n        let _startLine = option.startLine;\n        let _start_block = patternInfo.isBlock && !patternInfo.isBlockStarted && !patternInfo.blockStartInfo;\n        if (_start_block) {\n            this._checkStartBlockDefinition(patternInfo, option, true);\n        }\n\n        if (_old) {\n            const _oldMarker = _old.marker;\n            if ((_oldMarker != patternInfo) || (option.pos < group.index)) {\n                option.storeRange(option.pos, group.index);\n                this._updateStreamRangeModeToHolder(_oldMarker, option, _old);\n            }\n            option.markerInfo.unshift(_old);\n        } else {\n            _old = this._updateMarkerOldContentOrSwapBuffer(patternInfo, null, _buffer, _endRegex, option);\n        }\n        if (_start_block) {\n            formatting.oldStartStreamingBlock(_old);\n        }\n        option.startLine = _startLine;\n        if (end_line) {\n            if ((_line.trim().length > 0) || (_old.start)) {\n                option.appendToBuffer(_line, patternInfo);\n            }\n            option.pos = _nextOffset;\n        } else {\n            let _p, _matcher;\n            ({ _p, _matcher } = this.detectPatternInfo(_line, patternInfo, option));\n            if (_p && !_matcher) {\n\n                let select = Utils.GetNextCapture(_line, patternInfo.endRegex, option);\n                let _buffer = this._updateOldMarkerContent(_old, option);\n                option.formatterBuffer.appendToBuffer(_buffer);\n                let _endpos = option.pos + select.index + select.offset;\n                option.storeRange(option.pos, _endpos);\n                let _bool = option.shiftFromMarkerInfo(patternInfo, true);\n                option.restoreBuffer(_bool);\n                if (option.pos != _endpos) {\n                    this._updatePrevPatternPrevConstant(patternInfo, option);\n                } else {\n                    option.pos = _endpos + select.offset;\n                }\n                this._onEndHandler(patternInfo, option);\n                option.skipMarkerFlag = false;\n                return patternInfo.parent;\n            }\n            else {\n                // handle the next \n                if (_matcher) {\n                    let _constant_line = option.line.substring(option.pos, _matcher.group.index);\n\n                    if (_constant_line.length > 0) {\n                        this._appendConstant(patternInfo, _constant_line, option);\n                    }\n                    option.storeRange(option.pos);\n                    this._registerTokenName(patternInfo, option);\n                    let _ret = this._handleMarker(_matcher, option);\n                    return _ret;\n                }\n            }\n\n\n        }\n        return patternInfo;\n    }\n\n    //------------------------------------------\n    //#region handle pattern property \n    _handleInstructionSeperatorProperty(_marker, option, _e) {\n        const _cm_value = _e.value;\n        if (_marker.isInstructionSeparator) {\n            let b = this.settings.isInstructionSeperator(_cm_value.trim());\n            _e.isInstructionSeparator = b;\n        }\n    }\n    _handleMatchCaptureDefinition(_marker, option, _e, { _old, group, match }) {\n        let _cm_value = group[0];// _e.value;\n        const { parent } = _marker;\n        const _formatting = this.formatting;\n        let b = _e.isInstructionSeparator;\n        let _cond = _old && ((_cm_value.length == 0) || (_cm_value.trim().length == 0)\n            && (!_formatting.allowEmptySpace(_old.marker.mode, option))) &&\n            _marker.isMatchCaptureOnly;\n        if (_cond) {\n            _e.handle = true;\n            let _gcm_value = Utils.GetNextCapture(group.input, match, option);\n            _cm_value = _gcm_value[0];\n            if (_marker.isInstructionSeparator) {\n                b = this.settings.isInstructionSeperator(_cm_value.trim());\n            }\n\n            if (parent && (group.offset == 0)) {\n                // + | match capture only definition\n                if (_old && b) {\n                    _formatting.onEndInstruction(_marker, option);\n                }\n                // + | passing to handle parent group\n                if (parent.endGroup?.index == group.index) {\n                    let _g = this._handleToEndPattern(parent, _cm_value.trim(), option);\n                    if (b && !option.formatterBuffer.isEmpty) {\n                        option.store();\n                        if (_marker.isBlock) {\n                            // + | close block \n                            _g = this._closeBlockEntry(option, _marker, _g, _marker.closeParentData);\n                        }\n                    }\n                    return _g;\n                }\n                if (_marker.closeParent) {\n                    return this._closeMarker(_marker, parent, option, _marker.closeParentData);\n                }\n            }//\n            return parent;\n        }\n    }\n    appendJoinToBuffer(value, option) {\n        option.appendToBuffer(value, new JoinMarkerPattern());\n    }\n    /**\n     * store to buffer \n     * @param {string} buffer \n     * @param {string} data \n     * @param {PatternMatchInfo} marker \n     * @param {FormatterOptions} option \n     * @param {boolean} raise \n     */\n    _storeToBuffer(buffer, data, marker, option, raise = true) {\n        const s = { buffer, data };\n        const { debug, formatterBuffer } = option;\n        Utils.UpdateMarkedSegment(s, marker);\n        debug?.feature('match-value-handler') && (() => {\n            Debug.log('--:::store to buffer:::--');\n            console.log(s);\n        })();\n        formatterBuffer.appendToBuffer(s);\n        if (raise) {\n            this.onAppendToBuffer(marker, s, option);\n        }\n    }\n    _storeMatchValueHandler(_marker, option, _e, _extra) {\n        const { _op, _old, _skip_value } = _extra;\n        let _cm_value = _e.value;\n        let _data = _e.data;\n        const q = this;\n        // const { debug, formatterBuffer } = option;\n        const _formatting = this.formatting;\n        const b = _e.isInstructionSeparator || false;\n        const _is_join = option.joinWith && option.startLine;\n        const _store_to_buffer = (_cm_value, _data, option) => {\n            if (_data != undefined) {\n                q._storeToBuffer(_cm_value, _data, _marker, option, true);\n            } else {\n                option.appendToBuffer(_cm_value, _marker);\n            }\n        };\n\n        if (b || (!_marker.lineFeed) || (option.buffer.length > 0) || (_cm_value.length > 0)) {\n\n            if (_op.indexOf('replaceWith') == -1) {\n                if (_is_join) {\n                    // join entry with join value\n                    this.appendJoinToBuffer(option.joinWith, option);\n\n                }\n                _store_to_buffer(_cm_value, _data, option);\n\n            } else {\n                if ((option.glueValue == _cm_value)) {\n                    this._onEndHandler(_marker, option);\n                    return _marker.parent;\n                }\n                // + | check to add empty space before append.\n                if (!option.skipEmptyMatchValue || (_cm_value.trim().length > 0)) {\n                    if (_is_join) {\n                        // join entry with join value\n                        option.formatterBuffer.appendToBuffer(option.joinWith);\n                    }\n                    _store_to_buffer(_cm_value, _data, option);\n                    if (option.skipEmptyMatchValue) {\n                        option.skipEmptyMatchValue = false;\n                    }\n                }\n            }\n            if (_old && b) {\n                _formatting.onEndInstruction(_marker, option);\n            }\n            option.useGlue(_marker, _cm_value);\n            this._updateJoinWith(_marker, option);\n            _e.storeValue = true;\n            this._updateNextMode(option, _marker);\n        }\n    }\n    _updateJoinWith(_marker, option) {\n        if (_marker.joinWith) {\n            option.joinWith = _marker.joinWith;\n        } else {\n            option.joinWith = null;\n        }\n    }\n    //#endregion\n    //------------------------------------------\n\n\n    //-------------------------------------------\n    //#region MATCH AND BEGIN/END START HANDLER \n\n    _handleChainHandler(_marker, _chains_match, _e_args, option) {\n        while (_chains_match.length > 0) {\n            let _handle = _chains_match.shift();\n            let _fc = null;\n            let _target = null;\n            let _cparent = null;\n            let _extra_args = null;\n\n            if (Array.isArray(_handle)) {\n                _fc = _handle[1];\n                _target = _handle[0];\n                _extra_args = (2 in _handle) ? _handle[2] : null;\n            }\n            if (_fc) {\n                _cparent = _fc.apply(_target, [_marker, option, _e_args, _extra_args]);\n                if (_e_args.handle) {\n                    if (_e_args.udpateChild) {\n                        this._updateMarkerChild(_marker);\n                    }\n                    this._onEndHandler(_marker, option);\n                    return _cparent;\n                }\n            }\n        }\n    }\n    _updateOldEntryCapture(_old, _cm_value, option) {\n        if (_old && _old.captureEntry) {\n            _cm_value = _old.captureEntry + _cm_value;\n            _old.captureEntry = null;\n\n            option.saveBuffer();\n            option.appendToBuffer(_cm_value, _old.marker);\n\n            _cm_value = option.buffer;\n            option.formatterBuffer.clear();\n            option.restoreSavedBuffer();\n            _old.childs.push(new EntryCapturePattern(_cm_value));\n\n        }\n        return _cm_value;\n    }\n\n    /**\n     * onMatch handle affect only on content match\n     * @param {PatternMatchInfo} _marker \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    _handleMatchMarker(_marker, option) {\n        // + | - handle :match/match\n        option.debug?.feature('match/match') && Debug.log('--::: Handle match marker :::--' + _marker.toString());\n        option.state = 'match';\n        const { parent, group, match, closeParentData } = _marker;\n        const { formatting } = this;\n        option.lastMarker = _marker;\n        const _old = option.peekFirstMarkerInfo();// option.parentMatcherInfo;\n        let _cm_value = group[0];\n        let _next_position = group.index + group.offset;\n        let _checkParentInfo, _endCaptureCallback;\n        // TODO: skip entired line\n        const _handle_EOL = !option.EOL && (option.line.length == _next_position);\n\n        if (_handle_EOL) {\n            option.skipEndOfLine = true;\n        }\n\n        if (!_handle_EOL && (option.pos == _next_position) && (!_marker.closeParent)) {\n            // + | not move update marker formatting\n            if (_marker.formattingMode) {\n                this._updateMarkerFormatting(_marker, option, true);\n                option.lastEmptyMarkerPattern = _marker;\n                return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, _marker.parent);\n            }\n            if (option.EOL) {\n                return parent;\n            }\n            // + | handle stop - then skip to end line\n            let _ret = this._handleStopMarker(_marker, option);\n\n            // + | --------------------------------------------\n            // + | skip line \n            // + | by reading to end of line\n            // + |\n            option.pos = option.length;\n            let _constant_line = option.line.substring(_next_position, option.pos);\n            if (_constant_line.trim().length > 0) {\n                this._appendConstant(_marker, _constant_line, option);\n            }\n            // + |\n            // + | if stop en match empty value then - return null\n            // + | + macromate definitiont\n            if (_ret) {\n                _ret = this._justCloseMarker(_ret, option);\n                option.lineFeedFlag = true;\n            }\n            return _ret;\n        }\n        _cm_value = this._updateOldEntryCapture(_old, _cm_value, option);\n        // + | update cursor position\n        option.pos = _next_position;\n        const _op = FormatterMatchTreatment.Init(_cm_value);\n        // + | store update .data\n\n        // + | treat match value\n        _cm_value = this._treatMatchValue(_cm_value, _marker, option, _op);\n\n        // + skip empty value\n        const _fake_empty = _cm_value.trim().length == 0;\n        const _option_glue = option.glueValue;\n\n        let _skip_value = ((option.startLine && _fake_empty)) ||\n            (_option_glue && (_option_glue == _marker.isGlueValue)) ||\n            (_option_glue && (_option_glue == _cm_value)) ||\n            (_cm_value == '');\n\n        // + | -----------------------------------\n        // + | skip value on non empty glue values\n        // + |\n        if (!_skip_value && _marker.isGlueValue && _marker.skipGlueOnLineEnd && option.isEOL){\n            _skip_value =  true;\n        }\n\n        if (parent && !_skip_value && parent.isEndCaptureOnly) {\n            // passing to parent \n            let _p = parent.endGroup;\n            if (_p && (_next_position >= _p.index)) {\n                ({ _checkParentInfo, _endCaptureCallback } = this._handleCheckParentInfo(\n                    parent, _marker, _p, _old, option, '', '', group.index, \"match\"));\n            }\n        }\n        // + | inject argurment  \n        let _e_args = {\n            handle: false,\n            value: _cm_value,\n            state: 'match',\n            udpateChild: true,\n            _skip_value,\n            isInstructionSeparator: false,\n            data: _op.data\n        };\n        let _chains_match = [\n            [this, this._handleInstructionSeperatorProperty],\n            [this, this._handleCloseParentProperty, { closeParentData }],\n            [this, this._handleMatchCaptureDefinition, { _old, group, match }],\n            [this, function (_marker, option, _e) {\n                if (_e._skip_value) {\n                    _e.handle = true;\n                    _e.udpateChild = false;\n                    if (_marker.isBlock && _marker.parent) {\n                        // + | close block - consider as a block definition \n                        return this._closeBlockEntry(option, _marker, _marker.parent, closeParentData);\n                    }\n                    if (_marker.parent) {\n                        // +| update next mode with parent\n                        this._updateNextMode(option, _marker.parent);\n                    }\n                    return _marker.parent;\n                }\n            }],\n            [this, this._storeMatchValueHandler, { _op, _old }]\n        ];\n        let _ret = this._handleChainHandler(_marker, _chains_match, _e_args, option);\n        if (_e_args.handle) {\n            return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, _ret);\n        }\n        this._updateMarkerChild(_marker);\n        // + | marker is not a line feed directive or buffer is not empty - end instruction directive\n        if (!_e_args.storeValue) {\n            this._storeMatchValueHandler(_marker, option, _e_args, { _op, _old });\n        }\n        this._onEndHandler(_marker, option);\n\n        formatting.updateMatchNextFormatting(_marker, option, _old);\n\n        if (_marker.closeParent) {\n            return this._closeMarker(_marker, parent, option, _marker.closeParentData);\n        }\n        return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, parent);\n    }\n    /**\n     * just close marker to skip\n     * @param {*} _marker \n     * @param {*} option \n     * @returns \n     */\n    _justCloseMarker(_marker, option) {\n        let _ret = _marker;\n        // + | close all marking.\n        while (_ret) {\n            const _told = option.shiftFromMarkerInfo(_ret, true);\n            const _lbuffer = option.bufferState;\n            option.restoreBuffer(_told);\n            option.formatterBuffer.appendToBuffer(\n                {\n                    bufferSegments: _told.data.bufferSegment,\n                    dataSegments: _told.data.dataSegment,\n                }\n            );\n            option.formatterBuffer.appendToBuffer(\n                _lbuffer.data\n            );\n            this._onEndHandler(_ret, option);\n            _ret = _ret.parent;\n        }\n        return _ret;\n    }\n    _updateNextMode({ nextMode }, marker) {\n        nextMode = marker.mode;\n        arguments[0].nextMode = nextMode;\n    }\n    /**\n     * shift pattern content name\n     * @param {*} patternInfo \n     * @param {*} option \n     */\n    _shiftPatternContentName(patternInfo, option) {\n        const { tokenList } = option;\n        const name = patternInfo.contentName;\n        if (name && patternInfo.isShiftenContentName) {\n            if ((tokenList.length > 0)) {\n                Utils.UnshiftTokens(name, tokenList);\n                patternInfo.isShiftenContentName = false;\n            }\n            else {\n                throw Error('missing contentName');\n            }\n        }\n    }\n    /**\n     * unshift pattern content name \n     * @param {*} patternInfo \n     * @param {*} option \n     */\n    _unshiftPatternContentName(patternInfo, option) {\n        const { tokenList } = option;\n        const name = patternInfo.contentName;\n        if (name && !patternInfo.isShiftenContentName) {\n            Utils.StoreTokens(name, tokenList);\n            patternInfo.isShiftenContentName = true;\n        }\n    }\n\n    /**\n     * move entryBuffer to parent definition \n     * @param {*} marker\n     * @param {FormatterOptions} option\n     */\n    _updateBlockMarkerPropertyContent(marker, option) {\n        const _old = option.peekMarkerInfo;\n        const _entryBuffer = _old.entryBuffer;\n        let _content = _old.content;\n        let _marker = _old.marker;\n        let _new_v = _content.startsWith(_entryBuffer) ? _content.substring(_entryBuffer.length) : _content;\n\n        const { formatting } = this;\n        const { bufferSegment, dataSegment } = _old.data;\n        if (_entryBuffer.length > 0) {\n            let idx = bufferSegment.indexOf(_entryBuffer);\n            const data = dataSegment[idx];\n            // passing to entry buffer \n            _old.state.formatterBuffer.appendToBuffer({ buffer: _entryBuffer, data });\n            let _count = 0;\n            while (idx >= 0) {\n                dataSegment.shift();\n                bufferSegment.shift();\n                idx--;\n                _count++;\n            }\n            if (bufferSegment.marked) {\n                FormatterBuffer.ReduceBufferSegmentIndex(_count, bufferSegment);\n                FormatterBuffer.TreatMarkedSegments({ dataSegment, bufferSegment }, 'trimmed');\n            }\n        }\n\n        _old.useEntry = false;\n        _old.blockStarted = true;\n        _marker.isBlockStarted = true;\n        this._initUpdatedisBlockStartInformation(marker, option);\n        if (_new_v.length > 0) {\n            // + | prefix with line fied\n            option.saveBuffer();\n            option.appendExtraOutput();\n            // option.formatterBuffer.appendToBuffer({ buffer: _new_v, data: dataSegment.join('') });\n            option.formatterBuffer.appendToBuffer({ dataSegments: dataSegment, bufferSegments: bufferSegment });//  _new_v, data: dataSegment.join('') });\n            option.store();\n            const _buffer = option.flushAndData(true);\n            option.restoreSavedBuffer();\n            _new_v = _buffer.buffer;\n            // update data segment\n            FormatterBuffer.ClearSegments({ bufferSegment, dataSegment });\n            bufferSegment.push(_buffer.buffer);\n            dataSegment.push(_buffer.data);\n\n\n        }\n        _old.content = _new_v;\n        _old.useEntry = false;\n        _old.startBlock = 0;\n        formatting.startBlock(_old);\n    }\n\n    /**\n     * init block start \n     * @param {*} marker \n     * @param {*} param1 \n     */\n    _initBlockStarting(marker, { depth }) {\n        marker.isFormattingStartBlockElement = true;\n        marker.blockStartInfo = {\n            depth: depth\n        }\n    }\n    /**\n     * handle marker info \n     * @param {PatternMatchInfo} patternInfo \n     * @param {*} option \n     * @returns \n     */\n    _handleBeginEndMarker(patternInfo, option) {\n        option.state = 'begin/end'; const { formatting } = this;\n        const { debug, line, markerInfo } = option;\n        const { parent, lineFeed, group } = patternInfo;\n        debug?.feature('match/begin-end') && Debug.log('--::: begin/end - handle marker :::---#' + patternInfo.toString());\n\n        let _endRegex = null;\n        let _start = true;\n        let _line = '';\n        let _old = null;\n        let _buffer = null;\n        let _p, _matcher, _error;\n\n        // get _old marker to continue matching selection  \n\n        if ((markerInfo.length > 0) && (_old = option.shiftFromMarkerInfo(patternInfo, false))) {\n            _start = false; // update the marker to handle start definition\n            _buffer = this._updateOldMarkerContent(_old, option);\n        } else if (patternInfo.start) {\n            // + | if (transform treat  )\n            let _captures = null;\n            let _startOutput = { buffer: null, data: null };\n            if (patternInfo.transform) {\n                // treat match value before \n                let _cm_value = patternInfo.group[0];\n                let _op = [];\n                _startOutput.data = _cm_value;\n                _cm_value = this._treatMatchValue(_cm_value, patternInfo, option, _op, null, false);\n                if (_op.indexOf('transform') != -1) {\n                    _captures = patternInfo.transformCaptures || null;\n                    ({ _captures } = this._treatTransform(_cm_value, patternInfo, _captures));\n                }\n                // + | update start input \n                _startOutput.buffer = _cm_value;\n            }\n            // _captures = _captures || Utils.BeginCaptures(patternInfo);\n            // + | treat begin captures and update buffer\n            const _outdefine = {};\n            if (option.treatBeginCaptures(patternInfo, _captures, _outdefine) == undefined) {\n                const _fstartOutput = patternInfo.startOutput;\n                _startOutput.buffer = option.treatValueBeforeStoreToBuffer(patternInfo, _fstartOutput);\n                _startOutput.data = {\n                    dataSegment: [_fstartOutput],\n                    bufferSegment: [_startOutput.buffer]\n                };\n            } else {\n                _startOutput.buffer = patternInfo.startOutput;\n                _startOutput.data = _outdefine;\n            }\n            FormatterBuffer.InitBufferMarkedSegment(_startOutput.data.bufferSegment);\n            patternInfo.start = false;\n            if (patternInfo.isBlock) {\n                // +| on base start width K_R coding style \n                // this._checkStartBlockDefinition(patternInfo, option, false); \n                if (!patternInfo.isStreamCapture)\n                    this._initBlockStarting(patternInfo, option);\n            }\n            if (patternInfo.isBlockConditionalContainer) {\n                option.pushConditionalContainer(patternInfo);\n            }\n            this._updateParentProps(patternInfo, true, option);\n            if (parent) {\n                if (parent.isBlock && !parent.isBlockStarted && this._isChildBlock(patternInfo, option)) {\n                    // + | start block so that element \n                    if (markerInfo.length > 0) {\n                        this._updateBlockMarkerPropertyContent(patternInfo, option);\n                    }\n                }\n            } else {\n                if (lineFeed && (option.depth == 0)) {\n                    // auto change line feed \n                    if (!option.blockStarted) {\n                        option.blockStarted = true;\n                    }\n                }\n            }\n            const _mode = patternInfo.mode;\n            formatting.updateStartFormatting(_mode, option);\n            this._unshiftPatternContentName(patternInfo, option);\n            patternInfo.startOutput = _startOutput.buffer;\n            patternInfo.startData = _startOutput.data;\n            this._onStartMarker(patternInfo, option, { type: 'begin/end' });\n        } else {\n            throw new Error(\"missing logic for : \" + patternInfo);\n        }\n        _buffer = _start ? patternInfo.startOutput : _buffer;\n        _endRegex = patternInfo.endRegex;\n        _line = line.substring(option.pos);\n\n        if (!_start && option.TOEND) {\n            _p = patternInfo.endGroup || [''];\n            _p.index = 0;\n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n\n        if (option.EOF) {\n            // ---------------------------------------------------------------\n            // END FOUND\n            // ---------------------------------------------------------------\n            _p = this._lastExpectedMatchResult(patternInfo, option, _old);\n            _buffer = _old.content;\n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n\n        if (_line.length == 0) {\n\n            // + | check for end found - \n            ({ _p, _matcher, _error } = this.detectPatternInfo(_line, patternInfo, option));\n            const _eol = option.EOL;\n            if (_p && ((_matcher == null) || (_eol))) {\n                let _nextPos = Math.max(option.pos, _p.index);\n                // + | update the next position hosting\n                option.pos = _nextPos;\n                // \n                if (_p[0].length == 0) {\n                    let _close_data = patternInfo.closeParentData;\n                    if (_close_data) {\n                        const _op = [];\n                        _close_data = this._treatMatchValue(_close_data, patternInfo, option, _op, null, true);\n                        _buffer += _close_data;\n                        if (_old) {\n                            _old.data.bufferSegment.push(_close_data);\n                            _old.data.dataSegment.push(_close_data);\n                        }\n                    }\n                }\n                return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n            }\n            this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, patternInfo.endRegex, option);\n            return patternInfo;\n        }\n        // treat patterns\n        let _pos = option.pos;\n        if (_start) {\n            let _next_position = patternInfo.group.index + patternInfo.group.offset;\n            // + | on start before handle \n            _pos = _next_position;\n            option.pos = _next_position;\n        }\n        _line = line.substring(_pos);\n        // + | start pattern stream capture\n        if (patternInfo.isStreamCapture && _start) {\n            return this._startStreamingPattern(patternInfo, _line, _endRegex, option, null, null, _buffer, false);\n        }\n        // + | --------------------------------------------------------        \n        // + | DETECT: core match\n        // + | --------------------------------------------------------\n        ({ _p, _matcher, _error } = this.detectPatternInfo(_line, patternInfo, option)); \n\n        if (_error) {\n            throw new Error(_error);\n        }\n        if (_matcher == null) {\n            // no child matcher found\n            if (_p == null) {\n\n                if (patternInfo.isStreamCapture) {\n                    // + | detect buffer empty - buffer detection \n                    return this._startStreamingPattern(patternInfo, _line, _endRegex, option, _error, _old, _buffer, true);\n                }\n                this._checkStartBlockDefinition(patternInfo, option);\n                // no end - found \n                // _continue_with_marker = false;\n                // update cursor - start new marker and update - \n                this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n                if (_line.trim().length > 0) {\n                    this._appendConstant(patternInfo, _line, option);\n                }\n                option.pos = option.line.length;\n                if ((_buffer.length > 0) && this.info.isSubFormatting) {\n                    option.formatterBuffer.appendToBuffer(\n                        {\n                            bufferSegments: patternInfo.startData.bufferSegment,\n                            dataSegments: patternInfo.startData.dataSegment,\n                        }\n                    );\n                    _buffer = null;\n                }\n                return patternInfo;\n            } else {\n                // ---------------------------------------------------------------\n                // END FOUND\n                // ---------------------------------------------------------------\n                return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n            }\n        }\n        else {\n\n            // compared index and handle child\n            if ((_p == null) || (_matcher.group.index < _p.index)) {\n                this._checkStartBlockDefinition(patternInfo, option);\n\n                if (_matcher.isStreamCapture) {\n                    // + | detect buffer empty - buffer detection   \n                    // + | before startStream . \n                    // _old = \n                    this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n                    // start new stream for new \n                    return this._startStreamingPattern(_matcher, _line, _endRegex, option, _error, null, '', false);\n                }\n                // + | \n\n                // handle matcher \n                return this._handleItemFoundCallback().apply(this, [\n                    _matcher, patternInfo, _old, _buffer, _endRegex, option\n                ]);\n            }\n            // check if same \n            if (_matcher.group.index == _p.index) {\n                if (_matcher.isStartOnly) {\n                    // ---------------------------------------------------------------\n                    // END FOUND : priority to patternInfo\n                    // ---------------------------------------------------------------\n                    return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n                }\n                return Formatters.HandleSameGroup(this, patternInfo, _matcher, _p, _old, _buffer, _endRegex, option, null, _line);\n            }\n            // priority to current marker \n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n    }\n    _handleStopMarker(marker, option) {\n        const { parent } = marker;\n        let r = option.peekMarkerInfo;\n        // + | backup \n        let { pos, line, nextMode } = option;\n        let s = null;\n        if (r?.marker == marker)\n            this._closeMarkerByStop(marker, marker.endGroup, option);\n\n        if (parent) {\n            r = option.peekMarkerInfo;\n            if (r?.marker == parent) {\n                let _p = [''];\n                _p.index = 0;\n                _p.indices = [];\n                s = this._closeMarkerByStop(parent, _p, option, {\n                    _parentNextMode: nextMode\n                })\n            }\n        }\n        // + | restore \n        option.pos = pos;\n        option.line = line;\n        option.nextMode = nextMode;\n\n        return s;\n    }\n\n    // #endregion\n    //-------------------------------------------\n\n    /**\n     * detect logical pattern info\n     * @param {string} _line \n     * @param {PatternMatchInfo} patternInfo \n     * @param {FormatterOptions} option \n     * @param {PatternMatchInfo} parentMatcherInfo to handle parent result for pattern\n     * @param {bool} throwError re throw error in detection \n     * @returns \n     */\n    detectPatternInfo(_line, patternInfo, option, parentMatcherInfo, throwError = true) {\n        let _matcher = null;\n        let _p = null;\n        let _endRegex = patternInfo.endRegex;\n\n        let _error = null;\n        parentMatcherInfo = parentMatcherInfo || patternInfo;\n        const { patterns } = patternInfo;\n        const _call = (patterns && (patterns.length > 0));\n        const _call_update_regex = (_p, _endRegex) => {\n            _p.sourceRegex = _endRegex;\n            _p.type = '_end_';\n            _p.offset = _p[0].length;\n        };\n        try {\n            _matcher = _call ? Utils.GetPatternMatcher(patterns, option, parentMatcherInfo) : null;\n            // if (_call && !_matcher && option.lineMatcher){\n            //     _matcher = Utils.GetPatternMatcher(patterns, option, parentMatcherInfo, option.lineMatcher.subLine, option.lineMatcher.offset);\n            // }\n        }\n        catch (e) {\n            if (throwError) {\n                throw e;\n            }\n            _error = {\n                _line,\n                index: e.match.index - option.pos\n            }\n        }\n        // + | fix to end regex\n        if (_endRegex) {\n\n            //_p = _endRegex.exec(_line); \n            _p = option.lineMatcher.check(_endRegex);\n            if (_p) {\n                // _p.index += option.pos;\n                _call_update_regex(_p, _endRegex);\n            } else if (option.sourceLine != _line) {\n                const { lineMatcher } = option;\n                // + | possibility to detect a sub line */\n                let _ts = RegexUtils.RegexToStringRegex(_endRegex);\n                let c = RegexUtils.RemoveCaptureAndLeaveMovementCapture(_ts);\n                //\n                let treat = null;\n                if (c && c.length > 0) {\n                    // + | treat end priority to movement capture definition \n                    const _pline = (new RegExp(c, 'd')).exec(lineMatcher.subLine);\n                    treat = _pline;\n                }\n                const _pline = _endRegex.exec(lineMatcher.subLine);\n                if (_pline) {\n                    if (treat && (treat.index >= _pline.length)) {\n                        _p = treat;\n                    } else {\n                        _p = _pline;\n                    }\n                } else if (treat) {\n                    _p = _pline;\n                }\n                if (_p) {\n                    _p.index += lineMatcher.offset;\n                    _call_update_regex(_p, _endRegex);\n                }\n            } \n            patternInfo.endGroup = _p;\n        } \n        if (_p && patternInfo.checkMoveEndRegex(_p, option)){ \n            _p = null;\n        } \n        return { _p, _matcher, _error };\n    }\n    _updatePatternPrevConstant(_marker, option, _prev, offset, append_child = true) {\n        _prev = _prev || option.getLineRangeContent();\n        if (_prev.length > 0) {\n            offset = offset || 0;\n            if (!option.startLine || (_prev.trim().length > 0)) {\n                this._appendConstant(_marker, _prev, option, append_child);\n            }\n            option.pos += (offset || _prev.length);\n        }\n    }\n    /**\n     * determine that the pattern is a child block\n     * @param {*} patternInfo \n     * @returns bool\n     */\n    _isChildBlock(patternInfo, option) {\n        const { parent } = patternInfo;\n        let r = false;\n        const requestParentBlockCondition = parent?.requestParentBlockCondition;\n        if (requestParentBlockCondition) {\n            r = this._isEmptyRequestBlock({\n                childs: [patternInfo],\n                _marker: parent,\n                condition: requestParentBlockCondition\n            });\n        }\n        return r;\n    }\n    /**\n     * update buffer on end\n     * @param {*} _marker \n     * @param {*} option \n     * @param {*} param2 \n     * @private\n     * @returns \n     */\n    _updateBuffer(_marker, option, { _append, _buffer, _data, _trimOutput }) {\n        const q = this;\n        const { parent } = _marker;\n        const { formatterBuffer } = option;\n        let _skipOffset = 0;\n        if (_buffer.length > 0) {\n\n            if (_trimOutput) {\n                if (_data.bufferSegment.join('') != _buffer) {\n                    throw new Error('trim out buffer not match');\n                }\n                FormatterBuffer.TreatMarkedSegments(_data, 'trimmed');\n                _buffer = _data.bufferSegment.join('');\n            }\n\n            // + | direct append to buffer\n            formatterBuffer.storeToBuffer({ _buffer, _data }, option);\n            _buffer = '';\n        }\n        const _use_append = ((_marker.matchType==0)  && _append.length>0) || (_append.trim().length > 0);\n        if (_use_append) {\n            // + | append constant marker definition \n            if (_marker.isFormattingStartBlockElement && !_marker.newLine) {\n                _marker.newLine = true;\n            }\n            if (parent?.isAutoBlockElement) {\n                let r = option.buffer;\n                option.formatterBuffer.clear();\n                if (r.length > 0)\n                    option.output.push(r);\n                else\n                    option.appendExtraOutput();\n                q._appendConstant(_marker, _append, option);\n                option.store();\n                r = option.flush(true);\n                option.formatterBuffer.appendToBuffer(r);\n            }\n            else {\n                q._appendConstant(_marker, _append, option);\n                _skipOffset = _append.length;\n            }\n            _append = '';\n        }\n        option.nextMode = _marker.mode;\n        return { _append, _buffer, _skipOffset };\n    }\n    /**\n     * use to handle close parent\n     * @param {*} _marker \n     * @param {*} option \n     * @param {{handle:bool}} arg \n     */\n    _handleCloseParentProperty(_marker, option, arg = { handle: false }, _extra) {\n        const { debug } = option;\n        let _handle = false;\n        let _data = _extra?.closeParentData;\n        if (_data == undefined) {\n            return;\n        }\n        let _g = null;\n        debug && Debug.log('---:::CLOSE PARENT PROPERTY:::---' + _marker);\n        arg.udpateChild = this._requestUpdateChild(_marker, arg.state);\n        let _gparent = _marker.parent;\n        if (_gparent) {\n            if (_gparent.isBlock) {\n                _g = this._closeBlockEntry(option, _marker, _gparent, _data);\n            } else {\n                _g = this._closeMarkerAndUpdate(_marker, _gparent, option, _data);\n            }\n        }\n\n        _handle = true;\n\n        arg.handle = _handle;\n        return _g;\n    }\n    _requestUpdateChild(_marker, state) {\n        if (state == 'match') {\n            return (_marker.group[0].length > 0);\n        }\n        return true;\n    }\n    /**\n     * close block entry\n     * @param {FormatterOptions} option \n     * @param {PatternMatchInfo} _marker current marker \n     * @param {PatternMatchInfo} _parent parent\n     * @param {string} data data used to close  \n     * @param {boolean} store data used to close  \n     */\n    _closeBlockEntry(option, _marker, _parent, data = '', store = true) {\n        const { formatting } = this;\n        if (store && (option.depth > 0))\n            option.store();\n        option.depth = Math.max(--option.depth, 0);\n        if (_marker && _parent) {\n            return this._closeMarkerAndUpdate(_marker, _parent, option, data);\n        }\n    }\n    _closeMarkerAndUpdate(_marker, _parent, option, data) {\n        const { formatting } = this;\n        let _r = this._closeMarker(_marker, _parent, option, data);\n        formatting.updateEmptySkipMatchedValueFormatting(_r, option, { mode: _marker.mode, formattingMode: _parent.formattingMode });\n        return _r;\n    }\n    _closeMarker(_marker, _g, option, data = '') {\n        const { debug } = option;\n        debug && Debug.log(\":::CLOSEMARKER:::\" + _marker);\n        if (_marker?.isBlock) {\n            this.formatting.closeMarker(_marker);\n            _marker.isBlock = false;\n        }\n        if (_g) // move to parent \n        {\n            const { endGroup } = _g;\n            // if (endGroup==null){\n            //     // - continue thru parent\n            //     return _g;\n            // }\n            let _value = data;\n            let _type = null;\n            if (typeof (data) == 'object') {\n                _value = data.value;\n                _type = data.type;\n            }\n\n            if (endGroup && (endGroup[0] != _value)) {\n                let p = _g.endRegex.exec(_value) || ((d) => {\n                    d.indices = [[0, d[0].length]];\n                    d.index = 0;\n                    return d;\n                })([_value]);\n\n                p.index += option.pos;\n                _g.endGroup = p;\n            }\n            _g = this._handleToEndPattern(_g, _value, option);\n            let _buffer = option.buffer;\n            if (_type) {\n                _buffer = option.flush(true) + _buffer;\n                option.appendToBuffer(_buffer, new TypeMarkerInfoPattern(_type, { parser: this.registryClassName, data }));\n            } else {\n                option.store();\n            }\n        }\n        return _g;\n    }\n    /**\n     * \n     * @param {*} parent \n     * @param {*} _marker \n     * @param {*} _p \n     * @param {*} _old \n     * @param {*} option \n     * @param {*} _buffer \n     * @param {*} _line \n     * @param {number} _next_position \n     * @param {*} state \n     * @returns \n     */\n    _handleCheckParentInfo(parent, _marker, _p, _old, option, _buffer, _line, _next_position, state = 'begin/end') {\n\n        let _endCaptureCallback;\n        let _checkParentInfo;\n        const _isSkipTreatEnd = option.skipTreatEnd;\n        if (parent && !_isSkipTreatEnd && (parent.matchType == 0) &&\n            (parent.isEndCaptureOnly || _marker.isEndCaptureOnly)) {\n            // + | send to parent block\n            _checkParentInfo = {\n                _line,\n                _marker,\n                _old,\n                parent,\n                buffer: _buffer,\n                pos: _next_position,\n                line: option.line,\n                offset: option.offset,\n                endGroup: _p,\n                fromChild: (!parent.isEndCaptureOnly && _marker.isEndCaptureOnly),\n                state\n            };\n            _endCaptureCallback = this._closeNonCaptureBlock;\n        }\n        return { _endCaptureCallback, _checkParentInfo };\n    }\n\n    /**\n     * resolv data segments \n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _old \n     * @returns \n     */\n    _resolvFoundData(_marker, option, _old) {\n        if (option.EOF) {\n            if (_old) {\n                const c_data = _old.data;\n                if (c_data.bufferSegment.length > 0) {\n                    return c_data;\n                }\n            }\n            return _marker.startData;\n        }\n        return _old?.data || _marker.startData;\n    }\n    /**\n     * begin/end end found\n     * @param {string} _buffer current buffer presentation\n     * @param {*} _line entry line\n     * @param {*} _marker current marker\n     * @param {*} _p end match\n     * @param {FormatterOptions} option option \n     * @param {FormatterMarkerInfo} _old store information \n     * @returns \n     */\n    _handleFoundEndPattern(_buffer, _line, _marker, _p, option, _old) {\n        // calculate next position \n        const { debug } = option;\n        const { parent } = _marker;\n        let _next_position = _p.index + _p[0].length; // do not move cursor until condition meet\n        let _next_offset = undefined; //option.offset;\n        let _append = option.pos < _p.index ? option.line.substring(option.pos, _p.index) : '';\n        let _checkParentInfo = null;\n        let _endCaptureCallback = null;\n        const q = this;\n        const _formatting = q.formatting;\n        const _isSkipTreatEnd = option.skipTreatEnd;\n        const prependExtra = _old?.prependExtra;\n        let _b = null;\n        let _data = null;\n\n        debug?.feature('match/begin-end.end') && Debug.log(`--::: END::Begin/End handleFoundEndPattern :::--#${_marker}`);\n        option.lastMarker = _marker;\n\n        if (prependExtra) {\n            let r = _formatting.updatePreprendExtra(prependExtra, null, option);\n            _buffer += r.extra;\n            _old.prependExtra = null;\n        }\n        ({ _checkParentInfo, _endCaptureCallback } = this._handleCheckParentInfo(parent, _marker, _p, _old, option, _buffer, _line, _next_position));\n\n\n\n        let _saved = false;\n        if (_old == null) {\n            option.saveBuffer();\n            _saved = true;\n        }\n        this._shiftPatternContentName(_marker, option);\n\n        ({ _b, _data } = (() => {\n            const _empty = { _b: '', _data: '' };\n            return _isSkipTreatEnd ? _empty : (() => {\n                if (_p[0].length > 0) {\n                    let __b = option.treatEndCaptures(_marker, _p);\n                    if (__b == undefined) {\n                        __b = option.treatValueBeforeStoreToBuffer(_marker, _p[0]);\n                    }\n                    return { _b: __b, _data: _p[0] };\n                }\n            })() || _empty;\n        })());\n\n\n        option.skipTreatEnd = false;\n        let _close_block = false;\n        let _skipOffset = 0;\n\n\n        //const _debug_parent_is_capture_only = parent?.isEndCaptureOnly;\n\n        // + | update parent host - check update properties for end \n        this._updateMarkerChild(_marker, option);\n\n\n\n        // + | full fill pattern buffer \n        ({ _append, _buffer, _skipOffset } = _formatting.onEndUpdateBuffer({\n            marker: _marker,\n            option,\n            _buffer,\n            _data: this._resolvFoundData(_marker, option, _old),\n            _trimOutput: true,\n            update(info) {\n                return q._updateBuffer(_marker, option, { _append, _buffer, ...(info || {}) });\n            }\n        }\n        ));\n        if (_skipOffset) {\n            _next_offset = Math.min(_next_position, option.offset + _skipOffset + 1);\n        }\n\n        // + | node division  \n        if (_marker.isBlock && !_marker.blockStartInfo) {\n            // + | for some reason marker block is a block element but not got a blockStartInfo\n            this._closeBlockEntry(option, _marker, null, null, false);\n        }\n\n        if (_marker.isBlock && _marker.blockStartInfo) {\n            // + | just remove block before store \n            // + | reset block value;\n            _close_block = true;\n            //_marker.isBlockDefinition = null;\n            if (_marker.isFormattingStartBlockElement) {\n                ({ _b, _data } = _formatting.handleEndFormattingBeforeStore(q, _marker, option, _buffer,\n                    { _b, _data }));\n                const _refData = {};\n                _buffer = option.getBufferContent(true, _refData);\n                option.output.push(_buffer);\n                option.dataOutput.push(_refData.buffers.dataSegment.join(''));\n            } else {\n                _formatting.handleEndFormattingOnNonStartBlockElement(q, _marker, option);\n            }\n            _buffer = '';\n            // + | just reduce block depth\n            this._closeBlockEntry(option, _marker, null, null, false);\n        } else {\n\n            ({ _b } = _formatting.handleEndOnNonBlockElement(this, _marker, option,\n                { _b, _old, data: _p[0] }\n            ));\n        }\n        // + | append to buffer \n        if (_b.length > 0) {\n            option.formatterBuffer.appendToBuffer(_b);\n            _b = '';\n        }\n\n        // + | --------------------------------------------------------------------------------------\n        // + | update formatting and update mode depending on current marker.formattingMode or childs\n        // + | \n        this._updateMarkerFormatting(_marker, option);\n\n        if (_close_block) {\n            option.store();\n            _buffer = option.flushAndData(true);\n            option.formatterBuffer.appendToBuffer(_buffer);\n\n            // + | restore block old state\n            if (_old)\n                _marker.isBlock = _old.oldBlockStart;\n        }\n        if (_old != null) {\n\n            // + | restore buffering then update the buffer\n            if ((_old.marker == _marker)) {\n                // + | save buffer \n                _buffer = option.bufferState;\n\n\n                let _nextBuffer = null;\n                // - so st treat buffer \n                if (!_old.useEntry && _marker.isBlock) {\n                    // + | store                    \n                    // option.store(false);\n                    option.output.push(_buffer.buffer);\n                    _buffer = option.flush(true);\n                } else {\n                    if (_old.useEntry && parent && !parent.isBlock && _marker.updateParentProps?.isBlock && (_old.entryBuffer.length > 0)) {\n                        // + | possibility of parent child block - passing to parent \n                        ({ _buffer, _nextBuffer } = this._updatePreservedBlockBuffer(_buffer, _marker, _old, option));\n                    }\n                }\n                option.restoreBuffer(_old);\n                // + | > passing data\n                _formatting.updateEndBlockAfterRestoringBuffer(q, _marker, _buffer, _old, option);\n                _buffer = '';\n                if (_nextBuffer) {\n                    option.peekMarkerInfo.storePrependExtra(_nextBuffer);\n                }\n            }\n        }\n\n        // + | view child debug\n        // + | determine childs\n        debug?.feature('child-counter') && (_marker.childs.length > 0) && Debug.log(`--::: Counter ::-- #${_marker.name} have ${_marker.childs.length} childs`);\n\n        if (_marker?.parent?.newLine) {\n            _marker.parent.newLine = false;\n        }\n\n        if (_p[0].length == 0) {\n            _next_position = Math.max(option.pos, _next_position);\n        }\n        // + | update position\n        option.moveTo(_next_position, _next_offset);\n        // + | restore backup buffer\n        if (_saved) {\n            const _buffState = option.bufferState;\n            option.restoreSavedBuffer();\n            if (_buffState.buffer.length > 0) {\n                // + | \n                // + | passing current data to buffer definition so it can be encapsulate\n                // + | \n                option.appendToBuffer(_buffState, _marker, true, true);\n            }\n            if (!_close_block && (_marker.\n                isFormattingStartBlockElement || _marker.isBlock)) {\n                if (parent && (_marker.mode == 1)) {\n                    option.store();\n                }\n            } else if (_close_block) {\n                _formatting.updateNextSavedMode(_marker.mode, option);\n            }\n        }\n\n        if (!_marker.value && _old) {\n            // + | update marker value fallback \n            _marker.value = {\n                source: option.data,\n                value: option.buffer\n            }\n        }\n\n        // + | streat value berfore end \n        this.treatEndMarkerValue(_marker, option);\n\n\n        this._onEndHandler(_marker, option);\n        // + | reset glub value      \n        option.onBeginEndFound(_marker, _old);\n        // + |\n        // + | to update join\n        this._updateJoinWith(_marker, option);\n\n        //if (parent && (parent.childs.length ==1)){\n        // only for onchilds parents. check that element is empty \n        //}\n        if (parent && _marker.closeParent) {\n            let _data = _marker.closeParentData;\n            return this._closeMarker(_marker, parent, option, _data);\n        }\n        // + invoke check parent\n        return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, parent);\n    }\n    /**\n     * \n     * @param {*} _checkParentInfo \n     * @param {*} _endCaptureCallback \n     * @param {*} option global option context\n     * @param {*} fallbackMarker fallback\n     * @returns \n     */\n    _invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, fallbackMarker) {\n        if (_checkParentInfo && _endCaptureCallback) {\n            return _endCaptureCallback.apply(this, [_checkParentInfo, option]);\n        }\n        return fallbackMarker;\n    }\n    /**\n     * \n     * @param {*} _buffer \n     * @param {*} _marker \n     * @param {*} option \n     */\n    _updatePreservedBlockBuffer(_buffer, _marker, _old, option) {\n        const _parentInfo = option.peekMarkerInfo;\n        let _nextBuffer = null;\n        // const { parent } = _marker; \n        if (_buffer.indexOf(_old.entryBuffer) === 0) {\n            let _ln = _old.entryBuffer.length;\n            let _up = _buffer.substring(0, _ln);\n            _nextBuffer = _buffer.substring(_ln);\n\n            this._updateOldMarkerContent(_parentInfo, option, _up, '');\n            _buffer = '';\n        }\n        return { _buffer, _nextBuffer };\n\n    }\n    _closeMarkerByStop(marker, tp, option, { _line = '', nextMode }) {\n        let _old = null;\n        let _endFound = this._handleFoundEndPattern;\n        let _buffer = null;\n\n        tp = tp || [''];\n        if (marker.from && (option.markerInfo.length > 0)) {\n            _old = option.shiftFromMarkerInfo(marker.from, true);\n            _old = option.shiftFromMarkerInfo(marker, true);\n            _endFound = _old.endFound || _endFound;\n            marker = marker.from;\n        } else {\n            _old = option.shiftFromMarkerInfo(marker, true);\n        }\n\n\n        _buffer = _old ? this._updateOldMarkerContent(_old, option) : '';\n\n        // let _cline = _line.substring(tp.index);\n        // + | clear line input to update end buffer formatter\n        option.lineMatcher.save('');\n        tp.input = '';\n        tp.index = 0;\n        option.skipTreatEnd = true;\n        marker.endGroup = tp;\n        marker = _endFound.apply(this, [_buffer, _line, marker, tp, option, _old]);\n        option.skipTreatEnd = false;\n        option.lineMatcher.restore();\n        return marker;\n    }\n    /**\n     * update format mode\n     * @param {*} from \n     * @param {*} to \n     */\n    _updateFormatModeFromTo(from, to, option) {\n        const { formatting } = this;\n        if (to === null) {\n            // + update global mode formatting\n            formatting.updateGlobalFormatting(from, option);\n        } else {\n            // + | move next mode to top parent\n            to.mode = option.nextMode;\n            if (to !== from) {\n                option.lineFeedFlag = false;\n            }\n        }\n    }\n    /**\n     * end non capture block\n     * @param {{pos:number, line:string, buffer:string, _line: string, _old:*, endGroup}} info \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    _closeNonCaptureBlock(info, option) {\n        const { parent, endGroup, state } = info;\n        const { lineMatcher } = option;\n        let p = null;\n        const _line = info.line.substring(info.pos);\n        const _nextPosition = option.pos;\n        const _bckLine = option.line;\n        let _bckLineOffset = lineMatcher.offset;\n        let treat = false;\n        let fromChild = info.fromChild;\n        let tp = null;\n        let _end_non_capture = (marker, tp, nextMode) => {\n            marker.mode = nextMode;\n            let _ret_marker = this._closeMarkerByStop(marker, tp, option, { _line, nextMode });\n            this._updateFormatModeFromTo(marker, _ret_marker, option);\n            return _ret_marker;\n        };\n        let _offsetPosition = _nextPosition;\n        let _is_match = state == 'match';\n        if (_is_match) {\n            _offsetPosition = info.pos;\n        }\n        let _tcline = lineMatcher.subLine;\n        let _toffset = lineMatcher.offset;\n        let _loopCounter = 0;\n        // + | element do not  capture data \n        let _start = endGroup[0].length == 0;\n        // + | loop thru end captured data to close \n        let _supportCapture = false;\n        while (_start && info.parent && (fromChild || _supportCapture || info.parent.isEndCaptureOnly)) {\n            p = info.parent;\n            const { endRegex } = p;\n            _loopCounter++;\n\n            if (endRegex == null) {\n                // just loop on current p;\n                treat = true;\n                break;\n            }\n            if (tp = endRegex.exec(_tcline)) {\n                let l = (tp.index + _toffset);\n                let _ln = tp[0].length;\n                let _empty_capture = (_ln == 0);\n                if (((l == endGroup.index) && _empty_capture) || (_supportCapture && !_empty_capture && (endGroup.index == l + _ln))) {\n                    if (_supportCapture && !_empty_capture && (endGroup.index == l + _ln)) {\n                        tp.index += _toffset + _ln;\n                    } else\n                        tp.index += _toffset;\n                    p = _end_non_capture(p, tp, option.nextMode);\n                } else {\n\n                    // fix offset parent\n                    if ((l < endGroup.index) || !_empty_capture)\n                        _bckLineOffset = _offsetPosition;\n                    break;\n                }\n                treat = true;\n            } else {\n                tp = endRegex.exec(_line);\n                if (tp) {\n                    if ((tp.index + _offsetPosition) == endGroup.index) {\n                        // + | same index - update capture continue end\n                        tp.index += _offsetPosition;\n                        // + \n                        if (tp[0].length == 0) {\n                            // fromChild = p.isEndCaptureOnly;\n                            p = _end_non_capture(p, tp, option.nextMode);\n                        }\n                    } else {\n                        break;\n                    }\n                    treat = true;\n                } else {\n                    if (treat) {\n                        if (option.EOF) {\n                            p = _end_non_capture(p, null);\n                            info.parent = p;\n                            break;\n                        } else {\n                            break; // return p;\n                            throw new Error('end treatment - missmatch pattern: ' + p.toString());\n                        }\n                    }\n                    p = null;\n                }\n            }\n            info.parent = p;\n            fromChild = false;\n            _supportCapture = p ? ((p) => {\n                const { endRegex } = p;\n                return RegexUtils.HasMovementCapture(endRegex);\n            })(p) : false;\n        }\n\n        if (_is_match && (treat) && p) {\n            const _endRegex = p.endRegex;\n            if (_endRegex) {\n                tp = _endRegex.exec(_line);\n                if (tp && (tp[0].length == 0) && (tp.index + _offsetPosition == endGroup.index)) {\n                    tp.index += _offsetPosition;\n                    p = _end_non_capture(p, tp);\n                }\n            }\n        }\n        option.pos = _nextPosition;\n        option.line = _bckLine;\n        // if (!_start){\n        // + | update end lineMatcher offset to next research will start at position\n        if (treat) {\n            option.lineMatcher.offset = _nextPosition;\n            return p;\n        }\n        option.lineMatcher.offset = _bckLineOffset;\n        return parent;\n    }\n\n    /**\n     * check if this marker will be consider as an empty block if requested\n     * @param { {childs: [], _marker,condition}} option  \n     */\n    _isEmptyRequestBlock({ childs, _marker, condition }) {\n        if (childs.length == 0) {\n            return false;\n        }\n        const _tchilds = childs.slice(0);\n        if (condition) {\n            let r = true;\n            let q = null;\n            let expression = this._funcRegistryExpression();\n            const list = expression.namespaces.filter((o) => {\n                // ignore no valid name spacec\n                return o.indexOf('-') == -1;\n            }).join(',');\n            let fc = new Function(\"registry\", \"child\", \"marker\", `const {${list}} = registry; return ${condition};`);\n            while (_tchilds.length > 0) {\n                q = _tchilds.shift();\n\n                try {\n                    r = fc.apply({ child: q }, [\n                        expression.registry, q, _marker]);\n                }\n                catch (e) {\n                    console.error(\"error : \", e);\n                    return true;\n                }\n                if (r) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * update marker child \n     * @param {*} _marker \n     */\n    _updateMarkerChild(_marker, option) {\n        const { parent } = _marker;\n        if (!parent) return;\n\n        parent.childs.push({\n            name: _marker.name,\n            marker: _marker\n        });\n        this._updateParentProps(_marker, false, option);\n    }\n    /**\n     * \n     * @param {{name:string, marker:*}[]} childs \n     * @returns \n     */\n    static IsChildBlock(childs) {\n        let _block = false;\n        childs.forEach(c => {\n            _block = _block || (c.marker.isBlock);\n        });\n        return _block;\n    }\n    /**\n     * \n     * @param {*} _marker \n     * @param {*} _old \n     * @param {*} _buffer \n     * @param {*} _endRegex \n     * @param {*} option \n     * @returns \n     */\n    _updateMarkerOldContentOrSwapBuffer(_marker, _old, _buffer, _endRegex, option) {\n        if (_old) {\n            _old.content = _buffer;\n            if ((option.markerInfo.length < 0) || (option.markerInfo[0] !== _old))\n                option.unshiftMarker(_old);\n        } else {\n            if (!this.settings.useIndent) {\n                //_buffer = _buffer.trimStart();\n            }\n            _old = this._backupMarkerSwapBuffer(option, _marker, _buffer, _endRegex);\n            if (option.holdBufferState)\n                option.newOldBuffers.push(_old);\n        }\n        return _old;\n    }\n\n    /**\n     * restore buffer\n     * @param {*} option \n     * @param {*} data \n     */\n    _restoreBuffer(option, data) {\n        option.debug && Debug.log(':::--restore buffer--:::');\n        option.restoreBuffer(data);\n    }\n    /**\n     * initialize marker info object \n     * @param {FormatterOptions} option \n     * @param {PatternMatchInfo} _marker \n     * @param {string} entry \n     * @param {string|RegExp} _endRegex \n     */\n    _backupMarkerSwapBuffer(option, _marker, entry, _endRegex) {\n        option.debug?.feature('backup-swap-buffer') && Debug.log('--::: backup and swap buffer.[' + entry + ']');\n        let _u_content = null;\n        const _formatting = this.formatting;\n        if (_marker.isBlock && _marker.isCaptureOnly && !_marker.isStreamCapture) {\n            // buffer = content+buffer;\n            _u_content = entry;\n            entry = '';\n        }\n        if (option.appendToBufferListener) {\n            option.appendToBufferListener(entry, _marker, false, option);\n            entry = '';\n        }\n        const _inf = new FormatterMarkerInfo(this, _marker, entry, _endRegex, option);\n\n        // + | unshift marker \n        option.unshiftMarker(_inf);\n        // + | save option state\n        _inf.saveState(option, _marker.mode);\n        // + | create a new buffer \n        option.newBuffer(option.markerInfo.length);\n        // + | update option mode with current mode\n        option.nextMode = _inf.currentMode;\n        // + | remove start line flag\n        option.startLine = false;\n        // + | \n        option.skipEmptyMatchValue = false;\n        // + | reset line feed flag\n        if (_marker.parent)\n            option.lineFeedFlag = false;\n\n        _formatting.updateStartFormatting(option.nextMode, option);\n        if (_u_content) {\n            _inf.captureEntry = _u_content;\n            option.nextMode = _formatting.appendMode;\n        }\n        // update glue flags\n        // if (entry=='(')\n        option.useGlue(_marker, '');\n\n        return _inf;\n    }\n    /**\n     * update marker information - content and datathat is on the buffer\n     * @param {*} _old \n     * @param {bool} startLine \n     * @param {FormatterOptions } option \n     * @returns \n     */\n    _updateOldMarkerContent(_old, option, buffer, extra) {\n        let { content, marker, currentMode, autoStartLine, prependExtra } = _old;\n        let data = null;\n        const _formatting = this.formatting;\n        const _is_buffer = (buffer == undefined) && (extra == undefined);\n        const _ref_data = {};\n        let _buffer_data = null;\n        if (_is_buffer) {\n            _buffer_data = option.formatterBuffer.joinSegments('');\n            buffer = option.buffer;\n            data = option.data;\n            extra = option.flush(true, _ref_data);\n        } else {\n            buffer = buffer || '';\n            extra = extra || '';\n        }\n        const isEntryContent = _old.useEntry && (content == _old.entryBuffer);\n        let _joinwith = null;\n        if (_old.captureEntry) {\n            buffer = this._updateOldEntryCapture(_old, buffer, option);\n            _joinwith = marker.joinWith;\n        }\n\n        const props = {\n            marker, buffer, extra, option,\n            content,\n            data,\n            segments: _old.data,\n            mode: currentMode,\n            autoStartLine,\n            startBlock: _old.startBlock,\n            isEntryContent,\n            prependExtra,\n            bufferData: _buffer_data // join segment with buffered data.\n        };\n        content = _formatting.updateOldMarkerContent(props);\n        //+| update current mode \n        if (_old.currentMode != props.mode) {\n            _old.currentMode = props.mode;\n        } else if (option.nextMode != _old.currentMode) {\n            _old.currentMode = option.nextMode;\n        }\n        // update content\n        _old.content = content;\n        _old.startBlock = 0;\n        _old.autoStartLine = props.autoStartLine;\n        // + | store update current joinWith\n        _old.joinWith = _joinwith;\n        _old.prependExtra = props.prependExtra;\n        _old.set();\n        return content;\n    }\n\n    _handleSameGroup2(_marker, _matcher, _p, _old, _buffer, option, _endRegex) {\n        const { formatting } = this;\n        this._checkStartBlockDefinition(_matcher, option);\n        if (_matcher.group[0].length == 0) {\n            // matcher is empty and must past to end group\n            // just invoke the matcher before send to parent \n            if ((option.markerInfo.length == 0) || (option.markerInfo[0] !== _marker)) {\n                this._updateMarkerOldContentOrSwapBuffer(_marker, _old, _buffer, _endRegex, option);\n            }\n            let _q = this._handleMarker(_matcher, option);\n            return _q;\n        }\n        // + | update parent markerin of before handle marker \n        if ((option.markerInfo.length == 0) || (option.markerInfo[0] !== _marker)) {\n            this._updateMarkerOldContentOrSwapBuffer(_marker, _old, _buffer, _endRegex, option);\n        }\n        return this._handleMarker(_matcher, option);\n    }\n    /**\n     * update parent property\n     * @param {PatternMatchInfo} _marker \n     * @param {bool} _start \n     * @param {FormatterOptions} option \n     */\n    _updateParentProps(_marker, _start, option) {\n        const { parent, updateParentProps, requestParentBlockCondition } = _marker;\n        if (parent && updateParentProps) {\n            const _list = [\"isBlock\", 'lineFeed'];\n            _list.forEach(a => {\n                if (!(a in parent.updatedProperties) && (a in updateParentProps)) {\n                    let s = updateParentProps[a];\n                    if (a == _list[0]) {\n                        if (s && (requestParentBlockCondition)) {\n                            s = this._isEmptyRequestBlock({\n                                childs: _marker.childs,\n                                _marker,\n                                condition: requestParentBlockCondition\n                            });\n                        }\n                    }\n                    if (parent[a] != s) {\n                        parent[a] = s;\n                        parent.updatedProperties[a] = a;\n                    }\n                }\n            });\n\n\n            if (!_start) {\n                this._initUpdatedisBlockStartInformation(_marker, option);\n            } else {\n                this._checkUpdatedStartBlockProperties(parent, option, true);\n            }\n        }\n    }\n    /**\n     * \n     * @param {PatterMatchErrorInfo} _marker \n     * @param {FormatterOptions} option \n     * @param {boolean} _startBlock \n     */\n    _checkUpdatedStartBlockProperties(_marker, option, _startBlock) {\n        const { updatedProperties, isBlockStarted, blockStartInfo } = _marker;\n        if ((\"isBlock\" in updatedProperties) && !isBlockStarted && !blockStartInfo) {\n            // + | update parent block information \n            // + | ------------------------------- \n            if (!_startBlock) {\n                _marker.isBlockStarted = true;\n            }\n            _marker.blockStartInfo = {\n                depth: option.depth\n            }\n            _startBlock && this._startBlock(option);\n        }\n    }\n    _initUpdatedisBlockStartInformation(_marker, option) {\n        const { parent } = _marker;\n        // block already started\n        if (parent && (\"isBlock\" in parent.updatedProperties) && (_marker.isBlockStarted)) {\n            this._checkUpdatedStartBlockProperties(parent, option, false);\n        }\n\n    }\n    /**\n     * \n     * @param {*} patternInfo \n     * @param {*} _line \n     * @param {*} option \n     * @returns \n     */\n    detectConstantPattern(patternInfo, _line, option) {\n        const _endRegex = patternInfo.endRegex;\n        let _nPatternInfo = this._createStreamConstantPattern(patternInfo, _line, _endRegex, option);\n        option.pos = option.line.length;\n        this._updateMarkerOldContentOrSwapBuffer(_nPatternInfo, null, '', _endRegex, option);\n        return _nPatternInfo;\n    }\n    /**\n     * create the stream buffer object\n     * @returns \n     */\n    _createStreamBuffer() {\n        return new FormatterStreamBuffer();\n    }\n    /**\n     * create a stream constant pattern\n     * @param {*} patternInfo \n     * @param {*} _line \n     * @param {*} _endRegex \n     * @param {*} option \n     * @returns \n     */\n    _createStreamConstantPattern(patternInfo, _line, _endRegex, option) {\n        // patterns : patternInfo.hostPatterns\n        let _stream_buffer = this._createStreamBuffer();\n        _stream_buffer.from = patternInfo;\n        _stream_buffer.initialMode = option.nextMode;\n        // copy marker info \n        _stream_buffer.sourceMarkerInfo = option.markerInfo.slice(0);\n        _stream_buffer.sourceTokenList = option.tokenList.slice(0);\n        if (_line && _line.length > 0)\n            _stream_buffer.appendToBuffer(_line);\n\n\n        let _nPatternInfo = new PatternMatchInfo();\n        let _idx = patternInfo.indexOf;\n        _nPatternInfo.use({\n            marker: _stream_buffer,\n            endRegex: patternInfo.endRegex, //  ,\n            group: patternInfo.group,\n            line: option.line, // source line\n            parent: patternInfo?.parent,\n            patterns: patternInfo.hostPatterns,\n            index: _idx,\n            formatting: this.formatting\n        });\n        _stream_buffer.startPosition = option.pos;\n        _stream_buffer.start(option);\n        return _nPatternInfo;\n    }\n    /**\n     * check and start block definition\n     * @param {*} patternInfo \n     * @param {*} option \n     * @param {boolean} init \n     */\n    _checkStartBlockDefinition(patternInfo, option, init = false) {\n        const _formatting = this.formatting;\n        // start a new block\n        if (patternInfo.isBlock && !patternInfo.isBlockStarted) {\n            init && this._initBlockStarting(patternInfo, option);\n            _formatting.startBlockDefinition(this, patternInfo, option);\n        }\n    }\n    /**\n     * \n     * @param {*} patternInfo \n     * @param {*} option \n     * @param {*} _old \n     */\n    _updateStreamRangeModeToHolder(patternInfo, option, _old) {\n        if (option.range.start != option.range.end) {\n            this._updatePatternPrevConstant(patternInfo, option, null, null, true);\n            this._updateOldMarkerContent(_old, option);\n            option.storeRange(option.pos);\n        }\n    }\n    /**\n     * get item found callback\n     * @returns \n     */\n    _handleItemFoundCallback() {\n        return function (_matcher, patternInfo, _old, _buffer, _endRegex, option) {\n            const { debug } = option;\n            let { nextMode } = option;\n            if (_old == null) {\n                this._registerTokenName(patternInfo, option);\n            }\n            // handle matcher   \n\n            let _newOld = this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n            nextMode = _newOld.currentMode;\n\n            // update previous matcher info\n            option.storeRange(option.pos, _matcher.group.index);\n            if (option.range.start != option.range.end) {\n                this._updatePatternPrevConstant(patternInfo, option, null, null, true);\n                _newOld.currentMode = nextMode;\n                this._updateOldMarkerContent(_newOld, option);\n                option.storeRange(option.pos);\n            }\n            this._checkStartBlockDefinition(patternInfo, option);\n            this._checkStartBlockDefinition(_matcher, option);\n            debug?.feature('found-items') && Debug.log(\"--::: found item #\" + _matcher.toString());\n            let _ret = this._handleMarker(_matcher, option);\n            return _ret;\n        };\n    }\n    /**\n     * \n     * @param {{_p, _matcher, patternInfo, option, endFound(), itemFound(), \n     * handleConstant(patternInfo, _line:string, option):}} param \n     */\n    handleMatchLogic({\n        _p, _matcher, _buffer, _old, patternInfo, option, _line,\n        endFound,\n        itemFound, handleConstant\n    }) {\n        let _continue_with_marker = false;\n        const _endRegex = patternInfo.endRegex;\n        const q = this;\n        endFound = endFound || q._handleFoundEndPattern;\n        handleConstant = handleConstant || q.detectConstantPattern;\n        itemFound = itemFound || q._handleItemFoundCallback();\n        if (_matcher == null) {\n            // no child matcher found\n            if (_p == null) {\n                // no end - found \n                _continue_with_marker = true;\n                // update cursor \n                q._appendConstant(patternInfo, _line, option);\n                option.pos = option.line.length;\n            } else {\n                // ---------------------------------------------------------------\n                // + | invoke END FOUND\n                // ---------------------------------------------------------------\n                return endFound.apply(q,\n                    [_buffer, _line, patternInfo, _p, option, _old]);\n            }\n        }\n        else {\n\n            // compared index and handle child\n            if ((_p == null) || (_matcher.group.index < _p.index)) {\n                // handle matcher  \n                return itemFound.apply(q, [_matcher, patternInfo, _old, _buffer, _endRegex, option]);\n            }\n            // check if same \n            if (_matcher.group.index == _p.index) {\n                return Formatters.HandleSameGroup(q, patternInfo, _matcher, _p, _old, _buffer, _endRegex, option, endFound);\n            }\n            // priority to current marker \n            return endFound.apply(q, [_buffer, _line, patternInfo, _p, option, _old]);\n            // throw new Error(\"Detected after not handle\");\n        }\n        if (_continue_with_marker) {\n            q._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n            return patternInfo;\n        }\n\n        // + | default append \n        listener.append(group[0], patternInfo);\n        // + | move forward\n        option.moveTo(_next_position);\n        return patternInfo.parent;\n    }\n    static HandleSameGroup(q, patternInfo, _matcher, _p, _old, _buffer, _endRegex, option, endFound, _line) {\n\n        const { debug } = option;\n        // const { endMatchLogic } = q.settings;\n        debug?.feature('handle-same-group') && (() => {\n            Debug.log('-:::handle same group:::-');\n        })();\n        // + | priority end group\n        let _ret = null;\n        _line = _line || option.line.substring(option.pos);\n        let startLine = patternInfo.isStreamCapture ? option.startLine : undefined;\n        // debug && Debug.log(\"Before logic just call end found. \");             \n        if (endFound) {\n            _ret = endFound.apply(q, [_buffer, _line, patternInfo, _p, option, _old]);\n        } else {\n            _ret = q._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n        if (startLine) {\n            option.startLine = startLine;\n            if (startLine) {\n                option.skipUpdateStartLine = true;\n            }\n        }\n        return _ret;\n    }\n    isSpecialMarker(marker) {\n        return marker instanceof SpecialMeaningPatternBase\n    }\n    /**\n     * append buffer and new line end buffer list\n     * @param {string} sb \n     * @param {PatternMatchInfo} marker \n     * @param {FormatterOptions} option \n     */\n    appendBufferAndLine(sb, marker, option) {\n        option.appendToBuffer(sb, marker);\n        option.store();\n        option.appendExtraOutput();\n    }\n}\n\nclass SpecialMeaningPatternBase extends Patterns {\n    get isSpecial() { return true; }\n}\n\nclass BlockPatternBase extends SpecialMeaningPatternBase {\n    get isBlock() { return true; }\n}\nclass EmptyBlockPattern extends BlockPatternBase {\n    name = 'system.empty.block';\n    get isEmptyBlock() { return true; }\n}\nclass BlockDefinitionPattern extends BlockPatternBase {\n    get isBlockDefinition() { return true };\n    name = 'system.block.definition';\n}\n\n/**\n * use to debug constant list \n */\nclass SystemConstantPattern extends SpecialMeaningPatternBase {\n    tokenID = 'constant';\n    transform = [function (v) {\n        if (v.trim().length == 0) return ''; return v;\n    }, 'joinSpace']\n    markedInfo() {\n        return Utils.GetMarkedInfo(this);\n    }\n}\n// previous contains before add to buffer \nclass PrevLineFeedConstantPattern extends SystemConstantPattern {\n    name = 'system.prev.line.feed.constant';\n\n    /**\n     * check if shift id constant\n     * @returns {bool}\n     */\n    shiftIdConstant() {\n        return false;\n    }\n}\n\nclass TrimmedPrevLineFeedConstant extends PrevLineFeedConstantPattern {\n    constructor() {\n        super();\n        this.markedSegment = {\n            trimmed: true\n        }\n    }\n}\n\nconst SYSTEM_MATCH_TYPE = 0x100;\n\nclass GlobalConstantPattern extends SystemConstantPattern {\n    name = 'system.global.line.constant';\n\n}\nclass StreamLineConstantPattern extends SystemConstantPattern {\n    name = 'system.stream.line.constant';\n}\nclass StreamBufferConstantPattern extends SystemConstantPattern {\n    name = 'system.stream.buffer.constant';\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 8;\n    }\n}\n\nclass PrevConstantPattern extends SystemConstantPattern {\n    name = 'system.prev.line.constant';\n}\nclass NameOnlyConstantPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 3;\n    }\n}\n\nclass RefConstantPattern extends SystemConstantPattern {\n    constructor(n) {\n        super();\n        this.name = n;\n    }\n}\nclass JoinMarkerPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 6;\n    }\n}\n\nclass EntryCapturePattern extends SpecialMeaningPatternBase {\n    name = 'entry.capture.pattern';\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 7;\n    }\n    constructor(value) {\n        super();\n        Object.defineProperty(this, 'value', { get() { return value; } })\n    }\n}\nclass TypeMarkerInfoPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 5;\n    }\n    constructor(type, { parser, data }) {\n        super();\n        if (typeof (type) == 'string') {\n            type = type.replace('.', '-');\n            this.tokenID = data?.tokenID || type;\n            this.name = data?.name || type;\n        }\n        if (data) {\n            // get extra key definition and append to parent\n            const keys = Object.keys(data);\n            const _mkeys = Object.keys(this);\n\n            ['type', 'value'].forEach(i => {\n                const idx = keys.indexOf(i);\n                if (idx !== -1)\n                    delete (keys[idx]);\n            });\n\n            const _diff = keys.filter((a) => _mkeys.indexOf(a) === -1);\n            const q = this;\n            _diff.forEach((o) => {\n                Object.defineProperty(q, o, { get() { return data[o]; } });\n            });\n        }\n    }\n}\n\nUtils.Classes = {\n    ...Utils.Classes,\n    Formatters\n};\n\nexports.Formatters = Formatters;\nexports.Utils = Utils;\nexports.Patterns = Patterns;\nexports.JSonParser = JSonParser;\nexports.SpecialMeaningPatternBase = SpecialMeaningPatternBase;\n\nconst { FormatterStreamBuffer } = require('./FormatterStreamBuffer');\nconst { FormatterLintError } = require('./FormatterLintError');\nconst { PatterMatchErrorInfo } = require('./PatterMatchErrorInfo');\nconst { ReplaceWithCondition } = require('./ReplaceWithCondition');\nconst { FormatterMatchTreatment } = require('./FormatterMatchTreatment');\n\n\n\nUtils.Classes.FormatterStreamBuffer = FormatterStreamBuffer;\n\n// Utils.DefineProperties(Utils.Classes, exports);","\"use strict\";\nconst K_R = 'KAndR'\nconst PSR_2 = 'PSR-2';\nconst PSR_21 = 'PSR-21';\nconst PSR_12 = 'PSR-12';\nconst ALLMAN = 'Allman';\nclass FormattingCodeStyles{\n    static get K_R(){return K_R; } \n    static get PSR_2(){return PSR_2; } \n    static get PSR_21(){return PSR_21; } \n    static get PSR_12(){return PSR_12; } \n    static get ALLMAN(){return ALLMAN; } \n\n    /**\n     * \n     * @param {*} data \n     */\n    static Support(data){\n        // \n        return FormattingCodeStyles.GetSupportedValues().indexOf(data) != -1;\n    }\n    static GetSupportedValues(){\n        return [\n            K_R,PSR_2, PSR_21, PSR_12, ALLMAN\n        ]\n    }\n}\nexports.FormattingCodeStyles = FormattingCodeStyles;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nexports.FormattingBase = void (0);\nconst { Debug } = require(\"../Debug\");\nconst { FormatterSegmentJoin } = require(\"../FormatterSegmentJoin\");\nconst { FormatterBuffer } = require(\"../FormatterBuffer\");\n\n\nconst CODE_STYLE_FORMATTERS = {};\n/**\n * operation to manipulate the formatter buffer on condition.\n */\nclass FormattingBase {\n    trimConstant;\n\n    startBlock({ currentMode }, _marker, _option) {\n        currentMode = FM_START_LINE;\n        arguments[0].currentMode = currentMode;\n    }\n    oldStartStreamingBlock({currentMode}){\n        currentMode = FM_START_LINE; \n        //arguments[0].currentMode = 100+currentMode;\n    }\n    /**\n     * update buffer prev content constant\n     * @param {*} data \n     * @param {*} mode \n     * @param {*} _marker \n     * @param {*} option \n     */\n    updateBufferConstant(data, mode, _marker, option) {\n        const { formatterBuffer } = option;\n        switch (mode) {\n            case FM_START_LINE:\n            case FM_END_BLOCK:\n                data = data.trimStart();\n                let _buffer = option.buffer;\n                if (_buffer.length > 0) {\n                    option.output.push(_buffer); // append line \n                    formatterBuffer.clear();\n                }\n                option.appendToBuffer(data, _marker);\n                mode = FM_APPEND;\n                break;\n            case FM_APPEND:\n                option.appendToBuffer(data, _marker);\n                break;\n            case FM_START_BLOCK:\n                // +| depending on the formatting mode start new block\n                data = data.trimStart();\n                if (data.length > 0) {\n                    option.appendToBuffer(data, _marker);\n                    mode = FM_APPEND;\n                }\n                break;\n            case FM_END_INSTRUCTION: // update buffer after end instruction\n                data = data.trimStart();\n                if (data.length > 0) {\n                    option.lineFeedFlag && option.appendExtraOutput();\n                    option.appendToBuffer(data, _marker);\n                    if (option.output.length > 0) {\n                        option.store();\n                        formatterBuffer.appendToBuffer(option.flush(true));\n                    }\n                    mode = FM_APPEND;\n                }\n                break;\n            case FM_START_LINE_APPEND:\n                data = data.trimStart();\n                if (data.length > 0) {\n                    option.appendToBuffer(data, _marker);\n                    option.store();\n                    mode = FM_APPEND;\n                }\n                break;\n            default:\n                throw new Error('update Buffer not handled : ' + mode);\n        }\n        _marker.mode = mode;\n    }\n    /**\n     * update marker global option\n     * @param {*} param0 \n     */\n    updataMarkerGlobalOption({ mode, lineFeedFlag, startLine }, option) {\n        const e = arguments[0];\n        switch (mode) {\n            case FM_START_LINE_NEXT_LINE:\n            case FM_END_BLOCK:\n            case FM_START_LINE:\n            case FM_END_INSTRUCTION:\n            case FM_APPEND_BLOCK:\n                startLine = true;\n                lineFeedFlag = true;\n                break;\n            default:\n                break;\n        }\n\n        e.lineFeedFlag = lineFeedFlag;\n        e.startLine = startLine;\n        if (option) {\n            option.startLine = startLine;\n            option.lineFeedFlag = lineFeedFlag;\n            option.nextMode = mode;\n        }\n    }\n    /**\n     * \n     * @param {number} mode \n     * @param {*} option \n     */\n    updateGlobalFormatting({ mode, formattingMode }, { lineFeedFlag, line, pos, length }) {\n        // after mode update global mode options\n        const option = arguments[1];\n\n        if (formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) {\n            if (mode == FM_START_LINE) {\n                mode = FM_APPEND;\n                lineFeedFlag = (pos >= length) || (line.trimEnd().length == pos);\n            }\n        }\n        switch (mode) {\n            case FM_START_LINE:\n            case FM_START_BLOCK:\n            case FM_END_BLOCK:\n                lineFeedFlag = true;\n                break;\n        }\n        option.lineFeedFlag = lineFeedFlag;\n    }\n    /**\n     * treat contant value before append to buffer\n     * @param {*} value \n     * @param {*} marker \n     */\n    treatConstantValue(value, marker, option) {\n        if (this.trimConstant) {\n            value = value.trimEnd();\n        }\n        return value;\n    }\n    /**\n     * retrieve append mode\n     */\n    get appendMode() {\n        return FM_APPEND;\n    }\n    updateStartFormatting(mode, option) {\n        switch (mode) {\n            case FM_START_LINE:\n            case FM_START_BLOCK:\n                option.startLine = true;\n                break;\n        }\n\n    }\n    updateEmptySkipMatchedValueFormatting(parent, option, { formattingMode }) {\n        if (parent) {\n            parent.mode = FM_START_LINE;\n        } else {\n            let _gformatting = FM_APPEND;\n            if (formattingMode == PatternFormattingMode.PFM_LINE_FEED) {\n                _gformatting = FM_START_LINE;\n            }\n            this.updateGlobalFormatting({ mode: _gformatting, formattingMode }, option);\n        }\n    }\n    /**\n     * update mode on close marker \n     * @param {*} marker \n     */\n    closeMarker(marker) {\n        if ((marker.isBlock) && (marker.mode == FM_APPEND)) {\n            marker.mode = FM_START_LINE;\n        }\n    }\n    updateMergeEndBlock({ content, marker, option, extra, buffer, _hasBuffer, _hasExtra }) {\n        let value = '';\n        let mode = marker.mode;\n        if (_hasBuffer) {\n            value += buffer;\n            mode = FM_START_LINE;\n        }\n        content = content.trimEnd();\n        return { value, content, mode };\n    }\n    /**\n     * \n     * @param {*} marker \n     * @param {FormatterOptions} option \n     */\n    updateEndLineUpdateMode(marker, option) {\n        if (marker) {\n            const _old = option.markerInfo[0];\n            const { formattingMode, mode } = marker;\n            let _buffer_is_empty = option.formatterBuffer.isEmpty;\n            if ((formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) && (mode == FM_APPEND)) {\n                option.nextMode = FM_START_LINE;\n                marker.mode = FM_START_LINE;\n                // + | change the current mode to start line request\n                if ((_old.currentMode == FM_APPEND) && (_buffer_is_empty)) {\n                    _old.currentMode = FM_START_LINE;\n                }\n            }\n        }\n    }\n    updatePreprendExtra(prependExtra, extra, option) {\n        option.saveBuffer();\n        let r = '';\n        (!Array.isArray(prependExtra) ? [prependExtra] : prependExtra).\n            forEach(i => {\n                option.formatterBuffer.appendToBuffer(i);\n                option.store();\n            });\n        if (extra !== null)\n            option.output.push(extra);\n        r = option.flush(true);\n        option.restoreSavedBuffer();\n        extra = r;\n        return { extra };\n    }\n    /**\n     * update buffer segment data\n     * @param {*} formatterBuffer \n     * @param {*} bufferData \n     */\n    _updateFormatterBufferSegments(formatterBuffer, bufferData) {\n        const { bufferSegment, dataSegment } = bufferData;\n        formatterBuffer.appendToBuffer({\n            bufferSegments: bufferSegment,\n            dataSegments: dataSegment\n        });\n    }\n    // + | -------------------------------------------------------------\n    // + | depending on marker mode update old marker content new value\n    // + | update from buffer content. \n    // + | -------------------------------------------------------------    \n    updateOldMarkerContent({ content, marker, extra, buffer, data, segments, option, mode, isEntryContent,\n        autoStartLine, prependExtra, bufferData }) {\n        let _ld = '';\n        const { debug, joinWith, formatterBuffer } = option;\n        mode = mode == undefined ? FM_APPEND : mode;\n        const _props = arguments[0];\n        let _hasExtra = (extra.length > 0);\n        let _hasBuffer = (buffer.length > 0);\n        if (!_hasExtra && !_hasBuffer) {\n            return content;\n        }\n        if (prependExtra) {\n            // + | ----------------------------------------------------------\n            // + | prepend extra data \n            // + | ----------------------------------------------------------\n            ({ extra } = this.updatePreprendExtra(prependExtra, extra, option));\n            prependExtra = null;\n        }\n\n        const _undef = typeof (marker.mode) == 'undefined';\n        let _append_next_mode = _undef ? FM_APPEND : marker.mode;\n\n        debug?.feature('update-old-buffer') && (function () {\n            Debug.log(\"--::: update old buffer :::--\");\n            console.log({ content, buffer, extra, mode, data });\n        })();\n\n        const _updateLd = () => {\n            const _ref_data = {};\n            const _buffer = option.flush(true, _ref_data);\n            _ld += _buffer;\n            _updateSegment({ buffer: _buffer, data: _ref_data.data });\n        };\n        const _updateSegment = ({ buffer, data }) => {\n            segments.bufferSegment.push(buffer);\n            segments.dataSegment.push(data);\n        };\n        // + | update what for buffer data\n        const _updateBufferedData = ({ dataSegment, bufferSegment }) => {\n            FormatterSegmentJoin.UpdateSegmentData(segments, { dataSegment, bufferSegment });\n        };\n        let _treat_buffer_data = false;\n\n        const _treat_buffer_data_fc = (op='trimmed')=>{\n            if (_treat_buffer_data)return;\n            FormatterBuffer.TreatMarkedSegments(bufferData, op);\n            buffer = bufferData.bufferSegment.join('');\n            _treat_buffer_data = true;\n        };\n\n        //+ || handle trimmed container\n        if ((marker.formattingOptions?.trimmedContainer || /\\(|\\[|\\{/.test(content)) && (marker.childs.length < 2)){\n            _treat_buffer_data_fc();\n        }\n\n\n\n\n        const _flushData = {};\n        switch (mode) {\n            case FM_START_LINE:\n                _treat_buffer_data_fc(); \n                if (joinWith) {\n                    _ld = buffer;\n                } else {\n                    _ld = this._treatOldMarkerContent(option, true, extra, buffer, _hasBuffer, _hasExtra);\n                }\n                if (_ld.length <= 0) {\n                    _append_next_mode = FM_START_LINE;\n                } else\n                    _flushData.dataOutput = _ld;\n                break;\n            case FM_END_BLOCK:\n                // after end block\n                // start line \n                option.appendExtraOutput();\n                let value = '';\n                ({ value, mode, content } = this.updateMergeEndBlock({ content, marker, extra, buffer, option, _hasBuffer, _hasExtra }));\n                option.formatterBuffer.appendToBuffer(value);\n                option.store();\n                _ld = option.flush(true, _flushData);\n                break;\n            case FM_START_BLOCK: // every block start with extra output\n                option.appendExtraOutput();\n                if (_hasExtra)\n                    option.output.push(extra);\n                if (_hasBuffer) {\n                    formatterBuffer.appendToBuffer(buffer);\n                    option.store();\n                }\n                _ld = option.flush(true, _flushData);\n                if (_append_next_mode == FM_END_BLOCK) {\n                    _append_next_mode = FM_START_LINE;\n                }\n                break;\n            case FM_END_INSTRUCTION: // after end instruction \n                if (_hasExtra) {\n                    option.output.push(extra);\n                    _ld = option.flush(true);\n                    _hasExtra = false;\n                }\n                if (_hasBuffer) {\n                    if (!_hasExtra) {\n                        option.appendExtraOutput();\n                    }\n                    option.formatterBuffer.appendToBuffer(buffer.trimStart());\n                    option.store();\n                    _ld += option.flush(true);\n                }\n                break;\n            case FM_APPEND_TO_NEXT:\n                if (_hasExtra) {\n                    option.appendExtraOutput();\n                    option.output.push(extra);\n                    _ld = option.flush(true);\n                }\n                if (buffer.length > 0) {\n                    if (!/\\\\s+$/.test(content)) {\n                        content += Utils.TreatValue(option.formatterBuffer, ' ', marker, option);\n                    }\n                    _ld += buffer;\n                }\n                break;\n\n            case FM_END_LINE:\n                // + | end line technique\n                option.appendExtraOutput();\n                if (_hasExtra) {\n                    option.output.push(extra);\n                    _updateLd();\n                }\n                if (_hasBuffer) {\n                    // trim end before store \n                    FormatterBuffer.TreatMarkedSegments(bufferData, 'trimmed');\n                    this._updateFormatterBufferSegments(formatterBuffer, bufferData);\n\n                }\n                option.store();\n                _ld = option.flush(true, _flushData);\n                if (option.nextMode == mode) {\n                    _append_next_mode = mode;\n                }\n                break;\n            case FM_APPEND:\n                if (_hasExtra) {\n                    option.appendExtraOutput();\n                    option.output.push(extra);\n                    _updateLd();\n                }\n                if (buffer.length > 0) {\n                    _ld += buffer;\n                    _updateBufferedData(bufferData);\n                }\n                break;\n            case FM_START_LINE_NEXT_LINE:\n                option.appendExtraOutput();\n                if (_hasBuffer) {\n                    formatterBuffer.appendToBuffer(buffer);\n                    option.store();\n                }\n                _ld = option.flush(true);\n                mode = FM_START_LINE_APPEND;\n                break;\n            case FM_START_LINE_APPEND:\n                _ld = this._treatOldMarkerContent(option, true, extra, buffer, _hasBuffer, _hasExtra);\n                _append_next_mode = FM_APPEND;\n                break;\n            case FM_APPEND_BLOCK:\n                ({ content, _ld } = this.onAppendBlock(content, extra, buffer, _hasBuffer, _hasExtra, isEntryContent, _flushData, segments));\n                if (!('dataOutput' in _flushData)) {\n                    _flushData['dataOutput'] = bufferData.dataSegment.join('');\n                }\n                break;\n\n            default:\n                throw new Error('mode not handle : ' + mode);\n        }\n        if ('dataOutput' in _flushData) {\n            _updateBufferedData({ dataSegment: [_flushData.dataOutput], bufferSegment: [_ld] });\n        }\n\n        marker.mode = _append_next_mode;\n        this._updateGlobalMarkerOptionDefinition(marker, option);\n        _props.mode = marker.mode;\n        _props.autoStartLine = autoStartLine;\n        _props.prependExtra = prependExtra;\n        return content + _ld;\n    }\n    /**\n     * append block\n     * @param {*} content \n     * @param {*} extra \n     * @param {*} buffer \n     * @param {*} _hasBuffer \n     * @param {*} _hasExtra \n     * @returns \n     */\n    onAppendBlock(content, extra, buffer, _hasBuffer, _hasExtra, isEntryContent, _flushData) {\n        let _ld = '';\n        if (extra.length > 0) {\n            _ld += extra;\n        }\n        if (buffer.length > 0) {\n            _ld += buffer;\n        }\n        return { content, _ld };\n    }\n    /**\n     * update defition \n     * @param {*} marker \n     * @param {*} option \n     */\n    _updateGlobalMarkerOptionDefinition(marker, option) {\n        const { mode, formattingMode } = marker;\n        const { lineFeedFlag, startLine } = option;\n        this.updataMarkerGlobalOption({ mode, formattingMode, lineFeedFlag, startLine }, option);\n    }\n    _treatOldMarkerContent(option, extraOutput, extra, buffer, _hasBuffer, _hasExtra) {\n        const { formatterBuffer } = option;\n        //extraOutput && !_hasExtra && option.appendExtraOutput();\n        extraOutput && option.appendExtraOutput();\n        if (_hasExtra) {\n            option.output.push(extra);\n        }\n        if (_hasBuffer) {\n            formatterBuffer.appendToBuffer(buffer);\n            option.store();\n        }\n        let _ld = option.flush(true);\n        return _ld.trim().length > 0 ? _ld : '';\n    }\n    /**\n     * is line feed\n     * @param {number} formattingMode \n     * @returns {boolean}\n     */\n    isLineFeed(formattingMode) {\n        return (formattingMode == PatternFormattingMode.PFM_LINE_FEED) ||\n            (formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED);\n    }\n    /**\n     * check if change to next append mode\n     * @param {*} mode \n     * @returns \n     */\n    canChangeNextFormatting(mode) {\n        switch (mode) {\n            case FM_END_INSTRUCTION:\n            case FM_END_BLOCK:\n                return true;\n\n        }\n        return false;\n    }\n    /**\n     * \n     * @param {*} formatter \n     * @param {PatternMatchInfo} marker \n     * @param {*} option \n     */\n    onAppendToBuffer(formatter, marker, value, option) {\n        let { mode } = marker;\n        const { debug } = option;\n        if (option.markerInfo.length > 0) {\n            const _old = option.markerInfo[0];\n            debug?.feature('on-append-to-buffer') && (()=>{\n                Debug.log(\"---::: onAppend to buffer - value :::---\");\n                console.log( value );\n            })()\n            // + | change current mode according to formatting rule\n            if (marker.formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) {\n\n                if (this.canChangeNextFormatting(_old.currentMode)) {\n                    if (option.startLine && (option.line.trimStart().indexOf(value) == 0)) {\n                        _old.currentMode = FM_START_LINE;\n                    } else\n                        _old.currentMode = FM_APPEND_TO_NEXT;\n                }\n\n            }\n        }\n        if (marker.lineFeed) {\n            mode = FM_START_LINE;\n        }\n        marker.mode = mode;\n\n\n    }\n    handleEndFound(formatter, marker, option, _buffer, _b) {\n        return marker.parent;\n    }\n    static Factory(name) {\n        if (name in CODE_STYLE_FORMATTERS) {\n            return CODE_STYLE_FORMATTERS[name];\n        }\n        let s = null;\n        let cname = name + 'Formatting';\n        const Library2 = Library;\n        let fc = new Function('lib', `const {${cname}} = lib; return ${cname};`);\n        let g = fc.apply(globalThis, [Library2]);\n        if (g) {\n            s = new g();\n            CODE_STYLE_FORMATTERS[name] = s;\n            return s;\n        }\n        throw new Error('missing code style formatters');\n    }\n\n    /**\n     * handle end end block buffer\n     * @param {*} _marker \n     * @param {*} _buffer \n     * @param {*} option \n     * @param {*} _old \n     * @returns \n     */\n    handleEndBlockBuffer(_marker, _buffer, option, _old) {\n        let _sbuffer = '';\n        if (option.depth > 0) {\n            if (!_old.blockStarted && (_old.content.length == 0)) {\n                option.store();\n                _sbuffer = option.flush(true);\n            }\n            else {\n                if (_old.entryBuffer.length == _old.content.trim().length) {\n                    option.store();\n                }\n                _sbuffer = option.flush(true) + _buffer;\n            }\n        } else {\n            option.store();\n            _sbuffer = option.flush(true);\n        }\n        return { _sbuffer };\n    }\n    /**\n     * on closing element passing mode to parent or ask for new line\n     * @param {*} formatter \n     * @param {*} marker_info \n     * @param {*} option \n     */\n    handleEndOnNonBlockElement(formatter, marker_info, option, { _b, _old }) {\n        // + | append with line feed if requested\n        const { parent, mode, lineFeed, formattingMode } = marker_info;\n        let _lf = (formattingMode == PatternFormattingMode.PFM_LINE_FEED) || (lineFeed);\n        let _build_lf = false;\n        if (parent) {\n            if (_lf) {\n                parent.mode = FM_START_LINE;\n            }\n            else {\n                // + passing current mode to parent\n                parent.mode = mode;\n            }\n        } else {\n            // build line on line feed or after ind line mode\n            _build_lf = (marker_info.mode == FM_END_LINE);\n            if (_lf) {\n                marker_info.mode = FM_START_LINE;\n            } else {\n                // + | depending on mode.\n                this._updateGlobalMarkerOptionDefinition(marker_info, option);\n            }\n        }\n        if (formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) {\n\n            if (this.onHandleSingleLineBuffer(option) &&\n                (_b.length > 0)) {\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.formatterBuffer.appendToBuffer(_b);\n                option.store();\n                let _buffer = option.flush(true);\n                option.restoreSavedBuffer();\n                option.formatterBuffer.appendToBuffer(_buffer);\n                _b = '';\n            }\n        } else {\n            _build_lf = _build_lf || (_old?.currentMode == FM_START_LINE);\n            if (_build_lf) {\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.formatterBuffer.appendToBuffer(_b);\n                option.store();\n                let _buffer = option.flush(true);\n                option.restoreSavedBuffer();\n                option.formatterBuffer.appendToBuffer(_buffer);\n                _b = '';\n            }\n        }\n        return { _b };\n    }\n    onHandleSingleLineBuffer({ buffer, startLine }) {\n        return startLine || buffer.split(\"\\n\").length > 1;\n    }\n    /**\n     * join stream buffer\n     * @param {*} mode \n     * @param {*} buffer \n     * @param {*} append \n     * @returns \n     */\n    joinStreamBuffer(mode, buffer, append) {\n        return buffer + append;\n    }\n    /**\n     * operation to handle end block after restoring buffer\n     * @param {Formatters} formatter \n     * @param {*} _marker parent marker info \n     * @param {string|{buffer:string, data:string}} _buffer \n     * @param {FormatterOptions} option \n     */\n    updateEndBlockAfterRestoringBuffer(formatter, _marker, _buffer, _old, option) {\n        const { parent, isBlock } = _marker;\n        let _mark_buffer = false;\n        if (parent) {\n            const { mode, childs, isAutoBlockElement } = parent;\n            if (isAutoBlockElement) {\n                if ((childs.length > 1)) {\n                    if (mode == FM_START_LINE) {\n\n                        option.saveBuffer();\n                        let _frm = option.formatterBuffer;\n                        _frm.appendToBuffer(_buffer);\n                        option.store();\n                        _buffer = option.flush(true);\n                        option.restoreSavedBuffer();\n                        option.output.push(_buffer);\n                        _buffer = '';\n                    }\n                } else if (isBlock && !option.formatterBuffer.isEmpty) {\n                    let c = option.buffer;\n                    c = option.flush(true) + c;\n                    option.output.push(c + _buffer);\n                    _buffer = option.flush(true);\n                    parent.mode = FM_END_BLOCK;\n                }\n            } else {\n                _mark_buffer = true;\n            }\n        }\n\n        if (_buffer?.output?.length > 0) {\n            option.output.push(..._buffer.output);\n        }\n        if (_buffer?.dataOutput?.length > 0) {\n            option.dataOutput.push(..._buffer.dataOutput);\n        }\n\n\n        const _next_old = (option.markerInfo.length > 0) ? option.markerInfo[0] : null;\n        if (!_mark_buffer)\n            option.formatterBuffer.appendToBuffer(_buffer);\n        else {\n            if (_next_old && _next_old.joinWith) {\n                formatter.appendJoinToBuffer(_next_old.joinWith, option);\n                _next_old.joinWith = null;\n            }\n            if (typeof (_buffer) == 'string') {\n                option.appendToBuffer(_buffer, _marker);\n            } else {\n                option.formatterBuffer.appendToBuffer(_buffer);\n            }\n        }\n        if (isBlock && _next_old) {\n            // + | update marker definition depending of the formatter\n            if (_next_old.currentMode == FM_APPEND) {\n                // change mode to append item\n                _next_old.currentMode = FM_APPEND_BLOCK;\n                option.nextMode = _next_old.marker.mode\n                    = FM_START_LINE;\n            }\n        }\n    }\n    /**\n     * depending on next matching mode updete line feed\n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _old old markerInfo\n     */\n    updateMatchNextFormatting(marker, option, _old) {\n        _old = _old || option.peekMarkerInfo;\n        let { content, currentMode } = _old || {};\n        const _parentMarker = _old?.marker;\n        const { formattingMode } = marker;\n        let { lineFeedFlag, nextMode, formatter } = option;\n        switch (formattingMode) {\n            case PatternFormattingMode.PFM_LINE_FEED:\n                lineFeedFlag = true;\n                nextMode = FM_START_LINE;\n                break;\n            case PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED:\n                // + | append to extra line comment if possible \n                if ((content?.length > 0) && (option.lineSegments.length > 1) && (currentMode !== FM_END_LINE) && (currentMode == FM_START_LINE)) {\n                    lineFeedFlag = false;\n                    currentMode = FM_APPEND;\n                    _old.currentMode = FM_APPEND;\n                    _old.marker.mode = option.nextMode = FM_END_LINE;\n                    const _prepend = marker.formattingPrependExtra;\n                    let _prepend_value = _prepend == undefined ? \" \" : _prepend;\n                    if (_prepend_value) {\n                        let s = FormatterBufferUtils.TreatValue(formatter, _prepend_value, marker, option);\n                        option.formatterBuffer.prepend(s);\n                    }\n                    formatter._updateOldMarkerContent(_old, option);\n                    lineFeedFlag = true;\n                    nextMode = _old.marker.mode;\n                } else {\n                    let _emode = FM_END_LINE;\n                    if (_parentMarker?.isBlock && (content?.length==0)){\n                        _old.currentMode = FM_START_BLOCK;\n                    }\n                    lineFeedFlag = true;\n                    nextMode = _emode;\n                }\n                break;\n            default:\n                break;\n        }\n        option.lineFeedFlag = lineFeedFlag;\n        option.nextMode = nextMode;\n    }\n    updateNextSavedMode(mode, option) {\n        switch (mode) {\n            case FM_START_BLOCK:\n                mode = FM_END_BLOCK;\n                break;\n        }\n        option.nextMode = mode;\n        option.startLine = this.isStartLine(mode);\n    }\n    isStartLine(mode) {\n        return mode == FM_END_BLOCK;\n    }\n    /**\n     * on end update buffer\n     */\n    onEndUpdateBuffer({ marker, option, update, _buffer, _data, _trimOutput = false }) {\n        return update({ marker, _buffer, _data, _trimOutput }, option);\n    }\n    /**\n     * \n     * @param {*} old \n     * @param {*} option \n     */\n    updateBlockMarkerPropertyMode(old, option) {\n        old.currentMode = FM_APPEND_BLOCK;\n    }\n    /**\n    * treat and start block definition \n    * @param {Formatters} formatter \n    * @param {PatternMatchInfo} patternInfo \n    * @param {FormatterOptions} option \n    */\n    startBlockDefinition(formatter, patternInfo, option) {\n        patternInfo.isBlockStarted = true;\n        formatter._startBlock(option);\n        if (!option.isCurrentFormatterBufferIsRootBuffer) {\n            let _cf = option.flush(true);\n            if (_cf.length > 0) {\n                throw new Error('start block contains definition: ' + _cf);\n            }\n        }\n        patternInfo.mode = FM_START_BLOCK;\n        const { parent } = patternInfo;\n        if (parent) {\n            parent.mode = FM_APPEND;\n        }\n    }\n\n    /**\n     * element is block by auto child setup\n     * @param {} formatter \n     * @param {*} marker_info \n     * @param {*} option \n     */\n    handleEndFormattingOnNonStartBlockElement(formatter, marker_info, option) {\n        const { mode } = marker_info;\n        switch (mode) {\n            case FM_START_LINE:\n                // append line \n                let _buffer = option.buffer;\n                option.appendExtraOutput();\n                let _sbuffer = option.flush(true);\n                if (_buffer.length > 0) {\n                    option.output.push(_buffer); // append line \n                }\n                option.formatterBuffer.appendToBuffer(_sbuffer);\n                marker_info.mode = FM_APPEND;\n                break;\n        }\n    }\n    handleBufferingNextToSbuffer(marker, option) {\n        const { mode } = marker;\n        let _sbuffer = option.buffer;\n        // clear buffer \n        _sbuffer += option.flush(true);\n        return _sbuffer;\n    }\n    onEndInstruction(marker, option) {\n        // instruction        \n        marker.mode = FM_END_INSTRUCTION;\n        this._updateGlobalMarkerOptionDefinition(marker, option);\n    }\n    formatJoinFirstEntry(entryBuffer, buffer) {\n        return [entryBuffer, buffer].join(\"\\n\");\n    }\n    formatHandleExtraOutput(marker, _extra, option) {\n        let { mode } = marker;\n        let r = _extra;\n        switch (mode) {\n            case FM_END_INSTRUCTION:\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.output.push(r);\n                r = option.flush(true);\n                option.restoreSavedBuffer();\n                mode = FM_APPEND;\n                break;\n        }\n        marker.mode = mode;\n        return r;\n    }\n}\n\n//+ |  on end append technique\n\n\n\nexports.FormattingBase = FormattingBase\n/**\n * code style formatters\n */\nconst { KAndRFormatting } = require('./KAndRFormatting');\nconst { FM_APPEND, FM_START_LINE, FM_START_BLOCK, FM_END_BLOCK, FM_START_LINE_NEXT_LINE, FM_APPEND_BLOCK,\n    FM_END_INSTRUCTION, FM_START_LINE_APPEND, FM_APPEND_TO_NEXT, FM_END_LINE\n    , PatternFormattingMode,\n    FormattingMode } = require('./FormattingMode');\nconst { FormatterOptions } = require('../FormatterOptions');\nconst { Formatters, Utils } = require('../Formatters');\nconst { PatternMatchInfo } = require('../PatternMatchInfo');\nconst { FormatterBufferUtils } = require(\"../FormatterBufferUtils\");\n\n\nconst Library = {\n    KAndRFormatting\n};","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst FM_START = 0;\nconst FM_APPEND = 1;\nconst FM_APPEND_BLOCK = 9;\nconst FM_START_BLOCK = 5;\nconst FM_END_INSTRUCTION = 3;\nconst FM_END_BLOCK = 6;\nconst FM_START_LINE = 2;\nconst FM_START_LINE_NEXT_LINE = 7; \nconst FM_START_LINE_APPEND = 8; // start line then append \nconst FM_APPEND_TO_NEXT = 10;\nconst FM_END_LINE = 11; // mark current mode as end of line . used for single line comment\n\nexports.FM_APPEND = FM_APPEND;\nexports.FM_START_LINE = FM_START_LINE; \nexports.FM_START_BLOCK = FM_START_BLOCK;\nexports.FM_END_BLOCK = FM_END_BLOCK; \nexports.FM_START_LINE_NEXT_LINE = FM_START_LINE_NEXT_LINE; \nexports.FM_END_INSTRUCTION = FM_END_INSTRUCTION; \nexports.FM_START_LINE_APPEND = FM_START_LINE_APPEND; \nexports.FM_APPEND_BLOCK = FM_APPEND_BLOCK; \nexports.FM_APPEND_TO_NEXT = FM_APPEND_TO_NEXT; \nexports.FM_END_LINE = FM_END_LINE; \n\n/**\n * configured formatting mode \n */\n// format as single line feed\nconst PFM_LINE_FEED = 1;\n// require join for single pattern\nconst PFM_LINE_JOIN_END = 2; \n// join line formatting mode \nconst PFM_LINE_JOIN = 3;\n\n// enable streaming buffer\nconst PFM_STREAMING = 4;\n\nconst PFM_APPEND_THEN_LINE_FEED = 5;\n\nconst PFM_LINE_FEED_IF_IS_UPDATED_BLOCK = 6;\n\n\nexports.PatternFormattingMode = {\n    get PFM_LINE_FEED(){\n        return PFM_LINE_FEED;\n    },\n    get PFM_LINE_JOIN_END(){\n        return PFM_LINE_JOIN_END;\n    },\n    get PFM_LINE_JOIN(){\n        return PFM_LINE_JOIN;\n    },\n    get PFM_STREAMING(){\n        return PFM_STREAMING;\n    },\n    get PFM_APPEND_THEN_LINE_FEED(){\n        return PFM_APPEND_THEN_LINE_FEED;\n    },\n    get PFM_LINE_FEED_IF_IS_UPDATED_BLOCK(){\n        return PFM_LINE_FEED_IF_IS_UPDATED_BLOCK;\n    }\n};\n\n\nexports.FormattingMode = {\n    FM_APPEND,\n    FM_START_BLOCK,\n    FM_END_INSTRUCTION,\n    FM_END_BLOCK,\n    FM_START_LINE,\n    FM_START_LINE_NEXT_LINE ,\n    FM_APPEND_BLOCK,\n};\n\n\nexports.HandleFormatting = function(_marker, option, _old) {\n        let _mode = _marker.mode;\n        let _sbuffer = '';\n        let _buffer = option.buffer;\n\n        let _formatting = this.formatting;\n        switch (_mode) {\n            case FM_START:\n                option.store();\n                option.appendExtraOutput();\n                _sbuffer = option.flush(true);\n                _mode = FM_START_LINE;\n                break;\n            case FM_START_LINE:\n                // store then go to append\n                let _append = true;\n                if (_buffer.trim().length == 0) {\n                    option.formatterBuffer.clear();\n                    _buffer = '';\n                    _append =false;\n                } else {\n                    option.store(); \n                }\n                _sbuffer = option.flush(true);\n                if (_append && (_sbuffer.length > 0)) {\n                    _mode = FM_APPEND;\n                }\n                break;\n            case FM_APPEND:\n                // + | append to buffer \n                _sbuffer = option.buffer;\n                _sbuffer = option.flush(true) + _sbuffer;\n                break;\n            case FM_END_INSTRUCTION: \n                // + | append-flush-next-start-new-line\n                _sbuffer = option.flush(true)+_buffer;  \n                _mode = FM_START_LINE;\n                break;\n            case 4:\n                // store what is on the buffer append nuew file\n                option.store();\n                option.appendExtraOutput();\n                _sbuffer = option.flush(true);\n                _mode = FM_START_LINE;\n\n                break;\n            case FM_START_BLOCK: // start block - append line before append\n                if (_buffer.length>0){ \n                    option.store();   \n                    _sbuffer = option.flush(true);\n                    _mode = FM_APPEND;\n                }\n                break; \n            case FM_END_BLOCK:\n                ({_sbuffer} = _formatting.handleEndBlockBuffer(_marker, _buffer, option, _old)); \n                _mode = FM_START_LINE;\n                break;\n            case FM_START_LINE_NEXT_LINE:\n                option.store();\n                _sbuffer = option.flush(true);\n                if (_sbuffer.length > 0) {\n                    _mode = FM_START_LINE;\n                }else\n                    _mode = FM_APPEND;\n                break;\n        }\n        _marker.mode = _mode;\n        return _sbuffer;\n};\n \n/**\n * \n * @param {*} patternInfo \n */\nfunction formattingSetupPatternForBuffer(patternInfo, option){\n \n} \nexports.formattingSetupPatternForBuffer = formattingSetupPatternForBuffer;\n\n\nconst AC_PARENT = 'parent';\nconst AC_NEXT = 'next';\nclass StreamActions{\n    static get PARENT(){\n        return AC_PARENT;\n    }\n    static get NEXT(){\n        return AC_NEXT;\n    }\n}\n\n\nexports.StreamActions = StreamActions;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterOptions } = require('../FormatterOptions');\nconst { PatternMatchInfo } = require('../PatternMatchInfo');\nconst { FormattingBase } = require('./FormattingBase')\nconst { FM_APPEND, FM_START_LINE, FM_START_BLOCK, FM_END_BLOCK,\n    FM_START_LINE_NEXT_LINE, FM_END_INSTRUCTION,\n    FM_START_LINE_APPEND,\n    PatternFormattingMode } = require('./FormattingMode');\n\nconst { Utils } = require('../Utils');\n\n\n\n\nconst ALLOW_WHITE_SPACE = [FM_APPEND, FM_START_LINE];\n\nclass KAndRFormatting extends FormattingBase {\n    mergeEndBlock = true;\n\n    /**\n     * join stream buffer\n     * @param {number} mode \n     * @param {string} buffer \n     * @param {string} append \n     * @returns \n     */\n    joinStreamBuffer(mode, buffer, append) {\n        switch (mode) {\n            case FM_START_BLOCK:\n                buffer = buffer.trimEnd() + append;\n                return buffer;\n\n        }\n        return super.joinStreamBuffer(mode, buffer, append);\n    }\n\n    updateMergeEndBlock({ content, marker, option, extra, buffer, _hasBuffer, _hasExtra }) {\n        if (this.mergeEndBlock) {\n            return super.updateMergeEndBlock(arguments[0]);\n        }\n        let value = '';\n        let mode = marker.mode;\n        if (_hasBuffer) {\n            value += buffer;\n            mode = FM_START_LINE;\n        }\n        content = content.trimEnd();\n        option.output.push(content);\n        option.appendExtraOutput();\n        content = option.flush(true);\n        return { value, content, mode };\n    }\n    /**\n     * check allow empty space \n     * @param {number} mode \n     * @param {FormatterOptions} option \n     * @return {bool}\n     */\n    allowEmptySpace(mode, option) {\n        if (option.formatterBuffer.length > 0) {\n            return true;\n        }\n        return ALLOW_WHITE_SPACE.indexOf(mode) != -1;\n    }\n    /**\n     * \n     * @param {*} formatter \n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _buffer \n     * @param {*} _refData \n     * @returns \n     */\n    handleEndFormattingBeforeStore(formatter, marker, option, _buffer, _refData) {\n        let { _b, _data } = _refData;\n        let sb = '';\n        let sd = '';\n        let _bbuffer = option.buffer;\n        let _bdata = option.data;\n        // let _state_saved = option.bufferState;\n        const { formatterBuffer, lineFeedFlag } = option;\n        let _clean = false;\n\n        if (this.mergeEndBlock) {\n            // + | remove last empty items.\n            _bbuffer = _bbuffer.trimEnd();\n        }\n        if (marker.childs.length == 0) {\n            sb = _bbuffer;\n            sd = _bdata;\n            if (lineFeedFlag) {\n                option.lineFeedFlag = false;\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.output.push(_b.trimStart());\n                sb += option.flush(true);\n                option.restoreSavedBuffer();\n            } else {\n                sb += _b;\n                sd += _data;\n            }\n            formatterBuffer.clear();\n            formatterBuffer.appendToBuffer({buffer:sb, data:sd});\n            formatterBuffer.clearOutput();\n            _clean = true;\n        } else {\n            option.formatterBuffer.clear();\n            option.formatterBuffer.appendToBuffer(_bbuffer);\n\n            if (this.mergeEndBlock) {\n                if ((marker.mode == FM_END_BLOCK) && (marker.childs.length == 1)) {\n                    // + | merge close tag\n                    option.formatterBuffer.appendToBuffer(_b.trimEnd());\n                    _clean = true;\n                }\n            } else {\n                if ((marker.mode == FM_END_BLOCK) && (marker.childs.length == 1)) {\n                    // + | merge close tag\n                    option.storeToOutput({ clear: true });\n                    option.formatterBuffer.appendToBuffer(_b.trimEnd());\n                    option.storeAndUpdateBuffer();\n                   _clean = true;\n                }\n            }\n        }\n        let _c_mode = (marker.childs == 0)\n            ? FM_APPEND : FM_END_BLOCK;\n        if (_clean){\n            _b = '';\n            sd = '';\n        }\n        // + | update marker mode to pass to parent\n        // marker.mode = _c_mode;\n        option.nextMode = _c_mode;\n        option.startLine = this.isStartLine(_c_mode);\n        if (_b && (marker.formattingMode == PatternFormattingMode.PFM_LINE_JOIN_END)) {\n            option.formatterBuffer.appendToBuffer(_b.trimEnd()); \n            _clean = true;\n        }\n        if (_clean){\n            _b = '';\n            sd = '';\n        }\n        \n        _refData._b = _b;\n        _refData._data = sd;\n        return _refData;\n    }\n    /**\n     * \n     * @param {*} content \n     * @param {*} extra \n     * @param {*} buffer \n     * @param {*} _hasBuffer \n     * @param {*} _hasExtra \n     * @param {*} isEntryContent \n     * @param {*} _flushData reference data to export\n     * @param {*} segments segment that represent the current content\n     * @returns \n     */\n    onAppendBlock(content, extra, buffer, _hasBuffer, _hasExtra, isEntryContent, _flushData, segments) {\n        const { FormatterBuffer } = Utils.Classes;\n        let _ld = '';\n        if (extra.length > 0) {\n            _ld += extra;\n        }\n        if (buffer.length > 0) {\n            _ld += buffer;\n        }\n        const _trimEnd = function(){\n            if (segments){\n\n                FormatterBuffer.TreatMarkedSegments(segments, 'trimmed'); \n                content = segments.bufferSegment.join('');\n\n            }\n            return content.trimEnd();\n            \n        };\n\n\n        content = !isEntryContent ? _trimEnd() : content;\n        if (!this.mergeEndBlock) {\n            option.appendExtraOutput();\n            option.formatterBuffer.appendToBuffer(_ld.trimStart());\n            option.store();\n            _ld = option.flush(true, _flushData);\n        }\n        return { content, _ld };\n    }\n    handleEndFound(formatter, marker, option, _buffer, _b) {\n        let sb = '';\n        if (marker.childs.length == 0) {\n            sb = _buffer.trimEnd() + _b.trimStart();\n            option.appendToBuffer(sb, marker);\n        }\n\n        return marker.parent;\n    }\n\n    formatJoinFirstEntry(entryBuffer, buffer) {\n        return [entryBuffer, buffer].join('');\n    }\n    /**\n     * format buffer marker\n     * @param {*} formatter \n     * @param {*} _marker \n     * @param {*} option \n     * @param {boolean} force force update \n     */\n    formatBufferMarker(formatter, _marker, option, force=false) {\n        let _buffer = option.buffer;\n        const { parent, startOutput } = _marker;\n        const { formattingMode, isBlock, isUpdatedBlock } = _marker;\n        let update_line_feed = ()=>{\n            if (parent) {\n                _marker.mode = FM_START_LINE;\n                this._updateGlobalMarkerOptionDefinition(_marker, option);\n            } else {\n                // + | update current buffer to handle\n                formatter.updateBuffedValueAsToken(_buffer, _marker, option);\n                if (option.depth == 0) {\n                    option.skipEmptyMatchValue = true;\n                }\n            }\n        };\n\n        switch (formattingMode) {\n            case PatternFormattingMode.PFM_LINE_FEED:\n                // + | formatting request last fied \n                if (force ||((_marker.childs.length > 0) || (startOutput.trim().length>0))) {  \n                   update_line_feed();\n                }\n                break;\n            case PatternFormattingMode.PFM_LINE_FEED_IF_IS_UPDATED_BLOCK:\n                if (force || ((_marker.childs.length>0) && (isBlock || isUpdatedBlock))){\n                    update_line_feed();\n                }\n                break;\n            case PatternFormattingMode.PFM_LINE_JOIN_END:\n            case PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED:\n            case PatternFormattingMode.PFM_LINE_JOIN_END:\n            // join line formatting mode \n            case PatternFormattingMode.PFM_LINE_JOIN:\n            // enable streaming buffer\n            case PatternFormattingMode.PFM_STREAMING:\n                break;\n            default:\n                throw new Error('not implement formatting mode '+formattingMode);\n        }\n    }\n\n    /**\n     * on last handling mode\n     * @param {*} param0 \n     * @returns \n     */\n    onLastExpectedBlock({ mode, option, buffer }) {\n        let f = null;\n        switch (mode) {\n            case FM_END_BLOCK:\n                if (buffer.length > 0) {\n                    f = option.flush(true) + buffer;\n                }\n                break;\n            default:\n                option.store();\n                break;\n        }\n        return f;\n    }\n    onLastExpectedBlockStart({ _old, option }) {\n        if (this.mergeEndBlock) {\n            return;\n        }\n        if (!_old.blockStarted && (option.output.length > 0)) {\n            option.output.push(option.buffer);\n            let _buffer = option.flush(true);\n            option.formatterBuffer.appendToBuffer(_buffer);\n            option.storeAndUpdateBuffer();\n        }\n    }\n}\n\nexports.KAndRFormatting = KAndRFormatting;\nexports.FormattingBase = FormattingBase","Object.defineProperty(exports, '__esModule', {value:true});\n\n/**\n * json parser info\n */\nclass JSonParser{\n    source;\n    data; \n    registry;\n    repositoryKey;\n    throwOnError;\n    /**\n     * store pattern class name\n     */\n    patternClassName;\n    /**\n     * store capture info class name\n     */\n    captureInfoClassName;\n\n    get current(){\n        return this.m_current;\n    }\n\n    constructor(){\n        this.m_current = null;\n        this.throwOnError = true;\n    }\n\n    /**\n     * initialize object to registry\n     * @param {*} _o \n     */\n    initialize(_o){\n        if (this.registry){\n            this.registry.initialize(_o);\n        }\n    }\n\n    parse(){\n        obj = new this.source();\n        this.m_current = this.data;\n        JSonParser._LoadData(this, obj, this.data);\n        return obj;\n    }\n    /**\n     * load data with reference object \n     * @param {*} parser \n     * @param {*} obj \n     * @param {*} data \n     * @param {*} refKey \n     * @param {*} _refObj \n     * @returns \n     */\n    static _LoadData(parser, obj, data, refKey, _refObj){\n        const _throwOnError = parser.throwOnError;\n        const keyData = ()=>{\n            if (obj.json_keys){\n                return obj.json_keys();\n            }\n            return Object.keys(obj);\n        };\n        let validation = obj.json_validate;\n        let json_parsing = obj.json_parse;\n        keyData().forEach((i)=>{\n            let _r = data[i];\n            if (typeof(_r)=='undefined'){\n                return;\n            } \n            if ((validation)&& !validation.apply(obj, [i, _r, _throwOnError])){\n                return;\n            }\n            if (json_parsing){\n                _r = json_parsing.apply(obj, [parser, i, _r, refKey, _refObj]);\n            }\n            obj[i] = _r;\n        });\n        return obj;\n    }\n}\n\nexports.JSonParser = JSonParser;","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', { value: true });\nconst globalRegExp = RegExp;\nconst NATIVE_EXEC = (() => {\n    const _fn = globalRegExp.prototype.exec;\n    if (_fn.toString().indexOf('[native code]') !== -1)\n        return _fn;\n    throw new Error('missing native RegExp.exec');\n})();\nconst NATIVE_TEST = (() => {\n    const _fn = globalRegExp.prototype.test;\n    if (_fn.toString().indexOf('[native code]') !== -1)\n        return _fn;\n    throw new Error('missing native RegExp.test');\n})();\n/**\n * implement native RegExp because some extension override required function\n */\nclass NativeRegExp {\n    static #sm_states = [];\n    static Save() {\n        NativeRegExp.#sm_states.unshift({\n            exec: globalRegExp.prototype.exec,\n            test: globalRegExp.prototype.test\n        });\n        globalRegExp.prototype.exec = NATIVE_EXEC;\n        globalRegExp.prototype.test = NATIVE_TEST;\n    }\n    static Restore(){\n        const _g = NativeRegExp.#sm_states.shift();\n        if (_g){\n            globalRegExp.prototype.exec = _g.exec;\n            globalRegExp.prototype.test = _g.test;\n        }\n    }\n}\n\nNativeRegExp.prototype.exec = NATIVE_EXEC;\nNativeRegExp.prototype.test = NATIVE_TEST;\n\nexports.NativeRegExp = NativeRegExp;","\"use stricts;\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n\n/**\n * use to define error message object \n */\nclass PatterMatchErrorInfo{\n    /**\n     * error message\n     * @var {?string}\n     */\n    message\n    /**\n     * error code \n     * @var {?number}\n     */\n    code;\n}\n\nexports.PatterMatchErrorInfo = PatterMatchErrorInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\nclass PatternFormattingOptions{\n    /**\n     * patterns is trim block container - check on start and end\n     * @var {?bool}\n     */\n    trimContainer;\n}\nexports.PatternFormattingOptions = PatternFormattingOptions; ","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { RegexUtils } = require('./RegexUtils');\nconst { Utils } = require('./Utils');\n\n/**\n * type checking requirement\n * @param {*} v \n * @param {*} types \n * @returns \n */\nfunction is(v, types) {\n    const t = typeof (v);\n    return (types.indexOf(v) != -1) || (types.indexOf(t) != -1);\n}\n\n/**\n * export pattern match info\n */\nclass PatternMatchInfo {\n\n    /**\n     * indicate new created pattern info\n     * @var {bool}\n     */\n    start = true;\n\n    /**\n     * formatting start block element\n     */\n    isFormattingStartBlockElement = false;\n\n    /**\n     * formatting listener to handle start and end block element\n     */\n    formattingBlockListener;\n    /**\n     * \n     */\n    range = {\n        startLine: 0, // on start line \n        start: 0, // position start\n        end: 0 // position end\n    }\n    /**\n    * store marker info childs\n    */\n    childs = [];\n\n    /**\n     * store value\n     * @var {null|{value:string, source:string }}\n     */\n    value;\n\n    /**\n     * define block start information\n     */\n    blockStartInfo;\n\n    /**\n     * formatter new line flag\n     */\n    newLine = false;\n\n    /**\n     * get or store the end group\n     */\n    endGroup = null;\n\n    /**\n    * @var {?boolean}\n    */\n    isShiftenName = false;\n\n\n    /**\n     * flag: shiftenContentName\n     * @var {?boolean}\n     */\n    isShiftenContentName = false;\n\n    /**\n     * store start data\n     */\n    startData;\n\n    get isMarkedSegments() {\n        return (this.isTrimmedSegment === true) || (this.markedSegment != null);\n    }\n    /**\n     * is capture to end line \n     * @param {*} line \n     * @returns \n     */\n    isCaptureToEndLine({lineMatcher, lastMarker}){\n        const { childs } = this;\n        let lastChild = childs.length>0 ? childs[childs.length-1].marker : null;\n        lastMarker = lastChild || lastMarker;\n        if (lastMarker){\n            const { subLine } = lineMatcher;\n            const { end, matchType, match } = lastMarker;\n            if (matchType==1){\n                // + | match end regex\n                return RegexUtils.CheckRequestEndLine(match) && match.exec(subLine);\n            }\n            else if (matchType==0){\n                // + begin/end\n                return RegexUtils.CheckRequestEndLine(end) &&  end.exec(subLine);\n            }\n        }\n        return false;\n    }\n    markedInfo() {\n        //const { Utils } = require('./Utils');\n        return Utils.GetMarkedInfo(this); \n    }\n    constructor() {\n        var m_parent;\n        var m_marker;\n        var m_endRegex;\n        var m_group;\n        var m_line;\n        var m_isBlock = false;\n        var m_lineFeed = false;\n        var m_startOutput = null;\n        var m_endOutput = null;\n        var m_updatedProperties = {};\n        var m_isBlockStared = false;\n        var m_bufferMode = 1; // how to operate on buffer \n        var m_patterns = null;\n        var m_fromGroup = null; // store pattern group - to dected token id\n        var m_index = -1;\n        var m_state = null; // store use state\n        /**\n        * get or set the buffer mode. 0 - add a line before add go to 1 just append to buffer, 2 add a line after\n        */\n        Object.defineProperty(this, 'mode', {\n            get() { return m_bufferMode; },\n            set(v) {\n                if (v != m_bufferMode) {\n                    m_bufferMode = v; \n                }\n            }\n        });\n\n        /**\n         * get or set the parent info matcher\n         */\n        Object.defineProperty(this, 'isBlockStarted', {\n            get() {\n                return (this.isBlock) ? m_isBlockStared : false;\n            }, set(v) {\n                if (typeof (v) != 'boolean') {\n                    throw new Error('not a valid value');\n                }\n                if (this.isBlock) {\n                    m_isBlockStared = v;\n                }\n            }\n        });\n\n        Object.defineProperty(this, 'parent', { get() { return m_parent; } });\n        Object.defineProperty(this, 'updatedProperties', { get() { return m_updatedProperties; } });\n        Object.defineProperty(this, 'isBlock', {\n            get() { return m_isBlock; }, set(value) {\n\n                if (value === null) {\n                    throw new Error('can  not store null value');\n                }\n                m_isBlock = value;\n            }\n        });\n        Object.defineProperty(this, 'lineFeed', {\n            get() {\n                return m_lineFeed;\n            }\n        });\n        Object.defineProperty(this, 'marker', { get() { return m_marker; } });\n        Object.defineProperty(this, 'endRegex', { get() { return m_endRegex; } });\n        // group info\n        Object.defineProperty(this, 'group', { get() { return m_group; } });\n        Object.defineProperty(this, 'state', { get() { return m_state; } });\n\n        Object.defineProperty(this, 'line', { get() { return m_line; } });\n        Object.defineProperty(this, 'startOutput', {\n            get() {\n                // + | return group[0] on start definition\n                if ((m_startOutput == null) || (m_startOutput == undefined))\n                    return m_group[0];\n                return m_startOutput;\n            },\n            set(v) {\n                m_startOutput = v;\n            }\n        });\n        Object.defineProperty(this, 'endOutput', {\n            get() { return m_endOutput; }, set(v) {\n                m_endOutput = v;\n            }\n        });\n        Object.defineProperty(this, 'isBlockConditionalContainer', {\n            get() {\n                const { marker } = this;\n                return marker.isBlockConditionalContainer || (() => {\n                    return marker.formattingMode && marker.requestParentBlockCondition;\n\n                })();\n            }, set(v) {\n                if (is(v, ['boolean', undefined, 'undefined'])) {\n                    this.pattern.isBlockConditionalContainer = v;\n                }\n            }\n        });\n\n        Object.defineProperty(this, 'indexOf', {\n            get() {\n                return m_index;\n            }\n        });\n        Object.defineProperty(this, 'hostPatterns', {\n            get() {\n                return m_patterns;\n            }\n        });\n        Object.defineProperty(this, 'fromGroup', {\n            get() {\n                return m_fromGroup;\n            }\n        });\n\n        /**\n         * \n         * @param {*} marker \n         */\n        this.use = function ({ marker, endRegex, group, line, parent, patterns, formatting, fromGroup, index = -1 , state}) {\n            m_marker = marker;\n            m_endRegex = endRegex;\n            m_group = group;\n            m_state = state;\n            m_line = line;\n            m_parent = parent;\n            // setup configurable properties\n            m_isBlock = marker.isBlock;\n            m_lineFeed = marker.lineFeed || formatting.isLineFeed(marker.formattingMode);\n            m_patterns = patterns;\n            m_fromGroup = fromGroup;\n            m_index = index;\n\n\n            (function (q, pattern) {\n                const _keys = Object.keys(q);\n                const _keys_t = Object.keys(pattern);\n                ['isBlock', 'lineFeed', 'streamAction', 'isBlockConditionalContainer'].forEach(s => {\n                    delete _keys_t[_keys_t.indexOf(s)];\n                });\n                _keys_t.forEach(i => {\n\n                    if (_keys.indexOf(i) != -1) {\n                        console.log(\"property alreay defined [\" + i + \"]\");\n                        return;\n                    }\n                    let _i = Object.getOwnPropertyDescriptor(pattern, i);\n                    if (!_i || (_i.get) || _i.writable) {\n                        // q[i] = pattern[i];\n                        Object.defineProperty(q, i, { get() { return pattern[i]; } })\n                    }\n                });\n            })(this, m_marker);\n        };\n    }\n    /**\n     * @var {boolean}\n     */\n    get isUpdatedBlock() {\n        const { updatedProperties } = this;\n        return updatedProperties && ('isBlock' in updatedProperties);\n    }\n    get isMatchCaptureOnly() {\n        return this.marker?.isMatchCaptureOnly;\n    }\n    //\n    get isEndCaptureOnly() {\n        return this.marker?.isEndCaptureOnly;\n    }\n    get isWhileCaptureOnly() {\n        return this.marker?.isWhileCaptureOnly;\n    }\n    get isBeginCaptureOnly() {\n        return this.marker?.isBeginCaptureOnly;\n    }\n    get isCaptureOnly() {\n        return this.marker?.isCaptureOnly;\n    }\n    /**\n     * get if this empty block is start only use definition \n     */\n    get isStartOnly() {\n        return this.marker?.isStartOnly;\n    }\n\n    get closeParentData() {\n        let m = this.marker?.closeParent;\n        let _type = typeof (m);\n        if (_type == 'string') {\n            return m;\n        }\n        if (_type == 'boolean') {\n            return !m ? undefined : '';\n        }\n        return m;\n    }\n    /**\n     * get if this match info is a stream capture\n     */\n    get isStreamCapture() {\n        if (this.marker?.isStartOnly) {\n            return false;\n        }\n        return this.isCaptureOnly && (this.group[0].length == 0);\n    }\n    /**\n     * check this is a block but non configured;\n     */\n    get isAutoBlockElement() {\n        return this.isBlock && !this.isFormattingStartBlockElement;\n    }\n\n    get index() {\n        return this.group?.index;\n    }\n    get offset() {\n        return this.group?.offset;\n    }\n    get name() {\n        return this.marker?.name;\n    }\n    get captures() {\n        return this.marker?.captures;\n    }\n    get endCaptures() {\n        return this.marker?.endCaptures;\n    }\n    get beginCaptures() {\n        return this.marker?.beginCaptures;\n    }\n    get replaceWith() {\n        return this.marker?.replaceWith;\n    }\n    get replaceWithCondition() {\n        return this.marker?.replaceWithCondition;\n    }\n    get streamAction() {\n        const { streamAction } = this.marker;\n        return streamAction || 'next';\n    }\n    /**\n     * expose parker match type\n     */\n    get matchType() {\n        return this.marker.matchType;\n    }\n\n    /**\n     * check is pattern only definition.\n     * @var {bool}\n     */\n    get isPatternsOnly() {\n\n        return false;\n    }\n    /**\n     * debug this marker. internal used\n     */\n    get debug() {\n        return this.marker?.debug;\n    }\n    /**\n     * \n     * @returns \n     */\n    toString() {\n        return \"[PatternMatchInfo: \" + this.marker?.toString() + \"]\";\n    }\n\n    /**\n     * match type with glue type \n     */\n    get skipGlueOnLineEnd(){\n        const b = this.isGlueValue;\n        if (typeof(b) == 'object'){\n            let { skipGlueOnLineEnd } = b || {skipGlueOnLineEnd:false};\n            return skipGlueOnLineEnd; \n        }\n        return this.skipGlueOnLineEnd;\n\n    }\n\n    /**\n     * \n     * @param {*} end \n     * @param {*} param1 \n     * @returns \n     */\n    checkMoveEndRegex(end, {lineCount}){\n        return (this.group.index == end.index) && \n           (this.state.lineCount == lineCount);\n    }\n}\n\nexports.PatternMatchInfo = PatternMatchInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { JSonParser } = require('./JSonParser');\nconst { ReplaceWithCondition } = require('./ReplaceWithCondition');\nconst { Utils } = require('./Utils');\nconst { RegexUtils } = require('./RegexUtils');\nconst { BlockInfo } = require('./BlockInfo');\nconst { PatterMatchErrorInfo } = require('./PatterMatchErrorInfo');\nconst { RegexEngine } = require('./RegexEngine');\nconst { PatternFormattingOptions } = require('./PatternFormattingOptions');\n\n\nconst PatternParsing = { init: false };\nconst PTN_BEGIN_END = 0;\nconst PTN_MATCH = 1;\nconst PTN_BEGIN_WHILE = 2;\nconst PTN_MATCH_TRANSFORM = 3;\n\n\n\n/**\n * @typedef IFormatterReplaceWithCondition\n * @type\n * @property {string} expression,\n * \n */\n\n/**\n * \n */\nclass Patterns {\n    /**\n     * @var {undefined|?PatternFormattingOption} \n     */\n    formattingOptions;\n    /**\n     * @var {undefined|null|string|{message:string, code: number}} lint error \n     */\n    lintError;\n    /**\n     * \n     */\n    match;\n\n    /**\n     * match transform for injection\n     * @var {} \n     */\n    matchTransform;\n    /**\n     * start capture \n     */\n    begin;\n    /**\n     * end match\n     */\n    end;\n\n    /**\n     * pattern cardinality in list. \n     * @var {number} \n     */\n    cardinality;\n\n    /**\n     * use for begin/while . to implement\n     * @var {string|Regex}\n     */\n    while;\n\n    /**\n     * while captures definitions\n     */\n    whileCaptures;\n    /**\n     * setup the value on end missing\n     * @var {string|undefined|{expression:string, captures: undefined|captureInfo}}\n     */\n    endMissingValue;\n\n    /**\n     * the name of this pattern\n     */\n    name;\n\n    /**\n     * capture set content name\n     */\n    contentName;\n    /**\n     * describe this pattern\n     */\n    comment;\n    /**\n   * @var {?string} use for token matching\n   */\n    tokenID;\n    /**\n     * @var {?array} list of patterns\n     */\n    patterns;\n    /**\n     * indicate that this must be used as lineFeed\n     * @var {?bool}\n     */\n    lineFeed;\n    /**\n     * indicate that this must be consider as a block element\n    * @var {?bool|BlockInfo}\n    */\n    isBlock;\n\n    /**\n     * indicate that this pattern is a block conditional start\n     * @var {undefined|?boolean}\n     */\n    isBlockConditionalContainer;\n\n    /**\n     * indicate that condition of trimmed segment on depth update\n     */\n    isTrimmedSegment;\n\n    /**\n     * how to marked segment from definition\n     */\n    markedSegment;\n\n    /**\n     * get or set condition expression to set if this element is a block.\n     * @var {?string}\n     */\n    emptyBlockCondition;\n\n    /**\n     * get or set condition expression to evaluate if this element change the parent block property.\n     * @var {?string}\n     */\n    requestParentBlockCondition;\n\n\n    /**\n     * mark this match as instruction separator. by default will be use as lineFeed. by default the contains will be checked\n     * in match only alogrithm\n     */\n    isInstructionSeparator;\n\n    //  /**\n    //  * @var {?{start: string, end: string}} \n    //  */\n    // block;\n    /**\n     * @var {?bool}\n     */\n    allowMultiline;\n    /**\n     * @var {?bool}\n     */\n    preserveLineFeed;\n\n    /**\n     * depend on token force trim end white space for buffer\n     */\n    nextTrimWhiteSpace = false;\n\n    /**\n     * similar likje end expression will replace the match apend value before adding it to buffer\n     * @var {string|undefined|ReplaceWithCondition|ReplaceWithCondition[]}\n     */\n    replaceWith;\n\n    /**\n     * replace with condition object \n     * @var {object} \n     */\n    replaceWithCondition;\n\n    /**\n     * apply transform on start line\n     * @var {null|string|string[]}\n     */\n    startLineTransform;\n\n    /**\n     * used for begin capture\n     */\n    beginCaptures;\n\n    /**\n     * used for end captures\n     */\n    endCaptures;\n\n    /**\n     * apply to both begin and end captures definition\n     */\n    captures;\n\n    /**\n     * get updated parent props, {isBlock:?bool, lineFeed:?bool}\n     */\n    updateParentProps;\n\n    /**\n     * list of tranform operation\n     * @var {string|string[]}\n     */\n    transform;\n\n    /**\n     * match to apply after tranform definition\n     * @var {null|undefined|RegExp|string}\n     */\n    transformMatch;\n\n    /**\n     * transform captures\n     * @var  {null|undefined|captures}\n     */\n    transformCaptures;\n\n    /**\n     * formatting mode after begin of (begin/end) selection\n     * @var {?number}\n     */\n    beginFormattingMode;\n\n    /**\n     * formatting mode - after rendering the element\n     */\n    formattingMode = 0;\n\n\n    /**\n     * prepend value - on formattingMode = 5\n     * @var {string|undefined} - default value is space litteral if undefined\n     */\n    formattingPrependExtra;\n\n    /**\n     * a glue value - to merge on \n     */\n    isGlueValue;\n\n    /**\n     * same value with\n     * @var {?string} join \n     */\n    joinWith;\n\n    /**\n     * throw error on matching\n     * @var {null|bool|string|PatterMatchErrorInfo}\n     */\n    throwError;\n\n    /**\n     * stream action type.\n     * value use only on streaming default is 'next'\n     * @var {?string|'parent'|'next'}\n     */\n    streamAction;\n\n    /**\n     * stream formatter\n     * @var {{format(buffer: string):string}|(buffer:string):string}\n     */\n    streamFormatter;\n\n    /**\n     * captures to attach on stream or use captures as a fallback\n     */\n    streamCaptures;\n\n\n    /**\n     * indicate that this pattern must be only apply on start line\n     * @var {boolean}\n     */\n    startLine = false;\n\n    /**\n     * @var {number}\n     */\n    applyEndPatternLast;\n\n    /**\n     * @var {boolean} debug this field\n     */\n    debug;\n\n\n    /**\n     * name used in debug mode\n     * @var {?string}\n     */\n    debugName;\n\n    /**\n     * force close parent with litteral\n     * @var {null|undefined|true|string} close parent with litteral\n     */\n    closeParent;\n\n\n    /**\n     * skip matching on condition(s)\n     * @var {null|undefined|string|string[]}\n     */\n    skip;\n\n    /**\n     * formatting next glue value\n     */\n    nextGlueValue;\n\n\n    /**\n     * skip value on line end.\n     */\n    skipGlueOnLineEnd;\n\n    /**\n     * .ctr\n     */\n    constructor() {\n        this.patterns = [];\n        this.isBlock = false;\n        this.allowMultiline = true;\n        this.preserveLineFeed = false;\n        this.cardinality = 0;\n        var m_parent = null;\n        var m_startOnly = false;\n\n        Object.defineProperty(this, 'parent', {\n            get() { return m_parent; }, set(v) {\n                if ((v == null) || (v instanceof Patterns))\n                    m_parent = v;\n                else\n                    throw Error('parent value not valid');\n            }\n        });\n        Object.defineProperty(this, 'isStartOnly', {\n            get() {\n                return m_startOnly;\n            }, set(v) {\n                m_startOnly = v;\n            }\n        });\n    }\n    static IsSkipped(skip) {\n        return RegexUtils.IsSkipped(skip);\n    }\n    json_parse(parser, fieldname, data, refKey, refObj) {\n\n        // if (!PatternParsing.init) {\n        //     PatternParsing.parser = (() => {\n\n\n        const { Patterns, RefPatterns, CaptureInfo } = Utils.Classes;\n        const q = this;\n        const patterns = Utils.ArrayPatternsFromParser(parser, Patterns, RefPatterns);\n        const transform = Utils.TransformPropertyCallback();\n        const _regex_parser = RegexUtils.RegexParser(q);\n        const _capture_parser = Utils.JSONInitCaptureField(q);\n        const _replace_with = (n, parser, fieldname, refObj) => {\n            if (typeof (n) == 'string') {\n                //n = n.replaceAll(\"\\\\\\\\\",\"\\\\\");\n\n                const _reg = _regex_parser.apply(q, [n, parser, fieldname, refObj]);\n                return _reg;\n            }\n            if (typeof (n) == 'object') {\n                let m = new ReplaceWithCondition;\n                JSonParser._LoadData(parser, m, n, refObj);\n                return m;\n            }\n            if (Array.isArray(n)) {\n                let d = [];\n                n.forEach(n => {\n                    let m = new ReplaceWithCondition;\n                    JSonParser._LoadData(parser, m, n, refObj);\n                    d.push(m);\n                });\n                return d;\n            }\n            return null;\n        };\n\n        const parse = {\n            endMissingValue(n, parser) {\n                if (typeof (n) == 'object') {\n                    const { FormatterEndMissingExpression } = Utils.Classes;\n                    const { expression } = n;\n                    let { captures } = n;\n                    if (captures) {\n                        captures = _capture_parser(captures, parser);\n                    }\n                    return new FormatterEndMissingExpression(expression, captures);\n                }\n                return n;\n            },\n            closeParent(n, parser) {\n                const _type = typeof (n);\n                const { FormatterCloseParentInfo } = Utils.Classes;\n                const _gcl = parser.closeParentInfoClassName || FormatterCloseParentInfo;\n                if (_type == 'object') {\n\n                    let m = new _gcl;\n                    JSonParser._LoadData(parser, m, n);\n                    return m;\n                }\n                if (_type == 'boolean') {\n                    return n;\n                }\n                if (_type == 'string') {\n                    return n;\n                }\n                throw new Error('invalid closeParentType');\n            },\n            patterns(n, parser, refKey, refObj) {\n                let d = patterns.apply(q, [n, parser, refKey, refObj]);\n                d.forEach((s) => {\n                    s.parent = q;\n                });\n                return d;\n            }, // update with parent\n            begin: _regex_parser,\n            end: function (n, parser, refKey, refObj) {\n                if (typeof (n) == 'string') {\n                    // skip end matching \n                    if (n.length == 0) {\n                        return RegexUtils.SKIP_REGEX;\n                    }\n                }\n                return _regex_parser(n, parser, refKey, refObj);\n            },\n            while: _regex_parser,\n            match: _regex_parser,\n            matchTransform: _regex_parser,\n            replaceWith: _replace_with,\n            transformMatch: _regex_parser,\n            lintError: function (n, parser) {\n                const _t = typeof (n);\n                let _rt = { message: null, code: null };\n                if (_t == 'string') {\n                    _rt.message = _t;\n                } else if (n) {\n                    const { code, message, $ref } = n;\n                    const { lintErrors } = parser.data;\n                    if ($ref && lintErrors) {\n                        if ($ref in lintErrors) {\n                            const { code, message } = { code: $ref, message: lintErrors[$ref] };\n                            _rt.message = message;\n                            _rt.code = code;\n                            return _rt;\n                        }\n\n                    }\n                    _rt.message = message;\n                    _rt.code = code;\n                }\n                return _rt;\n            },\n            replaceWithCondition(n, parser) {\n                let m = new ReplaceWithCondition;\n                JSonParser._LoadData(parser, m, n, refObj);\n                return m;\n            },\n            beginCaptures: _capture_parser,\n            endCaptures: _capture_parser,\n            captures: _capture_parser,\n            streamCaptures: _capture_parser,\n            transformCaptures: _capture_parser,\n            transform,\n            formattingOptions(d, parser){\n                if (typeof(d)=='object'){\n                const l = new PatternFormattingOptions;\n                JSonParser._LoadData(parser, l, d);\n                return d;\n                }\n            },\n            lineFeed(d, parser) {\n                return typeof (d) == 'boolean' ? d : false;\n            },\n            isBlock(d, parser) {\n                let _t = typeof (d);\n                if (_t == 'object') {\n                    let m = new BlockInfo;\n                    JSonParser._LoadData(parser, m, d);\n                    return m;\n                }\n                return _t == 'boolean' ? d : false;\n            },\n            throwError(d, parser) {\n                if (typeof (d) == \"string\") {\n                    let l = new PatterMatchErrorInfo;\n                    l.message = d;\n                    return l;\n                }\n                return objOrBool(d, parser, PatterMatchErrorInfo);\n            }\n        };\n        //         return parse;\n        //     })();\n        //     PatternParsing.init = true;\n        // }\n        // const q = this;\n        // const parse = PatternParsing.parser;\n\n        let fc = parse[fieldname];\n        if (fc) {\n            return fc.apply(q, [data, parser, refKey, refObj]);\n        }\n        return data;\n    }\n    json_validate(field_name, d, throw_on_error) {\n        const validator = {\n            patterns(d) {\n                return Array.isArray(d);\n            },\n            replaceWithCondition(d) {\n                return typeof (d) == 'object';\n            }\n        };\n        let f = validator[field_name];\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    get matchType() {\n        const { begin, end, match, matchTransform } = this;\n        const _while = this.while;\n        if (begin) {\n            if (end)\n                return PTN_BEGIN_END;\n            else if (_while) {\n                return PTN_BEGIN_WHILE;\n            }\n        } else if (match) {\n            return PTN_MATCH;\n        } else if (matchTransform) {\n            return PTN_MATCH_TRANSFORM;\n        }\n        return -1;\n    }\n    /**\n     * get if end is capture only regex\n     */\n    get isEndCaptureOnly() {\n        let s = this.end;\n        if (s) {\n            return RegexUtils.IsCapturedOnlyRegex(s.toString());\n        }\n        return false;\n    }\n    /**\n     * get if begin capture only\n     */\n    get isBeginCaptureOnly() {\n        let s = this.begin;\n        if (s) {\n            return RegexUtils.IsCapturedOnlyRegex(s);\n        }\n        return false;\n    }\n    /**\n     * get if block is capture only\n     * @return {boolean}\n     */\n    get isCaptureOnly() {\n        let { begin, end } = this;\n        if (begin && end) {\n            return this.isBeginCaptureOnly && this.isEndCaptureOnly;\n        }\n        return false;\n    }\n    /**\n     * is match capture only\n     */\n    get isMatchCaptureOnly() {\n        let s = this.match;\n        if (s) {\n            return RegexUtils.IsCapturedOnlyRegex(s);\n        }\n        return !1;\n    }\n    /**\n     * new line continue state\n     */\n    get newLineContinueState() {\n        return true;\n    }\n    static Init(_o) {\n        if (_o.begin && !_o.end && !_o.while) {\n            // + | force begin/end\n            _o.end = RegexUtils.SKIP_REGEX;\n        }\n\n        if ((_o.matchType == -1) && (_o.patterns?.length > 0)) {\n            _o.patterns.forEach(s => {\n                _o._initRef(s);\n            });\n        }\n         \n    }\n    /**\n     * initialize reference\n     * @param {*} a \n     */\n    _initRef(a) {\n        if (!a.tokenID && this.tokenID) {\n            a.tokenID = this.tokenID;\n        }\n    }\n    getEntryRegex() {\n        const { begin, match, matchTransform } = this;\n        //const _while = this.while;\n        switch (this.matchType) {\n            case PTN_BEGIN_END:\n            case PTN_BEGIN_WHILE:\n                return begin;\n            case PTN_MATCH:\n                return match;\n            case PTN_MATCH_TRANSFORM: return matchTransform;\n        }\n    }\n    /**\n     * depending on the regex value - or type\n     * @param {string} l string to check\n     * @param {*} option \n     * @param {*} parentMatcherInfo parent matcher\n     * @param {*} regex \n     * @returns \n     */\n    check(l, option, parentMatcherInfo, regex) {\n        let p = null;\n        const { patterns } = this;\n        regex = regex || this.getEntryRegex();\n        if (regex) {\n            p = regex.exec(l);\n        } else {\n            // + | use for pattern only definition list\n            if (patterns) {\n                const cp = Utils.GetMatchInfo(patterns, l, option, parentMatcherInfo);\n                if (cp) {\n                    return { p: cp._match, s: cp._a, from: this, patterns: patterns, index: cp.index, regex: cp.regex };\n                }\n                return false;\n            }\n            throw new Error(\"cannot check : \" + l);\n        }\n        return { p, s: this, index: -1, regex };\n    }\n\n    get matchRegex() {\n        const rgs = {\n            \"0\": this.begin,\n            \"1\": this.match,\n            \"2\": this.while,\n            \"3\": this.matchTransform\n        };\n        return rgs[this.matchType]; //  this.matchType == 0 ? this.begin : this.match;\n    }\n    /**\n     * calculate end regex\n     * @param {*} p \n     * @returns \n     */\n    endRegex(p) {\n        const { end } = this;\n        if (!end || ((this.end instanceof RegexEngine) && end.isEmpty)\n            || Patterns.IsSkipped(end)) {\n            return null;\n        }\n\n\n\n        if (this.matchType == 0) {\n            let s = this.end.toString();\n            let idx = s.lastIndexOf('/');\n            let flag = '';\n            if (idx < (s.length - 1)) {\n                //remove options\n                flag = s.substring(idx + 1);\n                s = s.substring(0, idx + 1);\n            }\n            return Utils.GetRegexFrom(s, p, flag, 'end');\n        }\n        return null;\n    }\n    endWhile(p) {\n        if (this.matchType == 2) {\n            let s = this.while.toString();\n            let idx = s.lastIndexOf('/');\n            let flag = '';\n            if (idx < (s.length - 1)) {\n                //remove options\n                flag = s.substring(idx + 1);\n                s = s.substring(0, idx + 1);\n            }\n            return Utils.GetRegexFrom(s, p, flag, 'while');\n        }\n        return null;\n    }\n\n    toString() {\n        let { name, begin, end, match, debugName, matchType } = this;\n        const _while = this.while;\n        name = (debugName ? \"[\" + debugName + \"]\" : null) || name;\n        function getMatchInfo() {\n            switch (matchType) {\n                case PTN_BEGIN_END:\n                    return { \"begin\": begin?.toString(), \"end\": end?.toString() };\n                case PTN_MATCH:\n                    return { 'match': match?.toString() };\n                case PTN_BEGIN_WHILE:\n                    return { 'begin': begin?.toString(), \"while\": _while?.toString() };\n                case PTN_MATCH_TRANSFORM:\n                    return { \"matchTransfrom\": _while?.toString() };\n            }\n        }\n        if (!name) {\n            name = JSON.stringify({\n                type: matchType,\n                //...getMatchInfo()\n            });\n        }\n        return `Patterns[#${name}]`;\n    }\n\n}\n\n\nconst objOrBool = (d, parser, class_type) => {\n    let _t = typeof (d);\n    if (_t == 'object') {\n        let m = new class_type;\n        JSonParser._LoadData(parser, m, d);\n        return m;\n    }\n    return _t == 'boolean' ? d : false;\n}\n\n\nexports.Patterns = Patterns;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { Patterns } = require(\"./Patterns\");\n\nclass RefPatterns extends Patterns {\n    \n    /**\n     * reference pattern\n     * @param {Patterns} pattern \n     */\n    constructor(pattern){\n        super();\n        if (!pattern || !(pattern instanceof Patterns)){\n            throw new Error('pattern not a Pattern instance');\n        }\n        // + | init property ref keys \n        (function(q, pattern){\n            const _keys = Object.keys(q);\n            _keys.forEach(i => {\n                // let t = typeof (q[i]);\n                // if (/function|object/.test(t))\n                //     return;\n                let _i = Object.getOwnPropertyDescriptor(q, i);\n                if (!_i || (_i.get) || _i.writable) {\n                    // q[i] = pattern[i];\n                    Object.defineProperty(q, i, {get(){ return pattern[i]; }})\n                } \n            });\n        })(this, pattern);\n \n        Object.defineProperty(this, 'pattern', { get(){return pattern; }}); \n    }\n    check(l, option, parentMatcherInfo){\n        return this.pattern.check(l, option, parentMatcherInfo);\n    } \n    /**\n     * \n     * @returns \n     */\n    getEntryRegex(){\n        return this.pattern.getEntryRegex();\n    }\n    toString(){\n        let n = this.pattern.name;\n        if (!n){\n            if (this.patterns.matchType == -1){\n                n = 'groups'\n            };\n        }\n        return `RefPatterns[#${n}]`;\n    }   \n    endRegex(p){\n        return this.pattern.endRegex(p);\n    } \n}\nexports.RefPatterns = RefPatterns;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { RegexUtils } = require(\"./RegexUtils\")\n\n\n\n\nclass RegexEngine{\n    info;\n\n    constructor(def, empty){ \n        const _reg = def;\n        var _type;\n        Object.defineProperty(this, '_regex', {get(){return _reg;}});\n        Object.defineProperty(this, '_type', {get(){return _type;}});\n        Object.defineProperty(this, 'isEmpty', {get(){return empty;}});\n\n        this._store =(e)=>{\n            _reg.push(e);\n        };\n        this._clear =()=>{ _reg.length = 0; };\n        this._changeType = (f)=>{\n            _type = f;\n        };\n    }\n    toString(){\n        if (this._regex.length==1){\n            return this._regex[0].toString();\n        }\n        return this.info.s;\n    }\n    static Load(expression, empty){\n        if (!expression){\n            return null;\n        }\n        if (empty){\n            return new RegexEngine([expression], empty);\n        }\n        let _flag = null;\n        if (typeof(expression)!='string'){\n            expression = expression.toString();\n            let ind = expression.lastIndexOf(\"/\");\n            let option = expression.substring(ind+1);\n            expression = expression.substring(0, ind+1).slice(1,-1);\n            if (option){\n                let moption = [];\n                if (option.indexOf('i')!=-1) moption.push('i');\n                if (option.indexOf('m')!=-1) moption.push('m');\n                if (option.indexOf('d')!=-1) _flag = 'd';\n                // - //\n                if (moption.length>0){\n                    expression = \"(?\"+moption.join(\"\")+\")\"+expression;\n                }\n            }\n            //expression = expression.slice(1,-1);\n        }\n        let inf = RegexUtils.RegexInfo(expression);\n        let _s = inf.s;\n        //treat \n        let _offset = 0;\n        let _p = null;\n        let _start = 0;\n        let _def = [];\n        let _match = /\\(\\?[i]:/d;\n        let _ss = null;\n        let _is_extended = inf.option.indexOf('x')!=-1;\n        inf.option = inf.option.replace(\"x\",'');\n        if (_flag){\n            inf.option+= _flag;\n        }\n        // + | -------------------------------------------------\n        // + | JS: load extended data \n        // + |--------------------------------------------------\n        if (_is_extended){\n            let lit = inf.s.split(\"\\n\");\n            let _gt = [];\n            lit.forEach(i=>{\n                i = i.trimStart();\n                if (/^#/.test(i)) return;\n                i = i.replace(/^\\| /, \"|\");\n                _gt.push(i);\n                //\n            })\n            _s = _gt.join('');\n            inf.s = _s;  \n        }\n\n\n        while (_p = _match.exec(_s)){\n            // remove section flags - then \n            _offset = _p.index;\n            let _pre_exec = _s.substring(0, _offset);\n            if (!_start){\n                _def.push(new RegExp(_pre_exec, inf.option));\n            } \n            let _ms = _s.substring(_offset);\n            _s = _ss = _ms.replace(_match, \"(?:\");\n            _ss = RegexUtils.ReadBrank(_ss, 0, 0);\n            if (_match.test(_ss)){\n                // contains sub activated flags\n                throw new Error(\"contains sub activate flag - not allowed\")\n            }\n            _def.push(new RegExp(_ss, \"i\")); \n            _offset = _ss.length;\n            _s = _s.substring(_offset);\n        } \n        if (_s.length>0){\n            _def.push(new RegExp(_s, _def.length>0?'': inf.option));  \n        }\n\n        if (_def.length>0){\n            let _engine = new RegexEngine(_def, false);  \n            _engine.info = inf; \n            return _engine;\n        }\n        return null;\n    }\n    test(l){\n        return this.exec(l) !==null;\n    }\n    exec(l){\n        if (this.isEmpty){\n            return null;\n        }\n        let _cond = true;\n        let _q = this._regex.slice();\n        let _ret = null;\n        let _gret = null;\n        let _index = 0;\n        while(_cond && (_q.length>0)){\n            let m = _q.shift();\n            _ret = m.exec(l);\n            if (_ret){\n                if (_gret==null){\n                    // initial source\n                    _gret = _ret;\n                }else{\n                    // update gret\n                    // update group \n                    _gret[0] += _ret[0];\n                    _index+= _ret[0].length;\n                    l = l.substring(_index);\n                }\n            }else{\n                _cond = false;\n                _gret = null;\n            }\n        }\n        return _gret;\n    }   \n}\n\nexports.RegexEngine = RegexEngine;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst START_HERE = \"(??)\";\nconst CAPTURE_MOVEMENT =/\\(\\?((<)?!|(\\<)?=)./;\nconst SKIP_REGEX = {\n    exec(){\n        return null;\n    },\n    test(){\n        return null;\n    },\n    toString(){\n        return '';\n    }\n};\n/**\n * regex utility class \n */\nclass RegexUtils {\n    /**\n     * is skipped end regex\n     * @param {regex} skip \n     * @returns \n     */\n    static IsSkipped(skip){\n        return skip === SKIP_REGEX;\n    }\n    /**\n     * to remove [not-]ahead-backyard: matching\n     */\n    static get CAPTURE_NOT_AHEAD_BACKYARD() {\n        // not-ahead-backyard : (<)?!\n        // ahead: (=)\n        // backyard: <=\n        return /\\(\\?([imx]|(<)?!|(\\<)?=)./;\n    }\n    static get CAPTURE_MOVEMENT() {\n        return CAPTURE_MOVEMENT;\n    }\n    /**\n     * \n     */\n    static get CAPTURE_LEAVE_AHEAD_BACKYARD() {\n        // not-ahead-backyard : (<)?!\n        // ahead: (=)\n        // backyard: <=\n        return /\\((\\?(:|[imx])|(?!\\?))./; \n    }\n\n    /**\n     * check if has selection movement capture\n     * @param {*} regex \n     * @returns \n     */\n    static HasMovementCapture(regex){\n        let rc = RegexUtils.CAPTURE_NOT_AHEAD_BACKYARD;\n        let _ret =  rc.test(regex);\n        return _ret;\n    }\n    /**\n     * check if regex contains backyard movement capture\n     * @param {*} regex \n     * @returns \n     */\n    static HasBackyardMovementCapture(regex){\n        const rc = /(\\(\\?<(!|=))./;\n        return rc.test(regex);\n    }\n  \n    /**\n     * regex parsing\n     * @param {{isReadonly:boolean}} q \n     * @returns {(str:string)=>string}\n     */\n    static RegexParser(q){\n        const { Utils } = require(\"./Utils\");\n        const { RegexEngine } = require(\"./RegexEngine\");\n        return (s) => {\n            if (s == '(??)') {\n                q.isStartOnly = true;\n                s = '';\n            }\n            let is_empty = false;\n            if (s == '') {\n                is_empty = true;\n            }\n            let g = Utils.RegexParse(s, 'd');\n            g = RegexEngine.Load(g, is_empty);\n            return g;\n        }; \n    }\n\n    /**\n     * remove regex not-ahead-backyard - group\n     * @param {string} str \n     * @returns {?string}\n     */\n    static RemoveNotAheadBackyardGroup(str) {\n        let s = RegexUtils.RemoveCapture(str, RegexUtils.CAPTURE_NOT_AHEAD_BACKYARD);\n        if (s) {\n            return RegexUtils._TreatCaptureGroup(s);\n        }\n        return s;\n    }\n    /**\n     * removce capture on regex\n     * @param {string} str \n     * @returns \n     */\n    static RemoveCaptureAndLeaveMovementCapture(str) {\n        let s = RegexUtils.RemoveCapture(str, RegexUtils.CAPTURE_LEAVE_AHEAD_BACKYARD);\n        if (s) {\n            return RegexUtils._TreatCaptureGroup(s);\n        }\n        return s;\n    }\n    static _TreatCaptureGroup(s) {\n        if ((s[0]==\"/\") && (s[s.length-1]==\"/\")){\n            s = s.slice(1,-1);\n        }\n        return s.split('|').filter(o => o.length > 0).join('|')\n    }\n    /**\n     * regex to string regex\n     * @param {RegExp} s \n     * @returns \n     */\n    static RegexToStringRegex(s){\n        s = s.toString();\n        return s.substring(0, s.lastIndexOf('/')+1).slice(1,-1);\n    }\n    /**\n    * get regex info on start line\n    * @param {string} s regex string expression\n    */\n    static RegexInfo(s) {\n        let option = '';\n        if (s == \"(??)\") {\n            return {\n                s: \"^.^\",\n                option,\n                beginOnly: true\n            };\n        }\n\n        let _option = /^\\(\\?(?<active>[imx]+)(-(?<disable>[ixm]+))?\\)/;\n        let _potion = null;\n        if (_potion = _option.exec(s)) {\n            let sp = '';\n            if (_potion.groups) {\n                sp = _potion.groups.active ?? '';\n                if (_potion.groups.disable) {\n                    _potion.groups.disable.split().forEach(i => {\n                        sp = sp.replace(i, '');\n                    });\n                }\n            }\n            s = s.replace(_option, '');\n            option = sp;\n        }\n        return {\n            s,\n            option\n        };\n    }\n    /**\n     * check request start line\n     * @param {*} reg \n     * @returns \n     */\n    static CheckRequestStartLine(reg) {\n        // + | TO CHECK that regex request for start line \n        // - ^ must not be escaped \\^\n        // - ^ must not be a non validated group [^] \n        return /([^\\\\\\\\[]|^)\\^/.test(reg.toString());\n    }\n    /**\n     * check regex request on end line\n     * @param {*} reg \n     * @returns {boolean}\n     */\n    static CheckRequestEndLine(reg) {\n        // + | TO CHECK that regex request for start line \n        // - ^ must not be escaped \\$\n        // - ^ must not be a non validated group [$] \n        return /([^\\\\\\\\[]|$)\\$/.test(reg.toString());\n    }\n    /**\n    /**\n     * stringify and regex result\n     * @param {*} c \n     * @returns \n     */\n    static Stringify(c) {\n        return c.toString().slice(1, -1).replace(\"\\\\/\", \"/\")\n    }\n /**\n  * remove capture group\n  * @param {string} str regex data \n  * @param {*} regex regex that represent the capture\n  * @returns \n  */\n    static RemoveCapture(str, regex) {\n\n        if (typeof (str) != 'string') {\n            throw new Error('invalid parameter.');\n        }\n\n        let l = str;\n        let p = 0;\n        let ch = '';\n        regex = regex || /\\(\\?(:|(\\<)?=)./;\n        function rm_brank(l, index, start = '(', end = ')') {\n            let i = 1;\n            let ln = l.length;\n            const start_index = index;\n            let escaped = false;\n            while ((i < ln) && (i > 0) && (index < ln)) {\n\n                ch = l[index + 1];\n                if (ch == start) {\n                    if (!escaped) {\n                        i++;\n                    }\n                } else if (ch == end) {\n                    if (!escaped)\n                        i--;\n                }\n                escaped = ch == \"\\\\\";\n                index++;\n            }\n            //+ | fix: remove repeating brank symbol\n            if ((index + 1 < ln) && (/[\\\\?\\\\*]/.test(l[index + 1]))) {\n                index++;\n            }\n            return l.substring(0, start_index) + l.substring(index + 1);\n        }\n        let capture = false;\n        let _prev = '';\n        while (p = regex.exec(l)) {\n            if (p.index>0){\n                let _escape = l[p.index-1]==\"\\\\\";\n                if (_escape){\n                    _prev += l.substring(0, p.index+1);\n                    l = l.substring(p.index+1);\n                    continue;\n                }\n            }\n            l = rm_brank(l, p.index);\n            capture = true;\n        }\n        if (_prev.length>0){\n            if (capture){\n                l = _prev+l;\n            }\n        }\n        return capture ? l : str;\n    }\n\n    static ReadBrank(str, position, count = 1, start = '(', end = ')') {\n        const ln = str.length;\n        let ch = null;\n        let _stpos = position;\n        while (position < ln) {\n            ch = str[position];\n            if (ch == start) {\n                count++;\n            } else if (ch == end) {\n                count--;\n                if (count == 0) {\n                    position++;\n                    break;\n                }\n            }\n            position++;\n        }\n        return str.substring(_stpos, position);\n    }\n\n    /**\n     * check if is captured only regex expression\n     * @param {string|RegExp} regex \n     * @returns {bool}\n     */\n    static IsCapturedOnlyRegex(regex) {\n        let f = false;\n        let s = regex.toString();\n        s = s.substring(0, s.lastIndexOf('/') + 1).slice(1, -1);\n        s = RegexUtils.RemoveCapture(s, /\\(\\?((<)?!|(\\<)?=)./);\n        if (s == null) {\n            return false;\n        }\n        s = s.split('|').join('').trim();\n\n        f = s.length == 0;\n        return f;\n    }\n    /**\n     * unset capture definition \n     * @param {*} m \n     */\n    static UnsetCapture(m) {\n        const _regex = /\\(\\?(:|<|=)/;\n        let p = null;\n        let s = '';\n        let ch = null;\n        while (p = _regex.exec(m)) {\n            s = m.substring(0, p.index);\n            // + | remove branket dans leave content \n            let i = 1;\n            let g = m.substring(p.index + p[0].length);\n            let ln = g.length;\n            let pos = 0;\n            while (pos < ln) {\n                ch = g[pos];\n                if (ch == ')') {\n                    i--;\n                    if (i == 0) {\n                        if ((pos + 1 < ln) && /\\?|\\*/.test(g[pos + 1])) {\n                            pos++;\n                        }\n                        let end = g.substring(0, pos) + g.substring(pos + 1);\n                        s += end;\n                        break;\n                    }\n                }\n                else if (ch == '(') {\n                    i++;\n                }\n                pos++;\n            }\n            m = s;\n        }\n        return m;\n    }\n}\n\nRegexUtils.SKIP_REGEX = SKIP_REGEX;\n\nexports.RegexUtils = RegexUtils;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n \nconst { Utils } = require(\"./Utils\");\n\n\nclass ReplaceWithCondition{\n    /**\n     * expression to check\n     * @var {undefined|*}\n     */\n    expression;\n    check;\n    operator = '=';\n    match;\n    captures;\n\n    constructor(){ \n    }\n\n    json_parse(parser, fieldname, data, refKey){\n        const _regex_parser = (s)=>{\n            return Utils.RegexParse(s); \n        };\n        const _capture_parser = Utils.JSONInitCaptureField(this);\n        return Utils.JSonParse(this, {\n            expression: _regex_parser,\n            match: _regex_parser,\n            captures : _capture_parser\n        }, parser, fieldname, data, refKey);\n    }\n    json_validate(field_name, d, throw_on_error){\n        let string_test = (v)=> typeof(v)=='string';\n        return Utils.JSonValidate(this, {\n            check:string_test,\n            operator:string_test,\n            operator:string_test,\n        },field_name, d, throw_on_error); \n    }\n\n}\n\nexports.ReplaceWithCondition = ReplaceWithCondition;","\"use strict\";\nObject.defineProperty(exports, \"__ESModule\", { value: true });\n\nconst _REGISTRY = {};\n/**\n * base transform engine\n */\nclass TransformEngine\n{\n    /**\n     * register transform engine\n     * @param {*} id \n     * @param {*} func_or_class_name \n     */\n    static Register(id, func_or_class_name){\n        _REGISTRY[id] = func_or_class_name;\n    }\n    static CleareRegistry(){\n        Object.keys(_REGISTRY).forEach((o)=>{\n            delete(_REGISTRY[o]);\n        });\n\n    }\n    /**\n     * create a transform engine \n     * @param {*} id \n     * @returns \n     */\n    static Create(id){\n        const def = _REGISTRY[id];\n        if (def){\n            return new def();\n        }\n        return null;\n    }\n}\n\nexports.TransformEngine = TransformEngine;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { JSonParser } = require(\"./JSonParser\");\nconst { RegexUtils } = require(\"./RegexUtils\");\n\n/**\n * utility classe\n */\nclass Utils {\n    static TestScope;\n\n    /**\n     * utility trim buffer segment\n     * @param {*} bufferSegment \n     */\n    static TrimBufferSegment(bufferSegment, dataSegment) {\n        if (dataSegment.length != bufferSegment.length){\n            throw new Error('invalid trim operation. length must match');\n        }\n        const _tlist = bufferSegment.marked.slice(0);\n        let _dir = 0;\n        let _idx = 0;\n        let _count = 0;\n        let q = bufferSegment;\n        let _ln = bufferSegment.length;\n\n        while (_tlist.length > 0) {\n            _idx = _dir == 0 ? _tlist.shift() : _tlist.pop();\n            let _top = bufferSegment.marked.op[_idx] || null;\n            let _trim = _dir == 0 ? _idx == _count : _idx == _count;\n            if (_top && _trim && _top.trimmed) {\n                //let _ts = q[_idx];\n                delete (q[_idx]);\n                delete (dataSegment[_idx]);\n                delete (bufferSegment.marked[bufferSegment.marked.indexOf(_idx)]);\n                delete (bufferSegment.marked.op[_idx]);\n\n            }\n            if (_dir == 1) {\n                if (!_trim) {\n                    break;\n                }\n                _count--;\n            } else {\n                if (!_trim) {\n                    _dir = 1;\n                    _count = _ln - 1;\n                    _tlist.unshift(_idx);\n                    continue;\n                }\n                _count++;\n            }\n        }\n\n        if (dataSegment.length != bufferSegment.length){\n            throw new Error('invalid trim operation');\n        }\n    }\n    /**\n     * get marked segment setting\n     * @param {*} marker \n     * @returns \n     */\n    static GetMarkedInfo(marker){\n        let _info = null;\n        const { isMarkedSegments, isTrimmedSegment, markedSegment } = marker;\n        if (isMarkedSegments) {\n            if (typeof (markedSegment) == 'object') {\n                _info = {\n                    trimmed: isTrimmedSegment,\n                    ...markedSegment\n                }\n            }else{\n                _info = {isTrimmed: isTrimmedSegment};\n            }\n            return _info;\n        }\n        return false;\n    }\n    static ReorderBufferSegment(bufferSegment) {\n        const { FormatterBuffer } = Utils.Classes;\n        // order \n        const _op = bufferSegment.marked.op;\n        const _marked = bufferSegment.marked;\n        let _ni = 0;\n        let _buff = [];\n        _buff.marked = FormatterBuffer.InitMarkedSegment();\n        // update buffer marker order \n        for (let ri = 0; ri < bufferSegment.length; ri++) {\n            if (bufferSegment[ri] != undefined) {\n                // delete \n                _buff.push(bufferSegment[ri]);\n                if (ri in _op) {\n                    _buff.marked.push(_ni);\n                    _buff.marked.op[_ni] = _op[ri];\n                } else if (_marked.indexOf(ri) != -1) {\n                    _buff.marked.push(_ni);\n                }\n                _ni++;\n            }\n        }\n\n        bufferSegment.length = 0;\n        bufferSegment.push(..._buff);\n        bufferSegment.marked = _buff.marked;\n\n    }\n\n    /**\n     * \n     * @param {*} _d \n     * @param {*} _idx \n     * @param {*} op operation to do \n     */\n    static UpdateSegmentMarkerOperation(_d, _idx, op) {\n        if (Array.isArray(_d)==false){\n            throw new Error(\"required array\");\n        }\n      \n        // if (!op) {\n        //     console.log(\"----not op-----\", _d);\n        //     return;\n        // }\n        _d.op[_idx] = op;\n    }\n    static UpdateMarkedSegment(s, _marker) {\n        if (_marker.isMarkedSegments) {\n            s.marked = _marker.markedInfo();\n        }\n    }\n\n    /**\n     * Get default begin captures\n     * @param {*} marker \n     * @returns \n     */\n    static BeginCaptures(marker) {\n        return { ...marker.captures, ...marker.beginCaptures };\n    }\n    static EndCaptures(marker) {\n        return { ...marker.captures, ...marker.endCaptures };\n    }\n\n    static JSON_REGEX_PARSER() {\n        return (s) => {\n            if (s == '(??)') {\n                q.isStartOnly = true;\n                s = '';\n            }\n            let is_empty = false;\n            if (s == '') {\n                is_empty = true;\n            }\n            let g = Utils.RegexParse(s, 'd');\n            g = RegexEngine.Load(g, is_empty);\n            return g;\n        };\n    }\n\n    /**\n     * create end match\n     * @param {*} value \n     * @returns \n     */\n    static CreateEndMatch(value, input) {\n        const _p = [value];\n        _p.index = 0;\n        _p.indices = [[0, value.length]];\n        _p.input = input || \"\\0\";\n        return _p;\n    }\n\n    static ReplaceWithCheck(replaceWith, value, { match, captures, operator, check }, _refObj) {\n        let _rpw = Utils.RegExToString(replaceWith);\n        const { g } = _refObj;\n        _refObj._rpw = _rpw;\n        if (match) {\n            let _op = operator || '=';\n            let _s = Utils.ReplaceRegexGroup(check, g);\n            if (/(!)?=/.test(_op)) {\n                let r = match.test(_s);\n                if (_op) {\n                    if (((_op == '=') && !r) || ((_op == '!=') && (r))) {\n                        _refObj.replaced = false;\n                        return value;\n                    }\n                }\n            } else if (/(\\<\\>)=/.test(_op)) {\n                let _ex = match.toString().replace(/\\\\\\//g, '');\n                if (\n                    ((_op == \">=\") && (_s >= _ex)) ||\n                    ((_op == \"<=\") && (_s <= _ex))\n                ) {\n                    if (_s >= _ex) {\n                        _refObj.replaced = false;\n                        return value;\n                    }\n                }\n            }\n        }\n        else {\n            _refObj.replaced = false;\n        }\n        return value;\n    }\n\n    /**\n     * render data\n     * @param {string} value \n     * @param {PatternMatchInfo} marker \n     * @param {null|CaptureInfo[]} captures \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static RenderToBuffer(value, marker, captures, option) {\n        let _cm_value = value;\n        let _cm_data = value;\n\n        // if (captures){\n        //     _cm_value = Utils.TreatCapture(marker, captures, _cm_value, option.tokenChains, option)\n        // }\n\n        option.saveBuffer();\n        option.appendToBuffer(_cm_value, marker, option);\n        option.store();\n        let refdata = { data: null };\n        _cm_value = option.flush(true, refdata);\n        _cm_data = refdata.data;\n        option.restoreSavedBuffer();\n\n        return {\n            \"buffer\": _cm_value,\n            \"data\": _cm_data\n        };\n\n    }\n    /**\n     * define properties\n     * @param {*} target \n     * @param {*} def \n     */\n    static DefineProperties(target, def) {\n        for (let i in def) {\n            target[i] = def[i];\n        }\n    }\n    /**\n    * define and inject property \n    * @param {string} n namespace\n    * @param {undefined|*} v \n    * @param {*} globalname \n    * @returns \n    */\n    static FunctionDefineArg(n, v, globalname) {\n        let c = 0;\n        let result = 0;\n        let s = '';\n        if (globalname) {\n            s = '((w,p,q,n)=>{n=w; while((p.length>1) && (q = p.shift())){ n[q] = n[q] || {}; n = n[q];} n[p[0]] = v})(' + globalname + \", \\\"\" + n + \"\\\".split('.'), v) || \";\n        }\n        n.split('.').forEach((i) => {\n            if (!result) {\n                result = i + '=((v)=>{ return ' + s + '{'\n            } else {\n                if (c) {\n                    result += \"{\"\n                }\n                result += i + \":\";\n                c++;\n            }\n        });\n        v = typeof (v) == 'undefined' ? 'undefined' : (typeof (v) == 'object' ? JSON.stringify(v) : v) || '\"' + n + '\"';\n        result += v + '}'.repeat(c) + \"})(\" + v + \")\";\n\n        return result;\n    }\n    /**\n     * define property \n     * @param {string} n \n     * @param {undefined|*} v \n     * @param {object} global object definition \n     * @returns \n     */\n    static DefineProp(n, v, window) {\n        return ((q, v, window) => {\n            let r = null; let m = null; let _last = null; let _o = null;\n            v = (typeof (v) != \"undefined\" ? v : n);\n            if (q.length == 0) return v;\n            q.forEach(i => {\n                if (r == null) {\n                    // first object definition\n                    r = m = (window ? window[i] : null) || {};\n                    if (window) {\n                        window[i] = r;\n                    }\n                }\n                if (_last) {\n                    _o = m;\n                    if (typeof (m[i]) == 'string') {\n                        m[i] = {};\n                    }\n                    m[i] = m[i] || {};\n                    m = m[i];\n                }\n                _last = i;\n            });\n\n            if (_o)\n                _o[_last] = v;\n            else {\n                if (window) {\n                    window[q[0]] = v;\n                }\n            }\n            return r;\n        })(n.split('.'), v, window);\n    }\n    /**\n     * store tokens\n     * @param {*} name \n     * @param {*} tokens \n     */\n    static StoreTokens(name, tokens) {\n        tokens.unshift(...name.split(' ').reverse());\n    }\n    /**\n     * unshift tokens\n     * @param {*} name \n     * @param {*} tokens \n     */\n    static UnshiftTokens(name, tokens) {\n        const r = name.split(' ').reverse();\n        while (r.length > 0) {\n            const q = r.shift();\n            if (tokens[0] == q) {\n                tokens.shift();\n            } else {\n                throw new Error('missing tokens definition ' + q);\n            }\n        }\n    }\n\n    static ArrayPatternsFromParser(parser, Patterns, RefPatterns) {\n\n        const _pattern_class = parser.patternClassName || Patterns;\n        return Utils.ArrayParser(_pattern_class, RefPatterns);\n    }\n    /**\n     * \n     * @param {*} class_name \n     * @param {*} data \n     * @param {*} registry \n     * @param {null|undefined|{patternClassName: undefined|class, captureInfoClassName:undefined|class, closeParentInfoClassName: undefined|class}} registry \n     * @returns \n     */\n    static JSonParseData(class_name, data, registry, pattern_class_name) {\n        let parser = new JSonParser;\n        parser.source = class_name;\n        parser.data = data;\n        parser.includes = {};\n        // + | init parser definitions\n        if (typeof (pattern_class_name) == 'object') {\n            const { patternClassName, captureInfoClassName, closeParentInfoClassName } = pattern_class_name;\n            parser.patternClassName = patternClassName;\n            parser.captureInfoClassName = captureInfoClassName;\n            parser.closeParentInfoClassName = closeParentInfoClassName;\n        } else {\n            parser.patternClassName = pattern_class_name;\n        }\n        if (registry) {\n            parser.registry = registry;\n        }\n        return Utils.LoadData(parser, new class_name(), data, null); //.parse();\n    }\n    static LoadData(parser, obj, data, refKey) {\n        return JSonParser._LoadData(parser, obj, data, refKey);\n    }\n    /**\n     * array parser callback\n     * @param {*} class_name \n     * @returns \n     */\n    static ArrayParser(class_name, refkey_class_name) {\n        if (!refkey_class_name || typeof (refkey_class_name) == 'undefined') {\n            throw new Error('missing refkey_class_name');\n        }\n        /**\n         * \n         */\n        return function (d, parser, refKey, refObj) {\n            let _out = [];\n            let q = refObj || this;\n            const { Formatters } = Utils.Classes;\n            d.forEach((a) => {\n                const { include } = a;\n                const _extends = a.extends;\n                let _o = null, _key = null, _def = null;\n                if (include) {\n                    if (include[0] == '#') {\n                        // + | LOAD INCLUDE PROPERTY . #include\n                        _key = include.substring(1);\n                        if (_key in parser.includes) {\n                            _o = new refkey_class_name(parser.includes[_key]);\n                        }\n                        else {\n                            if (refKey && (refKey == _key) && refObj) {\n                                _o = new refkey_class_name(q);\n                            } else {\n                                _def = parser.data.repository[_key];\n                                if (_def) {\n                                    _o = new class_name();\n                                    parser.includes[_key] = _o;\n                                    JSonParser._LoadData(parser, _o, _def, _key, refObj || _o);\n                                    parser.initialize(_o);\n                                    class_name.Init(_o);\n                                }\n                            }\n                        }\n                    } else {\n                        // TODO: load engine source formatter - or not\n                        // _o = new FormatterResourceLoadingPattern(include);\n                        const { EngineFormatter } = Formatters;\n                        if (EngineFormatter) {\n                            return EngineFormatter.resolve(include);\n                        }\n\n                    }\n                }\n                else if (_extends) {\n                    throw new Error(\"extends not support yet\");\n                }\n                else {\n                    _o = new class_name();\n                    JSonParser._LoadData(parser, _o, a, refKey, refObj || _o);\n                    parser.initialize(_o);\n\n                }\n                if (_o) {\n                    _out.push(_o);\n                }\n            });\n            return _out;\n        }\n    }\n    /**\n     * check skip pattern\n     * @param {*} skip \n     * @param {*} marker \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static CheckSkip(skip, marker, option) {\n\n        if (typeof (skip) == 'string') {\n            skip = [skip];\n        }\n        const _flags = {\n            startLine: option.startLine,\n            startBlock: option.startBlock,\n            conditionBlockStart: option.isConditionalBlockStart()\n        }\n        while (skip.length > 0) {\n            let q = skip.shift();\n            if (q in _flags) {\n                if (_flags[q]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * \n     * @param {*} s \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static _SkipLine(s, option) {\n        let _skip = false;\n        if (s.startLine) {\n            if (!option.startLine) {\n                _skip = true;\n            }\n        }\n        if (!_skip && s.skip) {\n            _skip = Utils.CheckSkip(s.skip, s, option);\n        }\n        if (!_skip && option.matchTransform && s.matchTransform) {\n            _skip = true;\n        }\n        if (!_skip && (option.lastEmptyMarkerPattern?.marker == s)) {\n            _skip = true;\n            option.lastEmptyMarkerPattern = null;\n        }\n        return _skip;\n    }\n    /**\n     * get match info\n     * @var {array} patterns\n     * @var {string} l string\n     * @var {*} options\n     * @var {*} parentMatcherInfo parent pattern for get result\n     * @var {boolean|{_a,_match: null|number|RegExpResult,_from:undefined, patterns}}\n     */\n    static GetMatchInfo(patterns, l, option, parentMatcherInfo) {\n        // const { FormatterOptions } = Utils.Classes;\n        let _a = null;\n        let _from = null;\n        let _match = 0;\n        let _index = -1;\n        let _patterns = patterns;\n        let _position = -1; // selected pattern position        \n        const { lineMatcher, debug } = option;\n        lineMatcher.startLine = option.startLine;\n        const _tloop = [{ patterns: patterns, from: null, ref: parentMatcherInfo, count: 0 , slice:0}];\n        const ll = l;\n        while (_tloop.length > 0) {\n            const _m_patterns = _tloop.shift();\n            let _count = 0;\n            let _mpatterns = _m_patterns.patterns.slice(_m_patterns.slice);\n            while (_mpatterns.length > 0) {\n                let s = _mpatterns.shift();\n                //_m_patterns.patterns.forEach((s) => {\n                let p = null;\n                let from = null;\n                let item_index = null;\n                let skip = Utils._SkipLine(s, option);\n\n                if (!skip) {\n                    let { patterns } = s;\n                    const _regex = s.getEntryRegex();\n                    let _d = null;\n                    if (_regex) {\n                        p = lineMatcher.check(_regex, option);\n                        _d = {\n                            p, s: s, index: -1, regex: _regex, from: _m_patterns.from,\n                            patterns: _m_patterns.patterns,\n                            ref: _m_patterns.ref\n                        };\n                    }\n                    else {\n                        if (patterns) {\n                             _tloop.push({ patterns: patterns, from: s, ref: parentMatcherInfo, \n                                count: _count ,\n                                slice: 0});\n                            if (_mpatterns.length > 0) {\n                                _tloop.push({ patterns: _m_patterns.patterns, from: _m_patterns.from, ref: parentMatcherInfo, \n                                    count: _count, \n                                   slice : _m_patterns.patterns.length - _mpatterns.length});\n                                _mpatterns.length = 0;\n                            }\n                            continue;\n                        }\n                    }\n                    if (_d) {\n                        ({ p, s, from, patterns } = _d);\n                        item_index = _d.index == -1 ? _count : _d.index;\n                    }\n                    if (p && ((_index == -1) || (_index > p.index))) {\n                        _index = p.index;\n                        _a = s;\n                        _match = p;\n                        _from = from;\n                        _patterns = patterns || _patterns;\n                        _position = item_index || _count;\n                    }\n                }\n                _count++;\n                // });\n            }\n        } \n        if (_match === 0) {\n            return false;\n        }\n        return { _a, _match, _from, patterns: _patterns, index: _position };\n    }\n    /**\n     * \n     * @param {*} patterns \n     * @param {*} option \n     * @param {*} parentMatcherInfo \n     * @returns \n     */\n    static GetPatternMatcher(patterns, option, parentMatcherInfo = null/*, _line = null, _sub_line_offset = null*/) {\n        const { line, debug, depth, lineCount, lineMatcher, startLine } = option;\n        const { FormatterPatternException } = Utils.Classes;\n        let _a = null;\n        let _match = 0;\n        let _from = -1;\n        let l = lineMatcher.nextLine;\n        const { RefPatterns } = Utils.Classes;\n        let index;\n        ({ _a, _match, _from, patterns, index } = Utils.GetMatchInfo(patterns, l, option, parentMatcherInfo));\n        if (_match) {\n            if (_match.index > option.length) {\n                _a = null;\n                _match = null;\n            }\n        }\n        if (_a) {\n\n            debug?.feature('matcher-begin') && console.log('matcher-begin: ', {\n                '__name': _a.toString(),\n                name: _a.name,\n                line,\n                pos: _match.index,\n                depth,\n                hasParent: _a.parent != null,\n                isBlock: _a.isBlock,\n                comment: _a.comment,\n                isRef: _a instanceof RefPatterns,\n                value: _match[0],\n                detectOn: l,\n                offset: lineMatcher.offset,\n                regex: _a.matchRegex,\n                type: _a.matchType == 0 ? \"begin/end\" : \"match\",\n                isFromGroupRef: _from != null,\n                parent: _a.parent?.toString(),\n                from: _from?.toString(),\n                startLine\n            });\n            if (_a.throwError) {\n                let e = _a.throwError;\n                let msg = typeof (e) == 'object' ? e.message : 'invalid match';\n                msg = msg.replace(\"%value%\", \"'\" + _match[0] + \"'\");\n                throw new FormatterPatternException(msg, _a, _match, lineCount);\n            }\n            // + | add property to offset \n            _match.offset = _match[0].length;\n            // + | treat begin captures must be at corresponding data  \n            let _info = new PatternMatchInfo;\n            Utils.InitPatternMatchInfo(_info, _a, _match, parentMatcherInfo, _from, line, patterns, index, option.formatter.formatting,\n                {\n                    lineCount: option.lineCount\n                }\n            );\n            return _info;\n        }\n        return _a;\n    }\n    /**\n     * \n     * @param {*} _info \n     * @param {*} _a \n     * @param {*} _match \n     * @param {*} parentMatcherInfo \n     * @param {*} _from \n     * @param {*} line \n     * @param {*} patterns \n     * @param {*} index \n     * @param {*} formatting \n     * @param {{lineCount: number}} state state info\n     */\n    static InitPatternMatchInfo(_info, _a, _match, parentMatcherInfo, _from, line, patterns, index = -1, formatting=null, state = null) {\n        _info.use({\n            marker: _a,\n            endRegex: _a.endRegex(_match),\n            line,\n            group: _match,\n            parent: parentMatcherInfo,\n            patterns,\n            fromGroup: _from,\n            index,\n            formatting,\n            state\n        });\n    }\n    /**\n     * \n     * @param {string} l \n     * @param {*} patterns \n     * @param {*} option \n     * @param {*} parentMatcherInfo \n     * @returns \n     */\n    static GetPatternMatcherInfoFromLine(line, patterns, option, parentMatcherInfo) {\n        const { debug, depth, lineCount, formatter } = option;\n        const { RefPatterns, FormatterPatternException } = Utils.Classes;\n        let _a = null;\n        let _match = 0;\n        let pos = 0;\n        let _from = null;\n        let index = -1;\n        const { formatting } = formatter;\n        ({ _a, _match, _from, patterns, index } = Utils.GetMatchInfo(patterns, line, option, parentMatcherInfo));\n\n        if (_a) {\n            // _match.index += pos;\n            if (debug) {\n                console.log('matcher-begin-1: ', {\n                    '__name': _a.toString(),\n                    name: _a.name, line, pos:\n                        _match.index, depth,\n                    hasParent: _a.parent != null,\n                    isBlock: _a.isBlock,\n                    isRef: _a instanceof RefPatterns,\n                    value: _match[0],\n                    regex: _a.matchRegex,\n                    index\n                });\n            }\n            if (_a.throwError) {\n                let e = _a.throwError;\n                const msg = typeof (e) == 'object' ? e.message : 'invalid match';\n                throw new FormatterPatternException(msg, _a, _match, lineCount);\n            }\n            // + | add property to offset \n            _match.offset = _match[0].length;\n            // +| treat begin captures must be at corresponding data info \n\n            let _info = new PatternMatchInfo;\n            Utils.InitPatternMatchInfo(_info, _a, _match, parentMatcherInfo, _from, line, patterns, index, formatting);\n            return _info;\n        }\n        return _a;\n    }\n    /**\n     * get regex from\n     * @param {string} s regex expression\n     * @param {*} p group match\n     * @returns \n     */\n    static GetRegexFrom(s, p, flag, op) {\n        if ((op == 'end') || (op == 'while')) {\n\n            s = s.replace(/\\\\([\\d]+)/g, (a, m) => {\n\n                return p[m];\n            });\n\n        }\n        else {\n\n            s = s.replace(/[^\\\\]?\\$([\\d]+)/g, (a, m) => {\n                if (a[0] == \"\\\\\") return a;\n                if (a[0] != '$')\n                    return a[0] + p[m];\n                return p[m];\n            });\n        }\n        s = /^\\/.+\\/$/.test(s) ? s.slice(1, -1) : s;\n        return new RegExp(s, flag || '');\n    }\n\n\n    static ReplaceRegexGroup(s, group, op) {\n        let gp = Utils.GetRegexFrom(s, group, null, op);\n        gp = gp.toString().substring(1).slice(0, -1).replace(/\\\\\\//g, \"/\");\n        s = s.replace(s, gp);\n        return s;\n    }\n    /**\n     * convert to string en remove the flags\n     * @param {*} regex \n     * @returns \n     */\n    static RegExToString(regex) {\n        let s = regex.toString();\n        s = s.substring(0, s.lastIndexOf('/') + 1);\n        return s;\n    }\n\n    /**\n     * get regex info on start line\n     * @param {string} s regex string expression\n     */\n    static RegexInfo(s) {\n        return RegexUtils.RegexInfo(s);\n    }\n    static RegexParseInfo(s, flag) {\n        let _info = Utils.RegexInfo(s);\n        if (flag && ((_info.option.length == 0) || (_info.option.indexOf(flag) == -1))) {\n            _info.option += flag;\n        }\n        return _info;\n    }\n\n\n    /**\n     * \n     * @param {*} s \n     * @param {*} flag \n     * @returns \n     */\n    static RegexParse(s, flag) {\n        if (typeof (s) == 'string') {\n            let _info = Utils.RegexParseInfo(s, flag);\n            return new RegExp(_info.s, _info.option);\n        } else if (typeof (s) == 'object') {\n            if (s instanceof RegExp) {\n\n                s = RegexUtils.RegexToStringRegex(s);\n                let _info = Utils.RegexParseInfo(s, flag);\n                let _ms = new RegExp(_info.s, _info.option);\n                return _ms;\n            }\n            const { option, regex } = s;\n            if (regex instanceof RegExp) {\n                regex = Utils.GetRegexFrom(regex.toString(), option);\n                return regex;\n            }\n            return new RegExp(regex, option);\n        }\n        return s;\n    }\n    static StringValueTransform(v, transform) {\n        const _func = {\n            captialize(s){\n                let tb = [];\n                s.split(\" \").forEach(a =>{\n                    tb.push(a.charAt(0).toUpperCase()+a.slice(1).toLowerCase());\n                });\n                return tb.join(\" \");\n            },\n            joinSpace(s) {\n                s = s.replace(/\\s+/g, ' ');\n                return s;\n            },\n            upperCase(v) {\n                return v.toUpperCase();\n            },\n            lowerCase(v) {\n                return v.toLowerCase();\n            },\n            trim(v) {\n                return v.trim();\n            },\n            /**\n             * \n             * @param {string} v \n             * @returns \n             */\n            rtrim(v) {\n                return v.trimEnd();\n            }\n            , /**\n            * \n            * @param {string} v \n            * @returns \n            */\n            ltrim(v) {\n                return v.trimStart();\n            }\n        };\n        transform.forEach((s) => {\n            // if (v.length == 0) {\n            //     return;\n            // }\n            let _p = null;\n            if (_p = /^:(?<symbol>=|\\^|#)(.)(?<number>\\d+)/.exec(s)) {\n                // + | replacement value with pattern\n                let n = parseInt(_p.groups['number']);\n                let _s = _p.groups['symbol'];\n                if (n > v.length) {\n                    let _g = _p[2];\n                    if (_s == '#') {\n                        v = v.toString().padEnd(n, _g);\n                    } else if (_s == '^') {\n                        v = v.toString().padStart(n, _g);\n                    }\n                    else if (_s == '=') {\n                        let c = Math.floor((n - v.length) / 2);\n                        v = v.toString().padEnd((c % 2) == 0 ? n - c : n - c + 1, _g);\n                        v = v.toString().padStart(n, _g);\n                    }\n                }\n                return v;\n            }\n\n            if (_p = /^\\[(?<expression>.+)\\]$/.exec(s)) {\n                let c = Utils.GetRegexFrom(_p.groups['expression'], [v]);\n                c = RegexUtils.Stringify(c);\n                v = v.replace(v, c);\n                return v;\n            }\n\n            v = typeof (s) == 'function' ? s(v) : _func[s](v);\n        });\n        return v;\n    }\n    /**\n     * \n     * @param {*} q \n     * @param {*} validator \n     * @param {*} field_name \n     * @param {*} d \n     * @param {*} throw_on_error \n     * @returns \n     */\n    static JSonValidate(q, validator, field_name, d, throw_on_error) {\n\n        let f = validator ? validator[field_name] : null;\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * \n     * @param {*} q \n     * @param {*} parse \n     * @param {*} parser \n     * @param {*} fieldname \n     * @param {*} data \n     * @param {*} refKey \n     * @returns \n     */\n    static JSonParse(q, parse, parser, fieldname, data, refKey) {\n        let fc = parse ? parse[fieldname] : null;\n        if (fc) {\n            return fc.apply(q, [data, parser, refKey]);\n        }\n        return data;\n    }\n    static TransformPropertyCallback() {\n        return function (n, parser) {\n            if (typeof (n) == 'string') {\n                let t = []\n                n.split(',').forEach((i) => {\n                    i.trim();\n                    if (i.length > 0)\n                        t.push(i);\n                });\n                return t;\n            }\n            if (Array.isArray(n)) {\n                return n;\n            }\n        };\n    }\n    /**\n * do replace with\n * @param {*} value \n * @param {*} _formatter \n * @param {string} replace_with \n * @param {*} group \n * @param {*} _marker markerInfo\n * @param {FormatterOptions} option markerInfo\n * @param {*} captures markerInfo\n * @param {refobject|boolean} treat treat marker with capture\n * @returns \n */\n    static DoReplaceWith(value, _formatter, replace_with, group, _marker, option, captures, treat = true) {\n        let g = group;\n        let _rp = replace_with; // \n        let m = '';\n        const { CaptureRenderer } = Utils.Classes;\n        const { listener } = option;\n        if (g) {\n            // ------------------------\n            // \n            //\n            m = Utils.ReplaceRegexGroup(_rp, g); // check for regex presentation\n            let check = m.replace(/(?<=(^|[^\\\\]))(\\(|\\))/g, ''); // remove capture brackets\n            // escape range \n            // ------------------------\n            // consider escape to check\n            //\n            let cp = new RegExp(m, 'd');\n            let _in = value.replace(value, check).replace(/\\\\\\\\/g, /\\\\0/);\n            // passing exec to formatt new value\n            let matches = cp.exec(_in);\n            const _tokens = option.tokenChains;\n            const _caps = captures || _formatter.getMarkerCaptures(_marker);\n            if (matches && _caps) {\n                g = CaptureRenderer.CreateFromGroup(matches, _tokens);\n                const _outdefine = {};\n                let out = g.render(listener, _caps, false, _tokens, option, _outdefine, treat);\n                if (typeof (treat) == 'object') {\n                    treat.segments = _outdefine;\n                }\n                return out;\n            }\n            check = check.replace(/\\\\(.)/g, '$1');\n            return check;\n\n        } else {\n            //treat:\n            _rp = _rp.substring(1).slice(0, -1)\n            if (_rp == '(?:)') {\n                _rp = '';// empty string\n            }\n            m = _rp.replace(/\\\\\\//g, \"/\");\n        }\n        value = value.replace(value, m);\n        return value;\n    }\n\n    /**\n     * Treat patterns values\n     * @param {string|{value:string, name:string}} value value to treat \n     * @param {*} patterns \n     * @param {*} group - parent group match to resolve\n     * @param {*} option - options\n     * @returns \n     */\n    static TreatPatternValue(value, patterns, group, option) {\n        const _formatter = option.formatter;\n        let _bckCapture = _formatter.info.captureGroup;\n        _formatter.info.captureGroup = group;\n        let name = null;\n        let _name = null;\n        let _value = null;\n        // extra name and value\n        if (typeof (value) == 'object') {\n            ({ value, name } = value);\n        } else {\n            _value = value;\n        }\n        _name = name;\n        _value = value;\n\n        const q = option;\n        if (_formatter.settings.useCurrentFormatterInstance) {\n            option.pushState();\n            // backup setting\n            let _bck = {\n                patterns: _formatter.patterns,\n                buffer: q.buffer,\n                output: q.output,\n                formatterBuffer: q.formatterBuffer,\n                lineCount: q.lineCount,\n                markerInfo: q.markerInfo.slice(0),\n                line: q.line,\n                pos: q.pos,\n                depth: q.depth,\n                tokenList: q.tokenList.slice(0),\n                markerDepth: q.markerDepth,\n                blockStarted: q.blockStarted,\n                appendToBufferListener: q.appendToBufferListener,\n                lastEmptyMarkerPattern: option.lastEmptyMarkerPattern\n            };\n            // clean setting\n\n            q.appendToBufferListener = null;\n            q.lineCount = 0;\n            q.depth = 0;\n            q.markerInfo.length = 0;\n            option.lineMatcher.save();\n            option.lineSegments.save();\n            option.lastEmptyMarkerPattern = null;\n            q.newBuffer('_subformat_buffer_');\n            _formatter.info.isSubFormatting++;\n            _formatter.patterns = patterns;\n\n            value = _formatter.format(_value, { name: _name });\n            _formatter.info.isSubFormatting--;\n            _formatter.patterns = _bck.patterns;\n            // + | restore setting\n            q.lineCount = _bck.lineCount;\n            option.lineMatcher.restore();\n            option.lineSegments.restore();\n            q.line = _bck.line;\n            q.depth = _bck.depth;\n\n            q.appendToBufferListener = _bck.appendToBufferListener;\n            q.restoreBuffer({ state: { formatterBuffer: _bck.formatterBuffer } });\n            _bck.markerInfo.forEach(a => q.markerInfo.push(a));\n            option.popState();\n            option.lastEmptyMarkerPattern = _bck.lastEmptyMarkerPattern;\n\n        } else {\n            // passing value to pattern \n            let n_formatter = Formatters.CreateFrom({ patterns: d.patterns });\n            value = n_formatter.format(value);\n        }\n        _formatter.info.captureGroup = _bckCapture;\n        return value;\n    }\n\n    /**\n     * \n     * @param {*} marker \n     * @param {*} _cap \n     * @param {*} group \n     * @param {*} tokenChains \n     * @param {*} option \n     * @returns {string|undefined}\n     */\n    static TreatCapture(marker, _cap, group, tokenChains, option) {\n        const { listener } = option;\n        const { CaptureRenderer } = Utils.Classes;\n        let _s = null;\n        if (Array.isArray(group) == false) {\n            if (group === null)\n                group = '';\n            const indices = [];\n            indices.push([0, group.length]);\n            group = [group];\n            group.indices = indices;\n        }\n        _s = CaptureRenderer.CreateFromGroup(group, marker.name);\n        if (_s) {\n            let _g = _s.render(listener, _cap, false, tokenChains, option);\n            return _g;\n        }\n    }\n    /**\n     * get next capture data\n     * @param {string} line \n     * @param {string} endRegex \n     * @param {*} option \n     * @returns \n     */\n    static GetNextCapture(line, endRegex, option) {\n        const { RegexUtils } = Utils.Classes;\n        let m = endRegex.toString();\n        m = m.substring(0, m.lastIndexOf('/') + 1).slice(1, -1);\n        m = RegexUtils.UnsetCapture(m);\n        let reg = new RegExp(m);\n        let _ret = reg.exec(line);\n        if (_ret) {\n            _ret.offset = _ret[0].length;\n        }\n        return _ret;\n    }\n\n    static JSONInitCaptureField(q) {\n        return (s, parser) => {\n            const _info_class = parser.captureInfoClassName || Utils.Classes.CaptureInfo;\n            let d = {};\n            for (let i in s) {\n                let m = new _info_class(q);\n                JSonParser._LoadData(parser, m, s[i]);\n                d[i] = m;\n                parser.initialize(m);\n            }\n            return d;\n        }\n    }\n    /**\n * \n * @param {*} patterns \n * @param {*} idx \n * @param {*} action \n * @returns \n */\n    static GetPatternsList(patterns, idx, action) {\n        switch (action) {\n            case 'next':\n                return patterns.slice(idx + 1);\n            case 'parent':\n                break;\n            case 'all':\n                return patterns.slice(0);\n            case 'exclude':\n                let r = patterns.slice(0);\n                delete (r[idx]);\n                return r;\n        }\n        return [];\n    }\n}\n\n\n\nexports.Utils = Utils;\n\n// + | extra const usage \nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");","\"use stricts\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterCloseParentInfo } = require(\"../lib/FormatterCloseParentInfo\");\nconst _utils = require(\"../lib/Utils\")\n \n\nconst { Patterns, CaptureInfo, Debug } = _utils.Utils.Classes;\n\nfunction InitLine(target, max_line_count) {\n    let _maxLine = (max_line_count + '').length;\n    let _style = 'display:inline-block; text-align:right; margin-right:4px; min-width: ' + _maxLine + 'em;';\n    let _lineCount = 0;\n    target.querySelectorAll('div.line').forEach(i => {\n        let n = document.createElement('div');\n        n.innerHTML = _lineCount + 1;\n        n.style = _style;\n        i.insertBefore(n, i.firstChild);\n        _lineCount++;\n    });\n}\n\nconst classDefinition = {\n    'comment':'comment',\n    'reserved-word':'rs-w',\n};\nfunction getClass(tokenID){\n    if (tokenID in classDefinition){\n        return classDefinition[tokenID];\n    }\n    return tokenID.toLowerCase();\n}\n\nclass ExtraFormatterCloseParentInfo extends FormatterCloseParentInfo{\n    className;\n    tokenID\n    getClass(){\n        return getClass(this.tokenID);\n    }\n}\nclass ExtraPattern extends Patterns{\n    className;\n    _initRef(a){\n        super._initRef(a);\n        if (!a.className && this.className){\n            a.className = this.className;\n        }\n    }\n}\nclass ExtraCapture extends CaptureInfo{\n    className\n    constructor(q){\n        super(q); \n    }\n}\nconst webStyleClass = {\n    patternClassName: ExtraPattern,\n    captureInfoClassName: ExtraCapture,\n    closeParentInfoClassName: ExtraFormatterCloseParentInfo\n};\n\n/**\n * webFormattingListener - \n * @param {*} _def \n * @returns \n */\nfunction webFormattingListener(_def) {\n    _def._maxLineCount = 0;\n    // + | define global map\n    _def.globalClassMap = {\n        'comment':1,\n        'constant':1,\n        'line':1,\n        'number':1,\n        'operator':1,\n        'reserver-word':1,\n        'string':1,\n        'symbol':1\n    };\n    return function () {\n        let blocks = [];\n        let sbuffer = false;\n        let _lineCount = 0;\n        let _self = this;\n        let _r_def = {\n            endOutput({lineFeed}){\n                return '';\n            },\n            endContent(){\n                return \"\";\n            },\n            appendConstant({_inf, update, data, patternInfo}){\n                if (data.trim().length == 0){\n                    if (patternInfo.isBlock && (patternInfo.childs.length==0))\n                    return;\n                } \n                update(); \n            }, \n            renderToken(v, tokens, tokenID, engine, debug, marker) {                \n                debug && Debug.log('renderToken', {value:v, tokenID, tokens: tokens.slice(0)})\n                if (v.length==0){\n                    return '';\n                }\n                let lt = tokens.shift();\n                let n = null;\n                let _clname = '';\n                let _map = {};\n                if (tokenID) {\n                    _map[tokenID] = 1;\n                    _def.globalClassMap[tokenID] = 1;\n                }\n                if (marker?.className){\n                    marker.className.split(' ').forEach(a=>{\n                       if(a.trim().length==0)return;\n                        _map[a]=1;\n                        if (!(a in _def.globalClassMap))\n                            _def.globalClassMap[a] = 2;\n                    });\n                }\n                if (/^symbol\\./.test(lt)) {\n                    v = v.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\n                    _map['s']=1;\n                    _map['symbol']=1; \n                }\n                if (/^constant\\.color/.test(lt)){\n                    v = \"<div class=\\\"inline-color\\\" style=\\\"display:inline-block; margin: 0 4px; background-color:\"+v+\"; width:8px; height:8px;\\\"></div>\"+v;\n                }\n                _clname = Object.keys(_map).join(' ');\n                if (_clname.length==0){\n                    return v;\n                }\n                    if (typeof(document) != 'undefined'){\n                    n = document.createElement('span');\n                    n.className = _clname;\n                    n.innerHTML = v;\n                    \n                    return n.outerHTML;\n                    } else {\n                        if (_clname.length>0){\n                            _clname = \" class=\\\"\"+_clname+\"\\\"\";\n                        }\n                        let sb = '<span'+_clname+'>'+v+'</span>';\n                        return sb;\n                    }  \n            },\n            newLine(){\n                console.log('bind:newLine');\n            },\n            appendExtraOutput({output}){ \n                // + | just push and extra value to join on render\n                output.push('');\n            },\n            treatOutput({output, lineFeed, tabStop}){\n                const l = [];\n\n                output.forEach((m)=>{\n                    m.split(\"\\n\").forEach(_l=>{\n                        //if (_l.length==0) return; // \n                        _l = \"<div class=\\\"line\\\">\"+_l;\n                        _l+= \"</div>\";\n                        l.push(_l);\n                        _def._maxLineCount++;\n                    });\n                });\n                return l.join(lineFeed).trimEnd();\n            },\n            output({ buffer, output, lineFeed, flush, _ctx }){    \n                let l = '';\n                //if (output.length>0)\n                    l =  output.join(lineFeed);\n\n                return l;\n            },\n            /**\n             * store what is in the buffer to output\n             * @param {*} param0 \n             */\n            store({ output, buffer, depth, tabStop, formatterBuffer }) {\n                \n                const store_buffer = function(buffer){\n                    if (buffer.length==0){\n                        return;\n                    }\n                    if (depth > 0) {\n                        buffer = '<span>' + (\"&nbsp;\".repeat(4)).repeat(depth) + '</span>' + buffer;\n                    } else { \n                        buffer = buffer; \n                    } \n                    output.push(buffer);\n                }\n                const r = [buffer]; \n                r.forEach(store_buffer); \n            },\n            startNewBlock(a) {\n                // start new block\n            }\n        };\n        Object.defineProperty(_def, 'bufferList', {get(){\n            return _buffers;\n        }});\n        return _r_def;\n    }\n}\nexports.webStyleClass = webStyleClass;\nexports.InitLine = InitLine;\nexports.webFormattingListener = webFormattingListener;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\"use strict\";\nconst { Formatters, Utils, Patterns } = require(\"./lib/Formatters\");\nObject.defineProperty(exports, '__esModule', {value:true});\n\nexports.Formatters = Formatters; \nexports.Patterns = Patterns; \nexports.CaptureInfo = Utils.Classes.CaptureInfo; \nexports.Utils = Utils; \nexports.Version = process.env.VERSION || '1.0.0'; \nexports.Web = (()=>{\n    const Utils = require (\"./web/Utils\")\n    return {\n        Utils\n    };\n})();"],"names":["root","factory","exports","module","define","amd","self","map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","defineProperty","value","BlockInfo","mode","Utils","CaptureInfo","name","tokenID","patterns","transform","comment","replaceWith","nextTrimWhiteSpace","captures","format","throwError","constructor","parent","this","get","json_parse","parser","fieldname","data","refKey","refObj","q","Patterns","RefPatterns","Classes","ArrayPatternsFromParser","_regex_parser","s","RegexParse","parse","n","d","apply","forEach","begin","end","match","replaceWithCondition","m","ReplaceWithCondition","JSonParser","_LoadData","TransformPropertyCallback","JSONInitCaptureField","matchTransform","fc","FormatterMatchTreatment","FormatterOptions","FormatterSyntaxException","CaptureRenderer","matches","roots","subcaptures","token","CreateFromGroup","_info","_t","length","indices","console","log","lp","range","_startIndex","rootgroup","_troot","_offset","chain_root","i","begin_root","idx","v","def_info","info_contains","start","index","childs","undefined","indexOf","_minfo","push","get_matche_token_info","_o","render","listener","tokens","option","outdefine","treat","debug","engine","_input","_begin","_output","_formatter","formatter","treat_root","refData","rf","rd","subchilds","output","sub","_end","shift","childrens","slice","unshift","croot","pop","cap","Array","isArray","nv","offset","_out","c","substring","dt","_treat_pattern","_op","Init","e_obj","CheckError","StoreTokens","treatMarkerValue","StringValueTransform","_bckTokens","tokenList","TreatPatternValue","renderToken","treat_constant","_keys","_Capkeys","_root_only","_ref_data","input","bufferSegment","dataSegment","j","rt","l","error","message","_error","RegExp","test","Debug","static","IsEnabled","msg","level","LogLevel","JSON","stringify","k","args","arguments","Enable","enable","bhtml","isAutoCloseTag","target","split","autoCloseTagValue","marker","_value","_lastData","_lastBuffer","_load_data","_cp","buffer","_captures","endCaptures","_is_closed","_close_tag","_is_auto_closed","_p","CreateEndMatch","tp","treatEndCaptures","RenderToBuffer","_isChildBlock","saveBuffer","appendExtraOutput","_rbuffer","flush","restoreSavedBuffer","join","Formatters","IsChildBlock","engines","Joiner","FormatterBuffer","m_output","m_bufferSegments","m_dataSegments","m_dataOutput","marked","InitMarkedSegment","isEmpty","bufferSegments","InitBufferMarkedSegment","CopyMarkedSegment","a","op","InitOpMarkedSegment","prepend","dataSegments","getContent","getData","joinSegments","JoinSegments","_bufferS","_dataS","sort","_OP","_call","tab","t","_marked","_idx","UpdateSegmentMarkerOperation","_g","appendToBuffer","appendToData","_joinWith","storeToBuffer","lastDefineStates","_buffer","_data","ClearSegments","ReduceBufferSegmentIndex","count","TS","_new_idx","FormatterSegmentJoin","updateData","clear","clearOutput","dataOutput","clearAll","trimEnd","segment","trimStart","trim","lastSegment","lastDataSegment","lastSegmentInfo","GetBufferMarkedOperation","FormatterSegmentInfo","replaceLastSegment","newValue","TreatMarkedSegments","bufferData","TrimBufferSegment","ReorderBufferSegment","elt","filter","FormatterBufferUtils","TreatValue","FormatterCloseParentInfo","type","FormatterDebugger","all","feature","DebugAll","DEBUG_ALL","Load","top_keys","r","ENGINES","REF","FormatterEndMissingEngine","Get","scopeName","FormatterEndMissingExpression","expression","load","group","_e","_ret","_args","Function","call","FormatterErrors","RegexUtils","FormatterLineMatcher","MATCHER_STATES","save","new_value","sourceLine","line","position","restore","def","startLine","subLine","nextLine","_np","reset","setPosition","check","regex","_has_movement","HasBackyardMovementCapture","_has_startLine","CheckRequestStartLine","exec","move","cp","_mark","new_s","FormatterLineSegment","super","m_states","mps","store","isCapturing","FormatterLintError","FormatterListener","m_lastToken","setLastMarker","appendLine","line_feed","_cbuffer","startNewBlock","formatterBuffer","tabStop","depth","endOutput","lineFeed","endContent","startBlock","_tab","repeat","FormatterToken","lastToken","FormatterMarkerInfo","state","oldBlockStart","blockStarted","useEntry","captureEntry","joinWith","prependExtra","storePrependExtra","toString","updateDataSegments","ic","_new_id","_marker","entry","_endRegex","isBlock","m_currentMode","set","_marker_info","_content","_isNew","oldValue","saveState","currentBufferContent","source","treatment","PatternMatchInfo","lineCount","lineOffset","continue","lineJoin","skipTreatEnd","skipTreatWhile","markerDepth","loopInfo","lastMarker","sourceOption","EOF","EOL","TOEND","lineFeedFlag","stream","newOldBuffers","holdBufferState","glueValue","skipEmptyMatchValue","skipUpdateStartLine","skipMarkerFlag","nextMode","skipEndOfLine","startReading","matchTransformFlag","lastEmptyMarkerPattern","nextGlueValue","lineSegments","pushConditionalContainer","conditionalContainer","isBlockConditionalContainer","popConditionalContainer","isConditionalBlockStart","topConditionalBlockContainer","_formatterBuffer","_listener","m_constants_def","_rg","c_lineMatcher","c_conditionalContainer","info","m_isCapturing","m_depth","_blockStarted","_bufferState","_markerInfo","_states","m_appendToBufferListener","_outputBufferInfo","updateLine","updateRange","m_saveCount","m_formatterListener","empty","is_emptyObj","_renderCaptures","callback","_bck","resetRange","storeRange","isRootFormatterBuffer","formatter_buffer","pos","_tokens","getTokens","concat","getLineRangeContent","unshiftMarker","shiftMarker","pushState","_state","_i","getOwnPropertyDescriptor","popState","updateBufferValue","joinBuffer","noSpaceJoin","raise","_def_value","treatValueBeforeStoreToBuffer","markedInfo","_storeBuffer","onAppendToBuffer","useGlue","_cm_value","isGlueValue","tokenChains","isSpecialMarker","shiftIdConstant","_shiftMarkerInfo","isShiftenName","fromGroup","getTokenID","treatBeginCaptures","patternInfo","_outdefine","_cap","BeginCaptures","_s","startOutput","markerInfo","endMatch","fc_handle_end","endOuput","treatCaptures","list","markers","prop","pushError","NameOnlyConstantPattern","moveTo","newPosition","newOffset","lineMatcher","restoreBuffer","newBuffer","_ctx","refdata","buffers","settings","treatAndFormat","sourcePattern","_cpos","streamFormatter","_gbuffer","loopStart","matcher","sourceOffset","transformMarker","_resetFlags","cleanNewOldBuffers","tq","bf","setSourceLine","onBeginEndFound","_old","onBeginWhileFound","shiftAndRestoreFrom","from","shiftFromMarkerInfo","_rdata","startLineReading","storeAndUpdateBuffer","getBufferContent","_cm","peekFirstMarkerInfo","storeToOutput","useDepth","peekMarkerInfo","AppendExtraLiveOutput","flushAndData","_refData","bufferSegmentState","bufferState","constantPattern","_c","constantName","constants","refConstantClass","GlobalConstant","FormatterPatternException","pattern","isMarked","UpdateSegmentData","segments","joiner","_length","_d","element","_ts","FormattingCodeStyles","FormattingBase","TransformEngine","FormatterSetting","blockOnSingleLine","codingStyle","K_R","useIndent","instructionSeparator","useCurrentFormatterInstance","transformEngine","endMatchLogic","Support","CreateEngine","getCodingStyleFormatting","Factory","isInstructionSeperator","ch","g","SpecialMeaningPatternBase","FormattingMode","FormatterStreamBuffer","initialMode","startPosition","started","closed","endFoundListener","sourceMarkerInfo","sourceTokenList","matchType","m_saved","saved","formatting","joinStreamBuffer","prototype","newLineContinueState","throwErrorOnEndSyntax","isEndCaptureOnly","isWhileCaptureOnly","isBeginCaptureOnly","endRegex","stopAndExitStream","_restoreState","_line","ret","bck","_onEndHandler","moveToNextPattern","handleMarkerListener","_restored","_topStreamRemoved","_restoreSavedBuffer","_nbuffer","appendToBufferListener","_restoreBackupState","parentMode","FM_APPEND","_matcher","detectPatternInfo","_def","endFound","HandleStreamEndFound","_stream_old","_updateMarkerOldContentOrSwapBuffer","handleMatchLogic","handleConstant","skipFormat","next_position","_tline","hostPatterns","streamAction","_patterns","GetPatternsList","GetPatternMatcherInfoFromLine","_rindex","_append","StreamLineConstant","_nextCapture","_next_position","GetNextCapture","_sline","_gline","GetBufferedLine","StreamBufferConstant","_src_line","_group","streamCaptures","TreatCapture","At","isRendered","NativeRegExp","HandleFormatting","formattingSetupPatternForBuffer","sm_globalEngine","sm_engine_formatter","lintErrors","repository","injectionSelector","foldingStartMarker","foldingStopMarker","fileTypes","uuid","firstLineMatch","EngineFormatter","GlobalEngine","EndListenerArguments","objClass","m_listener","m_objClass","m_info","isSubFormatting","captureGroup","m_errors","_storeObjClass","_skip","blockStart","m_option","json_keys","json_validate","field_name","throw_on_error","validator","f","_pattern_class","patternClassName","_lints","lint","parseInt","fix","concept","registry","initialize","repositoryKey","pattern_class_name","CreateFrom","_names","_registryExpression","Save","JSonParseData","registerName","_funcRegistryExpression","_entry","DefineProp","namespaces","Restore","CreateDefaultOption","PrevLineFeedConstant","PrevLineFeedConstantPattern","PrevConstant","PrevConstantPattern","GlobalConstantPattern","StreamLineConstantPattern","StreamBufferConstantPattern","TrimmedPrevLineFeedConstant","RefConstantPattern","transformTo","_initDebug","_matcherInfo","_trimStart","_trimEndOutput","trimmed","endsWith","_output_fc","_update_start_line_flag","_start_line_flag","_l","_is_sub_formatting","_nextLineOffset","skip_r","allowMultiline","_handleMarker","_nextLine","_nextPosOffset","ln","_updateLineFeed","_lastPost","GetPatternMatcher","p","isCaptureToEndLine","_handleCheckCloseMarker","_updateMarkerFormatting","updateEndLineUpdateMode","_formatting","_handleLastExpectedBlock","treatOutput","complete","isStreamCapture","_startStreamingPattern","_handleSameGroupMatch","_checkStartBlockDefinition","force","formattingMode","formatBufferMarker","_updateNextMode","updateBuffedValueAsToken","_lastExpectedMatchResult","endMissingValue","_cvalue","ReplaceRegexGroup","RegExToString","content","replace","onLastExpectedBlockStart","onLastExpectedBlock","_handleFoundEndPattern","_ln","_isBlockAndStart","_startBlock","getMarkerCaptures","beginCaptures","_registerTokenName","_updatePrevPatternPrevConstant","_updatePatternPrevConstant","handle","_handleCallback","_updateFormatModeFromTo","_operationReplaceWith","_refObj","replaced","_rpw","_cond","operator","_ex","DoReplaceWith","tvalue","ReplaceWithCheck","handleBeginEndMarker","_handleBeginEndMarker","handleMatchMarker","_handleMatchMarker","handleBeginWhile","_handleBeginWhile","handleMatchTransform","_handleMatchTransform","_onStartMarker","onStartHandler","onEndHandler","isShiftenContentName","_shiftPatternContentName","UnshiftTokens","_treatMatchValue","_ref_segment","_getMatchGroup","treated","_treatMatchResult","_treatTransform","_tmatch","transformMatch","transformCaptures","_operateOnFramebuffer","_handleToEndPattern","_treat","startLineTransform","treatEndMarkerValue","_appendConstant","append_child","constant_type_marker","_fempty","_def_type","treatConstantValue","_inf","use","fc_update","updateBufferConstant","appendConstant","update","end_line","_nextOffset","_createStreamConstantPattern","_startLine","_start_block","isBlockStarted","blockStartInfo","_oldMarker","_updateStreamRangeModeToHolder","oldStartStreamingBlock","select","_updateOldMarkerContent","_endpos","_bool","_constant_line","_handleInstructionSeperatorProperty","isInstructionSeparator","b","_handleMatchCaptureDefinition","allowEmptySpace","isMatchCaptureOnly","onEndInstruction","endGroup","_closeBlockEntry","closeParentData","closeParent","_closeMarker","appendJoinToBuffer","JoinMarkerPattern","_storeToBuffer","UpdateMarkedSegment","_storeMatchValueHandler","_extra","_skip_value","_is_join","_store_to_buffer","_updateJoinWith","storeValue","_handleChainHandler","_chains_match","_e_args","_handle","_fc","_target","_cparent","_extra_args","udpateChild","_updateMarkerChild","_updateOldEntryCapture","EntryCapturePattern","_checkParentInfo","_endCaptureCallback","_handle_EOL","_invokeCheckParent","_handleStopMarker","_justCloseMarker","_fake_empty","_option_glue","skipGlueOnLineEnd","isEOL","_handleCheckParentInfo","_handleCloseParentProperty","updateMatchNextFormatting","_told","_lbuffer","contentName","_unshiftPatternContentName","_updateBlockMarkerPropertyContent","_entryBuffer","entryBuffer","_new_v","startsWith","_count","_initUpdatedisBlockStartInformation","_initBlockStarting","isFormattingStartBlockElement","_start","_startOutput","_fstartOutput","_updateParentProps","_mode","updateStartFormatting","startData","_eol","_nextPos","Math","max","_close_data","_pos","_handleItemFoundCallback","isStartOnly","HandleSameGroup","_closeMarkerByStop","_parentNextMode","parentMatcherInfo","_call_update_regex","sourceRegex","RegexToStringRegex","RemoveCaptureAndLeaveMovementCapture","_pline","checkMoveEndRegex","_prev","requestParentBlockCondition","_isEmptyRequestBlock","condition","_updateBuffer","_trimOutput","_skipOffset","newLine","isAutoBlockElement","arg","_requestUpdateChild","_gparent","_closeMarkerAndUpdate","_parent","_r","updateEmptySkipMatchedValueFormatting","closeMarker","_type","TypeMarkerInfoPattern","registryClassName","_isSkipTreatEnd","fromChild","_closeNonCaptureBlock","_resolvFoundData","c_data","_next_offset","_b","updatePreprendExtra","extra","_saved","_empty","__b","_close_block","onEndUpdateBuffer","min","handleEndFormattingBeforeStore","handleEndFormattingOnNonStartBlockElement","handleEndOnNonBlockElement","_nextBuffer","updateParentProps","_updatePreservedBlockBuffer","updateEndBlockAfterRestoringBuffer","_buffState","updateNextSavedMode","fallbackMarker","_parentInfo","_up","_endFound","to","updateGlobalFormatting","_nextPosition","_bckLine","_bckLineOffset","_end_non_capture","_ret_marker","_offsetPosition","_is_match","_tcline","_toffset","_supportCapture","_empty_capture","HasMovementCapture","_tchilds","child","_block","_backupMarkerSwapBuffer","_restoreBuffer","_u_content","isCaptureOnly","currentMode","appendMode","autoStartLine","_buffer_data","isEntryContent","_joinwith","props","updateOldMarkerContent","_handleSameGroup2","_list","updatedProperties","_checkUpdatedStartBlockProperties","detectConstantPattern","_nPatternInfo","_createStreamBuffer","_stream_buffer","init","startBlockDefinition","_newOld","itemFound","_continue_with_marker","append","appendBufferAndLine","sb","isSpecial","SystemConstantPattern","GetMarkedInfo","markedSegment","SYSTEM_MATCH_TYPE","_mkeys","_diff","PatterMatchErrorInfo","PSR_2","PSR_21","PSR_12","ALLMAN","GetSupportedValues","CODE_STYLE_FORMATTERS","trimConstant","_option","FM_START_LINE","FM_END_BLOCK","FM_START_BLOCK","FM_END_INSTRUCTION","FM_START_LINE_APPEND","updataMarkerGlobalOption","FM_START_LINE_NEXT_LINE","FM_APPEND_BLOCK","PatternFormattingMode","PFM_APPEND_THEN_LINE_FEED","_gformatting","PFM_LINE_FEED","updateMergeEndBlock","_hasBuffer","_hasExtra","_buffer_is_empty","_updateFormatterBufferSegments","_ld","_props","_append_next_mode","_updateLd","_updateSegment","_updateBufferedData","_treat_buffer_data","_treat_buffer_data_fc","formattingOptions","trimmedContainer","_flushData","_treatOldMarkerContent","FM_APPEND_TO_NEXT","FM_END_LINE","onAppendBlock","_updateGlobalMarkerOptionDefinition","extraOutput","isLineFeed","canChangeNextFormatting","handleEndFound","cname","Library2","Library","globalThis","handleEndBlockBuffer","_sbuffer","marker_info","_lf","_build_lf","onHandleSingleLineBuffer","_mark_buffer","_next_old","_parentMarker","_prepend","formattingPrependExtra","_prepend_value","_emode","isStartLine","updateBlockMarkerPropertyMode","old","isCurrentFormatterBufferIsRootBuffer","_cf","handleBufferingNextToSbuffer","formatJoinFirstEntry","formatHandleExtraOutput","KAndRFormatting","PFM_LINE_JOIN_END","PFM_LINE_JOIN","PFM_STREAMING","PFM_LINE_FEED_IF_IS_UPDATED_BLOCK","StreamActions","PARENT","NEXT","ALLOW_WHITE_SPACE","mergeEndBlock","sd","_bbuffer","_bdata","_clean","_c_mode","isUpdatedBlock","update_line_feed","throwOnError","captureInfoClassName","current","m_current","obj","_throwOnError","validation","json_parsing","globalRegExp","NATIVE_EXEC","_fn","NATIVE_TEST","PatternFormattingOptions","trimContainer","formattingBlockListener","isMarkedSegments","isTrimmedSegment","CheckRequestEndLine","m_parent","m_marker","m_endRegex","m_group","m_line","m_isBlock","m_lineFeed","m_startOutput","m_endOutput","m_updatedProperties","m_isBlockStared","m_bufferMode","m_patterns","m_fromGroup","m_index","m_state","types","is","_keys_t","writable","isPatternsOnly","RegexEngine","lintError","cardinality","while","whileCaptures","emptyBlockCondition","preserveLineFeed","beginFormattingMode","applyEndPatternLast","debugName","skip","m_startOnly","IsSkipped","RegexParser","_capture_parser","_gcl","closeParentInfoClassName","SKIP_REGEX","_rt","$ref","objOrBool","_while","IsCapturedOnlyRegex","_initRef","getEntryRegex","GetMatchInfo","_match","_a","matchRegex","lastIndexOf","flag","GetRegexFrom","endWhile","class_type","_reg","_store","_clear","_changeType","_regex","_flag","ind","moption","inf","RegexInfo","_ss","_is_extended","lit","_gt","_pre_exec","_ms","ReadBrank","_engine","_q","_gret","_index","CAPTURE_MOVEMENT","CAPTURE_NOT_AHEAD_BACKYARD","CAPTURE_LEAVE_AHEAD_BACKYARD","is_empty","RemoveNotAheadBackyardGroup","str","RemoveCapture","_TreatCaptureGroup","beginOnly","_potion","sp","groups","active","disable","reg","Stringify","rm_brank","start_index","escaped","capture","_stpos","UnsetCapture","JSonParse","string_test","JSonValidate","_REGISTRY","Register","func_or_class_name","CleareRegistry","Create","_tlist","_dir","_top","_trim","isTrimmed","_ni","_buff","ri","EndCaptures","JSON_REGEX_PARSER","_cm_data","DefineProperties","FunctionDefineArg","globalname","result","window","_last","reverse","ArrayParser","class_name","includes","LoadData","refkey_class_name","include","_extends","extends","_key","CheckSkip","_flags","conditionBlockStart","_SkipLine","_from","_position","_tloop","ref","_m_patterns","_mpatterns","item_index","hasParent","isRef","detectOn","isFromGroupRef","InitPatternMatchInfo","gp","RegexParseInfo","_func","captialize","tb","charAt","toUpperCase","toLowerCase","joinSpace","upperCase","lowerCase","rtrim","ltrim","padEnd","padStart","floor","replace_with","_rp","_in","_caps","out","_bckCapture","_name","_info_class","action","_utils","classDefinition","webStyleClass","className","getClass","InitLine","max_line_count","_style","_lineCount","querySelectorAll","document","createElement","innerHTML","style","insertBefore","firstChild","webFormattingListener","_maxLineCount","globalClassMap","_r_def","lt","_clname","_map","outerHTML","_buffers","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","hasOwnProperty","Version","Web"],"sourceRoot":""}