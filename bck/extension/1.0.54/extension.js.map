{"version":3,"file":"1.0.54/extension.js","mappings":"wCAEA,IAAIA,EAAgB,EAAQ,MACxBC,EAAgB,EAAQ,MACxBC,EAAgB,EAAQ,KAE5BC,EAAOC,QAAU,SAAUC,EAAMC,GAChC,IAAIC,EAAS,GAIb,OAHAF,EAAOJ,EAAcI,GACrBL,EAAOM,GACPJ,EAAMG,GAAM,SAAUG,GAAQD,GAAUD,EAAME,IAASA,CAAM,IACtDD,CACR,C,6BCVA,IAmBIE,EAnBAC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,KACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MAEzBC,EAAiBF,EAAIE,KACrBC,EAAiBC,MAAMC,UAAUF,KACjCG,EAAiBC,OAAOD,eACxBE,EAAiBC,KAAKD,IACtBE,EAAiBD,KAAKC,IACtBC,EAAiBf,EAAa,MAAO,OACrCgB,EAAsC,UAArBC,QAAQC,SAAuB,EAAQ,MAAuB,KAO/EC,EAAWjB,GAAQ,SAAUkB,EAAOC,GACvC,OAAOX,EAAef,IAAS,gBAAiBC,EAAEC,EAAO,CAAC,EAAGuB,EAAME,cAAeD,IACnF,IAEIE,EAAQZ,OAAOa,OAClBC,SAAShB,UACTZ,EACCE,EAAIO,GAAM,SAAUe,GACnB,OAAOzB,EAAE8B,IAAG,WAAc,OAAOP,EAASQ,KAAMN,EAAM,GACvD,IACAlB,EAAe,CAEdyB,MAAOhC,GAAE,SAAUiC,GAElB,OADAA,EAAOC,MAAMD,GAAQ,IAAMf,EAAIF,EAAIiB,EAAM,GAAI,KACtCnB,EACNf,IAAS,gBACTC,EACCC,EAAO,CAAC,EAAG8B,KAAKL,cAAe,CAC9BS,IAAK,CAACf,EAAaA,EAAWa,GAAQ,QAAUA,EAAM,OAI1D,IACAG,QAASpC,GAAE,SAAUiC,GAEpB,OADAA,EAAOC,MAAMD,GAAQ,IAAMf,EAAIF,EAAIiB,EAAM,GAAI,KACtCnB,EACNf,IAAS,gBACTC,EACCC,EAAO,CAAC,EAAG8B,KAAKL,cAAe,CAC9BW,IAAK,CAACjB,EAAaA,EAAWa,GAAQ,GAAK,QAAUA,EAAM,OAI/D,QAKCK,EAAWhC,GAAQ,SAAU2B,GAAQ,OAAO,IAAIM,OAAO,OAAYN,EAAO,IAAK,IAAM,GAAG,CAC3FO,WAAW,IAGZzC,EAAQ,WACP,OAAOM,GACN,SAASoC,IACR,IAAIC,EAAQ,GACRC,EAAM,GACNC,EAAMjC,EAAKkC,KAAKC,UAAW,KAC3BC,EAAON,EAAKf,cACZsB,EAAUxC,EAAIyC,OAAOL,GAazB,OAZA1C,EACC6C,GACA,SAAUtB,EAAKyB,GACdP,EAAMnC,EAAIiB,EAAI,IAAMkB,EACpBD,GAASlC,EAAIiB,EAAI,IACbuB,IACHJ,EAAMA,EAAIO,QAAQb,EAASb,EAAI,IAAKN,EAAa+B,GAAO1C,EAAIiB,EAAI,IAAM,IAExE,GACA,MACA,GAEIhB,EAAc2C,mBACZV,EAAQE,EAAMD,EADyBC,CAE/C,GACAjB,EAEF,EAEAlC,EAAOC,QAAUqB,OAAOsC,iBAAiBtD,IAAS,CACjDuD,eAAgBtD,GAAGoB,GACnBM,cAAe1B,EAAE,GAAI,CAAC,I,wBC/FvBP,EAAOC,QAAU,G,8BCAjB,IAAI6D,EAAoB,EAAQ,KAC5BC,EAAoB,EAAQ,MAC5BC,EAAoB,EAAQ,MAC5BC,EAAoB,EAAQ,MAC5BnE,EAAoB,EAAQ,MAC5BoE,EAAoB,EAAQ,MAC5BC,EAAoB,EAAQ,MAE5BC,EAAOjD,MAAMC,UAAUgD,KAE3BpE,EAAOC,QAAU,SAAUoE,GAC1B,IAAIC,EAAUhD,OAAO+B,UAAU,IAC3BkB,EAAW,GACXC,EAAcF,EAAQG,SAAW,GACjCC,EAAO,GAcX,OAZAX,EAAKC,EAASK,IAAY,SAAUM,GACnC,IAAIC,EAAU,CAAC,IACfb,EAAKC,EAASW,IAAM,SAAUE,EAASC,GAEtC,IADA,IAAIC,EAAWjF,EAAc+E,GAASG,MAAM,MACrCD,EAASE,OAASL,EAAQK,QAAQL,EAAQR,KAAKN,EAASgB,EAAa,KAC5EC,EAAStE,SAAQ,SAAUyE,EAASC,GACnCP,EAAQO,GAAaL,GAAeI,CACrC,GACD,IACAd,EAAKgB,MAAMV,EAAME,EAClB,IAGCF,EACEhE,KAAI,SAAUiE,GACd,OAAOZ,EAAKC,EAASW,IAAM,SAAUU,EAAKC,GACzC,IAA2BC,EAAvBC,EAAMjB,EAASe,GAKnB,OAJKE,IAAKA,EAAMjB,EAASe,GAAS,CAAEG,MAAO,IAC3CJ,EAAMvF,EAAcuF,IACpBE,EAAYpB,EAAkBkB,IACdG,EAAIC,QAAOD,EAAIC,MAAQF,GAChC,CAAEF,IAAKA,EAAKJ,OAAQM,EAC5B,GACD,IACC7E,KAAI,SAAUiE,GACd,OAAOA,EACLjE,KAAI,SAAUgF,EAAMJ,GACpB,IAAIK,EAAKC,EAAgBC,EAAarB,GAAeA,EAAYc,GAGjE,OAFAM,EAAQC,GAAmC,UAArBA,EAAWD,MAAoB,QAAU,OAC/DD,EAAMzB,EAAOd,KAAK,IAAKmB,EAASe,GAAOG,MAAQC,EAAKT,QACtC,SAAVW,EAAyBF,EAAKL,IAAMM,EACjCA,EAAMD,EAAKL,GACnB,IACCnE,KAAK+C,EAAQK,EAAQwB,KAAOxB,EAAQwB,IAAM,MAC7C,IACC5E,KAAK,MAAQ,IAEjB,C,wBCrDAlB,EAAOC,QAAU,CAChB8F,OAAQ,OACRC,WAAY,OACZC,YAAa,MACbC,KAAM,OACNC,SAAU,OACVC,UAAW,M,8BCFZ,IAAIC,EAAQ,EAAQ,MAEpBrG,EAAOC,QAAU,SAAUoF,GAAO,OAAOgB,EAAMhB,GAAKJ,MAAQ,C,6BCN5D,IAAI1E,EAAI,EAAQ,MAEhBP,EAAOC,QAAUqB,OAAOsC,iBAAiB,EAAQ,KAAW,CAC3D0C,WAAY/F,EAAE,EAAQ,OACtBgG,MAAOhG,EAAE,EAAQ,OACjBiG,KAAMjG,EAAE,EAAQ,OAChBkG,KAAMlG,EAAE,EAAQ,OAChBkE,QAASlE,EAAE,EAAQ,OACnB8F,MAAO9F,EAAE,EAAQ,OACjB4D,kBAAmB5D,EAAE,EAAQ,OAC7BmG,MAAOnG,EAAE,EAAQ,OACjBoG,SAAUpG,EAAE,EAAQ,OACpBqG,MAAOrG,EAAE,EAAQ,OACjBsG,IAAKtG,EAAE,EAAQ,O,8BCVhB,IAAIC,EAAe,EAAQ,MACvBsG,EAAe,EAAQ,KACvBC,EAAe,EAAQ,MACvBC,EAAe,EAAQ,MACvBC,EAAe,EAAQ,MACvBC,EAAe,EAAQ,MAEvBC,EAAM,KAENpG,EAAM,SAAUyB,GAAQ,OAAO2E,EAAM3E,EAAO,GAAK,EAErDzB,EAAIoG,IAAMA,EAEV,IAAIlG,EAAOT,EACV,CAEC4G,KAAM,CAAEC,MAAO,CAAC,EAAG,KACnBC,OAAQ,CAAEC,QAAS,CAAC,EAAG,KACvBC,UAAW,CAAEC,WAAY,CAAC,EAAG,KAC7BC,MAAO,CAAEC,OAAQ,CAAC,EAAG,KACrBC,QAAS,CAAEC,SAAU,CAAC,EAAG,KACzBC,OAAQ,CAAEC,QAAS,CAAC,EAAG,MAIxB,CAAC,QAAS,MAAO,QAAS,SAAU,OAAQ,UAAW,OAAQ,SAASC,QAAO,SAC9EC,EACAC,EACA5C,GAUA,OAPA2C,EAAIC,GAAS,CAAExF,IAAK,CAAC,GAAK4C,EAAO,KACjC2C,EAAIC,EAAQ,UAAY,CAAExF,IAAK,CAAC,GAAK4C,EAAO,KAG5C2C,EAAI,KAAOC,EAAM,GAAGC,cAAgBD,EAAMxB,MAAM,IAAM,CAAE9D,IAAK,CAAC,GAAK0C,EAAO,KAC1E2C,EAAI,KAAOC,EAAM,GAAGC,cAAgBD,EAAMxB,MAAM,GAAK,UAAY,CAAE9D,IAAK,CAAC,IAAM0C,EAAO,KAE/E2C,CACR,GAAG,CAAC,IAGLlH,EAAIE,KAAOA,EAEXF,EAAIqH,QAAU,CAAC,EACfrH,EAAIsH,QAAU,CAAC,EAEftB,EAAO9F,GAAM,SAAUe,GACtB,IAAIsG,EAAUtG,EAAIgF,EAAQhF,IAE1BjB,EAAIqH,QAAQE,EAAQ,IAAMA,EAC1BvH,EAAIsH,QAAQC,EAAQ,IAAMA,CAC3B,IAEAvH,EAAIwH,UAAY,SAAUC,EAAYhG,GAAQgG,EAAWpE,KAAKrD,EAAIqH,QAAQ5F,GAAQ,EAElFzB,EAAI0H,WAAa,SAAUD,EAAYhG,GACtCyE,EAAa7D,KAAKoF,GAAY,SAAUF,EAAShD,GAC5CgD,EAAQ,KAAO9F,GAClBgG,EAAWE,OAAOpD,EAAO,EAE3B,GACD,EAGAvE,EAAI4H,QAAU,SAAUC,GACvB,OAAOA,EAAYlI,KAAI,SAAU4H,GAAW,OAAOvH,EAAIuH,EAAQ,GAAK,GACrE,EAGAvH,EAAI8H,SAAW,SAAUL,EAAYM,GAWpC,OAVAA,EAAYrI,SAAQ,SAAU+B,GAAQzB,EAAI0H,WAAWD,EAAYhG,EAAO,IAKxEgG,GAFAA,EAAaA,EAAWO,WAEArI,KAAI,SAAU4H,GAAW,OAAOA,EAAQ,EAAI,KAGpEE,EAAatB,EAAK9D,KAAKoF,IAEL9H,IAAIK,EACvB,EAIAA,EAAIyC,OAFS,SAAU6B,GAAO,OAAOyB,EAAS1D,KAAKiC,EAAK8B,EAAM,EAU9DpG,EAAIiI,YANc,SAAUC,GAC3B,IAAIzG,EAAOyG,EAAIvC,MAAM,GAAI,GAEzB,OADOwC,OAAO1G,EAEf,EAIAxC,EAAOC,QAAUc,C,wBClGjB,IAAIoI,EAAQ,KAcZnJ,EAAOC,QAAU,CAChBmJ,YAZiB,WAAcD,GAAQ,CAAM,EAa7CE,aAVkB,WAAcF,GAAQ,CAAO,EAW/CG,kBARuB,WAAcH,EAAQ,IAAM,EASnDxF,iBANsB,WAAc,OAAiB,OAAVwF,GAAkBvH,QAAQ2H,IAAIC,SAAWL,CAAO,E,wBCb5FnJ,EAAOC,QAAU,CAChB,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAAU,SAChF,SAAU,SAAU,SAAU,S,8BC7B/B,IAGIwJ,EACAC,EACAtJ,EACAuJ,EANAvF,EAAOjD,MAAMC,UAAUgD,KACvB4D,EAAS7G,MAAMC,UAAU4G,OACzB4B,EAAMpI,KAAKoI,IAmBf,IAbAH,EAAS,aAA8B,SAAUvB,GAChD,MAAO,CACN2B,EAAGC,SAAS5B,EAAMxB,MAAM,EAAG,GAAI,IAC/BqD,EAAGD,SAAS5B,EAAMxB,MAAM,EAAG,GAAI,IAC/BsD,EAAGF,SAAS5B,EAAMxB,MAAM,GAAI,IAE9B,IAEAgD,EAAQD,EAAO/C,MAAM,EAAG,IAExB1G,EAAOC,QAAUG,EAAS,GAE1BuJ,EAAI,EACGA,EAAI,GACVvJ,EAAOgE,KAAK,GAAKuF,KAGlB,IADAA,EAAI,EACGA,EAAI,GACVvJ,EAAOgE,KAAK,GAAKuF,KAElBvF,EAAKgB,MACJhF,EACAqJ,EAAO/C,MAAM,IAAIhG,KAAI,SAAUuJ,GAC9B,IAAI3E,EAAO4E,EAAOC,IAgBlB,OAfAT,EAAMU,OAAM,SAAUC,EAAYC,GACjC,IAAIC,EAAQvC,EAAO5E,KAClB,OACA,SAAUoH,EAAaC,GAEtB,OADAD,EAAeZ,EAAIS,EAAWI,GAAWR,EAAKQ,GAE/C,GACA,GAMD,OAJIF,EAAQL,IACX5E,EAAQgF,EACRJ,EAAOK,GAEDA,CACR,IACOnK,EAAOkF,EACf,I,8BChDD,IAGIoF,EAAIC,EAAMC,EAAOC,EAHjBtK,EAAQ,EAAQ,MAChBuK,EAAQ,EAAQ,MAEOlB,EAAMpI,KAAKoI,IAAKmB,EAAQvJ,KAAKuJ,MAAOxJ,EAAMC,KAAKD,IAEtEyJ,EAAU,SAAUC,GACvB,OAAO,SAAUC,GAEhB,OADAA,EAAMzI,MAAMyI,GAAO,EAAI3J,EAAIwJ,EAAMG,GAAM,IAC1B,KAAUA,EAAMD,EAAU,EACxC,CACD,EAEAjL,EAAOC,QAAUqB,OAAOsC,kBACvB,SAAUuH,EAAGC,GAGZ,OAFAD,EAAI1I,MAAM0I,GAAK,EAAIJ,EAAMI,GACzBC,EAAI3I,MAAM2I,GAAK,EAAIL,EAAMK,IACjBD,EAAI,EAAIP,EAAMO,GAAKN,GAAMM,KAAOC,EAAI,EAAIT,EAAKS,GAAKV,GAAIU,GAC/D,GACA,CACCV,GAAInK,EAAGmK,EAAKM,EAAQ,MACpBL,KAAMpK,EAAGoK,EAAOK,EAAQ,MACxBJ,MAAOrK,EAAGqK,EAAQI,EAAQ,MAC1BH,KAAMtK,EAAGsK,EAAOG,EAAQ,MACxBK,GAAI9K,GAAE,SAAU4K,EAAGC,GAGlB,OAFAD,EAAI1I,MAAM0I,GAAK,EAAI5J,EAAIwJ,EAAMI,GAAI,GAAK,EAE/B,MADPC,EAAI3I,MAAM2I,GAAK,EAAI7J,EAAIwJ,EAAMK,GAAI,GAAK,GACjB,IAAMD,EAAI,GAChC,IACAG,MAAO/K,GAAE,SAAUgL,GAClB,IAAIC,EAIJ,OAFAA,GADAD,EAAIT,EAAMS,IAAM,IACL,EAAI,IAAM,IAEd,MADPA,EAAIR,EAAMnB,EAAI2B,KACOC,EAAM,MAC5B,IACAC,IAAKlL,EAAE,WACPmL,OAAQnL,EAAE,WACVoL,UAAWpL,EAAE,WACbqL,QAASrL,EAAE,Y,wBCtCbP,EAAOC,QAAU,WAIhB,OAAO,IAAI6C,OACV,wLAKA,IAEF,C,wBCZA9C,EAAOC,QAAU,Y,8BCEjB,IAAI4L,EAAgB,EAAQ,MACxB/L,EAAgB,EAAQ,MACxBmF,EAAgB,EAAQ,MACxBlE,EAAgB,EAAQ,MACxBQ,EAAgBC,KAAKD,IAErBuK,EAAQ,SAAUC,GAASzJ,KAAKyJ,MAAQA,CAAO,EAE/CC,EAAW,SAAU3G,GACxB,IAAIqE,EAAQmC,IAASI,KAAK5G,GAE1B,IAAKqE,EACJ,MAAO,CAACrE,GAGT,IAAyB6G,EAAMC,EAASC,EAApC9G,EAAQoE,EAAMpE,MAElB,OAAc,IAAVA,GACH4G,EAAOxC,EAAM,GACb0C,EAAO/G,EAAIqB,MAAMwF,EAAKjH,QAEf,CAAC,IAAI6G,EAAMI,IAAOG,OAAOL,EAASI,MAG1CD,EAAU9G,EAAIqB,MAAM,EAAGpB,GACvB4G,EAAOxC,EAAM,GACb0C,EAAO/G,EAAIqB,MAAMpB,EAAQ4G,EAAKjH,QAEvB,CAACkH,EAAS,IAAIL,EAAMI,IAAOG,OAAOL,EAASI,IACnD,EA+EApM,EAAOC,QAAU,SAAUoF,GAC1B,IAAIiH,EAA+DC,EAA1DC,EAAQtD,OAAO7F,UAAU,IAAKH,EAAMgG,OAAO7F,UAAU,IAoB9D,OAlBAgC,EAAMvF,EAAcuF,GACpBkH,EAAMtH,EAAOI,GAET5C,MAAM+J,KACTA,EAAQ,GAEL/J,MAAMS,KACTA,EAAMqJ,GAEHC,EAAQ,IACXA,EAAQjL,EAAIgL,EAAMC,EAAO,IAEtBtJ,EAAM,IACTA,EAAM3B,EAAIgL,EAAMrJ,EAAK,IAItBoJ,EAxFc,SAAUA,EAAKE,EAAOtJ,GACpC,IAAIuJ,EAASH,EAAItE,QAChB,SAAUmB,EAAOuD,GAChB,IAAIpH,EAAQ6D,EAAM7D,MAElB,GAAIoH,aAAiBZ,EAAO,CAC3B,IAAItJ,EAAOzB,EAAIiI,YAAY0D,EAAMX,OAE7BzG,GAASkH,GACRhK,KAAQzB,EAAIqH,SACfrH,EAAIwH,UAAUY,EAAMwD,WAAYnK,GAE7BA,KAAQzB,EAAIsH,SACftH,EAAI0H,WAAWU,EAAMwD,WAAYnK,IAExB8C,EAAQpC,IACdV,KAAQzB,EAAIqH,SACfrH,EAAIwH,UAAUY,EAAMyD,UAAWpK,GAC/B2G,EAAMmD,IAAIlI,KAAKsI,IACLlK,KAAQzB,EAAIsH,UACtBc,EAAM0D,UAAUzI,KAAK5B,GACrB2G,EAAMmD,IAAIlI,KAAKsI,IAGlB,KAAO,CACN,IAAII,EAAY,GAEhB,GApCiB,SAAUJ,EAAOpH,EAAOkH,EAAOtJ,GAGnD,QAAIsJ,EAFWE,EAAMzH,OAASK,GAG1BpC,EAAMoC,EAEX,CA8BQyH,CAAeL,EAAOpH,EAAOkH,EAAOtJ,GAAM,CAC7C,IAAI8J,EAAWxL,KAAKD,IAAIiL,EAAQlH,EAAO,GACnC2H,EAASzL,KAAKC,IAAIyB,EAAMoC,EAAOoH,EAAMzH,QAEzC6H,EAAYJ,EAAMhG,MAAMsG,EAAUC,EACnC,CAEA9D,EAAMmD,IAAIlI,KAAK0I,GACf3D,EAAM7D,MAAQA,EAAQoH,EAAMzH,MAC7B,CAEA,OAAOkE,CACR,GACA,CACC7D,MAAO,EACPgH,IAAK,GAKLK,WAAY,GAKZC,UAAW,GAIXC,UAAW,KASb,OALAJ,EAAOH,IAAM,GAAGD,OACftL,EAAI4H,QAAQ8D,EAAOE,YAAaF,EAAOH,IACvCvL,EAAI8H,SAAS,GAAGwD,OAAOI,EAAOE,WAAYF,EAAOG,WAAYH,EAAOI,YAG9DJ,EAAOH,GACf,CAsBOY,CADNZ,EAAMN,EAAS3G,GACKmH,EAAOtJ,GACpBoJ,EACL5L,KAAI,SAAUgM,GACd,OAAIA,aAAiBZ,EACbY,EAAMX,MAGPW,CACR,IACCxL,KAAK,GACR,C,8BC1IA,IAAIpB,EAAgB,EAAQ,MACxB+J,EAAgB,EAAQ,KAAR,GAEpB7J,EAAOC,QAAU,SAAUoF,GAAO,OAAOvF,EAAcuF,GAAK3B,QAAQmG,EAAG,GAAK,C,8BCL5E,IAKuCsD,EALnCC,EAAe,EAAQ,MACvBC,EAAe,EAAQ,MACvB9M,EAAe,EAAQ,MACvB+M,EAAe,EAAQ,KAI3BH,EAAmB,WAEnB,EACA7L,OAAOsC,iBAAiBuJ,EAAiB/L,UAAW,CACnDkE,MAAO/E,GAAG,GACVgN,QAAShN,GAAE,GACXiN,KAAMjN,GAAE,WACP,IAAI8E,EAAM/C,KAAKiL,QAAU,KAAW,GAEpC,OADKjL,KAAKiL,UAASjL,KAAKiL,SAAU,GAC3BlI,EAXG,QAWU/C,KAAKgD,OAAShD,KAAKgD,MAAQ,GAXxBmI,EAYxB,IACA7G,MAAOrG,GAAE,WACR,OAAK+B,KAAKiL,SACVjL,KAAKgD,OAAS,EACdhD,KAAKiL,SAAU,EACR,MAHmB,EAI3B,MAGDvN,EAAOC,QAAUA,EAAU,SAAUyN,EAAOC,GAC3C,IAA2B5B,EAAvB6B,EAASvK,UAAU,GAAWwK,EAAW,IAAIV,EAIjD,OAHAE,EAASK,GACTC,EAAWL,EAAaK,QACTG,IAAXF,IAAsBF,EAAQN,EAAQhK,KAAKsK,EAAOL,EAASO,KACxD,CACN3K,MAAO,WACF8I,IACJA,EAAQgC,aAAY,WAAcL,EAAMG,EAASL,OAAS,GAAGG,GAC9D,EACAK,QAAS,WACR1L,KAAK2L,OACL3L,KAAKW,OACN,EACAgL,KAAM,WACAlC,IACLmC,cAAcnC,GACdA,EAAQ,KACR2B,EAAMG,EAASjH,SAChB,EAEF,EAEAtF,OAAOD,eAAepB,EAAS,WAAYM,EAAE4M,G,8BCjD7C,IAAI5M,EAAI,EAAQ,MAEhBe,OAAOsC,iBAAiB3D,EAAS,CAChCwF,MAAOlF,EAAE8B,GAAG,MAAM,WAAc,OAAOT,QAAQuM,OAAO1J,SAAW,CAAG,IACpE2J,OAAQ7N,EAAE8B,GAAG,MAAM,WAAc,OAAOT,QAAQuM,OAAOzJ,MAAQ,CAAG,K,8BCJnE,IAUI2J,EAVApK,EAAsB,EAAQ,MAC9BqK,EAAsB,EAAQ,MAC9BC,EAAsB,EAAQ,KAC9BC,EAAsB,EAAQ,KAC9BC,EAAsB,EAAQ,KAC9B/N,EAAsB,EAAQ,KAE9BgO,EAAOtM,SAAShB,UAAUsN,KAC1BrN,EAAiBC,OAAOD,eACxBsN,EAAiBrN,OAAOF,UAAUuN,eAGtCN,EAAS,SAAUO,EAAMC,EAAMvK,GAC9B,IAAkEwK,EAA9DC,EAAQT,EAAYO,IAASN,EAAoBM,EAAKE,OAU1D,cATAD,EAAMN,EAAKK,IACAG,gBACJF,EAAIC,MACXD,EAAIG,IAAM,WACT,OAAK3K,EAAQ4K,qBAAuBP,EAAevL,KAAKd,KAAMsM,GAAcG,GAC5EF,EAAKE,MAAQL,EAAKtL,KAAK2L,EAAOzK,EAAQ6K,eAAiB7K,EAAQ6K,eAAe7M,MAAQA,MACtFjB,EAAeiB,KAAMsM,EAAMC,GACpBvM,KAAKsM,GACb,EACOE,CACR,EAEA9O,EAAOC,QAAU,SAAUmP,GAC1B,IAAI9K,EAAUmK,EAAiBpL,UAAU,IAEzC,OADIY,EAAQK,EAAQ6K,iBAAiBZ,EAAoBjK,EAAQ6K,gBAC1DzO,EAAI0O,GAAO,SAAUP,EAAMD,GAAQ,OAAOP,EAAOO,EAAMC,EAAMvK,EAAU,GAC/E,C,8BC9BA,IAAIL,EAAkB,EAAQ,MAC1BoL,EAAkB,EAAQ,MAC1B7O,EAAkB,EAAQ,MAC1B8O,EAAkB,EAAQ,KAC1BC,EAAkB,EAAQ,MAErBvP,EAAOC,QAAU,SAAUuP,EAAMT,GACzC,IAAIU,EAAGC,EAAGC,EAAGrL,EAASuK,EAkBtB,OAjBIxL,UAAU4B,OAAS,GAAqB,iBAATuK,GAClClL,EAAUyK,EACVA,EAAQS,EACRA,EAAO,MAEPlL,EAAUjB,UAAU,GAEjBY,EAAQuL,IACXC,EAAIF,EAASnM,KAAKoM,EAAM,KACxBE,EAAIH,EAASnM,KAAKoM,EAAM,KACxBG,EAAIJ,EAASnM,KAAKoM,EAAM,OAExBC,EAAIE,GAAI,EACRD,GAAI,GAGLb,EAAO,CAAEE,MAAOA,EAAOa,aAAcH,EAAGI,WAAYH,EAAGV,SAAUW,GACzDrL,EAAiB9D,EAAO8O,EAAchL,GAAUuK,GAAtCA,CACnB,GAEExM,GAAK,SAAUmN,EAAMP,EAAKa,GAC3B,IAAIL,EAAGC,EAAGpL,EAASuK,EA6BnB,MA5BoB,iBAATW,GACVlL,EAAUwL,EACVA,EAAMb,EACNA,EAAMO,EACNA,EAAO,MAEPlL,EAAUjB,UAAU,GAEhBY,EAAQgL,GAEDI,EAAgBJ,GAGhBhL,EAAQ6L,GAERT,EAAgBS,KAC3BxL,EAAUwL,EACVA,OAAMhC,GAHNgC,OAAMhC,GAHNxJ,EAAU2K,EACVA,EAAMa,OAAMhC,GAHZmB,OAAMnB,EAUH7J,EAAQuL,IACXC,EAAIF,EAASnM,KAAKoM,EAAM,KACxBE,EAAIH,EAASnM,KAAKoM,EAAM,OAExBC,GAAI,EACJC,GAAI,GAGLb,EAAO,CAAEI,IAAKA,EAAKa,IAAKA,EAAKF,aAAcH,EAAGI,WAAYH,GAClDpL,EAAiB9D,EAAO8O,EAAchL,GAAUuK,GAAtCA,CACnB,C,8BC3DA,IAYIR,EAZAgB,EAAkB,EAAQ,MAC1Bf,EAAkB,EAAQ,MAC1BrK,EAAkB,EAAQ,MAC1BvD,EAAkB,EAAQ,KAC1B6O,EAAkB,EAAQ,KAE1BnM,EAAOhB,SAAShB,UAAUgC,KAC1B/B,EAAiBC,OAAOD,eACxB0O,EAA2BzO,OAAOyO,yBAClCC,EAAiB1O,OAAO0O,eACxBrB,EAAiBrN,OAAOF,UAAUuN,eAClCsB,EAAY,CAAEL,cAAc,EAAOC,YAAY,EAAOb,UAAU,EAAOD,MAAO,MAGlFV,EAAS,SAAUO,EAAMtK,GACxB,IAAIyK,EAAOD,EAAKoB,EAAWrB,EAAwBsB,EAAYC,EAA9BpB,GAAW,EA4F5C,OA3FA1K,EAAUhD,OAAOgN,EAAYhK,IAC7B4L,EAAY5L,EAAQ4L,UACpBE,EAAO9L,EAAQ8L,KACVnM,EAAQiM,KAAYA,EAAYtB,UAC9BtK,EAAQ4L,UACfnB,EAAQzK,EAAQyK,MAChBoB,EAAad,EAAgBN,UACtBzK,EAAQyK,OACfD,EAAM,CAAEc,aAAcS,QAAQ/L,EAAQsL,cAAeC,WAAYQ,QAAQ/L,EAAQuL,cAE5EZ,IADDL,IAASsB,EACF,WACT,OAAIvB,EAAevL,KAAKd,KAAM4N,KAC9BD,EAAUlB,MAAQoB,EAAa/M,EAAKA,KAAK2L,EAAOzM,KAAMgC,GAAWyK,EACjEkB,EAAUjB,SAAWA,EACrB3N,EAAeiB,KAAM4N,EAAWD,GAChCA,EAAUlB,MAAQ,KACdF,GAAMxN,EAAeiB,KAAMsM,EAAMC,IALYvM,KAAK4N,EAOvD,EACWE,EAsBD,SAASpN,IAClB,IAAiBsN,EAAbC,EAAOjO,KACX,GAAIqM,EAAevL,KAAKd,KAAMsM,GAAO,CAIpC,IADA0B,EAAUP,EAAyBzN,KAAMsM,IAC7BD,eAAe,SAAU,OAAO2B,EAAQvB,MACpD,GAA2B,mBAAhBuB,EAAQrB,KAAsBqB,EAAQrB,MAAQjM,EACxD,OAAOsN,EAAQrB,IAAI7L,KAAKd,KAE1B,CACA,MAAQqM,EAAevL,KAAKmN,EAAM3B,IAAO2B,EAAOP,EAAeO,GAI/D,OAHA1B,EAAKE,MAAQoB,EAAa/M,EAAKA,KAAK2L,EAAOwB,EAAMjM,GAAWyK,EAC5D1N,EAAekP,EAAM3B,EAAMC,GAC3BA,EAAKE,MAAQ,KACNwB,EAAK3B,EACb,EArCU,SAAS5L,IAClB,IAAIsN,EACJ,OAAI3B,EAAevL,KAAKd,KAAMsM,KAC7B0B,EAAUP,EAAyBzN,KAAMsM,IAKpC0B,EAAQ3B,eAAe,SAAiB2B,EAAQvB,MACzB,mBAAhBuB,EAAQrB,KAAsBqB,EAAQrB,MAAQjM,EACjDsN,EAAQrB,IAAI7L,KAAKd,MAElByM,GAGTF,EAAKE,MAAQoB,EAAa/M,EAAKA,KAAK2L,EAAOzM,KAAMgC,GAAWyK,EAC5D1N,EAAeiB,KAAMsM,EAAMC,GAC3BA,EAAKE,MAAQ,KACNzM,KAAKsM,GACb,EAoBDE,EAAIgB,IAAM,SAAUf,GACnB,GAAIJ,EAAevL,KAAKd,KAAMsM,GAC7B,MAAM,IAAI4B,UAAU,kCAAoC5B,EAAO,iBAAmBtM,MAEnFwM,EAAIG,IAAI7L,KAAKd,MACbA,KAAK4N,GAAanB,CACnB,EACIzK,EAAQuK,MACXA,EAAO,CACNe,aAAcL,EAASnM,KAAKkB,EAAQuK,KAAM,KAC1CgB,WAAYN,EAASnM,KAAKkB,EAAQuK,KAAM,MAErCqB,IAActB,GACjBC,EAAKG,SAAWO,EAASnM,KAAKkB,EAAQuK,KAAM,KAC5CA,EAAKE,MAAQ,OAEbC,EAAWO,EAASnM,KAAKkB,EAAQuK,KAAM,KACvCA,EAAKI,IAAMH,EAAIG,IACfJ,EAAKiB,IAAMhB,EAAIgB,YAETxL,EAAQuK,MACLqB,IAActB,IACxBC,EAAO,CACNe,aAAcS,QAAQ/L,EAAQsL,cAC9BC,WAAYQ,QAAQ/L,EAAQuL,YAC5Bb,SAAUqB,QAAQ/L,EAAQ0K,UAC1BD,MAAO,cAGFzK,EAAQsL,oBACRtL,EAAQuL,kBACRvL,EAAQ0K,SACRF,CACR,EAEA9O,EAAOC,QAAU,SAAUmP,GAC1B,OAAO1O,EAAI0O,GAAO,SAAUP,EAAMD,GAAQ,OAAOP,EAAOO,EAAMC,EAAO,GACtE,C,6BC5GA,IAAIE,EAAQ,EAAQ,MAEpB/O,EAAOC,QAAU,WAEhB,OADA8O,EAAMzM,MAAM2C,OAAS,EACd3C,IACR,C,8BCTA,IAAImO,EAAoB,EAAQ,MAC5BC,EAAoB,EAAQ,MAC5B3B,EAAoB,EAAQ,MAC5B4B,EAAoBxP,MAAMC,UAAUuP,QACpCC,EAAoBtP,OAAOF,UAAUuN,eACrC/E,EAAoBpI,KAAKoI,IACzBmB,EAAoBvJ,KAAKuJ,MAE7B/K,EAAOC,QAAU,SAAU4Q,GAC1B,IAAIlH,EAAG1E,EAAQ6L,EAAWC,EAC1B,IAAKN,EAAYI,GAAgB,OAAOF,EAAQvL,MAAM9C,KAAMe,WAQ5D,IANA4B,EAASyL,EAAS3B,EAAMzM,MAAM2C,QAC9B6L,EAAYzN,UAAU,GAKjBsG,EAJiBmH,EAAlBrO,MAAMqO,GAAwB,EACzBA,GAAa,EAAe/F,EAAM+F,GAC1BJ,EAASpO,KAAK2C,QAAU8F,EAAMnB,EAAIkH,IAE/BnH,EAAI1E,IAAU0E,EACjC,GAAIiH,EAAkBxN,KAAKd,KAAMqH,KAChCoH,EAAMzO,KAAKqH,GACP8G,EAAYM,IAAM,OAAOpH,EAG/B,OAAQ,CACT,C,8BCzBA,IAAI+G,EAAoB,EAAQ,MAC5BrD,EAAoB,EAAQ,MAC5B0B,EAAoB,EAAQ,MAC5B6B,EAAoBtP,OAAOF,UAAUuN,eACrCvL,EAAoBhB,SAAShB,UAAUgC,KAE3CpD,EAAOC,QAAU,SAAU+Q,GAC1B,IAAIrH,EAAG3G,EAAMiO,EAMb,IAJAjO,EAAO1B,OAAOyN,EAAMzM,OACpB+K,EAAS2D,GACTC,EAAU5N,UAAU,GAEfsG,EAAI+G,EAAS1N,EAAKiC,QAAU,EAAG0E,GAAK,IAAKA,EACzCiH,EAAkBxN,KAAKJ,EAAM2G,IAAIvG,EAAKA,KAAK4N,EAAIC,EAASjO,EAAK2G,GAAIA,EAAG3G,EAE1E,C,8BChBA,IAEIkO,EAFAP,EAAU,EAAQ,MAClBQ,EAAUhQ,MAAMC,UAAU+P,OAG9BD,EAAU,SAAUnC,EAAOzJ,GAAS,OAAOqL,EAAQvN,KAAKd,KAAMyM,KAAWzJ,CAAO,EAEhFtF,EAAOC,QAAU,WAAc,OAAOkR,EAAO/N,KAAKd,KAAM4O,EAAS5O,KAAO,C,8BCNxEtC,EAAOC,QAAU,EAAQ,KAAR,GAAgCkB,MAAM4C,KAAO,EAAQ,K,wBCAtE/D,EAAOC,QAAU,WAChB,IAAuBmR,EAAKhR,EAAxB2D,EAAO5C,MAAM4C,KACjB,MAAoB,mBAATA,IAEX3D,EAAS2D,EADTqN,EAAM,CAAC,MAAO,QAEPf,QAAQjQ,GAAUA,IAAWgR,GAAqB,QAAdhR,EAAO,IACnD,C,8BCNA,IAAIiR,EAAiB,iBACjBC,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MACzBb,EAAiB,EAAQ,MACzBrD,EAAiB,EAAQ,MACzBmE,EAAiB,EAAQ,MACzBvN,EAAiB,EAAQ,MACzBwN,EAAiB,EAAQ,MACzBC,EAAiBvQ,MAAMuQ,QACvBtO,EAAiBhB,SAAShB,UAAUgC,KACpCyL,EAAiB,CAAEe,cAAc,EAAMC,YAAY,EAAMb,UAAU,EAAMD,MAAO,MAChF1N,EAAiBC,OAAOD,eAG5BrB,EAAOC,QAAU,SAAU0R,GAC1B,IAEIC,EACAjI,EACAkI,EACAT,EACAnM,EACAzC,EACAqL,EACAzN,EACA0R,EACA/C,EAXAgD,EAAQ1O,UAAU,GAClB4N,EAAU5N,UAAU,GAexB,GAHAsO,EAAYrQ,OAAOkQ,EAAWG,IAE1B1N,EAAQ8N,IAAQ1E,EAAS0E,GACxBzP,MAAQA,OAASnB,OAAUoQ,EAAWjP,MAqB1CsP,EAAUtP,SArBuC,CAEjD,IAAKyP,EAAO,CACX,GAAIT,EAAYK,GAGf,OAAe,KADf1M,EAAS0M,EAAU1M,QACM9D,MAAMiE,MAAM,KAAMuM,KAC3CP,EAAM,IAAIjQ,MAAM,IACZ,GAAKwQ,EAAU,GACZP,GAER,GAAIM,EAAQC,GAAY,CAGvB,IADAP,EAAM,IAAIjQ,MAAO8D,EAAS0M,EAAU1M,QAC/B0E,EAAI,EAAGA,EAAI1E,IAAU0E,EAAGyH,EAAIzH,GAAKgI,EAAUhI,GAChD,OAAOyH,CACR,CACD,CACAA,EAAM,EACP,CAKA,IAAKM,EAAQC,GACZ,QAAkD7D,KAA7CgE,EAAcH,EAAUN,IAAgC,CAM5D,IAJAxD,EAAWR,EAASyE,GAAa1O,KAAKuO,GAClCC,IAASR,EAAM,IAAIQ,GACvBxR,EAASyN,EAASL,OAClB7D,EAAI,GACIvJ,EAAO4R,MACdjD,EAAQgD,EAAQ3O,EAAKA,KAAK2O,EAAOd,EAAS7Q,EAAO2O,MAAOpF,GAAKvJ,EAAO2O,MAChE6C,GACH/C,EAAKE,MAAQA,EACb1N,EAAe+P,EAAKzH,EAAGkF,IAEvBuC,EAAIzH,GAAKoF,EAEV3O,EAASyN,EAASL,SAChB7D,EAEH1E,EAAS0E,CACV,MAAO,GAAI8H,EAASE,GAAY,CAI/B,IAFA1M,EAAS0M,EAAU1M,OACf2M,IAASR,EAAM,IAAIQ,GAClBjI,EAAI,EAAGkI,EAAI,EAAGlI,EAAI1E,IAAU0E,EAChCoF,EAAQ4C,EAAUhI,GACdA,EAAI,EAAI1E,IACXzC,EAAOuM,EAAMkD,WAAW,KAEZ,OAAUzP,GAAQ,QAAQuM,GAAS4C,IAAYhI,IAE5DoF,EAAQgD,EAAQ3O,EAAKA,KAAK2O,EAAOd,EAASlC,EAAO8C,GAAK9C,EAClD6C,GACH/C,EAAKE,MAAQA,EACb1N,EAAe+P,EAAKS,EAAGhD,IAEvBuC,EAAIS,GAAK9C,IAER8C,EAEH5M,EAAS4M,CACV,CAED,QAAe/D,IAAX7I,EAIH,IAFAA,EAASyL,EAASiB,EAAU1M,QACxB2M,IAASR,EAAM,IAAIQ,EAAQ3M,IAC1B0E,EAAI,EAAGA,EAAI1E,IAAU0E,EACzBoF,EAAQgD,EAAQ3O,EAAKA,KAAK2O,EAAOd,EAASU,EAAUhI,GAAIA,GAAKgI,EAAUhI,GACnEiI,GACH/C,EAAKE,MAAQA,EACb1N,EAAe+P,EAAKzH,EAAGkF,IAEvBuC,EAAIzH,GAAKoF,EAQZ,OAJI6C,IACH/C,EAAKE,MAAQ,KACbqC,EAAInM,OAASA,GAEPmM,CACR,C,6BCpHA,IAAIV,EAAW,EAAQ,MACnB3B,EAAW,EAAQ,MACnBrI,EAAWvF,MAAMC,UAAUsF,MAE/B1G,EAAOC,QAAU,SAAUgF,GAC1B,IAAImM,EAAKc,EAET,GAAe,KADfjN,EAASyL,EAAS3B,EAAM9J,KACN,MAAO,GAIzB,IAFAmM,EAAM/N,UAAU4B,OAAS,EAAI,MAAC6I,GAAapH,EAAMtD,KAAKC,UAAW,EAAG,EAAI4B,IAEhEiN,EAAgBd,EAAInM,QAAUA,GACrCmM,EAAMA,EAAI/E,OAAO+E,EAAI1K,MAAM,EAAGzB,EAASiN,IAExC,OAAOd,CACR,C,8BCfA,IAAIrN,EAAU,EAAQ,MAClB2N,EAAUvQ,MAAMuQ,QAEpB1R,EAAOC,QAAU,SAAU0R,GAAa,OAAOD,EAAQC,GAAaA,EAAY5N,EAAK4N,EAAY,C,8BCHjG,IAAInR,EAAoB,EAAQ,MAC5B2R,EAAoB,EAAQ,MAC5BlO,EAAoB,EAAQ,MAC5BmO,EAAoBC,MAAMD,kBAE9BpS,EAAOC,QAAU,SAAUqS,GAC1B,IAAIC,EAAM,IAAIF,MAAMC,GAAU9P,EAAOa,UAAU,GAAImP,EAAMnP,UAAU,GAUnE,OATKY,EAAQuO,IACRL,EAAS3P,KACZgQ,EAAMhQ,EACNA,EAAO,MAGLyB,EAAQuO,IAAMhS,EAAO+R,EAAKC,GAC1BvO,EAAQzB,KAAO+P,EAAI/P,KAAOA,GAC1B4P,GAAmBA,EAAkBG,EAAKvS,EAAOC,SAC9CsS,CACR,C,8BCjBA,IAAItO,EAAW,EAAQ,MACnBoJ,EAAW,EAAQ,MACnBoF,EAAW,EAAQ,MAEnBrN,EAAQhD,SAAShB,UAAUgE,MAC3BhC,EAAOhB,SAAShB,UAAUgC,KAC1BsP,EAAS,SAAUC,EAAKC,GAAM,OAAOxP,EAAKA,KAAKwP,EAAItQ,KAAMqQ,EAAM,EAEnE3S,EAAOC,QAAU,SAAU4S,GAC1B,IAAIC,EAAKC,EACLC,EAAOP,EAAMpP,WAMjB,OALAyP,EAAM7O,EAAQ3B,MAAQ,CAACA,MAAM+J,OAAO2G,GAAQA,GACxCvS,QAAQ4M,GACZyF,EAAMA,EAAI/J,UACVgK,EAAQD,EAAI,GACZA,EAAMA,EAAIpM,MAAM,GACT,SAAUuM,GAAc,OAAOH,EAAI9K,OAAO0K,EAAQtN,EAAMhC,KAAK2P,EAAOzQ,KAAMe,WAAa,CAC/F,C,8BCjBA,IAIIwL,EAAMxN,EAAgByC,EAAUoP,EAyB9BC,EA7BFzC,EAAW,EAAQ,MAEnB0C,EAAO,SAAUC,EAAMC,GAAQ,OAAOA,CAAM,EAIhD,IACChS,OAAOD,eAAe+R,EAAM,SAAU,CACrCxD,cAAc,EACdZ,UAAU,EACVa,YAAY,EACZd,MAAO,GAET,CACA,MAAOwE,GAAS,CAEI,IAAhBH,EAAKnO,QAER4J,EAAO,CAAEe,cAAc,EAAMZ,UAAU,EAAOa,YAAY,GAC1DxO,EAAiBC,OAAOD,eACxBrB,EAAOC,QAAU,SAAU2S,EAAI3N,GAE9B,OADAA,EAASyL,EAASzL,GACd2N,EAAG3N,SAAWA,EAAe2N,GACjC/D,EAAKE,MAAQ9J,EACN5D,EAAeuR,EAAI,SAAU/D,GACrC,IAEAqE,EAAQ,EAAQ,MAEXC,EAAQ,GADbrP,EAEQ,SAAUmB,GAChB,IAAI+N,EAAMrJ,EAAI,EACd,GAAIwJ,EAAMlO,GAAS,OAAOkO,EAAMlO,GAEhC,IADA+N,EAAO,GACA/N,KAAU+N,EAAK5O,KAAK,OAASuF,GAAG6J,SAAS,KAEhD,OAAO,IAAIpR,SACV,KACA,oBAAsB4Q,EAAK9R,KAAK,MAAQ,2CAE1C,EAEDlB,EAAOC,QAAU,SAAUwT,EAAKxO,GAC/B,IAAIyO,EAEJ,GADAzO,EAASyL,EAASzL,GACdwO,EAAIxO,SAAWA,EAAQ,OAAOwO,EAClCC,EAAS5P,EAASmB,EAATnB,CAAiB2P,GAC1B,IAAMP,EAAMQ,EAAQD,EAAM,CAC1B,MAAOF,GAAS,CAChB,OAAOG,CACR,E,wBClDD,IAAIC,EAAcrS,OAAOF,UAAUoS,SAC/BI,EAAKD,EAAYvQ,KAAK,WAAe,OAAOC,SAAY,CAAlC,IAE1BrD,EAAOC,QAAU,SAAU8O,GAAS,OAAO4E,EAAYvQ,KAAK2L,KAAW6E,CAAI,C,wBCH3E,IAAID,EAAcrS,OAAOF,UAAUoS,SAC/BK,EAAsB/Q,OAAO1B,UAAUgS,KAAK1E,KAAK,mCAErD1O,EAAOC,QAAU,SAAU8O,GAC1B,MAAwB,mBAAVA,GAAwB8E,EAAoBF,EAAYvQ,KAAK2L,GAC5E,C,wBCJA/O,EAAOC,QAAU,WAAa,C,8BCD9B,IAAIoR,EAAiB,iBACjBpN,EAAiB,EAAQ,MACzB6P,EAAiB,EAAQ,MAE7B9T,EAAOC,QAAU,SAAU8O,GAC1B,QAAK9K,EAAQ8K,KACwB,mBAA1BA,EAAMsC,IACVyC,EAAY/E,GACpB,C,8BCRA,IAAIoD,EAAW,EAAQ,MACnB4B,EAAW,EAAQ,MAEvB/T,EAAOC,QAAU,SAAU8O,GAC1B,GAAIgF,EAAGhF,IAAUoD,EAASpD,GAAQ,OAAOA,EACzC,MAAM,IAAIyB,UAAUzB,EAAQ,2CAC7B,C,8BCNA/O,EAAOC,QAAU,EAAQ,KAAR,GAAgCuB,KAAKwS,KAAO,EAAQ,K,wBCArEhU,EAAOC,QAAU,WAChB,IAAI+T,EAAOxS,KAAKwS,KAChB,MAAoB,mBAATA,GACS,IAAbA,EAAK,MAA4B,IAAfA,GAAM,GAChC,C,wBCJAhU,EAAOC,QAAU,SAAU8O,GAE1B,OADAA,EAAQ7F,OAAO6F,GACXtM,MAAMsM,IAAoB,IAAVA,EAAoBA,EACjCA,EAAQ,EAAI,GAAK,CACzB,C,8BCJA/O,EAAOC,QAAU,EAAQ,KAAR,GAAgCuB,KAAKsJ,MAAQ,EAAQ,K,wBCAtE9K,EAAOC,QAAU,WAChB,IAAI6K,EAAQtJ,KAAKsJ,MACjB,MAAqB,mBAAVA,GACa,KAAjBA,EAAM,SAAoC,KAAnBA,GAAO,MACtC,C,wBCJA,IAAIC,EAAQvJ,KAAKuJ,MAEjB/K,EAAOC,QAAU,SAAU8O,GAC1B,OAAItM,MAAMsM,GAAekF,IAEX,KADdlF,EAAQ7F,OAAO6F,IACSA,EACpBA,IAAU5E,IAAiBA,IAC3B4E,KAAU,KAAkB,IAC5BA,EAAQ,EAAUhE,EAAMgE,IACpBhE,GAAOgE,EAChB,C,8BCVA/O,EAAOC,QAAU,EAAQ,KAAR,GAAgCiJ,OAAOzG,MAAQ,EAAQ,K,wBCAxEzC,EAAOC,QAAU,WAChB,IAAIwQ,EAAcvH,OAAOzG,MACzB,MAA2B,mBAAhBgO,IACHA,EAAY,CAAC,IAAMA,EAAYwD,OAASxD,EAAY,GAC7D,C,wBCJAzQ,EAAOC,QAAU,SAAU8O,GAE1B,OAAOA,GAAUA,CAClB,C,8BCHA,IAAIiF,EAAQ,EAAQ,MAChBpK,EAAQpI,KAAKoI,IACbmB,EAAQvJ,KAAKuJ,MAEjB/K,EAAOC,QAAU,SAAU8O,GAC1B,OAAItM,MAAMsM,GAAe,EAEX,KADdA,EAAQ7F,OAAO6F,KACKmF,SAASnF,GACtBiF,EAAKjF,GAAShE,EAAMnB,EAAImF,IADaA,CAE7C,C,8BCTA,IAAIoF,EAAY,EAAQ,MACpB5S,EAAYC,KAAKD,IAErBvB,EAAOC,QAAU,SAAU8O,GAAS,OAAOxN,EAAI,EAAG4S,EAAUpF,GAAS,C,8BCCrE,IAAI1B,EAA0B,EAAQ,MAClC0B,EAA0B,EAAQ,MAClCL,EAA0BtM,SAAShB,UAAUsN,KAC7CtL,EAA0BhB,SAAShB,UAAUgC,KAC7CgR,EAA0B9S,OAAO8S,KACjCC,EAA0B/S,OAAOF,UAAUkT,qBAE/CtU,EAAOC,QAAU,SAAUsU,EAAQC,GAClC,OAAO,SAAUvM,EAAK+I,GACrB,IAAIyD,EAAMxD,EAAU5N,UAAU,GAAIqR,EAAYrR,UAAU,GASxD,OARA4E,EAAM3G,OAAOyN,EAAM9G,IACnBoF,EAAS2D,GAETyD,EAAOL,EAAKnM,GACRyM,GACHD,EAAKE,KAA0B,mBAAdD,EAA2BhG,EAAKtL,KAAKsR,EAAWzM,QAAO6F,GAEnD,mBAAXyG,IAAuBA,EAASE,EAAKF,IACzCnR,EAAKA,KAAKmR,EAAQE,GAAM,SAAUhR,EAAK6B,GAC7C,OAAK+O,EAAwBjR,KAAK6E,EAAKxE,GAChCL,EAAKA,KAAK4N,EAAIC,EAAShJ,EAAIxE,GAAMA,EAAKwE,EAAK3C,GADEkP,CAErD,GACD,CACD,C,8BC3BAxU,EAAOC,QAAU,EAAQ,KAAR,GAAgCqB,OAAOd,OAAS,EAAQ,K,wBCAzER,EAAOC,QAAU,WAChB,IAA4BgI,EAAxBzH,EAASc,OAAOd,OACpB,MAAsB,mBAAXA,IAEXA,EADAyH,EAAM,CAAE2M,IAAK,OACD,CAAEC,IAAK,OAAS,CAAEC,KAAM,SAC7B7M,EAAI2M,IAAM3M,EAAI4M,IAAM5M,EAAI6M,OAAS,aACzC,C,8BCNA,IAAIV,EAAQ,EAAQ,MAChBrF,EAAQ,EAAQ,MAChBxN,EAAQC,KAAKD,IAEjBvB,EAAOC,QAAU,SAAU8U,EAAMtB,GAChC,IAAIuB,EAAOrL,EAAsCnJ,EAAnCyE,EAAS1D,EAAI8B,UAAU4B,OAAQ,GAS7C,IARA8P,EAAOzT,OAAOyN,EAAMgG,IACpBvU,EAAS,SAAUiD,GAClB,IACCsR,EAAKtR,GAAOgQ,EAAIhQ,EACjB,CAAE,MAAOiM,GACHsF,IAAOA,EAAQtF,EACrB,CACD,EACK/F,EAAI,EAAGA,EAAI1E,IAAU0E,EAEzByK,EADAX,EAAMpQ,UAAUsG,IACNlJ,QAAQD,GAEnB,QAAcsN,IAAVkH,EAAqB,MAAMA,EAC/B,OAAOD,CACR,C,6BCpBA,IAAItC,EAAS,EAAQ,MACjBjS,EAAS,EAAQ,MACjBuO,EAAS,EAAQ,MAErB/O,EAAOC,QAAU,SAAUgI,GAC1B,IAAIuG,EAAOlN,OAAOyN,EAAM9G,IAAOgN,EAAgB5R,UAAU,GAAIiB,EAAUhD,OAAO+B,UAAU,IACxF,GAAImL,IAASvG,IAAQgN,EAAe,OAAOzG,EAC3C,IAAIpO,EAAS,CAAC,EAQd,OAPI6U,EACHxC,EAAMwC,GAAe,SAAUC,IAC1B5Q,EAAQ6Q,QAAUD,KAAgBjN,KAAK7H,EAAO8U,GAAgBjN,EAAIiN,GACvE,IAEA1U,EAAOJ,EAAQ6H,GAET7H,CACR,C,8BCdA,IAA4BgV,EAOvBC,EAAYC,EAAWzG,EAPxB1M,EAASb,OAAOa,OAEf,EAAQ,KAAR,KACJiT,EAAO,EAAQ,OAGhBpV,EAAOC,QAEDmV,EACc,IAAfA,EAAKG,MAAoBpT,GAE7BkT,EAAa,CAAC,EACdC,EAAY,CAAC,EACbzG,EAAO,CAAEe,cAAc,EAAOC,YAAY,EAAOb,UAAU,EAAMD,WAAOjB,GACxExM,OAAOkU,oBAAoBlU,OAAOF,WAAWX,SAAQ,SAAUmO,GAU9D0G,EAAU1G,GATG,cAATA,EAScC,EARC,CACjBe,cAAc,EACdC,YAAY,EACZb,UAAU,EACVD,WAAOjB,EAKV,IACAxM,OAAOsC,iBAAiByR,EAAYC,GAEpChU,OAAOD,eAAe+T,EAAM,eAAgB,CAC3CxF,cAAc,EACdC,YAAY,EACZb,UAAU,EACVD,MAAOsG,IAGD,SAAUjU,EAAWgO,GAC3B,OAAOjN,EAAqB,OAAdf,EAAqBiU,EAAajU,EAAWgO,EAC5D,GA7BkBjN,C,8BCVnB,IAAI4M,EAA0B,EAAQ,MAClCsF,EAA0B/S,OAAOF,UAAUkT,qBAE/CtU,EAAOC,QAAU,SAAUgI,GAC1B,IAAI0B,EAEJ,IAAKA,KADLoF,EAAM9G,GACIA,EACT,GAAIoM,EAAwBjR,KAAK6E,EAAK0B,GAAI,OAAOA,EAElD,OAAO,IACR,C,8BCVA3J,EAAOC,QAAU,EAAQ,KAAR,CAAsB,U,8BCAvC,IAAIsR,EAAa,EAAQ,MACrBY,EAAa,EAAQ,MACrBlO,EAAa,EAAQ,MAEzBjE,EAAOC,QAAU,SAAU8O,GAC1B,OACE9K,EAAQ8K,IACgB,iBAAjBA,EAAM9J,SAIXkN,EAASpD,KAAWwC,EAAWxC,IAA4B,iBAAVA,KACpD,CAEF,C,wBCZA/O,EAAOC,QAAU,SAAUgI,GAAO,MAAsB,mBAARA,CAAoB,C,8BCFpE,IAAIhE,EAAU,EAAQ,MAElBvD,EAAM,CAAE+U,UAAU,EAAM5V,QAAQ,GAEpCG,EAAOC,QAAU,SAAU8O,GAAS,OAAQ9K,EAAQ8K,IAAUrO,SAAWqO,KAAW,CAAO,C,8BCJ3F,IAAI2G,EAAa,EAAQ,KAAR,GAEjB1V,EAAOC,QAAU,SAAU8Q,GAAO,OAAOA,IAAQ2E,GAAsB,OAAR3E,CAAc,C,8BCF7E/Q,EAAOC,QAAU,EAAQ,KAAR,GAAgCqB,OAAO8S,KAAO,EAAQ,K,wBCAvEpU,EAAOC,QAAU,WAChB,IAEC,OADAqB,OAAO8S,KAAK,cACL,CACR,CAAE,MAAO1E,GACR,OAAO,CACR,CACD,C,8BCPA,IAAIzL,EAAU,EAAQ,MAElBmQ,EAAO9S,OAAO8S,KAElBpU,EAAOC,QAAU,SAAUJ,GAAU,OAAOuU,EAAKnQ,EAAQpE,GAAUyB,OAAOzB,GAAUA,EAAS,C,6BCJ7F,IAAIwN,EAAW,EAAQ,MACnB5M,EAAW,EAAQ,MACnB2C,EAAWhB,SAAShB,UAAUgC,KAElCpD,EAAOC,QAAU,SAAUgI,EAAK+I,GAC/B,IAAI5Q,EAAS,CAAC,EAAG6Q,EAAU5N,UAAU,GAKrC,OAJAgK,EAAS2D,GACTvQ,EAAQwH,GAAK,SAAU8G,EAAOtL,EAAKkS,EAAWrQ,GAC7ClF,EAAOqD,GAAOL,EAAKA,KAAK4N,EAAIC,EAASlC,EAAOtL,EAAKkS,EAAWrQ,EAC7D,IACOlF,CACR,C,8BCXA,IAAI2O,EAA2B,EAAQ,MACnC1N,EAA2BC,OAAOD,eAClC0O,EAA2BzO,OAAOyO,yBAClCyF,EAA2BlU,OAAOkU,oBAClCI,EAA2BtU,OAAOsU,sBAEtC5V,EAAOC,QAAU,SAAUyT,EAAQmC,GAClC,IAAIb,EAAOc,EAAexU,OAAOyN,EAAM8G,IAcvC,GAbAnC,EAASpS,OAAOyN,EAAM2E,IACtB8B,EAAoBM,GAAcrV,SAAQ,SAAUmO,GACnD,IACCvN,EAAeqS,EAAQ9E,EAAMmB,EAAyB8F,EAAQjH,GAC/D,CAAE,MAAOc,GAAKsF,EAAQtF,CAAG,CAC1B,IACqC,mBAA1BkG,GACVA,EAAsBE,GAAcrV,SAAQ,SAAUsV,GACrD,IACC1U,EAAeqS,EAAQqC,EAAQhG,EAAyB8F,EAAQE,GACjE,CAAE,MAAOrG,GAAKsF,EAAQtF,CAAG,CAC1B,SAEa5B,IAAVkH,EAAqB,MAAMA,EAC/B,OAAOtB,CACR,C,6BCvBA,IAAIzP,EAAU,EAAQ,MAElBxD,EAAUU,MAAMC,UAAUX,QAAS0B,EAASb,OAAOa,OAQvDnC,EAAOC,QAAU,SAAU+V,GAC1B,IAAI5V,EAAS+B,EAAO,MAKpB,OAJA1B,EAAQ2C,KAAKC,WAAW,SAAUiB,GAC5BL,EAAQK,IATD,SAAUmP,EAAKxL,GAC5B,IAAIxE,EACJ,IAAKA,KAAOgQ,EAAKxL,EAAIxE,GAAOgQ,EAAIhQ,EACjC,CAOE7B,CAAQN,OAAOgD,GAAUlE,EAC1B,IACOA,CACR,C,wBCjBA,IAAIK,EAAUU,MAAMC,UAAUX,QAAS0B,EAASb,OAAOa,OAGvDnC,EAAOC,QAAU,SAAU0S,GAC1B,IAAI7C,EAAM3N,EAAO,MAEjB,OADA1B,EAAQ2C,KAAKC,WAAW,SAAUuL,GAAQkB,EAAIlB,IAAQ,CAAM,IACrDkB,CACR,C,8BCPA9P,EAAOC,QAAU,EAAQ,KAAR,GAAgCqB,OAAOV,eAAiB,EAAQ,K,wBCAjF,IAAIuB,EAASb,OAAOa,OAAQ6N,EAAiB1O,OAAO0O,eAAgBiG,EAAc,CAAC,EAEnFjW,EAAOC,QAAU,WAChB,IAAIW,EAAiBU,OAAOV,eAC5B,MAA8B,mBAAnBA,GACJoP,EAAepP,GAFqCyC,UAAU,IAAMlB,GAEzB,MAAO8T,MAAkBA,CAC5E,C,8BCDA,IAKIC,EAQwBC,EACvBvD,EAAI9C,EAdLqC,EAAmB,EAAQ,MAC3BpD,EAAmB,EAAQ,MAC3BqH,EAAmB9U,OAAOF,UAAUiV,cACpChV,EAAmBC,OAAOD,eAC1BiV,EAAmB,CAAE1G,cAAc,EAAMC,YAAY,EAAOb,UAAU,EAAMD,WAAOjB,GAGvFoI,EAAW,SAAUjO,EAAK7G,GAEzB,GADA2N,EAAM9G,GACY,OAAd7G,GAAsB+Q,EAAS/Q,GAAY,OAAO6G,EACtD,MAAM,IAAIuI,UAAU,sCACrB,EAEAxQ,EAAOC,SAAqBkW,EAmC3B,WACC,IAEIrG,EAFAyG,EAAUjV,OAAOa,OAAO,MACxBqU,EAAU,CAAC,EAEX3H,EAAOvN,OAAOyO,yBAAyBzO,OAAOF,UAAW,aAE7D,GAAIyN,EAAM,CACT,KACCiB,EAAMjB,EAAKiB,KACP1M,KAAKmT,EAASC,EACnB,CAAE,MAAOjD,GAAS,CAClB,GAAIjS,OAAO0O,eAAeuG,KAAaC,EAAS,MAAO,CAAE1G,IAAKA,EAAKyF,MAAO,EAC3E,CAGA,OADAgB,EAAQE,UAAYD,EAChBlV,OAAO0O,eAAeuG,KAAaC,EAAgB,CAAEjB,MAAO,KAEhEgB,EAAU,CAAC,GACHE,UAAYD,EAChBlV,OAAO0O,eAAeuG,KAAaC,GAAgB,CAAEjB,MAAO,GAGhE,CAtBD,GAjCKY,GACgB,IAAjBA,EAAOZ,MACNY,EAAOrG,KACVA,EAAMqG,EAAOrG,IACb8C,EAAK,SAAU3K,EAAK7G,GAEnB,OADA0O,EAAI1M,KAAK8S,EAASjO,EAAK7G,GAAYA,GAC5B6G,CACR,GAEA2K,EAAK,SAAU3K,EAAK7G,GAEnB,OADA8U,EAASjO,EAAK7G,GAAWqV,UAAYrV,EAC9B6G,CACR,EAGD2K,EAAK,SAAS5P,EAAKiF,EAAK7G,GACvB,IAAIsV,EAOJ,OANAR,EAASjO,EAAK7G,IACdsV,EAAaN,EAAiBhT,KAAKJ,EAAK2T,aAAc1O,YAC/BjF,EAAK2T,aAAaF,UACvB,OAAdrV,IAAoBA,EAAY4B,EAAK2T,cACzC1O,EAAIwO,UAAYrV,EACZsV,GAAYrV,EAAe2B,EAAK2T,aAAc,YAAaL,GACxDrO,CACR,EAEM3G,OAAOD,eAAeuR,EAAI,QAAS,CACzChD,cAAc,EACdC,YAAY,EACZb,UAAU,EACVD,MAAOoH,EAAOZ,SA9BK,MA0DrB,EAAQ,K,wBC9ERvV,EAAOC,QAAU,SAAU2S,GAC1B,GAAkB,mBAAPA,EAAmB,MAAM,IAAIpC,UAAUoC,EAAK,sBACvD,OAAOA,CACR,C,8BCHA,IAAIT,EAAW,EAAQ,MAEvBnS,EAAOC,QAAU,SAAU8O,GAC1B,IAAKoD,EAASpD,GAAQ,MAAM,IAAIyB,UAAUzB,EAAQ,qBAClD,OAAOA,CACR,C,8BCLA,IAAI9K,EAAU,EAAQ,MAEtBjE,EAAOC,QAAU,SAAU8O,GAC1B,IAAK9K,EAAQ8K,GAAQ,MAAM,IAAIyB,UAAU,gCACzC,OAAOzB,CACR,C,8BCLA,IAAIT,EAAgB,EAAQ,MACxBxO,EAAgB,EAAQ,MAE5BE,EAAOC,QAAU,SAAU8O,GAAS,OAAOjP,EAAcwO,EAAYS,GAAS,C,8BCH9E,IAAI6H,EAAa,EAAQ,MAEzB5W,EAAOC,QAAU,SAAUH,GAC1B,IACC,OAAIA,GAAiB8W,EAAW9W,EAAc0T,UAAkB1T,EAAc0T,WACvEqD,OAAO/W,EACf,CAAE,MAAO4P,GACR,MAAM,IAAIc,UAAU,uCACrB,CACD,C,8BCTA,IAAIoG,EAAa,EAAQ,MAEzB5W,EAAOC,QAAU,SAAU8O,GAC1B,IACC,OAAIA,GAAS6H,EAAW7H,EAAMyE,UAAkBzE,EAAMyE,WAC/CqD,OAAO9H,EACf,CAAE,MAAOW,GACR,MAAO,iCACR,CACD,C,6BCTA1P,EAAOC,QAAU,EAAQ,IAAR,GAAgC4W,OAAOzV,UAAUmO,SAAW,EAAQ,K,uBCArF,IAAIlK,EAAM,aAEVrF,EAAOC,QAAU,WAChB,MAA4B,mBAAjBoF,EAAIkK,WACgB,IAAxBlK,EAAIkK,SAAS,SAA2C,IAAxBlK,EAAIkK,SAAS,MACrD,C,wBCLA,IAAIoB,EAAUkG,OAAOzV,UAAUuP,QAE/B3Q,EAAOC,QAAU,SAAU6W,GAC1B,OAAOnG,EAAQvN,KAAKd,KAAMwU,EAAczT,UAAU,KAAO,CAC1D,C,8BCJArD,EAAOC,QAAU,EAAQ,KAAR,GAAgC4W,OAAOzV,UAAU8C,OAAS,EAAQ,K,wBCEnFlE,EAAOC,QAAU,WAChB,MAA0B,kBAHjB,MAGMiE,QACU,WAJhB,MAIEA,OAAO,EACnB,C,8BCDA,IAAI6K,EAAY,EAAQ,MACpBoF,EAAY,EAAQ,MAExBnU,EAAOC,QAAU,SAAU8W,GAC1B,IAA+B3W,EAA3BiF,EAAMwR,OAAO9H,EAAMzM,OAEvB,IADAyU,EAAQ5C,EAAU4C,IACN,EAAG,MAAM,IAAIC,WAAW,sBACpC,IAAK9C,SAAS6C,GAAQ,MAAM,IAAIC,WAAW,qBAG3C,IADA5W,EAAS,GACF2W,GACFA,EAAQ,IAAG3W,GAAUiF,GACrB0R,EAAQ,IAAG1R,GAAOA,GAEtB0R,IAAU,EAEX,OAAO3W,CACR,C,wBCrBA,IAAIuT,EAAcrS,OAAOF,UAAUoS,SAAUI,EAAKD,EAAYvQ,KAAK,IAEnEpD,EAAOC,QAAU,SAAU8O,GAC1B,MACkB,iBAAVA,GACNA,GACiB,iBAAVA,IACNA,aAAiB8H,QAAUlD,EAAYvQ,KAAK2L,KAAW6E,KACzD,CAEF,C,8BCVA,IAAIqD,EAAe,EAAQ,MAEvBC,EAAY,sBAEhBlX,EAAOC,QAAU,SAAU8O,GAC1B,IAAIoI,EAASF,EAAalI,GAO1B,OALIoI,EAAOlS,OAAS,MAAKkS,EAASA,EAAOzQ,MAAM,EAAG,IAAM,KAE/CyQ,EAAOzT,QAAQwT,GAAW,SAAU7W,GAC5C,OAAO+W,KAAKC,UAAUhX,GAAMqG,MAAM,GAAI,EACvC,GAED,C,6BCbA,IAM4C4Q,EANxC1W,EAAiB,EAAQ,MACzB2O,EAAiB,EAAQ,KACzBhP,EAAiB,EAAQ,MACzBgX,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MAEzBnW,EAAiBC,OAAOD,eAE5BiW,EAAgBtX,EAAOC,QAAU,SAAUmR,EAAKqG,GAC/C,KAAMnV,gBAAgBgV,GAAgB,MAAM,IAAI9G,UAAU,8BAC1DgH,EAASpU,KAAKd,KAAM8O,GAEuBqG,EADtCA,EACIlI,EAASnM,KAAKqU,EAAM,aAAqB,YACzClI,EAASnM,KAAKqU,EAAM,OAAe,MAChC,QAHM,QAIlBpW,EAAeiB,KAAM,WAAY/B,EAAE,GAAIkX,GACxC,EACI7W,GAAgBA,EAAe0W,EAAeE,UAG3CF,EAAclW,UAAUsW,YAE/BJ,EAAclW,UAAYE,OAAOa,OAAOqV,EAASpW,UAAW,CAC3DuW,SAAUpX,GAAE,SAAUoJ,GACrB,MAAsB,UAAlBrH,KAAKsV,SAA6BtV,KAAKuV,SAASlO,GAC9B,cAAlBrH,KAAKsV,SAAiC,CAACjO,EAAGrH,KAAKuV,SAASlO,IACrDA,CACR,MAEDtI,EAAeiW,EAAclW,UAAWmW,EAAOO,YAAavX,EAAE,IAAK,kB,6BC7BnE,IAAI+Q,EAAc,EAAQ,MACtBjE,EAAc,EAAQ,MACtBoE,EAAc,EAAQ,MACtBxC,EAAc,EAAQ,MAEtByC,EAAUvQ,MAAMuQ,QAAStO,EAAOhB,SAAShB,UAAUgC,KAAM2U,EAAO5W,MAAMC,UAAU2W,KAEpF/X,EAAOC,QAAU,SAAU+D,EAAUgN,GACpC,IAAIgH,EAA8B5X,EAAQ6X,EAASC,EAAQvO,EAAG1E,EAAQ5E,EAAMmC,EAAlEyO,EAAU5N,UAAU,GAS9B,GARIqO,EAAQ1N,IAAasN,EAAYtN,GAAWgU,EAAO,QAC9CvG,EAASzN,GAAWgU,EAAO,SAC/BhU,EAAWiL,EAAIjL,GAEpBqJ,EAAS2D,GACTiH,EAAU,WACTC,GAAS,CACV,EACa,UAATF,EAOJ,GAAa,WAATA,EAeJ,IAFA5X,EAAS4D,EAASwJ,QAEVpN,EAAO4R,MAAM,CAEpB,GADA5O,EAAKA,KAAK4N,EAAIC,EAAS7Q,EAAO2O,MAAOkJ,GACjCC,EAAQ,OACZ9X,EAAS4D,EAASwJ,MACnB,MAjBC,IADAvI,EAASjB,EAASiB,OACb0E,EAAI,EAAGA,EAAI1E,IACf5E,EAAO2D,EAAS2F,GACZA,EAAI,EAAI1E,IACXzC,EAAOnC,EAAK4R,WAAW,KACX,OAAUzP,GAAQ,QAAQnC,GAAQ2D,IAAW2F,IAE1DvG,EAAKA,KAAK4N,EAAIC,EAAS5Q,EAAM4X,IACzBC,KAPqBvO,QAR1BoO,EAAK3U,KAAKY,GAAU,SAAU+K,GAE7B,OADA3L,EAAKA,KAAK4N,EAAIC,EAASlC,EAAOkJ,GACvBC,CACR,GAuBF,C,8BC5CA,IAAI5G,EAAiB,EAAQ,MACzBG,EAAiB,EAAQ,MACzB6F,EAAiB,EAAQ,KACzBa,EAAiB,EAAQ,MACzBnU,EAAiB,EAAQ,MACzBqN,EAAiB,iBAErBrR,EAAOC,QAAU,SAAUgI,GAC1B,MAA6C,mBAAlCjE,EAASiE,GAAKoJ,GAAuCpJ,EAAIoJ,KAChEC,EAAYrJ,GAAa,IAAIqP,EAAcrP,GAC3CwJ,EAASxJ,GAAa,IAAIkQ,EAAelQ,GACtC,IAAIqP,EAAcrP,EAC1B,C,8BCZA,IAQwFuP,EARpFY,EAAW,EAAQ,KACnB5X,EAAW,EAAQ,MACnB6M,EAAW,EAAQ,MACnB0B,EAAW,EAAQ,MACnBxO,EAAW,EAAQ,MACnB8X,EAAW,EAAQ,MACnBd,EAAW,EAAQ,MAEnBlW,EAAiBC,OAAOD,eAAgBuC,EAAmBtC,OAAOsC,iBAEtE5D,EAAOC,QAAUuX,EAAW,SAAU/C,EAAM6D,GAC3C,KAAMhW,gBAAgBkV,GAAW,MAAM,IAAIhH,UAAU,8BACrD5M,EAAiBtB,KAAM,CACtBuV,SAAUtX,EAAE,IAAKwO,EAAM0F,IACvB8D,YAAahY,EAAE,IAAK+X,GACpBE,cAAejY,EAAE,IAAK,KAElB+X,IACLjL,EAASiL,EAAQG,IACjBH,EAAQG,GAAG,OAAQnW,KAAKoW,QACxBJ,EAAQG,GAAG,UAAWnW,KAAKqW,WAC3BL,EAAQG,GAAG,SAAUnW,KAAKsW,UAC3B,SAGOpB,EAASpW,UAAUsW,YAE1B9T,EACC4T,EAASpW,UACTZ,EACC,CACCqY,MAAOtY,GAAE,WACR,IAAIoJ,EACJ,GAAKrH,KAAKuV,SACV,OAAIvV,KAAKwW,eAEEhL,KADVnE,EAAIrH,KAAKwW,SAASC,SACUpP,EAEzBrH,KAAKkW,cAAgBlW,KAAKuV,SAAS5S,OAAe3C,KAAKkW,qBAC3DlW,KAAK0W,SAEN,IACAxL,KAAMjN,GAAE,WACP,OAAO+B,KAAK2W,cAAc3W,KAAKuW,QAChC,IACAI,cAAe1Y,GAAE,SAAUoJ,GAC1B,YAAUmE,IAANnE,EAAwB,CAAEqI,MAAM,EAAMjD,WAAOjB,GAC1C,CAAEkE,MAAM,EAAOjD,MAAOzM,KAAKqV,SAAShO,GAC5C,IACAgO,SAAUpX,GAAE,SAAUoJ,GACrB,OAAOrH,KAAKuV,SAASlO,EACtB,IACAqP,QAASzY,GAAE,WACV+B,KAAKuV,SAAW,YACTvV,KAAKwW,SACPxW,KAAKiW,cACVjW,KAAKiW,YAAYW,IAAI,OAAQ5W,KAAKoW,QAClCpW,KAAKiW,YAAYW,IAAI,UAAW5W,KAAKqW,WACrCrW,KAAKiW,YAAYW,IAAI,SAAU5W,KAAKsW,UACpCtW,KAAKiW,YAAc,KACpB,IACA/E,SAAUjT,GAAE,WACX,MAAO,YAAc+B,KAAKiV,EAAOO,cAAgB,UAAY,GAC9D,KAEDO,EAAS,CACRK,OAAQnY,GAAE,SAAU+E,GACfA,GAAShD,KAAKkW,kBAChBlW,KAAKkW,cACFlW,KAAKwW,UAIVxW,KAAKwW,SAASrY,SAAQ,SAAU0Y,EAAMxP,GACjCwP,GAAQ7T,IAAOhD,KAAKwW,SAASnP,KAAOwP,EACzC,GAAG7W,MACHA,KAAKwW,SAAS1U,KAAKkB,IANlBjE,EAAeiB,KAAM,WAAY/B,EAAE,IAAK,CAAC+E,KAO3C,IACAqT,UAAWpY,GAAE,SAAU+E,GACtB,IAAIqE,EACArE,GAAShD,KAAKkW,kBAChBlW,KAAKkW,cACFlW,KAAKwW,YAEC,KADXnP,EAAIrH,KAAKwW,SAASnI,QAAQrL,KACZhD,KAAKwW,SAASpQ,OAAOiB,EAAG,GACtCrH,KAAKwW,SAASrY,SAAQ,SAAU0Y,EAAMtH,GACjCsH,EAAO7T,IAAOhD,KAAKwW,SAASjH,KAAOsH,EACxC,GAAG7W,OACJ,IACAsW,SAAUrY,GAAE,WACP+B,KAAKwW,UAAUV,EAAMhV,KAAKd,KAAKwW,UACnCxW,KAAKkW,cAAgB,CACtB,QAKHnX,EACCmW,EAASpW,UACTmW,EAAO1J,SACPtN,GAAE,WACD,OAAO+B,IACR,I,8BCtGD,IAAIgP,EAAc,EAAQ,MACtBrN,EAAc,EAAQ,MACtBwN,EAAc,EAAQ,MAEtBJ,EAAiB,iBACjBK,EAAiBvQ,MAAMuQ,QAE3B1R,EAAOC,QAAU,SAAU8O,GAC1B,SAAK9K,EAAQ8K,KACT2C,EAAQ3C,KACR0C,EAAS1C,KACTuC,EAAYvC,IACwB,mBAA1BA,EAAMsC,GACrB,C,8BCVA,IAK4C8G,EALxCvX,EAAiB,EAAQ,MACzBL,EAAiB,EAAQ,MACzBgX,EAAiB,EAAQ,MACzBC,EAAiB,EAAQ,MAEzBnW,EAAiBC,OAAOD,eAE5B8W,EAAiBnY,EAAOC,QAAU,SAAUoF,GAC3C,KAAM/C,gBAAgB6V,GAAiB,MAAM,IAAI3H,UAAU,8BAC3DnL,EAAMwR,OAAOxR,GACbmS,EAASpU,KAAKd,KAAM+C,GACpBhE,EAAeiB,KAAM,aAAc/B,EAAE,GAAI8E,EAAIJ,QAC9C,EACIrE,GAAgBA,EAAeuX,EAAgBX,UAG5CW,EAAe/W,UAAUsW,YAEhCS,EAAe/W,UAAYE,OAAOa,OAAOqV,EAASpW,UAAW,CAC5DyX,MAAOtY,GAAE,WACR,GAAK+B,KAAKuV,SACV,OAAIvV,KAAKkW,cAAgBlW,KAAK8W,WAAmB9W,KAAKkW,qBACtDlW,KAAK0W,SAEN,IACArB,SAAUpX,GAAE,SAAUoJ,GACrB,IAA6BnH,EAAzBnC,EAAOiC,KAAKuV,SAASlO,GACzB,OAAIrH,KAAKkW,gBAAkBlW,KAAK8W,WAAmB/Y,GACnDmC,EAAOnC,EAAK4R,WAAW,KACX,OAAUzP,GAAQ,MAAenC,EAAOiC,KAAKuV,SAASvV,KAAKkW,iBAChEnY,CACR,MAEDgB,EAAe8W,EAAe/W,UAAWmW,EAAOO,YAAavX,EAAE,IAAK,mB,8BCpCpE,IAAI8Y,EAAa,EAAQ,MAEzBrZ,EAAOC,QAAU,SAAU8O,GAC1B,IAAKsK,EAAWtK,GAAQ,MAAM,IAAIyB,UAAUzB,EAAQ,oBACpD,OAAOA,CACR,C,8BCLA/O,EAAOC,QAAU,EAAQ,KAAR,GACd,eACA,EAAQ,K,8BCFX,IAAIqZ,EAAa,EAAQ,MACrBC,EAAa,CAAE1Z,QAAQ,EAAMkW,QAAQ,GAEzC/V,EAAOC,QAAU,WAChB,IACI8V,EADAwB,EAAS+B,EAAO/B,OAEpB,GAAsB,mBAAXA,EAAuB,OAAO,EACzCxB,EAASwB,EAAO,eAChB,IAAMV,OAAOd,EAAS,CACtB,MAAOrG,GAAK,OAAO,CAAO,CAG1B,QAAK6J,SAAkBhC,EAAO1J,aACzB0L,SAAkBhC,EAAOiC,gBACzBD,SAAkBhC,EAAOO,YAG/B,C,wBCjBA9X,EAAOC,QAAU,SAAU8O,GAC1B,QAAKA,IACgB,iBAAVA,KACNA,EAAM2I,aACoB,WAA3B3I,EAAM2I,YAAY9I,MAC0B,WAAzCG,EAAMA,EAAM2I,YAAYI,aAChC,C,8BCNA,IAAIvX,EAAI,EAAQ,MAEZ4B,EAASb,OAAOa,OAAQd,EAAiBC,OAAOD,eAAgBoY,EAAenY,OAAOF,UAEtFsY,EAAUvX,EAAO,MACrBnC,EAAOC,QAAU,SAAU4O,GAE1B,IADA,IAAiBD,EAAM+K,EAAnBC,EAAU,EACPF,EAAQ7K,GAAQ+K,GAAW,QAAQA,EAiB1C,OAfAF,EADA7K,GAAQ+K,GAAW,KACH,EAEhBvY,EACCoY,EAFD7K,EAAO,KAAOC,EAGbtO,EAAE8B,GAAG,MAAM,SAAU0M,GAKhB4K,IACJA,GAAoB,EACpBtY,EAAeiB,KAAMsM,EAAMrO,EAAEwO,IAC7B4K,GAAoB,EACrB,KAEM/K,CACR,C,8BCzBA,IAAIrO,EAAe,EAAQ,MACvBsZ,EAAe,eAEnB7Z,EAAOC,QAAU,SAAU6Z,GAC1B,OAAOxY,OAAOsC,iBAAiBkW,EAAgB,CAG9CC,YAAaxZ,EACZ,GAAKsZ,GAAgBA,EAAaE,aAAgBD,EAAe,gBAElEE,mBAAoBzZ,EACnB,GACCsZ,GAAgBA,EAAaG,oBAC7BF,EAAe,uBAEjBjM,SAAUtN,EAAE,GAAKsZ,GAAgBA,EAAahM,UAAaiM,EAAe,aAC1EpQ,MAAOnJ,EAAE,GAAKsZ,GAAgBA,EAAanQ,OAAUoQ,EAAe,UACpEpW,QAASnD,EAAE,GAAKsZ,GAAgBA,EAAanW,SAAYoW,EAAe,YACxEG,OAAQ1Z,EAAE,GAAKsZ,GAAgBA,EAAaI,QAAWH,EAAe,WACtEI,QAAS3Z,EAAE,GAAKsZ,GAAgBA,EAAaK,SAAYJ,EAAe,YACxE9U,MAAOzE,EAAE,GAAKsZ,GAAgBA,EAAa7U,OAAU8U,EAAe,UACpEN,YAAajZ,EACZ,GAAKsZ,GAAgBA,EAAaL,aAAgBM,EAAe,gBAElEhC,YAAavX,EACZ,GAAKsZ,GAAgBA,EAAa/B,aAAgBgC,EAAe,gBAElEK,YAAa5Z,EACZ,GAAKsZ,GAAgBA,EAAaM,aAAgBL,EAAe,iBAGpE,C,8BC/BA,IAAIvZ,EAAiB,EAAQ,MACzB6Z,EAAiB,EAAQ,MAEzBC,EAAW/Y,OAAOa,OAAO,MAE7BnC,EAAOC,QAAU,SAAU6Z,GAC1B,OAAOxY,OAAOsC,iBAAiBkW,EAAgB,CAC9CQ,IAAK/Z,GAAE,SAAUkD,GAChB,OAAI4W,EAAS5W,GAAa4W,EAAS5W,GAC3B4W,EAAS5W,GAAOqW,EAAejD,OAAOpT,GAC/C,IACA8W,OAAQha,GAAE,SAAUwV,GACnB,IAAItS,EAEJ,IAAKA,KADL2W,EAAerE,GACHsE,EACX,GAAIA,EAAS5W,KAASsS,EAAQ,OAAOtS,CAGvC,KAEF,C,8BClBA,IAWIqW,EAAgBU,EAAcC,EAX9Bla,EAAuB,EAAQ,MAC/B6Z,EAAuB,EAAQ,MAC/BP,EAAuB,eACvBa,EAAuB,EAAQ,MAC/BC,EAAuB,EAAQ,MAC/BC,EAAuB,EAAQ,MAE/BzY,EAASb,OAAOa,OAChByB,EAAmBtC,OAAOsC,iBAC1BvC,EAAiBC,OAAOD,eAI5B,GAA4B,mBAAjBwY,EACV,IACChD,OAAOgD,KACPY,GAAe,CAChB,CAAE,MAAOlH,GAAS,MAElBsG,EAAe,KAKhBW,EAAe,SAAgBK,GAC9B,GAAIvY,gBAAgBkY,EAAc,MAAM,IAAIhK,UAAU,+BACtD,OAAOsJ,EAAee,EACvB,EAIA7a,EAAOC,QAAU6Z,EAAiB,SAASvC,EAAOsD,GACjD,IAAI9E,EACJ,GAAIzT,gBAAgBiV,EAAQ,MAAM,IAAI/G,UAAU,+BAChD,OAAIiK,EAAqBZ,EAAagB,IACtC9E,EAAS5T,EAAOqY,EAAapZ,WAC7ByZ,OAA8B/M,IAAhB+M,EAA4B,GAAKhE,OAAOgE,GAC/CjX,EAAiBmS,EAAQ,CAC/B+E,gBAAiBva,EAAE,GAAIsa,GACvBE,SAAUxa,EAAE,GAAIma,EAAaG,MAE/B,EAEAF,EAAqBb,GACrBc,EAAoBd,GAGpBlW,EAAiB4W,EAAapZ,UAAW,CACxCsW,YAAanX,EAAEuZ,GACftG,SAAUjT,EAAE,IAAI,WAAc,OAAO+B,KAAKyY,QAAU,MAKrDnX,EAAiBkW,EAAe1Y,UAAW,CAC1CoS,SAAUjT,GAAE,WAAc,MAAO,WAAa6Z,EAAe9X,MAAMwY,gBAAkB,GAAK,IAC1FE,QAASza,GAAE,WAAc,OAAO6Z,EAAe9X,KAAO,MAEvDjB,EACCyY,EAAe1Y,UAAW0Y,EAAeN,YACzCjZ,EAAE,IAAI,WACL,IAAIwV,EAASqE,EAAe9X,MAC5B,MAAsB,iBAAXyT,EAA4BA,EAChCA,EAAOvC,UACf,KAEDnS,EAAeyY,EAAe1Y,UAAW0Y,EAAehC,YAAavX,EAAE,IAAK,WAG5Ec,EACCmZ,EAAapZ,UAAW0Y,EAAehC,YACvCvX,EAAE,IAAKuZ,EAAe1Y,UAAU0Y,EAAehC,eAOhDzW,EACCmZ,EAAapZ,UAAW0Y,EAAeN,YACvCjZ,EAAE,IAAKuZ,EAAe1Y,UAAU0Y,EAAeN,c,8BClFhD,IAAIyB,EAAW,EAAQ,MAEvBjb,EAAOC,QAAU,SAAU8O,GAC1B,IAAKkM,EAASlM,GAAQ,MAAM,IAAIyB,UAAUzB,EAAQ,oBAClD,OAAOA,CACR,C,8BCLA,IASI0J,EAAIyC,EAAMhC,EAAKiC,EAAMC,EAASC,EAAa9K,EAT3ChQ,EAAW,EAAQ,MACnB8M,EAAW,EAAQ,MAEnBjI,EAAQhD,SAAShB,UAAUgE,MAAOhC,EAAOhB,SAAShB,UAAUgC,KAC5DjB,EAASb,OAAOa,OAAQd,EAAiBC,OAAOD,eAChDuC,EAAmBtC,OAAOsC,iBAC1B+K,EAAiBrN,OAAOF,UAAUuN,eAClC2M,EAAa,CAAE1L,cAAc,EAAMC,YAAY,EAAOb,UAAU,GAuBpEkM,EAAO,SAAUK,EAAMC,GACtB,IAAIN,EAAMlY,EAUV,OARAqK,EAASmO,GACTxY,EAAOV,KACPmW,EAAGrV,KAAKd,KAAMiZ,EAAML,EAAO,WAC1BhC,EAAI9V,KAAKJ,EAAMuY,EAAML,GACrB9V,EAAMhC,KAAKoY,EAAUlZ,KAAMe,UAC5B,GAEA6X,EAAKO,mBAAqBD,EACnBlZ,IACR,EAoEA8Y,EAAU,CACT3C,GApGDA,EAAK,SAAU8C,EAAMC,GACpB,IAAIvR,EAeJ,OAbAoD,EAASmO,GAEJ7M,EAAevL,KAAKd,KAAM,UAK9B2H,EAAO3H,KAAKoZ,QAJZzR,EAAOqR,EAAWvM,MAAQ5M,EAAO,MACjCd,EAAeiB,KAAM,SAAUgZ,GAC/BA,EAAWvM,MAAQ,MAIf9E,EAAKsR,GACqB,iBAAftR,EAAKsR,GAAoBtR,EAAKsR,GAAMnX,KAAKoX,GACpDvR,EAAKsR,GAAQ,CAACtR,EAAKsR,GAAOC,GAFdvR,EAAKsR,GAAQC,EAIvBlZ,IACR,EAoFC4Y,KAAMA,EACNhC,IArEDA,EAAM,SAAUqC,EAAMC,GACrB,IAAIvR,EAAM0R,EAAWC,EAAWjS,EAIhC,GAFA0D,EAASmO,IAEJ7M,EAAevL,KAAKd,KAAM,UAAW,OAAOA,KAEjD,KADA2H,EAAO3H,KAAKoZ,QACFH,GAAO,OAAOjZ,KAGxB,GAAyB,iBAFzBqZ,EAAY1R,EAAKsR,IAGhB,IAAK5R,EAAI,EAAIiS,EAAYD,EAAUhS,KAAOA,EACpCiS,IAAcJ,GAChBI,EAAUH,qBAAuBD,IACV,IAArBG,EAAU1W,OAAcgF,EAAKsR,GAAQI,EAAUhS,EAAI,EAAI,GACtDgS,EAAUjT,OAAOiB,EAAG,SAItBgS,IAAcH,GAChBG,EAAUF,qBAAuBD,UAC5BvR,EAAKsR,GAId,OAAOjZ,IACR,EA4CC6Y,KA1CDA,EAAO,SAAUI,GAChB,IAAI5R,EAAGkS,EAAGL,EAAUG,EAAW3I,EAE/B,GAAKrE,EAAevL,KAAKd,KAAM,YAC/BqZ,EAAYrZ,KAAKoZ,OAAOH,IAGxB,GAAyB,iBAAdI,EAAwB,CAGlC,IAFAE,EAAIxY,UAAU4B,OACd+N,EAAO,IAAI7R,MAAM0a,EAAI,GAChBlS,EAAI,EAAGA,EAAIkS,IAAKlS,EAAGqJ,EAAKrJ,EAAI,GAAKtG,UAAUsG,GAGhD,IADAgS,EAAYA,EAAUjV,QACjBiD,EAAI,EAAI6R,EAAWG,EAAUhS,KAAOA,EACxCvE,EAAMhC,KAAKoY,EAAUlZ,KAAM0Q,EAE7B,MACC,OAAQ3P,UAAU4B,QAClB,KAAK,EACJ7B,EAAKA,KAAKuY,EAAWrZ,MACrB,MACD,KAAK,EACJc,EAAKA,KAAKuY,EAAWrZ,KAAMe,UAAU,IACrC,MACD,KAAK,EACJD,EAAKA,KAAKuY,EAAWrZ,KAAMe,UAAU,GAAIA,UAAU,IACnD,MACD,QAGC,IAFAwY,EAAIxY,UAAU4B,OACd+N,EAAO,IAAI7R,MAAM0a,EAAI,GAChBlS,EAAI,EAAGA,EAAIkS,IAAKlS,EACpBqJ,EAAKrJ,EAAI,GAAKtG,UAAUsG,GAEzBvE,EAAMhC,KAAKuY,EAAWrZ,KAAM0Q,GAG/B,GASAqI,EAAc,CACb5C,GAAIlY,EAAEkY,GACNyC,KAAM3a,EAAE2a,GACRhC,IAAK3Y,EAAE2Y,GACPiC,KAAM5a,EAAE4a,IAGT5K,EAAO3M,EAAiB,CAAC,EAAGyX,GAE5Brb,EAAOC,QAAUA,EAAU,SAAU6b,GACpC,OAAa,MAALA,EAAa3Z,EAAOoO,GAAQ3M,EAAiBtC,OAAOwa,GAAIT,EACjE,EACApb,EAAQmb,QAAUA,C,WCnIlB,IAAIW,EAAgB,WACnB,GAAoB,iBAAT/Y,MAAqBA,KAAM,OAAOA,KAC7C,GAAsB,iBAAXgZ,QAAuBA,OAAQ,OAAOA,OACjD,MAAM,IAAI3J,MAAM,kCACjB,EAEArS,EAAOC,QAAU,WAChB,GAAIqC,KAAM,OAAOA,KAOjB,IACChB,OAAOD,eAAeC,OAAOF,UAAW,aAAc,CACrD6N,IAAK,WAAc,OAAO3M,IAAM,EAChCsN,cAAc,GAEhB,CAAE,MAAOoF,GAER,OAAO+G,GACR,CACA,IAEC,OAAKE,YAAmBF,GAEzB,CAAE,eACMza,OAAOF,UAAU6a,UACzB,CACA,CAxBgB,E,8BCJjBjc,EAAOC,QAAU,EAAQ,KAAR,GAAgCic,WAAa,EAAQ,K,wBCAtElc,EAAOC,QAAU,WAChB,MAA0B,iBAAfic,cACNA,YACEA,WAAW/a,QAAUA,KAC7B,C,WCHA,SAASgb,EAAUlU,GACjB,QAASA,IAAuB,iBAARA,GAAmC,mBAARA,IAA2C,mBAAbA,EAAImU,IACvF,CALApc,EAAOC,QAAUkc,EACjBnc,EAAOC,QAAP,QAAyBkc,C,8BCCzB,IAAIzL,EAAW,EAAQ,MAEnBvO,EAASb,OAAOa,OAAQwM,EAAiBrN,OAAOF,UAAUuN,eAE9D3O,EAAOC,QAAU,SAAUoc,GAC1B,IAA6EC,EAAzEC,EAAO,EAAGhM,EAAO,EAAGiM,EAAQra,EAAO,MAAOzB,EAAMyB,EAAO,MAAOmD,EAAQ,EAE1E,OADA+W,EAAQ3L,EAAS2L,GACV,CACNI,IAAK,SAAU7I,GACd,IAAI8I,EAAWhc,EAAIkT,GAAK+I,IAAYrX,EAGpC,GAFAkX,EAAMG,GAAW/I,EACjBlT,EAAIkT,GAAM+I,GACLD,EAAU,CAEd,KADEH,GACUF,EAAO,OAGnB,OAFAzI,EAAK4I,EAAMjM,GACX+L,EAAI1I,GACGA,CACR,CAEA,UADO4I,EAAME,GACTnM,IAASmM,EACb,MAAQ/N,EAAevL,KAAKoZ,IAASjM,YACtC,EACAqM,OAAQN,EAAM,SAAU1I,GACvB,IAAI8I,EAAWhc,EAAIkT,GACnB,GAAK8I,WACEF,EAAME,UACNhc,EAAIkT,KACT2I,EACEhM,IAASmM,GAAb,CACA,IAAKH,EAGJ,OAFAjX,EAAQ,OACRiL,EAAO,GAGR,MAAQ5B,EAAevL,KAAKoZ,IAASjM,YANR,CAO9B,EACA6H,MAAO,WACNmE,EAAO,EACPhM,EAAO,EACPiM,EAAQra,EAAO,MACfzB,EAAMyB,EAAO,MACbmD,EAAQ,CACT,EAEF,C,8BCzCA,IAAImN,EAAe,EAAQ,MACvBoK,EAAe,EAAQ,KACvB3J,EAAe,EAAQ,MACvB4J,EAAe,EAAQ,MACvBC,EAAe,EAAQ,MAEvBrW,EAAQvF,MAAMC,UAAUsF,MAAOtB,EAAQhD,SAAShB,UAAUgE,MAAOjD,EAASb,OAAOa,OAErF,cAAgD,SAAU6a,EAAK1Z,GAC9D,IAII2Z,EACAC,EACAC,EANAC,EAAUjb,EAAO,MACjBgR,EAAQhR,EAAO,MACfoO,EAAOjN,EAAKxB,SACZub,EAAW/Z,EAAK+Z,SAMpB/Z,EAAKxB,SAAWgb,GAAa,SAAUnK,GACtC,IAAIK,EAAO3P,UAAWia,EAAOtK,EAAKA,EAAK/N,OAAS,GAKhD,MAJoB,mBAATqY,IACVL,EAAkBK,EAClBtK,EAAOtM,EAAMtD,KAAK4P,EAAM,GAAI,IAEtBzC,EAAKnL,MAAM8X,EAAiB5a,KAAM6a,EAAcnK,EACxD,GAAGzC,GACH,IAAM2C,EAAM5P,EAAKxB,SAAUyO,EAAO,CAClC,MAAOgD,GAAS,CAGhBjQ,EAAKmV,GAAG,OAAO,SAAU7E,GACxB,IAAI5C,EAAIsH,EAAStF,EACjB,GAAKiK,EAAL,CAGA,GAAIG,EAAQxJ,GAIX,MAH2B,mBAAhBwJ,EAAQxJ,GAAoBwJ,EAAQxJ,GAAM,CAACwJ,EAAQxJ,GAAKqJ,GAC9DG,EAAQxJ,GAAIxP,KAAK6Y,QACtBA,EAAkB,MAKnBjM,EAAKiM,EACL3E,EAAU4E,EACVlK,EAAOmK,EACPF,EAAkBC,EAAiBC,EAAc,KACjDJ,GAAS,WACR,IAAI9S,EACA0E,eAAevL,KAAK+P,EAAOS,IAC9B3J,EAAOkJ,EAAMS,GACbtQ,EAAK6X,KAAK,WAAYvH,EAAIZ,EAAMsF,GAChClT,EAAMhC,KAAK4N,EAAI/G,EAAKqO,QAASrO,EAAK+I,QAGlCiK,EAAkBjM,EAClBkM,EAAiB5E,EACjB6E,EAAcnK,EACdzC,EAAKnL,MAAMkT,EAAStF,GAEtB,GA5B4B,CA6B7B,IAGA1P,EAAK+Z,SAAW,WACf,IAAIrK,EAAMhC,EAAIuM,EAAQnd,EACtB,OAAK6c,GACLjK,EAAOP,EAAMpP,WACb2N,EAAK,SAAShO,EAAKuP,GAClB,IAAIvB,EAAIgC,EAAMY,EAAK5Q,EAAK4Q,GACxB,GAAU,MAANA,GAQJ,UAHO5Q,EAAK4Q,GACZ5C,EAAKoM,EAAQxJ,UACNwJ,EAAQxJ,GACV5C,EAmBL,OAdAgC,EAAOP,EAAMpP,WACTC,EAAKka,IAAI5J,KACRrB,EACHjP,EAAKsZ,OAAOhJ,IAEZT,EAAMS,GAAM,CAAE0E,QAAShW,KAAM0Q,KAAMA,GACnC1P,EAAK6X,KAAK,WAAYvH,EAAkB,mBAAP5C,EAAoB,EAAIA,EAAG/L,UAG5C,mBAAP+L,EACV5Q,EAASgF,EAAMhC,KAAK4N,EAAI1O,KAAM0Q,GAE9BhC,EAAGvQ,SAAQ,SAAUuQ,GAAM5Q,EAASgF,EAAMhC,KAAK4N,EAAI1O,KAAM0Q,EAAO,GAAG1Q,MAE7DlC,OAzBN2c,EAAS3X,EAAMsJ,KAAK1L,EAAMV,KAAMe,WA0BlC,EACAka,EAASN,EACTA,EAAkBC,EAAiBC,EAAc,KACjDnK,EAAK5O,KAAK4M,GACV5Q,EAASgF,EAAMhC,KAAKia,EAAU/a,KAAM0Q,GACpChC,EAAGA,GAAKuM,EACRN,EAAkBjM,EACX5Q,GAvCsBgF,EAAMhC,KAAKia,EAAU/a,KAAMe,UAwCzD,EAGAC,EAAKmV,GAAG,OAAO,SAAU7E,GACnBqJ,GAIDG,EAAQxJ,GAEgB,mBAAhBwJ,EAAQxJ,GAAoBwJ,EAAQxJ,GAAM,CAACwJ,EAAQxJ,GAAKqJ,EAAgBjM,IAC9EoM,EAAQxJ,GAAIxP,KAAK6Y,EAAgBjM,IAEtCoM,EAAQxJ,GAAMqJ,EAAgBjM,UAExBiM,EAAgBjM,GACvBiM,EAAgBrJ,GAAKA,EACrBqJ,EAAkB,MAZjB3Z,EAAKsZ,OAAOhJ,EAad,IAGAtQ,EAAKmV,GAAG,UAAU,SAAU7E,GAC3B,IAAIxT,EAIAuO,eAAevL,KAAKga,EAASxJ,IAC5BT,EAAMS,KACXxT,EAAS+S,EAAMS,UACRT,EAAMS,GACbtQ,EAAK6X,KAAK,cAAevH,EAAIlN,EAAMtD,KAAKhD,EAAO4S,KAAM,IACtD,IAGA1P,EAAKmV,GAAG,SAAS,WAChB,IAAIgF,EAAWtK,EACfA,EAAQhR,EAAO,MACfmB,EAAK6X,KACJ,aAAc0B,EAAUY,GAAU,SAAUxT,GAAQ,OAAOvD,EAAMtD,KAAK6G,EAAK+I,KAAM,EAAI,IAEvF,GACD,C,8BCrJA,IAAI3F,EAAa,EAAQ,MACrB5M,EAAa,EAAQ,MACrBid,EAAa,EAAQ,MAErBtY,EAAQhD,SAAShB,UAAUgE,MAE/BsY,EAAWC,QAAU,SAAUA,EAASra,EAAMgB,GAC7C,IAAIgY,EAEJ,GADAjP,EAASsQ,GACJrZ,EAAQsZ,OAASF,EAAWE,OAAWtZ,EAAQuZ,SAAWH,EAAWG,QASzE,OARAva,EAAKmV,GAAG,cAAe6D,EAAM,SAAU1I,EAAIkK,GAC1C1Y,EAAMhC,KAAKua,EAAS,KAAMG,EAC3B,QACAxa,EAAKmV,GAAG,cAAc,SAAUtF,GAC/B1S,EAAQ0S,GAAO,SAAU/S,EAAQwT,GACnC0I,EAAI1I,EAAIxT,EACT,GACE,IAGDkD,EAAKmV,GAAG,SAAU6D,EAAM,SAAU1I,EAAIxT,GACtCud,EAAQvd,EACT,GACCkD,EAAKmV,GAAG,SAAS,SAAUtF,GAC1B1S,EAAQ0S,GAAO,SAAU/S,EAAQwT,GAClC0I,EAAI1I,EAAIxT,EACT,GACC,GACD,C,8BC1BA,IAAIqS,EAAa,EAAQ,MACrBhS,EAAa,EAAQ,MACrBsc,EAAa,EAAQ,MACrBZ,EAAa,EAAQ,MACrB4B,EAAa,EAAQ,KACrBL,EAAa,EAAQ,MAErBM,EAAO5b,SAAShB,UAAWG,EAAMC,KAAKD,IAAKE,EAAMD,KAAKC,IAAKU,EAASb,OAAOa,OAE/Eub,EAAWO,OAAS,SAAUA,EAAQ3a,EAAMgB,GAC3C,IAAI4Z,EAAUtE,EAASuE,EAAaC,GAEpCH,EAASF,EAAQE,MAGjBC,EAAW/b,EAAO,MAClByX,EACEtV,EAAQsZ,OAASF,EAAWE,OAAWtZ,EAAQuZ,SAAWH,EAAWG,QACnE,QACA,GACJva,EAAKmV,GAAG,MAAQmB,GAAS,SAAUhG,GAClCsK,EAAStK,GAAMyK,YAAW,WAAc/a,EAAKsZ,OAAOhJ,EAAK,GAAGqK,GAC1B,mBAAvBC,EAAStK,GAAI0K,OAAsBJ,EAAStK,GAAI0K,QACtDF,IACDA,EAAiBxK,IACS,aAAzBwK,EAAiBxK,IAAoB2K,aAAaH,EAAiBxK,IAExEwK,EAAiBxK,GAAMyK,YAAW,kBAC1BD,EAAiBxK,EACzB,GAAGuK,GACuC,mBAA/BC,EAAiBxK,GAAI0K,OAAsBF,EAAiBxK,GAAI0K,QAC5E,IACAhb,EAAKmV,GAAG,SAAWmB,GAAS,SAAUhG,GACrC2K,aAAaL,EAAStK,WACfsK,EAAStK,GACXwK,IACwB,aAAzBA,EAAiBxK,IAAoB2K,aAAaH,EAAiBxK,WAChEwK,EAAiBxK,GACzB,IAEItP,EAAQka,WAEVL,GADwB,IAArB7Z,EAAQka,UAAqB/b,MAAM6B,EAAQka,UAChC,KAEAjd,EAAIE,EAAIyH,OAAO5E,EAAQka,UAAW,GAAI,MAGpDJ,EAAmB,CAAC,EACpBD,GAAe,EAAIA,GAAeF,EAClC3a,EAAKmV,GAAG,MAAQmB,GAAS,SAAUhG,EAAIZ,EAAMsF,GACvC8F,EAAiBxK,KACrBwK,EAAiBxK,GAAM,WACvBmJ,GAAS,WACR,IAAI3c,EACyB,aAAzBge,EAAiBxK,YACdwK,EAAiBxK,GACxBtQ,EAAKsZ,OAAOhJ,GACRtP,EAAQsZ,QACX5K,EAAOP,EAAMO,IACR5O,KAAK4Z,GAEX5d,EAASkD,EAAKxB,SAASsD,MAAMkT,EAAStF,GAClC1O,EAAQuZ,SAEP1B,EAAU/b,KACc,mBAAhBA,EAAO4R,KAAqB5R,EAAO4R,KAAKgM,EAAMA,GACpD5d,EAAOgc,KAAK4B,EAAMA,IAG1B,IAEF,KAIF1a,EAAKmV,GAAG,QAAUmB,GAAS,WAC1BnZ,EAAQyd,GAAU,SAAUtK,GAAM2K,aAAa3K,EAAK,IACpDsK,EAAW,CAAC,EACRE,IACH3d,EAAQ2d,GAAkB,SAAUxK,GAAiB,aAAPA,GAAmB2K,aAAa3K,EAAK,IACnFwK,EAAmB,CAAC,EAEtB,IACD,C,8BCrFA,IAAIK,EAAe,EAAQ,MACvBC,EAAe,EAAQ,MACvBhB,EAAe,EAAQ,MAE3BA,EAAWnc,IAAM,SAAUA,EAAK+B,EAAMgB,GACrC,IAAIsV,EAAS4C,EAAOC,GAEpBlb,EAAMkd,EAAald,MAGnBib,EAAQkC,EAASnd,GACjBqY,EAAWtV,EAAQsZ,OAASF,EAAWE,OAAWtZ,EAAQuZ,SAAWH,EAAWG,QAC7E,QAAU,GAEbva,EAAKmV,GAAG,MAAQmB,EAAS6C,EAAM,SAAU7I,QAE7B9F,KADX8F,EAAK4I,EAAMC,IAAI7I,KAEftQ,EAAKsZ,OAAOhJ,EACb,GACAtQ,EAAKmV,GAAG,MAAQmB,EAAS6C,GACzBnZ,EAAKmV,GAAG,SAAWmB,EAAS4C,EAAMI,QAClCtZ,EAAKmV,GAAG,QAAUmB,EAAS4C,EAAMpE,OAClC,C,8BCpBA,IAAIyE,EAAgB,EAAQ,KACxBlc,EAAgB,EAAQ,MACxBge,EAAgB,EAAQ,MACxBC,EAAgB,EAAQ,MACxBzC,EAAgB,EAAQ,MACxBY,EAAgB,EAAQ,MAExB5a,EAASb,OAAOa,OAChB0c,EAAiBle,EAAa,OAAQ,eAAgB,OAAQ,gBAElE,gBAAkD,SAAUqX,EAAM1U,GACjE,IAAI8Z,EAAUjb,EAAO,MAAOgR,EAAQhR,EAAO,MAAO2c,EAAW3c,EAAO,MAEpE,IAAa,IAAT6V,EACHA,EAAO,UAGP,GADAA,EAAO2G,EAAa3G,IACf6G,EAAe7G,GACnB,MAAM,IAAIxH,UAAU,IAAMoO,EAAc5G,GAAQ,+BAKlD1U,EAAKmV,GAAG,OAAO,SAAU7E,EAAIL,EAAQsK,GACpC,IAAIkB,GAAW,EAEf,IAAK5C,EAAU0B,GAId,OAFA1K,EAAMS,GAAMiK,OACZva,EAAK6X,KAAK,WAAYvH,EAAI,GAG3BwJ,EAAQxJ,GAAM,EACdkL,EAASlL,GAAMiK,EACf,IAAImB,EAAY,SAAU5e,GACzB,IAAI2W,EAAQqG,EAAQxJ,GACpB,GAAImL,EACH,MAAM,IAAI1M,MACT,2NAMG0E,WACEqG,EAAQxJ,GACfT,EAAMS,GAAMxT,EACZkD,EAAK6X,KAAK,WAAYvH,EAAImD,GAC3B,EACIkI,EAAY,WACfF,GAAW,EACN3B,EAAQxJ,YACNwJ,EAAQxJ,UACRkL,EAASlL,GAChBtQ,EAAKsZ,OAAOhJ,GACb,EAEIsL,EAAelH,EAGnB,GAFKkH,IAAcA,EAAe,QAEb,SAAjBA,EAAyB,CAC5B,IAAIC,EAAkB,WAAcpC,EAASkC,EAAY,EAO1B,mBAJ/BpB,EAAUA,EAAQzB,MAAK,SAAUhc,GAChC2c,EAASiC,EAAUtQ,KAAKpM,KAAMlC,GAC/B,GAAG+e,IAEgBC,SAClBvB,EAAQuB,QAAQD,EAElB,MAAO,GAAqB,SAAjBD,EAAyB,CAEnC,GAA4B,mBAAjBrB,EAAQ7L,KAClB,MAAM,IAAIK,MACT,8EAIFwL,EAAQ7L,KAAKgN,EAAWC,EACzB,MAAO,GAAqB,iBAAjBC,EAAiC,CAG3C,GAA4B,mBAAjBrB,EAAQ7L,KAClB,MAAM,IAAIK,MACT,sFAIF,GAA+B,mBAApBwL,EAAQuB,QAClB,MAAM,IAAI/M,MACT,yFAIFwL,EAAQ7L,KAAKgN,GACbnB,EAAQuB,QAAQH,EACjB,CACD,IAGA3b,EAAKmV,GAAG,OAAO,SAAU7E,EAAIZ,EAAMsF,GAClC,IAAIuF,EACJ,GAAIT,EAAQxJ,KACTwJ,EAAQxJ,OADX,CAIAiK,EAAUiB,EAASlL,GACnB,IAAIuH,EAAO,WAAc7X,EAAK6X,KAAK,WAAYvH,EAAIZ,EAAMsF,EAAU,EAC/D6D,EAAU0B,GACe,mBAAjBA,EAAQ7L,KAAqB6L,EAAQ7L,KAAKmJ,GAEpD0C,EAAQzB,MAAK,WAAcW,EAAS5B,EAAO,IAG5CA,GATD,CAWD,IAGA7X,EAAKmV,GAAG,UAAU,SAAU7E,GAE3B,UADOkL,EAASlL,GACZwJ,EAAQxJ,UACJwJ,EAAQxJ,QAGhB,GAAKjF,eAAevL,KAAK+P,EAAOS,GAAhC,CACA,IAAIxT,EAAS+S,EAAMS,UACZT,EAAMS,GACbtQ,EAAK6X,KAAK,cAAevH,EAAI,CAACxT,GAHa,CAI5C,IAGAkD,EAAKmV,GAAG,SAAS,WAChB,IAAIgF,EAAWtK,EACfA,EAAQhR,EAAO,MACfib,EAAUjb,EAAO,MACjB2c,EAAW3c,EAAO,MAClBmB,EAAK6X,KAAK,aAAc0B,EAAUY,GAAU,SAAUxT,GAAQ,MAAO,CAACA,EAAO,IAC9E,GACD,C,8BC9IA,IAAI1J,EAAa,EAAQ,MACrBmd,EAAa,EAAQ,MAErBvb,EAASb,OAAOa,OAAQyB,EAAmBtC,OAAOsC,iBAEtD8Z,EAAW2B,WAAa,SAAU9L,EAAQjQ,EAAMgB,GAC/C,IAAI6O,EAAOyG,EAEXzG,EAAQhR,EAAO,MACfyX,EAAWtV,EAAQsZ,OAASF,EAAWE,OAAWtZ,EAAQuZ,SAAWH,EAAWG,QAC7E,QAAU,GAEbva,EAAKmV,GAAG,MAAQmB,GAAS,SAAUhG,EAAI3O,GACvCkO,EAAMS,GAAM3O,GAAU,CACvB,IACC3B,EAAKmV,GAAG,MAAQmB,GAAS,SAAUhG,KACjCT,EAAMS,EACT,IACCtQ,EAAKmV,GAAG,SAAWmB,GAAS,SAAUhG,UAC/BT,EAAMS,EACd,IACCtQ,EAAKmV,GAAG,QAAUmB,GAAS,WAC3BzG,EAAQ,CAAC,CACV,IAECvP,EAAiBN,EAAKxB,SAAU,CAC/Bwd,UAAW/e,GAAE,WACZ,IAAIqT,EAAKtQ,EAAK2L,IAAI5L,WAClB,OAAW,OAAPuQ,EAAoB,KACnBT,EAAMS,OACJT,EAAMS,KACZtQ,EAAKsZ,OAAOhJ,IACL,GAHe,IAMxB,IACA2L,YAAahf,GAAE,WACd,IAAIqT,EAAKtQ,EAAK2L,IAAI5L,WAClB,OAAW,OAAPuQ,EAAoB,EACnBT,EAAMS,GACJT,EAAMS,GADU,CAExB,KAEF,C,8BC7CA,IAAItE,EAAgB,EAAQ,KACxBkQ,EAAgB,EAAQ,MACxBC,EAAgB,EAAQ,MAE5Bzf,EAAOC,QAAU,SAAU2S,GAC1B,IAA2C3N,EAAvCX,EAAUgL,EAAcjM,UAAU,IAyBtC,OAvBKiB,EAAQob,YAEG,KADfza,EAASX,EAAQW,OAASua,EAAclb,EAAQW,OAAQ2N,EAAG3N,OAAQX,EAAQsZ,UAEtEtZ,EAAQvB,WACI,IAAXkC,EACHX,EAAQob,WAAa,EAAQ,MACnBza,EAAS,IACnBX,EAAQob,WAAa,EAAQ,KAAR,CAA6Cza,IAEvCX,EAAQob,YAAf,IAAXza,EAAuC,EAAQ,KAAR,GAC7B,IAAXA,EAAmC,EAAQ,KAAR,GAClB,EAAQ,KAAR,CAAmCA,IAK5DX,EAAQsZ,OAAO,EAAQ,MACvBtZ,EAAQuZ,SAAS,EAAQ,MACzBvZ,EAAQqZ,SAAS,EAAQ,MACzBrZ,EAAQ2Z,QAAQ,EAAQ,MACxB3Z,EAAQ/C,KAAK,EAAQ,MACrB+C,EAAQ+a,YAAY,EAAQ,MAEzBI,EAAM7M,EAAItO,EAClB,C,8BC7BA,IAAIqb,EAAmB,EAAQ,MAC3B7C,EAAmB,EAAQ,MAC3Bvc,EAAmB,EAAQ,MAC3Bqf,EAAmB,gBACnBC,EAAmB,EAAQ,MAC3BC,EAAmB,EAAQ,KAE3B1a,EAAQhD,SAAShB,UAAUgE,MAC3BhC,EAAOhB,SAAShB,UAAUgC,KAC1BjB,EAASb,OAAOa,OAChByB,EAAmBtC,OAAOsC,iBAC1B6U,EAAKmH,EAAGnH,GACR0C,EAAOyE,EAAGzE,KAEdnb,EAAOC,QAAU,SAAUod,EAAUpY,EAAQX,GAC5C,IACIhB,EACAyc,EACA9Q,EACAa,EACAwM,EACAlE,EACA4H,EACAC,EACAC,EACAR,EACAS,EACAC,EACAC,EACAve,EACAwe,EAfAnN,EAAQhR,EAAO,MAiKnB,OAjJsB4d,GAAP,IAAX9a,EAA8BA,EACzBxC,MAAM4a,EAASpY,QAAqB,EAC5BoY,EAASpY,OAEtBX,EAAQob,aACXA,EAAaI,EAAiBxb,EAAQob,YACtCzQ,EAAMyQ,EAAWzQ,IACjBa,EAAM4P,EAAW5P,IACjBwM,EAAMoD,EAAW9C,OACjBxE,EAAQsH,EAAWtH,OAEK,MAArB9T,EAAQic,YAAmBD,EAAUT,EAAevb,EAAQic,YAG/Dze,EADGmN,EACQ6N,GAAa,SAAUnK,GACjC,IAAIiB,EAAIxT,EAAQ4S,EAAO3P,UAGvB,GAFIid,IAAStN,EAAOsN,EAAQtN,IAEjB,QADXY,EAAK3E,EAAI+D,KAEJrE,eAAevL,KAAK+P,EAAOS,GAE9B,OADIuM,GAAc7c,EAAK6X,KAAK,MAAOvH,EAAIZ,EAAM1Q,MACtC6Q,EAAMS,GAKf,GAFuBxT,EAAH,IAAhB4S,EAAK/N,OAAuB7B,EAAKA,KAAKia,EAAU/a,KAAM0Q,EAAK,IACjD5N,EAAMhC,KAAKia,EAAU/a,KAAM0Q,GAC9B,OAAPY,EAAa,CAEhB,GAAW,QADXA,EAAK3E,EAAI+D,IACQ,MAAM2M,EAAY,sBAAuB,uBAC1D/L,EAAK9D,EAAIkD,EACV,MAAO,GAAIrE,eAAevL,KAAK+P,EAAOS,GACrC,MAAM+L,EAAY,sBAAuB,uBAI1C,OAFAxM,EAAMS,GAAMxT,EACRggB,GAAc9c,EAAK6X,KAAK,MAAOvH,EAAI,KAAMxT,GACtCA,CACR,GAAG2f,GACkB,IAAX9a,EACC,WACV,IAAI7E,EACJ,GAAIuO,eAAevL,KAAK+P,EAAO,QAE9B,OADIgN,GAAc7c,EAAK6X,KAAK,MAAO,OAAQ9X,UAAWf,MAC/C6Q,EAAMlJ,KAId,GAFsB7J,EAAlBiD,UAAU4B,OAAiBG,EAAMhC,KAAKia,EAAU/a,KAAMe,WAC5CD,EAAKA,KAAKia,EAAU/a,MAC9BqM,eAAevL,KAAK+P,EAAO,QAC9B,MAAMwM,EAAY,sBAAuB,uBAI1C,OAFAxM,EAAMlJ,KAAO7J,EACTggB,GAAc9c,EAAK6X,KAAK,MAAO,OAAQ,KAAM/a,GAC1CA,CACR,EAEW,SAAUuS,GACpB,IAAIvS,EAA0BwT,EAAlBZ,EAAO3P,UAGnB,GAFIid,IAAStN,EAAOsN,EAAQjd,YAC5BuQ,EAAKiD,OAAO7D,EAAK,IACbrE,eAAevL,KAAK+P,EAAOS,GAE9B,OADIuM,GAAc7c,EAAK6X,KAAK,MAAOvH,EAAIZ,EAAM1Q,MACtC6Q,EAAMS,GAId,GAFuBxT,EAAH,IAAhB4S,EAAK/N,OAAuB7B,EAAKA,KAAKia,EAAU/a,KAAM0Q,EAAK,IACjD5N,EAAMhC,KAAKia,EAAU/a,KAAM0Q,GACrCrE,eAAevL,KAAK+P,EAAOS,GAC9B,MAAM+L,EAAY,sBAAuB,uBAI1C,OAFAxM,EAAMS,GAAMxT,EACRggB,GAAc9c,EAAK6X,KAAK,MAAOvH,EAAI,KAAMxT,GACtCA,CACR,EAEDkD,EAAO,CACN+Z,SAAUA,EACVvb,SAAUA,EACV0e,YAAalc,EAAQkc,YACrBvR,IAAK,SAAU+D,GAEd,OADIsN,IAAStN,EAAOsN,EAAQtN,IACxB/D,EAAYA,EAAI+D,GACb6D,OAAO7D,EAAK,GACpB,EACAwK,IAAK,SAAU5J,GAAM,OAAOjF,eAAevL,KAAK+P,EAAOS,EAAK,EAC5DgJ,OAAQ,SAAUhJ,GACjB,IAAIxT,EACCuO,eAAevL,KAAK+P,EAAOS,KAC5B0I,GAAKA,EAAI1I,GACbxT,EAAS+S,EAAMS,UACRT,EAAMS,GACTyM,GAAiB/c,EAAK6X,KAAK,SAAUvH,EAAIxT,GAC9C,EACAgY,MAAO,WACN,IAAIqF,EAAWtK,EACXiF,GAAOA,IACXjF,EAAQhR,EAAO,MACfmB,EAAK6X,KAAK,QAASsC,EACpB,EACAhF,GAAI,SAAU8C,EAAMC,GAInB,MAHa,QAATD,EAAgB4E,GAAe,EACjB,QAAT5E,EAAgB6E,GAAe,EACtB,WAAT7E,IAAmB8E,GAAkB,GACvC5H,EAAGrV,KAAKd,KAAMiZ,EAAMC,EAC5B,EACAL,KAAMA,EACNsF,UAAW,WAAcpD,EAAW/Z,EAAK+Z,QAAU,GAGnD2C,EADG/Q,EACM6N,GAAa,SAAUnK,GAC/B,IAAIiB,EAAIZ,EAAO3P,UACXid,IAAStN,EAAOsN,EAAQtN,IAEjB,QADXY,EAAK3E,EAAI+D,KAET1P,EAAKsZ,OAAOhJ,EACb,GAAGmM,GACkB,IAAX9a,EACD,WAAc,OAAO3B,EAAKsZ,OAAO,OAAS,EAE1C,SAAUjK,GAElB,OADI2N,IAAS3N,EAAM2N,EAAQjd,WAAW,IAC/BC,EAAKsZ,OAAOjK,EACpB,EAEDsN,EAASnD,GAAa,WACrB,IAAIlJ,EAAIZ,EAAO3P,UACf,OAAe,IAAX4B,EAAqBkO,EAAMlJ,MAC3BqW,IAAStN,EAAOsN,EAAQtN,IACnBY,EAAL3E,EAAUA,EAAI+D,GACR6D,OAAO7D,EAAK,IACfG,EAAMS,GACd,IACAsM,EAASpD,GAAa,WACrB,IAAIlJ,EAAIZ,EAAO3P,UACf,OAAe,IAAX4B,EAAqB3B,EAAKka,IAAI,SAC9B8C,IAAStN,EAAOsN,EAAQtN,IAGjB,QAFFY,EAAL3E,EAAUA,EAAI+D,GACR6D,OAAO7D,EAAK,MAEf1P,EAAKka,IAAI5J,GACjB,IACAhQ,EAAiB9B,EAAU,CAC1B4e,aAAcngB,GAAE,GAChBqc,OAAQrc,EAAEyf,GACV5H,MAAO7X,EAAE+C,EAAK8U,OACduI,KAAMpgB,EAAE0f,GACRW,KAAMrgB,EAAE2f,KAEF5c,CACR,C,8BCnLA,IAAI7C,EAAgB,EAAQ,MACxB6O,EAAgB,EAAQ,KACxBjC,EAAgB,EAAQ,MACxBwT,EAAgB,EAAQ,MACxBrB,EAAgB,EAAQ,MACxB9B,EAAgB,EAAQ,MAE5B1d,EAAOC,QAAU,SAAUY,GAC1B,OAAO,SAAUuO,GAmBhB,OAlBA3O,EAAQ2O,GAAO,SAAUP,GACxB,IAA+B5J,EAA3B2N,EAAKvF,EAASwB,EAAKE,OACvBF,EAAKE,MAAQ,SAAUzK,GAatB,OAZIA,EAAQwc,gBACXxc,EAAUgL,EAAchL,QACTwJ,IAAX7I,IACHA,EAASua,EACRlb,EAAQW,OACR2N,EAAG3N,OACHX,EAAQsZ,OAASF,EAAWE,QAG9BtZ,EAAQob,WAAapb,EAAQwc,cAAc7b,UACpCX,EAAQwc,eAETjgB,EAAQ+R,EAAGlE,KAAKpM,MAAOgC,EAC/B,CACD,IACOuc,EAAKzR,EACb,CACD,C,0CC7BA,IAAIsB,EAAW,EAAQ,MAEvB1Q,EAAOC,QAAU,SAAU8gB,EAAYC,EAAUC,GAChD,IAAIhc,EACJ,OAAIxC,MAAMse,IACT9b,EAAS+b,IACO,EACZC,GAAWhc,EAAeA,EAAS,EAChCA,EAFoB,GAIT,IAAf8b,GACGrQ,EAASqQ,EACjB,C,6BCZA,IAAI1T,EAAW,EAAQ,MAEvBrN,EAAOC,QAAU,SAAUihB,GAC1B,IAAIxB,EACJ,MAA8B,mBAAnBwB,EAAsC,CAAEpR,IAAKoR,EAAgBjS,IAAKiS,IAC7ExB,EAAa,CAAEzQ,IAAK5B,EAAS6T,EAAejS,WACjBnB,IAAvBoT,EAAepR,KAClB4P,EAAW5P,IAAMzC,EAAS6T,EAAepR,KACrCoR,EAAetE,SAAQ8C,EAAW9C,OAASvP,EAAS6T,EAAetE,SACnEsE,EAAe9I,QAAOsH,EAAWtH,MAAQ/K,EAAS6T,EAAe9I,QAC9DsH,IAERA,EAAW5P,IAAM4P,EAAWzQ,IACrByQ,GACR,C,8BCdA,IAImCyB,EAJ/BC,EAAW,EAAQ,MACnBnd,EAAW,EAAQ,MACnBoJ,EAAW,EAAQ,MAEnB3G,EAAQvF,MAAMC,UAAUsF,MAE5Bya,EAAc,SAAUnO,GACvB,OAAO1Q,KAAK5B,KAAI,SAAU4f,EAAS3W,GAClC,OAAO2W,EAAUA,EAAQtN,EAAKrJ,IAAMqJ,EAAKrJ,EAC1C,IAAG0C,OAAO3F,EAAMtD,KAAK4P,EAAM1Q,KAAK2C,QACjC,EAEAjF,EAAOC,QAAU,SAAUsgB,GAK1B,OAJAA,EAAYa,EAAQb,IACV9f,SAAQ,SAAU6f,GACvBrc,EAAQqc,IAAUjT,EAASiT,EAChC,IACOa,EAAYzS,KAAK6R,EACzB,C,8BClBAvgB,EAAOC,QAAU,EAAQ,KAAR,CAAyB,EAAQ,M,8BCAlD,IAAI0Q,EAAU,EAAQ,MAEtB3Q,EAAOC,QAAU,WAChB,IAAIohB,EAAS,EAAGC,EAAU,GAAInO,EAAQ,GACtC,MAAO,CACNlE,IAAK,SAAU+D,GACd,IAAI1N,EAAQqL,EAAQvN,KAAKke,EAAStO,EAAK,IACvC,OAAkB,IAAX1N,EAAe,KAAO6N,EAAM7N,EACpC,EACAwK,IAAK,SAAUkD,GAGd,OAFAsO,EAAQld,KAAK4O,EAAK,IAClBG,EAAM/O,OAAOid,GACNA,CACR,EACAzE,OAAQ,SAAUhJ,GACjB,IAAItO,EAAQqL,EAAQvN,KAAK+P,EAAOS,IACjB,IAAXtO,IACHgc,EAAQ5Y,OAAOpD,EAAO,GACtB6N,EAAMzK,OAAOpD,EAAO,GAEtB,EACA8S,MAAO,WACNkJ,EAAU,GACVnO,EAAQ,EACT,EAEF,C,8BC1BA,IAAIxC,EAAU,EAAQ,MAClBxO,EAAUb,OAAOa,OAErBnC,EAAOC,QAAU,SAAUgF,GAC1B,IAAIoc,EAAS,EAAG3gB,EAAM,CAAC,GAAI,IAAKyS,EAAQhR,EAAO,MAC/C,MAAO,CACN8M,IAAK,SAAU+D,GAEd,IADA,IAA0BrJ,EAAtBrE,EAAQ,EAAGwK,EAAMpP,EACd4E,EAAQL,EAAS,GAAG,CAE1B,IAAW,KADX0E,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KAChB,OAAO,KACrBwK,EAAMA,EAAI,GAAGnG,KACXrE,CACH,CAEA,OAAW,KADXqE,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KACT,KACdwK,EAAI,GAAGnG,IAAM,IACrB,EACAmG,IAAK,SAAUkD,GAEd,IADA,IAA0BrJ,EAAtBrE,EAAQ,EAAGwK,EAAMpP,EACd4E,EAAQL,EAAS,IAEZ,KADX0E,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,OAE7BqE,EAAImG,EAAI,GAAG1L,KAAK4O,EAAK1N,IAAU,EAC/BwK,EAAI,GAAG1L,KAAK,CAAC,GAAI,MAElB0L,EAAMA,EAAI,GAAGnG,KACXrE,EAQH,OALW,KADXqE,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,OAE7BqE,EAAImG,EAAI,GAAG1L,KAAK4O,EAAK1N,IAAU,GAEhCwK,EAAI,GAAGnG,KAAO0X,EACdlO,EAAMkO,GAAUrO,EACTqO,CACR,EACAzE,OAAQ,SAAUhJ,GAEjB,IADA,IAA0BjK,EAAtBrE,EAAQ,EAAGwK,EAAMpP,EAAQ6gB,EAAO,GAAIvO,EAAOG,EAAMS,GAC9CtO,EAAQL,EAAS,GAAG,CAE1B,IAAW,KADX0E,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KAE7B,OAEDic,EAAKnd,KAAK0L,EAAKnG,GACfmG,EAAMA,EAAI,GAAGnG,KACXrE,CACH,CAEA,IAAW,KADXqE,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KAC9B,CAMA,IAHAsO,EAAK9D,EAAI,GAAGnG,GACZmG,EAAI,GAAGpH,OAAOiB,EAAG,GACjBmG,EAAI,GAAGpH,OAAOiB,EAAG,IACTmG,EAAI,GAAG7K,QAAUsc,EAAKtc,QAC7B0E,EAAI4X,EAAKC,OACT1R,EAAMyR,EAAKC,OACP,GAAG9Y,OAAOiB,EAAG,GACjBmG,EAAI,GAAGpH,OAAOiB,EAAG,UAEXwJ,EAAMS,EAVb,CAWD,EACAwE,MAAO,WACN1X,EAAM,CAAC,GAAI,IACXyS,EAAQhR,EAAO,KAChB,EAEF,C,wBCpEAnC,EAAOC,QAAU,SAAUgF,GAC1B,OAAKA,EAKE,SAAU+N,GAEhB,IADA,IAAIY,EAAKiD,OAAO7D,EAAK,IAAKrJ,EAAI,EAAGuI,EAAgBjN,IACxCiN,GACR0B,GAAM,IAAWZ,IAAOrJ,GAEzB,OAAOiK,CACR,EAVQ,WACN,MAAO,EACR,CASF,C,8BCXA,IAAIjD,EAAU,EAAQ,MAElBxO,EAASb,OAAOa,OAEpBnC,EAAOC,QAAU,WAChB,IAAIohB,EAAS,EAAG3gB,EAAM,GAAIyS,EAAQhR,EAAO,MACzC,MAAO,CACN8M,IAAK,SAAU+D,GACd,IAA0BrJ,EAAtBrE,EAAQ,EAAGwK,EAAMpP,EAAQuE,EAAS+N,EAAK/N,OAC3C,GAAe,IAAXA,EAAc,OAAO6K,EAAI7K,IAAW,KACxC,GAAK6K,EAAMA,EAAI7K,GAAU,CACxB,KAAOK,EAAQL,EAAS,GAAG,CAE1B,IAAW,KADX0E,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KAChB,OAAO,KACrBwK,EAAMA,EAAI,GAAGnG,KACXrE,CACH,CAEA,OAAW,KADXqE,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KACT,KACdwK,EAAI,GAAGnG,IAAM,IACrB,CACA,OAAO,IACR,EACAmG,IAAK,SAAUkD,GACd,IAA0BrJ,EAAtBrE,EAAQ,EAAGwK,EAAMpP,EAAQuE,EAAS+N,EAAK/N,OAC3C,GAAe,IAAXA,EACH6K,EAAI7K,KAAYoc,MACV,CAKN,IAJKvR,EAAI7K,KACR6K,EAAI7K,GAAU,CAAC,GAAI,KAEpB6K,EAAMA,EAAI7K,GACHK,EAAQL,EAAS,IAEZ,KADX0E,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,OAE7BqE,EAAImG,EAAI,GAAG1L,KAAK4O,EAAK1N,IAAU,EAC/BwK,EAAI,GAAG1L,KAAK,CAAC,GAAI,MAElB0L,EAAMA,EAAI,GAAGnG,KACXrE,GAGQ,KADXqE,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,OAE7BqE,EAAImG,EAAI,GAAG1L,KAAK4O,EAAK1N,IAAU,GAEhCwK,EAAI,GAAGnG,KAAO0X,CACf,CAEA,OADAlO,EAAMkO,GAAUrO,EACTqO,CACR,EACAzE,OAAQ,SAAUhJ,GACjB,IAA0BjK,EAAtBrE,EAAQ,EAAGwK,EAAMpP,EAAQsS,EAAOG,EAAMS,GAAK3O,EAAS+N,EAAK/N,OAAQsc,EAAO,GAC5E,GAAe,IAAXtc,SACI6K,EAAI7K,QACL,GAAK6K,EAAMA,EAAI7K,GAAU,CAC/B,KAAOK,EAAQL,EAAS,GAAG,CAE1B,IAAW,KADX0E,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KAE7B,OAEDic,EAAKnd,KAAK0L,EAAKnG,GACfmG,EAAMA,EAAI,GAAGnG,KACXrE,CACH,CAEA,IAAW,KADXqE,EAAIgH,EAAQvN,KAAK0M,EAAI,GAAIkD,EAAK1N,KAE7B,OAKD,IAHAsO,EAAK9D,EAAI,GAAGnG,GACZmG,EAAI,GAAGpH,OAAOiB,EAAG,GACjBmG,EAAI,GAAGpH,OAAOiB,EAAG,IACTmG,EAAI,GAAG7K,QAAUsc,EAAKtc,QAC7B0E,EAAI4X,EAAKC,OACT1R,EAAMyR,EAAKC,OACP,GAAG9Y,OAAOiB,EAAG,GACjBmG,EAAI,GAAGpH,OAAOiB,EAAG,EAEnB,QACOwJ,EAAMS,EACd,EACAwE,MAAO,WACN1X,EAAM,GACNyS,EAAQhR,EAAO,KAChB,EAEF,C,wBCvFAnC,EAAOC,QAAU,SAAU+S,GAC1B,IAAIY,EAAIjK,EAAG1E,EAAS+N,EAAK/N,OACzB,IAAKA,EAAQ,MAAO,IAEpB,IADA2O,EAAKiD,OAAO7D,EAAKrJ,EAAI,MACZ1E,GAAQ2O,GAAM,IAAWZ,IAAOrJ,GACzC,OAAOiK,CACR,C,8BCNA,IAAIvG,EAAgB,EAAQ,MACxB5M,EAAgB,EAAQ,MACxBid,EAAgB,EAAQ,MACxB+D,EAAgB,EAAQ,MACxBjC,EAAgB,EAAQ,MAE5Bxf,EAAOC,QAAU,SAAS+C,EAAK4P,GAC9B,IAAItO,EAASW,EAAQ3B,EAKrB,GAHA+J,EAASuF,IACTtO,EAAUhD,OAAO+B,UAAU,KAEfua,OAAStZ,EAAQuZ,QAC5B,MAAM,IAAIxL,MAAM,yDAIjB,OAAI1D,eAAevL,KAAKwP,EAAI,kBAAoBtO,EAAQod,MAAc9O,GAGtE3N,EAASua,EAAclb,EAAQW,OAAQ2N,EAAG3N,OAAQX,EAAQsZ,OAASF,EAAWE,OAG9Eta,EAAOme,EAAU7O,EAAI3N,EAAQX,GAG7B7D,EAAQid,GAAY,SAAUiE,EAAO/S,GAChCtK,EAAQsK,IAAO+S,EAAMrd,EAAQsK,GAAOtL,EAAMgB,EAC/C,IAEItB,EAAK4e,cAAc5e,EAAK4e,aAAate,GAEzCA,EAAKmd,YACEnd,EAAKxB,SACb,C,wBClCA,IAAI+f,EAAiB,SAAUjP,GAC9B,GAAkB,mBAAPA,EAAmB,MAAM,IAAIpC,UAAUoC,EAAK,sBACvD,OAAOA,CACR,EAEIkP,EAAa,SAAUC,GAC1B,IAAwCvF,EAAOwF,EAA3CC,EAAOC,SAASC,eAAe,IAA0BxY,EAAI,EAwBjE,OAvBA,IAAIoY,GAAS,WACZ,IAAIK,EACJ,GAAK5F,EAGMwF,IACVxF,EAAQwF,EAAa3V,OAAOmQ,QAJjB,CACX,IAAKwF,EAAc,OACnBxF,EAAQwF,CACT,CAKA,GAFAA,EAAexF,EACfA,EAAQ,KACoB,mBAAjBwF,EAIV,OAHAI,EAAWJ,EACXA,EAAe,UACfI,IAID,IADAH,EAAKhY,KAAQN,IAAMA,EAAI,EAChBqY,GACNI,EAAWJ,EAAajJ,QACnBiJ,EAAa/c,SAAQ+c,EAAe,MACzCI,GAEF,IAAGC,QAAQJ,EAAM,CAAEK,eAAe,IAC3B,SAAU1P,GAChBiP,EAAejP,GACX4J,EACkB,mBAAVA,EAAsBA,EAAQ,CAACA,EAAO5J,GAC5C4J,EAAMpY,KAAKwO,IAGjB4J,EAAQ5J,EACRqP,EAAKhY,KAAQN,IAAMA,EAAI,EACxB,CACD,EAEA3J,EAAOC,QAAW,WAEjB,GAAwB,iBAAZ2B,SAAyBA,SAAwC,mBAArBA,QAAQmb,SAC/D,OAAOnb,QAAQmb,SAIhB,GAA8B,mBAAnBwF,eACV,OAAO,SAAUvR,GAAMuR,eAAeV,EAAe7Q,GAAM,EAI5D,GAAyB,iBAAbkR,UAA0BA,SAAU,CAC/C,GAAgC,mBAArBM,iBAAiC,OAAOV,EAAWU,kBAC9D,GAAsC,mBAA3BC,uBAAuC,OAAOX,EAAWW,uBACrE,CAIA,MAA4B,mBAAjBC,aACH,SAAU1R,GAAM0R,aAAab,EAAe7Q,GAAM,EAI/B,mBAAfqN,YAAqD,iBAAfA,WAC1C,SAAUrN,GAAMqN,WAAWwD,EAAe7Q,GAAK,EAAI,EAGpD,IACR,CA7BiB,E,wBC1CjBhR,EAAOC,QAAU,U,6BCAjB,IAAIyQ,EAAa,EAAQ,MACrBiS,EAAa,EAAQ,MAEzB3iB,EAAOC,QAAU,SAAU8O,GAE1B,IADAA,EAAQ2B,EAAS3B,IACL4T,EAAY,MAAM,IAAInS,UAAUzB,EAAQ,qCACpD,OAAOA,CACR,C,8BCPA,IAAI6T,EAAc,EAAQ,MAE1B5iB,EAAOC,QAAU,SAAU8O,GAC1B,GAAqB,mBAAVA,EAAsB,OAAO,EAExC,IAAKJ,eAAevL,KAAK2L,EAAO,UAAW,OAAO,EAElD,IACC,GAA4B,iBAAjBA,EAAM9J,OAAqB,OAAO,EAC7C,GAA0B,mBAAf8J,EAAM3L,KAAqB,OAAO,EAC7C,GAA2B,mBAAhB2L,EAAM3J,MAAsB,OAAO,CAC/C,CAAE,MAAO4P,GACR,OAAO,CACR,CAEA,OAAQ4N,EAAY7T,EACrB,C,8BChBA,IAAI8T,EAAgB,EAAQ,MACxBjE,EAAgB,EAAQ,MAE5B5e,EAAOC,QAAU,SAAU6iB,EAAc/T,EAAOgU,GAC3CA,GAAgBA,EAAaD,eAChCA,EAAeD,EAAaE,EAAaD,eAG1C,IAAIE,EAAmBF,EAAanS,QAAQ,MACxCsS,EAAaD,GAAoB,EAAIpE,EAAc7P,GAAS,KAChE,GAAIgU,GAAgBA,EAAanU,KAAM,CACtC,IAGMsU,EAAYC,EAAaC,EAAkBC,EAH7CC,EAAkBR,EAAanS,QAAQ,MAC3C,GAAI2S,GAAmB,EACtB,OAAIN,GAAoB,GAEnBM,EAAkBN,GACrBE,EAAaD,EACbG,EAAmBJ,EACnBG,EAAcJ,EAAanU,KAC3ByU,EAAoBC,IAEpBJ,EAAaH,EAAanU,KAC1BwU,EAAmBE,EACnBH,EAAcF,EACdI,EAAoBL,GAGpBF,EAAapc,MAAM,EAAG0c,GACtBF,EACAJ,EAAapc,MAAM0c,EAAmB,EAAGC,GACzCF,EACAL,EAAapc,MAAM2c,EAAoB,IAIxCP,EAAapc,MAAM,EAAG4c,GACtBP,EAAanU,KACbkU,EAAapc,MAAM4c,EAAkB,EAGxC,CACA,OAAIN,GAAoB,EAEtBF,EAAapc,MAAM,EAAGsc,GACtBC,EACAH,EAAapc,MAAMsc,EAAmB,GAGjCF,CACR,C,8BCjDA,IAAI7e,EAAsB,EAAQ,MAC9Bsf,EAAsB,EAAQ,MAElCvjB,EAAOC,QAAU,SAAU8O,EAAOyU,EAAgBT,GACjD,GAAIA,IAAiB9e,EAAQ8K,GAAQ,CACpC,GAAI,YAAagU,EAAc,OAAOA,EAAsB,QAC5D,GAAIA,EAAaU,WAAY,OAAO,IACrC,CACA,IACIzO,EAAQ,IADY+N,GAAgBA,EAAa1Q,OAAU7B,WAC9B+S,EAAoBC,EAAgBzU,EAAOgU,IAE5E,MADIA,GAAgBA,EAAaW,YAAW1O,EAAMxS,KAAOugB,EAAaW,WAChE1O,CACP,C,wBCZAhV,EAAOC,QAAU,SAAU8O,GAC1B,IACC,OAAOA,EAAMyE,UACd,CAAE,MAAOwB,GACR,IAAM,OAAO6B,OAAO9H,EAAQ,CAC5B,MAAO4U,GAAU,OAAO,IAAM,CAC/B,CACD,C,8BCPA,IAAI1M,EAAe,EAAQ,MAEvBC,EAAY,sBAEhBlX,EAAOC,QAAU,SAAU8O,GAC1B,IAAIoI,EAASF,EAAalI,GAC1B,OAAe,OAAXoI,EAAwB,mCAExBA,EAAOlS,OAAS,MAAKkS,EAASA,EAAOzQ,MAAM,EAAG,IAAM,KAExDyQ,EAASA,EAAOzT,QAAQwT,GAAW,SAAU7W,GAC5C,OAAQA,GACP,IAAK,KACJ,MAAO,MACR,IAAK,KACJ,MAAO,MACR,IAAK,SACJ,MAAO,UACR,IAAK,SACJ,MAAO,UAER,QACC,MAAM,IAAIgS,MAAM,wBAEnB,IAED,C,6BC1BA,IAAIpO,EAAU,EAAQ,MAGlB2f,EAAgB,CAAE,QAAU,EAAM,UAAY,EAAM,WAAa,GAErE5jB,EAAOC,QAAU,SAAU8O,GAC1B,QAAK9K,EAAQ8K,IACNJ,eAAevL,KAAKwgB,SAAsB7U,EAClD,C,6BCRA,IAAI8U,EAAmB,EAAQ,MAC3B9P,EAAmB,EAAQ,MAE/B/T,EAAOC,QAAU,SAAU8O,GAC1B,GAAIgF,EAAGhF,GAAQ,OAAOA,EACtB,IAAIzK,EAAUjB,UAAU,GACpByf,EACHxe,GAAWA,EAAQsK,KAChB,gDACA,6BACJ,OAAOiV,EAAiB9U,EAAO+T,EAAcxe,EAC9C,C,8BCXA,IAAIiN,EAAa,EAAQ,MAErBuS,EAAU,mBAAoBC,EAAmB3hB,SAAShB,UAAUoS,SAExExT,EAAOC,QAAU,SAAU8O,GAC1B,QAAKwC,EAAWxC,KACZ+U,EAAQ1Q,KAAK2Q,EAAiB3gB,KAAK2L,GAExC,C,8BCRA,IAAIoD,EAAW,EAAQ,KAEvBnS,EAAOC,QAAU,SAAU8O,GAC1B,IAAKoD,EAASpD,GAAQ,OAAO,EAC7B,IACC,QAAKA,EAAM2I,aACJ3I,EAAM2I,YAAYtW,YAAc2N,CACxC,CAAE,MAAOiG,GACR,OAAO,CACR,CACD,C,8BCVA,IAAI/Q,EAAW,EAAQ,MACnBkO,EAAW,EAAQ,KAEnB6R,EAAiB1iB,OAAOF,UAAUoS,SAEtCxT,EAAOC,QAAU,SAAU8O,GAC1B,IAAK9K,EAAQ8K,GAAQ,OAAO,KAC5B,GAAIoD,EAASpD,GAAQ,CAEpB,IAAIkV,EAAgBlV,EAAMyE,SAC1B,GAA6B,mBAAlByQ,EAA8B,OAAO,KAChD,GAAIA,IAAkBD,EAAgB,OAAO,IAG9C,CACA,IACC,MAAO,GAAKjV,CACb,CAAE,MAAOiG,GACR,OAAO,IACR,CACD,C,8BCpBA,IAAI6O,EAAmB,EAAQ,MAC3B9P,EAAmB,EAAQ,MAE/B/T,EAAOC,QAAU,SAAU8O,GAC1B,GAAIgF,EAAGhF,GAAQ,OAAOA,EACtB,IAAIzK,EAAUjB,UAAU,GACpByf,EACHxe,GAAWA,EAAQsK,KAAO,uCAAyC,gBACpE,OAAOiV,EAAiB9U,EAAO+T,EAAcxe,EAC9C,C,wBCNAtE,EAAOC,QAAU,SAAU8O,GAAS,OAAOA,OAAwC,C,iBCDnFzN,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAMmV,EAAS,EAAQ,MAGjBC,EAAM,EAAQ,MACd,gBAAEC,GAAoB,EAAQ,OAC9B,MAAEC,GAAU,EAAQ,OACpB,WAAEC,GAAe,EAAQ,MACzBC,EAAa,EAAQ,MAO3BH,EAAgBI,SAAS,SALzB,cAAoCJ,KAMpC,MAAMK,EAAgB,CAAC,EACvB,IAAIC,EAAa,KACjB,SAASC,EAAa/W,GAClB,GAAIA,KAAU6W,EACV,OAAOA,EAAc7W,GAEzB,IAEI,GADA8W,EAAaJ,EAAWM,KAAKhX,IACxB8W,EACD,MAAM,IAAIrS,MAAM,wBAA0BzE,EAAS,IAE3D,CAAE,MAAO8B,GACLmV,QAAQC,IAAI,QAASpV,EACzB,CAEA,OADA+U,EAAc7W,GAAU8W,EACjBA,CACX,CAOA,SAASK,EAAkB7C,EAAUtU,GACjC,MAAMoX,EAAQ9C,EAAS+C,UACjBC,EAAS,IAAIhB,EAAOiB,MACtBjD,EAASkD,OAAO,GAAGC,MAAMpiB,MACzBif,EAASkD,OAAOlD,EAASoD,UAAY,GAAGD,MAAMniB,KAE5CwhB,EAAaC,EAAa/W,GAChC,GAAI8W,EAAY,CACZG,QAAQC,IAAI,WAAY,CAAElX,WAC1B,IAAI2X,EAAOb,EAAW9W,OAAOoX,EAAMhgB,MAAM,OACzC,GAAIugB,EACA,OAAOrB,EAAOsB,SAAS9hB,QAAQwhB,EAAQK,GAE3CV,QAAQC,IAAI,qBAAsBJ,EAAW1P,MACjD,MACI6P,QAAQC,IAAIX,EAAIsB,IAAI,sBAAwB7X,GAEpD,CAgJA5N,EAAOC,QAAU,CACbylB,SA5IJ,SAAkBpN,GAEduM,QAAQC,IAAI,wBACZ,MAAMa,EAAoB,IAAIC,IAC9B,CAAC,OAAQ,QAAS,QAAS,MAAO,OAAQ,QAAS,YAAYnlB,SAASolB,IAEpE,IAAIC,EAAI5B,EAAO6B,UAAUC,uCACrBH,EAAG,CACHI,+BAA8B,CAAC/D,EAAU5d,EAASyH,IACvC,CAACgZ,EAAkB7C,EAAU2D,MAI5CvN,EAAQ4N,cAAc9hB,KAAK0hB,GAC3BH,EAAkB7V,IAAI+V,EAAGC,EAAE,IAE/B,MAAM,SAAEK,GAAa,EAAQ,MAGvBC,EAAY,IACXD,GAKP,IAAK,IAAIE,KAAQD,EAAW,CACxB,IAAIE,EAAMF,EAAUC,GAChB5W,EAAIyU,EAAOiC,SAASI,gBAAgBF,EAAMC,GAC9ChO,EAAQ4N,cAAc9hB,KAAKqL,EAC/B,CAGA,MAAM+W,EACN,CACI,KAAQ,IACDnC,EAAMoC,yBAAyB,sBAAuBvC,IAE7D,OAAU,CAON,qBAAAwC,CAAsBxE,EAAUnW,GAC5B,MAAMiZ,EAAQ9C,EAAS+C,UACjBP,EAAaJ,EAAWM,KAAK,WAC7B+B,EAAgBtC,EAAMuC,cAAclC,EAAYM,GAChD6B,EAAU,GAChB,GAAIF,EACA,IACIA,EAAclmB,SAAQkJ,IAClB,IAAIwB,EAAI+W,EAAS4E,WAA4B,EAAjBnd,EAAEod,cAC1B3b,EAAI8W,EAAS4E,WAAWnd,EAAEod,aAAepd,EAAEoF,MAAM9J,QACrD,MAAMigB,EAAS,IAAIhB,EAAOiB,MAAMha,EAAGC,GAC7B4b,EAAS3C,EAAM4C,SAAmB,YAAVtd,EAAE4R,KAAqB8I,EAAM6C,aAAavd,EAAEoF,OAASpF,EAAEoF,MAAOmV,GACtFiD,EAAU,IAAIjD,EAAOkD,iBAAiBlC,EAAQ8B,GACpDH,EAAQziB,KAAK+iB,EAAQ,GAE7B,CAAE,MAAOE,GACLxC,QAAQyC,MAAM,SAAUD,EAC5B,CAEJ,OAAOR,CACX,IAIR,IAAK,IAAIld,KAAK6c,EAAa,CACvB,MAAMe,EAAYf,EAAY7c,IAAM,CAAC,EACrC,KAAM,8BAA+B4d,GAAY,CAC7C,MAAM,0BAAEC,GAA8BnD,EAAMoD,wBAAwB9d,EAAGua,GACvEqD,EAAUC,0BAA4BA,CAC1C,CACA,MAAM/X,EAAIyU,EAAO6B,UAAU2B,sBAAsB,CAAEC,OAAQ,OAAQC,SAAUje,GACzE4d,GAEJjP,EAAQ4N,cAAc9hB,KAAKqL,EAC/B,CAKA6I,EAAQ4N,cAAc9hB,KAAK8f,EAAO6B,UAAU8B,+BAA+B,CACvEF,OAAQ,OACRC,SAAU,QACX,CASC,sBAAAE,CAAuB5F,EAAU6F,EAAUhc,EAAOuM,GAC9C,MAAM0P,EAAiB,GAEvB,2EAA2EhjB,MAAM,KAAK2P,OAAOlU,SAAQqb,IACjG,MAAMmM,EAAQ,IAAI/D,EAAOgE,eAAepM,GACxCmM,EAAME,iBAAmB,CAAC,MAC1BF,EAAMG,cAAgB,IAAIlE,EAAOmE,eAAe,wBAChDJ,EAAMK,WAAaxM,EAAI,OACvBmM,EAAMxQ,KAAOyM,EAAOqE,mBAAmBC,OAEvCR,EAAe5jB,KAAK6jB,EAAM,IAEX,EAAQ,MAChBtT,OAAOlU,SAAQqb,IACtB,MAAMmM,EAAQ,IAAI/D,EAAOgE,eAAepM,GACxCkM,EAAe5jB,KAAK6jB,EAAM,IAE9B,MAAM,eAAEQ,GAAmBlE,EAAWmE,MAChC,UAAEC,EAAS,SAAEC,GAAaH,EAAevG,EAAS+C,WAClD4D,EAAK,CAACF,EAAWC,GACvB,KAAOC,EAAG5jB,OAAS,GAAG,CAClB,MAAM6jB,EAAKD,EAAG9P,QAEd,IAAK,IAAIpP,KAAKmf,EAAI,CACd,MAAMb,EAAQ,IAAI/D,EAAOgE,eAAeve,GACxCse,EAAMK,WAAa,OAAO3e,EAAE,IAC5Bse,EAAMxQ,KAAOyM,EAAOqE,mBAAmBQ,SACvCf,EAAe5jB,KAAK6jB,EACxB,CACJ,CAEA,OAAOD,CACX,GAED,KACP,EAWIgB,WAPJ,WAEA,E,8BCzMA,MAAM,WAAE1E,EAAU,MAAE2E,EAAK,SAAEC,GAAa,EAAQ,KAChD5nB,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD9O,EAAQqkB,WAAaA,EACrBrkB,EAAQipB,SAAWA,EACnBjpB,EAAQkpB,YAAcF,EAAMG,QAAQD,YACpClpB,EAAQgpB,MAAQA,EAChBhpB,EAAQopB,QAAU,SAClBppB,EAAQqpB,IAEG,CACHL,MAFU,EAAS,M,iBCV3B,IAAIvoB,EAAM,CACT,yCAA0C,KAC1C,wCAAyC,KACzC,yBAA0B,KAC1B,gCAAiC,KACjC,0BAA2B,IAC3B,0BAA2B,IAC3B,2BAA4B,KAC5B,kCAAmC,KACnC,6BAA8B,IAC9B,4BAA6B,KAC7B,6BAA8B,KAC9B,gCAAiC,KACjC,uBAAwB,KACxB,6BAA8B,IAC9B,2BAA4B,KAC5B,yBAA0B,IAC1B,wBAAyB,KACzB,2BAA4B,IAC5B,6BAA8B,MAI/B,SAAS6oB,EAAeC,GACvB,IAAI5V,EAAK6V,EAAsBD,GAC/B,OAAOE,EAAoB9V,EAC5B,CACA,SAAS6V,EAAsBD,GAC9B,IAAIE,EAAoB5N,EAAEpb,EAAK8oB,GAAM,CACpC,IAAI9Z,EAAI,IAAI2C,MAAM,uBAAyBmX,EAAM,KAEjD,MADA9Z,EAAElN,KAAO,mBACHkN,CACP,CACA,OAAOhP,EAAI8oB,EACZ,CACAD,EAAenV,KAAO,WACrB,OAAO9S,OAAO8S,KAAK1T,EACpB,EACA6oB,EAAejJ,QAAUmJ,EACzBzpB,EAAOC,QAAUspB,EACjBA,EAAe3V,GAAK,I,eCvCpBtS,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAapD9O,EAAQ0pB,UAPR,MAII3R,K,8BCVJ1W,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IACpD,MAAM,MAAEka,GAAU,EAAQ,MAqG1BhpB,EAAQkpB,YApGR,MAKIva,KAKAgb,QAKAC,SAMAC,UAIAC,QAIAC,YAMAC,mBAKAC,SAMAtc,OAMAuc,WAEA,WAAAzS,CAAY0S,GAER9oB,OAAOD,eAAeiB,KAAM,SAAU,CAAC2M,IAAG,IAAUmb,GACxD,CAEA,UAAAC,CAAWC,EAAQC,EAAWtgB,EAAMugB,EAAQC,GACxC,MAAMC,EAAIpoB,MACJ,SAAE4mB,EAAQ,YAAEyB,GAAgB1B,EAAMG,QAClCS,EAAWZ,EAAM2B,wBAAwBN,EAAQpB,EAAUyB,GAE3DE,EAAiBC,GACZ7B,EAAM8B,WAAWD,EAAG,KAGzBE,EAAQ,CACV,QAAAnB,CAASte,EAAE+e,EAAQE,EAAQC,GACvB,IAAIlqB,EAAIspB,EAASzkB,MAAMslB,EAAG,CAACnf,EAAE+e,EAAQE,EAAQC,IAK7C,OAJAlqB,EAAEE,SAASqqB,IAEPA,EAAEV,OAASM,EAAEN,MAAM,IAEhB7pB,CACX,EACAiM,MAAOqe,EACP3nB,IAAK2nB,EACLnhB,MAAOmhB,EACPb,YAAaa,EACb,oBAAAI,CAAqB1f,EAAG+e,GACpB,IAAIY,EAAI,IAAIC,qBAEZ,OADAC,WAAWC,UAAUf,EAAQY,EAAG3f,EAAGkf,GAC5BS,CACX,EACApB,UAvBcb,EAAMqC,4BAwBpBpB,SApBajB,EAAMsC,qBAAqBb,GAqBxC,cAAAc,GACI,MAAM,IAAInZ,MAAM,8BACpB,GAEJ,IAAIoZ,EAAKT,EAAMT,GACf,OAAIkB,EACOA,EAAGrmB,MAAMslB,EAAG,CAACzgB,EAAMqgB,EAAQE,EAAQC,IAEvCxgB,CACX,E,8BCnGJ3I,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD,MAAM,wBAAE2c,GAA4B,EAAQ,OACtC,iBAAEC,GAAqB,EAAQ,OAC/B,yBAAEC,GAA6B,EAAQ,OACvC,MAAE3C,GAAU,EAAQ,MAC1B,MAAM4C,EACFC,QACAC,MACAC,YACAjgB,MAOA,sBAAOkgB,CAAgBH,EAAS/f,EAAM,YAqFlC,MAAMmgB,EApFN,SAA+BJ,EAAS/f,EAAM,YAC1C,IAAK+f,EACD,MAAM,IAAIzZ,MAAM,mBAEpB,IAAI8Z,EAAKL,EAAQ,GACjB,GAAIA,EAAQ7mB,OAAO,EACf,MAAO,CAAC8J,MAAMod,EAAIpgB,MAAOA,GAE7B,MAAM,QAACqgB,GAAWN,EAClB,QAAuB,IAAb,EAEN,OADAjH,QAAQC,IAAI,oBACL,KAEX,IAsBIuH,EACAhH,EAvBAiH,EAAcF,EAAQ,GAAG,GACzBG,EAAY,CAAC,EACbP,EAAc,CAAC,EACfQ,EAAS,KACTC,EAAU,EACVP,EAAQ,KACRQ,EAAa,SAASF,EAAQ7iB,GAC9BqiB,EAAYriB,GAAK6iB,EACjBD,EAAU5iB,GAAK6iB,CACnB,EACIG,EAAa,SAASC,EAAKC,EAAGxH,EAAO1b,GACrC8iB,EAAUG,EAAIC,EAAE5nB,OAChBunB,EAASM,EAASzH,EAAOwH,EAAG,KAAMljB,GAClC+iB,EAAWF,EAAQ7iB,GACnBuiB,EAAQ,IACZ,EACIa,EAAgB,SAAUjC,EAAGvqB,GAC7B,OAASuqB,EAAE7nB,OAAO1C,EAAE0C,OAAS6nB,EAAE5nB,KAAK3C,EAAE2C,GAC1C,EACI4pB,EAAW,SAASzH,EAAOwH,EAAGzC,EAAQxW,GACtC,MAAO,IAAIyR,EAAOtW,MAAM8d,EAAEjZ,KAAI,SAAItO,GAAS,OAAOhD,KAAKW,MAAQ6oB,EAAQxmB,KAAO,EAAG8kB,OAAQA,EAAQ4C,OAAO,GAC5G,EAIA,IAAI,IAAIrjB,EAAI,EAAGA,EAAImiB,EAAQ7mB,OAAQ0E,IAAI,CAEnC,GADA0iB,EAAKD,EAAQziB,QACG,IAAN,EAAkB,CACxBqiB,EAAYriB,GAAK,CAACoF,WAAOjB,GACzB,QACJ,CACA,IAAI+e,EAAIf,EAAQniB,GAChB0b,EAAQ,CAACpiB,MAAMopB,EAAG,GAAKC,EAAYppB,IAAImpB,EAAG,GAAKC,GAC/C,IAAIM,EAAMT,EAAGxb,QAAQkc,EAAGJ,GACxB,GAAY,MAARD,EAEAG,EAAWC,EAAIC,EAAGxH,EAAO1b,QAIzB,GAAI6iB,EAAOvpB,OAASoiB,EAAMpiB,OAAWupB,EAAOtpB,KAAKmiB,EAAMniB,IAGnD8oB,EAAYriB,GAAK6iB,OAEjB,GAAKA,EAAOvpB,OAAQoiB,EAAMpiB,OAAWupB,EAAOtpB,KAAKmiB,EAAMniB,IAAK,CACxD,GAAIgpB,GAASa,EAAcb,EAAO7G,GAAO,CAErC,IAAI4H,EAASH,EAASzH,EAAOwH,EAAGX,EAAOviB,GACvCuiB,EAAQe,CACZ,MACIf,EAAQY,EAASzH,EAAOwH,EAAGL,EAAQ7iB,GACnC6iB,EAAOQ,OAAO5oB,KAAK8nB,GAGvBF,EAAYriB,GAAKuiB,CACrB,MAEIS,EAAWC,EAAIC,EAAGxH,EAAO1b,EAIzC,CAOA,OALIwiB,EAAGlnB,OAAO,IACVonB,EAAKD,EAAQ,GACb/G,EAAQ,CAACpiB,MAAMopB,EAAG,GAAKC,EAAYppB,IAAImpB,EAAG,GAAKC,GAC/CI,EAAYI,EAASzH,EAAOyG,EAAQ,GAAI,KAAM,GAAI,IAE/C,CAACA,UAASC,MAAOQ,EAAWP,YAAaA,EACpD,CACckB,CAAsBpB,EAAS/f,GAC7C,IAAImgB,EACA,OAAO,KAEX,MAAM,MAAEH,EAAM,YAAEC,GAAgBE,EAChC,IAAIiB,EAAK,IAAItB,EAKb,OAJAsB,EAAGpB,MAAQA,EACXoB,EAAGrB,QAAUI,EAAMJ,QACnBqB,EAAGnB,YAAcA,EACjBmB,EAAGphB,MAAQA,EACJohB,CACX,CAWA,MAAAC,CAAO5R,EAAU0O,EAAUhnB,EAAKmqB,EAAQC,EAAQC,EAAWC,GAAM,GAC7D,IAAKtD,EACD,MAAM,IAAI7X,MAAM,yBAEpB,IAAKkb,EACD,MAAM,IAAIlb,MAAM,0BAEpB,MAAMrP,EAAOV,MACP,QAAEwpB,EAAO,MAAEC,GAAU/oB,GACrB,MAAEskB,EAAK,OAAEmG,GAAUH,EACzB,IAAII,EAAS5B,EAAQ,GACjB6B,EAAS,EACTC,EAAU,GACVlJ,EAAa4I,EAAOO,UACpBC,EAAa,SAAUJ,EAAQK,EAAMvS,EAAU0O,EAAUmD,EAAQW,GAEjE,IAAIC,EAAKF,EAAKhf,MACVmf,EAAKD,EACLE,EAAY,CAAC,CAACJ,OAAMK,OAAO,GAAIZ,OAAM,EAAOa,KAAI,IAChDC,GAAO,EACX,KAAMH,EAAUlpB,OAAO,GAAE,CACrB,IAAIylB,EAAIyD,EAAUpV,SACd,GAACnF,GAAK8W,EAAEqD,KACZ,IAAIrD,EAAE8C,MAIN,GADAc,GAAO,GACF5D,EAAE2D,KAAO3D,EAAEqD,KAAKf,OAAO/nB,OAAO,EAAE,CACjC,MAAMspB,EAAY7D,EAAEqD,KAAKf,OAAOtmB,MAAM,GAGtC,IAFAgkB,EAAE2D,KAAM,EACRF,EAAUK,QAAQ9D,GACZ6D,EAAUtpB,OAAO,GAAE,CACrB,IAAIwpB,EAAQF,EAAU/M,MACtB2M,EAAUK,QAAQ,CAACpE,OAAQM,EAAG8C,OAAM,EAAOO,KAAMU,EAAOJ,KAAI,GAChE,CACJ,KAAK,CACDJ,EAAKvD,EAAE2D,IAAM3D,EAAE0D,OAAS1D,EAAEqD,KAAKhf,MAC/Bse,EAASA,EAASA,EAAO3mB,MAAM,GAAK,GACpC,IAAIkjB,EAAU,KACV8E,EAAM,KAEV,GAAIvtB,MAAMuQ,QAAQuc,GAAI,CAElB,MAAMU,EAAKjE,EAAEqD,KAAKhf,MAClB,IAAI6f,EAAS,EACTC,EAAO,GACPpf,EAAI,GAERwe,EAAGxtB,SAAQqqB,IAEPrb,EAAIkf,EAAGG,UAAUF,EAAQ9D,EAAEzF,MAAM,IACjC,IAAI0J,EAAKtf,EAAEqb,EAAEmD,GACbW,EAAS9D,EAAEzF,MAAM,GAAGyF,EAAEzF,MAAM,GAC5BwJ,GAAOE,CAAE,IAGbF,GAAOF,EAAGG,UAAUF,GACpBX,EAAKY,CACT,CACA,IAAIG,GAAiB,EACrB,MAAMC,EAAMvD,EAAwBwD,KAAKjB,GACzC,GAAIra,KAAMsW,EAAS,CAEf,GADAwE,EAAMxE,EAAStW,GACX8a,EAAIvE,WAAW,CAEf,IAAIgF,EAAQtD,EAAgBuD,WAAWV,EAAIvE,WAAY8D,EAAIX,GAC3D,GAAI6B,EACA,MAAMA,CAEd,CAQA,GAPIT,EAAI9f,MACJqa,EAAMoG,YAAYX,EAAI9f,KAAMye,GAE5BqB,EAAI9E,UACJA,EAAU8E,EAAI9E,SAGd1mB,EAEAgrB,EAAKD,EACLA,EAAK/qB,EAAI+qB,EAAIS,EAAK9a,EAAI4H,EAAU,CAAC6R,SAAQI,SAAQnG,QAAOsC,YACxD0E,GAAO,OAWP,GARG5J,EACCuJ,EAAKvJ,EAAW4K,iBAAiBZ,EAAKT,EAAIgB,EAAK3B,EAAQtqB,EAAK8oB,SAGxD4C,EAAI5E,YACJmE,EAAKhF,EAAMsG,qBAAqBtB,EAAIS,EAAI5E,YAG5C4E,EAAI7E,UAAU5kB,OAAO,EAAE,CACvB,MAAMuqB,EAAalC,EAAOmC,UAAU/oB,MAAM,GAC1C4mB,EAAOmC,UAAYpC,EAAO3mB,MAAM,EAAG2mB,EAAOpoB,OAAO,GACjDgpB,EAAKhF,EAAMyG,kBAAkBzB,EAAIS,EAAI7E,SACjC7mB,EAAK8oB,QAASwB,GAClB0B,GAAiB,EAEjB1B,EAAOmC,UAAYD,CACvB,CAER,CAMA,GALIhU,IAAawT,GAAkBxT,EAASmU,cAExCzB,EAAKD,EACLA,EAAKK,IAASL,EAAKA,EAAKA,EAAGhpB,OAAO,EAAGuW,EAASmU,YAAY1B,EAAIZ,EAAQzD,EAAS6D,EAAQnG,EAAOoH,EAAKpB,GAAU,IAE7G5C,EAAEN,OAAO,CAET,IAAIU,EAAKJ,EAAEqD,KAAK9qB,MAAQynB,EAAEN,OAAO2D,KAAK9qB,MAClCyM,EAAKgb,EAAEqD,KAAK7qB,IAAMwnB,EAAEqD,KAAK9qB,MAEzBgrB,EAAGhpB,OAAO,GACVylB,EAAEN,OAAOgE,OAAOhqB,KAAK,CAACihB,MAAM,CAACyF,EAAEpb,GAAIue,KAAIC,MAE/C,CACAxD,EAAE8C,OAAQ,CACd,CACJ,CAEA,OADAQ,EAAQ/jB,KAAOikB,EACRD,CACX,EACI2B,EAAiB,SAASngB,EAAG+L,GAM7B,OALIgS,GAAU/d,EAAExK,OAAO,GACfuW,IACA/L,EAAI+L,EAASmU,YAAYlgB,EAAG,CAAC,uBAAwB,WAAYge,EAAQnG,EAAO,KAAMgG,IAGvF7d,CACX,EACIA,EAAI,GACJlP,EAAI,GACJsvB,EAAQvuB,OAAO8S,KAAK2X,GACpB+D,EAAWxuB,OAAO8S,KAAK8V,GACvB6F,EAAe,KAAK7F,GAA+B,GAAjB4F,EAAS7qB,OAC3C+qB,EAAY,CAAC/lB,KAAK,KAAMgmB,MAAMvC,EAAQwC,cAAc,GAAGC,YAAY,IACvE,IAAI,IAAIte,KAAKka,EAAM,CACf,IAAMgE,GAAmB,GAAHle,GAAQge,EAAM5qB,OAAO,EACvC,SAEJ,IAAImrB,EAAKrE,EAAMla,GAgBf,GAdApC,EAAIie,EAAOoB,UAAUnB,EAAQyC,EAAGntB,OAC5BwM,EAAExK,OAAO,IACT1E,GAAKkP,EACLugB,EAAUG,YAAY/rB,KAAKqL,GAC3BA,EAAImgB,EAAengB,EAAG+L,GACtBoS,GAAWne,EACXugB,EAAUE,cAAc9rB,KAAKqL,IAEjCA,EAAIqe,EAAWJ,EAAQ0C,EAAG5U,EAAS0O,EAASmD,EAAO2C,GACnDpC,GAAWne,EACXke,EAASyC,EAAGltB,IACZ3C,GAAGyvB,EAAU/lB,KACb+lB,EAAUG,YAAY/rB,KAAK4rB,EAAU/lB,MACrC+lB,EAAUE,cAAc9rB,KAAKqL,GACzBsgB,EACA,KACR,CACA,GAAIpC,EAASD,EAAOzoB,OAAO,CACvB,IAAI4W,EAAI6R,EAAOoB,UAAUnB,GACzBptB,GAAIsb,EACJmU,EAAUG,YAAY/rB,KAAKyX,GAC3BpM,EAAImgB,EAAe/T,EAAGL,GACtBoS,GAAWne,EACXugB,EAAUE,cAAc9rB,KAAKqL,EACjC,CAKA,OAJI8d,IACAA,EAAU2C,cAAgBF,EAAUE,cACpC3C,EAAU4C,YAAcH,EAAUG,aAE/BvC,CACX,CAQA,iBAAOwB,CAAWpa,EAAOiZ,EAAIX,GACzB,IAAI6B,EAAQ,KACR7c,EAAU,KAAO5I,EAAQ,KACzB2mB,GAAS,EAab,MAZqB,iBAAX,IACJ/d,UAAS5I,SAASsL,GAEpB1C,EAAU0C,EAEVtL,IAEA2mB,GAD6B,iBAAT,EAAmB,IAAIvtB,OAAO4G,GAASA,GAC5C0J,KAAK6a,IAEpBoC,IACAlB,EAAO,IAAIvD,EAAyBtZ,EAASgb,IAE1C6B,CACX,EAEJlvB,EAAQ4rB,gBAAkBA,C,2BCpU1BvqB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAuBtD9O,EAAQqwB,qBAnBR,MACE7b,KACA8b,OACA,WAAA7Y,GACEpV,KAAKmS,KAAO,GACZnS,KAAKiuB,OAAS,CAAC,CACjB,CACA,MAAAC,GACE,IAAI3U,EAAI,CAAC,EAQT,OAPIvZ,KAAKmS,KAAKxP,OAAS,IACrB4W,EAAQ,KAAIvZ,KAAKmS,MAEfnT,OAAO8S,KAAK9R,KAAKiuB,QAAQtrB,OAAS,IACpC4W,EAAU,OAAIvZ,KAAKiuB,QAGd1U,CACT,E,4BCrBFva,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAmBtD9O,EAAQwwB,kBAfR,MACEC,OACAC,SACA,gBAAIC,GACF,OAAOtuB,KAAK,gBACd,CACA,gBAAIsuB,CAAa/D,GACfvqB,KAAK,iBAAmBuqB,CAC1B,CACA,MAAA2D,GACE,IAAI3U,EAAI,IAAIvZ,MAEZ,OADAuZ,EAAE8U,SAA8B,kBAAb9U,EAAU,SAAeA,EAAE8U,SAAuB,QAAZ9U,EAAE8U,SACpD9U,CACT,E,4BCjBFva,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAyBtD9O,EAAQ4wB,gBAvBR,MACIC,OACAC,QACAC,SACAC,OACAC,OACA7L,MACA1f,IACAwrB,SACA,WAAIC,GACA,OAAO9uB,KAAK,WAChB,CACA,WAAI8uB,CAAQvE,GACRvqB,KAAK,YAAcuqB,CACvB,CACA,mBAAIwE,GACA,OAAO/uB,KAAK,mBAChB,CACA,mBAAI+uB,CAAgBxE,GAChBvqB,KAAK,oBAAsBuqB,CAC/B,E,4BCtBJvrB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IA8BtD9O,EAAQqxB,iBA5BR,MACI,kBAAIC,GAAmB,OAAOjvB,KAAK,kBAAoB,CACvD,kBAAIivB,CAAe1E,GAAKvqB,KAAK,mBAAqBuqB,CAAG,CACrD,mBAAI2E,GAAoB,OAAOlvB,KAAK,mBAAqB,CACzD,mBAAIkvB,CAAgB3E,GAAKvqB,KAAK,oBAAsBuqB,CAAG,CACvD,eAAI4E,GAAgB,OAAOnvB,KAAK,eAAiB,CACjD,eAAImvB,CAAY5E,GAAKvqB,KAAK,gBAAkBuqB,CAAG,CAC/C,cAAI6E,GAAe,OAAOpvB,KAAK,cAAgB,CAC/C,cAAIovB,CAAW7E,GAAKvqB,KAAK,eAAiBuqB,CAAG,CAC7C,eAAI8E,GAAgB,OAAOrvB,KAAK,eAAiB,CACjD,eAAIqvB,CAAY9E,GAAKvqB,KAAK,gBAAkBuqB,CAAG,CAC/C,aAAI+E,GAAc,OAAOtvB,KAAK,aAAe,CAC7C,aAAIsvB,CAAU/E,GAAKvqB,KAAK,cAAgBuqB,CAAG,CAC3C,cAAIgF,GAAe,OAAOvvB,KAAK,cAAgB,CAC/C,cAAIuvB,CAAWhF,GAAKvqB,KAAK,eAAiBuqB,CAAG,CAC7C,uBAAIiF,GAAwB,OAAOxvB,KAAK,wBAA0B,CAClE,uBAAIwvB,CAAoBjF,GAAKvqB,KAAK,yBAA2BuqB,CAAG,CAChE,yBAAIkF,GAA0B,OAAOzvB,KAAK,0BAA4B,CACtE,yBAAIyvB,CAAsBlF,GAAKvqB,KAAK,2BAA6BuqB,CAAG,CACpE,mBAAImF,GAAoB,OAAO1vB,KAAK,oBAAsB,CAC1D,mBAAI0vB,CAAgBnF,GAAKvqB,KAAK,qBAAuBuqB,CAAG,CACxD,cAAIoF,GAAe,OAAO3vB,KAAK,cAAgB,CAC/C,cAAI2vB,CAAWpF,GAAKvqB,KAAK,eAAiBuqB,CAAG,CAC7CpZ,IACA,gBAAIye,GAAiB,OAAO5vB,KAAK,gBAAkB,CACnD,gBAAI4vB,CAAarF,GAAKvqB,KAAK,iBAAmBuqB,CAAG,E,4BC3BrDvrB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAwBtD9O,EAAQkyB,WAtBR,MACI,WAAAza,GACIpV,KAAK8vB,MAAQ,EACjB,CACA,QAAA7iB,CAAS8iB,GACL,OAAO,CACX,CACA,MAAA7B,GACI,OAAOluB,KAAK8vB,KAChB,CACA,QAAAE,GACI,OAAOhwB,KAAK8vB,KAChB,CAKA,KAAAG,EAAM,IAACF,EAAG,MAAEG,EAAK,SAAEC,EAAQ,QAAEC,IACzBpwB,KAAK8vB,MAAMhuB,KAAK,CAACiuB,MAAKG,QAAOC,WAAUC,WAC3C,E,8BCrBJpxB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IACtD,MAAM,SAAE4jB,GAAa,EAAQ,MAY7B1yB,EAAQ2yB,cATR,cAA4BD,EACxB,UAAI3F,GACA,MAAM3G,EAAO,UAIb,OAHMA,KAAQ/jB,OACVA,KAAK+jB,GAAQ,CAAC,GAEX/jB,KAAK+jB,EAChB,E,WCZJ,MAAMwM,EAAa,m+zBAAm+zB7tB,MAAM,KAAKmM,QAAO,CAAC0b,EAAGljB,EAAGyH,IACpg0BA,EAAIT,QAAQkc,IAAMljB,IAE7B3J,EAAOC,QAAU4yB,C,4BCFjBvxB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAgBtD9O,EAAQ0yB,SAZR,MAMG,gBAAOG,CAAUC,EAAKC,GACrB,IAAI,IAAIrpB,KAAKqpB,EACTD,EAAIppB,GAAKqpB,EAAIrpB,EAElB,E,8BCdHrI,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,iBAAEkkB,GAAqB,EAAQ,MA8LrChzB,EAAQizB,oBAzLR,MAIIC,QAIAC,OAIA7C,OAMA8C,aAEAC,QAMAC,UAKAC,aAKAC,SAKAC,kBAIAC,kBAIAnB,MAIAoB,UAIAC,KAIAC,SAIA/xB,MAIAgyB,cAIAtB,SAOA,WAAA/a,GACIpV,KAAKiuB,OAAS,CAAC,EACf,IAAIyD,EAAU,KACd1yB,OAAOD,eAAeiB,KAAM,SAAS,CACjC2M,IAAG,KACM+kB,IACDA,EAAU,CAAC,GAERA,IAGnB,CAKA,MAAAxD,GACI,IAAIyD,EAAM,CAAC,GACP,OAAEC,EAAM,OAAE3D,GAAWjuB,KAEzB,IAAI,IAAIqH,KAAKrH,KAAK,CACd,GAAI,sBAAsB8Q,KAAKzJ,GAAI,SACnC,MAAMwqB,EAAK7xB,KAAKqH,GACZwqB,IACAF,EAAItqB,GAAKwqB,EAEjB,CASA,OARG5D,GAAWjvB,OAAO8S,KAAKmc,GAAQtrB,OAAO,IACrCgvB,EAAI1D,OAASA,GAEd2D,GAAW5yB,OAAO8S,KAAK8f,GAAQjvB,OAAO,IAGrCgvB,EAAIC,OAASA,GAEVD,CACX,CAKA,GAAAlB,GACI,SAASqB,EAAWlJ,GAChB,IAAIpF,EAAI,GAER,IAAI,IAAInc,KAAKuhB,EAAE,CACX,IAAIrZ,EAAIqZ,EAAEvhB,GACA,OAANkI,IACe,iBAAL,IACNA,EAAI,IAAIA,EAAE,KAEdiU,EAAE1hB,KAAKuF,EAAE,IAAQkI,GAEzB,CACA,OAAOiU,EAAE5kB,KAAK,IAClB,CACA,MACMmzB,EAAM,GACR/xB,KAAK6wB,SACLkB,EAAIjwB,KAAK,YAAY9B,KAAK6wB,SAG9B,MAAM/F,EAAS,IAAI6F,EACnB,IAAInI,EAAIsC,EAAOA,OAAO9qB,MAItB,GAHIwoB,GAAKA,EAAE7lB,OAAO,GACdovB,EAAIjwB,KAAK0mB,GAETxoB,KAAK8wB,OACL,IAAI,IAAIzpB,KAAKrH,KAAK8wB,OAAO,CACrB,IAAItI,EAAI,cAAcnhB,EAClBqpB,EAAM1wB,KAAK8wB,OAAOzpB,GAEtBmhB,GAAG,IACH,IAAI,IAAIjZ,KAAKmhB,EACTlI,GAAGjZ,EAAE,IACLiZ,GAAIsJ,EAAWpB,EAAInhB,IACnBiZ,GAAG,IAEPA,GAAG,IACHuJ,EAAIjwB,KAAK0mB,EACb,CAGJ,GAAIxoB,KAAKiuB,OACL,IAAK,IAAI5mB,KAAKrH,KAAKiuB,OAAO,CACtB,IACI1U,EAAIuY,EADA9xB,KAAKiuB,OAAO5mB,IAEhBkS,GAAMA,EAAE5W,OAAO,GACnBovB,EAAIjwB,KAAKuF,EAAE,IAAKkS,EAAG,IACvB,CAEJ,GAAIvZ,KAAK4xB,OAAO,CACZ,IAAIpJ,EAAIsC,EAAOkH,aAAahyB,KAAK4xB,QAC7BpJ,GACJuJ,EAAIjwB,KAAK0mB,EAEb,CACA,OAAOuJ,EAAInzB,KAzCC,GA0ChB,CACA,SAAAqzB,GACIjyB,KAAK4xB,OAAS,CAAC,CACnB,E,4BC5LJ5yB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAMylB,EAAe,CACjB,aAAgB,gBAChB,cAAiB,iBACjB,SAAY,YACZ,kBAAqB,sBACrB,cAAiB,iBACjB,kBAAqB,uBAEnBC,EAAa,CAAC,QAAS,QAAS,iBAAkB,YAAa,sBAAuB,sBAAuB,UAAW,YAAa,QAAQ,iBAAkB,WAAW,mBAY1KC,EAAc,CAACxJ,EAAG/Z,EAAQwjB,KAC5B,IAAI7O,EAAI,GAER,SAAS8O,EAAU9O,GACf,MAAMoF,EAAIpF,EAAE5kB,KAAK,KAGjB,OAFA4kB,EAAE7gB,OAAS,EACX6gB,EAAE1hB,KAAK8mB,GACApF,CACX,CACA,IAAK,IAAInc,KAAKuhB,EAAG,CACb,IAAI2J,EAAI3J,EAAEvhB,GACNwH,GAAUA,EAAOxH,KAGH,iBAAP,GACHgrB,GACIA,EAAW7O,EAAGnc,EAAGkrB,GACjBD,EAAU9O,GAKtBA,EAAE1hB,KAAKuF,EAAI,IAAYuhB,EAAEvhB,IAC7B,CAEA,OADAirB,EAAU9O,GACHA,EAAE,EAAE,EAEf,MAAMmN,EACF6B,QAAS,EACTC,QAAS,EACT,YAAAT,CAAaJ,GACT,IACIrE,EAAQvuB,OAAO8S,KAAK8f,GAWxB,OAVIrE,EAAM5qB,OAAS,GACf4qB,EAAMpvB,SAAQqqB,IACV,IAAIjP,EAAIqY,EAAOpJ,GACfA,EAAE1mB,KAAK,UAAY0mB,GACnBA,EAAE1mB,KAAK,KACP0mB,EAAE1mB,KAAKswB,EAAY7Y,IACnBiP,EAAE1mB,KAAK,IAAI,IARX,GAYClD,KAAK,GAElB,CAKA,MAAAksB,CAAOnlB,GACH,MAAM+sB,EAAU1zB,OAAO8S,KAAKnM,GAC5B,IAAI6iB,EAAI,GAoBR,OAnBAkK,EAAQv0B,SAAQqb,IACZ,GAAI,qCAAqC1I,KAAK0I,GAC1C,OAEJ,IAAImZ,EAAKhtB,EAAI6T,GACb,GAAImZ,EAAI,CACJ,IAAIC,EApETV,EADajpB,EAqEgBuQ,IApEVvQ,EAAE7H,QAAQ,UAAWoY,GAAM,IAAMA,EAAEqZ,gBAAeA,cAsE5D7O,EAAMhkB,KAAK,WAAawZ,EAAEqZ,cAAczxB,QAAQ,IAAK,MACrC,mBAAT,IACwB,GAA3B+wB,EAAW9jB,QAAQukB,KACnBpK,GAAK,IAAMoK,EAAK,KACpBpK,GAAKxE,EAAIlhB,MAAM9C,KAAM,CAAC2yB,KAEtBnK,GAAK,6BAA+BhP,EAAI,MAEhD,CA/EW,IAACvQ,CA+EZ,IAGGuf,CACX,CAQA,iBAAOsK,CAAW70B,GAAG,OAAEu0B,GAAU3jB,GAC7B,MAAM2Z,EAAI,GACV,IAAIuK,GAAK,EACLC,EAAU,CAAEC,MAAOF,GACnBG,EAAcrkB,EAAS,CAAC2Z,EAAGnhB,EAAGkS,IACvB1K,EAAO2Z,EAAGnhB,EAAGkS,EAAGyZ,GACvB,KAeJ,OAdAh0B,OAAO8S,KAAK7T,GAAGoU,OAAOlU,SAAQkJ,IAE1B,IAAIkS,EAAItb,EAAEoJ,GACV0rB,EAAKC,EAAQC,MACTT,GAAUO,GACVvK,EAAE1mB,KAAK,KAEX0mB,EAAE1mB,KAAKuF,GACPmhB,EAAE1mB,KAAK,KACP0mB,EAAE1mB,KAAKswB,EAAY7Y,EAAG,KAAM2Z,IAC5B1K,EAAE1mB,KAAK,KACPixB,GAAK,CAAI,IAGNvK,EAAE5pB,KAAK,GAClB,CACA,oBAAAu0B,CAAqBl1B,GACjB,MAAMuqB,EAAI,GACV,IAAK,IAAInhB,KAAKpJ,EAAG,CACb,IAAIsb,EAAItb,EAAEoJ,GACVmhB,EAAE1mB,KAAKuF,GACPmhB,EAAE1mB,KAAK,KACP0mB,EAAE1mB,KAAKswB,EAAY7Y,IACnBiP,EAAE1mB,KAAK,IACX,CACA,OAAO0mB,EAAE5pB,KAAK,GAClB,CACA,iBAAAw0B,CAAkBn1B,GACd,MAAMuqB,EAAI,GAEV,IAAK,IAAInhB,KAAKpJ,EAAG,CACb,IAAIsb,EAAItb,EAAEoJ,GACVmhB,EAAE1mB,KAAKuF,GACPmhB,EAAE1mB,KAAK,KACP,IAAIyN,EAAIgK,EAAc,WAClBhK,GACAiZ,EAAE1mB,MAAM,cAAgB9B,KAAKozB,kBAAkB7jB,IAAInO,QAAQ,mBAAoB,gBAEnFonB,EAAE1mB,KAAKswB,EAAY7Y,GAAIC,GAAM,kBAAkB1I,KAAK0I,MACpDgP,EAAE1mB,KAAK,IACX,CACA,OAAO0mB,EAAE5pB,KAAK,GAClB,CACA,gBAAAy0B,CAAiBp1B,GACb,OAAO0yB,EAAiBmC,WAAW70B,EAAG+B,KAC1C,CACA,aAAAszB,CAAcr1B,GACV,IAAIuqB,EAAI,GACR,IAAK,IAAInhB,KAAKpJ,EAAG,CACb,IAAIsb,EAAItb,EAAEoJ,GACVmhB,EAAE1mB,KAAK,UAAYuF,GACnBmhB,EAAE1mB,KAAK,KACP0mB,EAAE1mB,KAAK6uB,EAAiBmC,WAAWvZ,EAAGvZ,OACtCwoB,EAAE1mB,KAAK,IACX,CACA,OAAO0mB,EAAE5pB,KAAK,GAClB,CACA,aAAA20B,CAAct1B,GACV,MAAMmqB,EAAIpoB,KACJwoB,EAAI,GAIV,SAAS+K,EAAc/K,EAAGnhB,EAAGsrB,GACzB,IAAII,EAAU,WAAL1rB,EAAiB,IAAMA,EAAI,GACpCmhB,EAAE1mB,KAAK,SAAWixB,GAClBvK,EAAE1mB,KAAK,KACP0mB,EAAE1mB,KAAK6wB,GACPnK,EAAE1mB,KAAK,IACX,CACA,SAAS0xB,EAAoBhL,EAAGnhB,EAAGkS,GAC/B,IACIoZ,EAAKc,EADC,IAAKla,IAEXoZ,GAAOA,EAAGhwB,OAAS,GACnB4wB,EAAc/K,EAAGnhB,EAAGsrB,EAE5B,CACA,SAASc,EAAiBC,GACtB,MAAMC,EAAUD,EAAM,WAChBlL,EAAI,GAaV,GAAImL,EACA,IAAK,IAAItsB,KAAKssB,EAAS,CACnB,IACIhB,EAAKc,EADC,IAAKE,EAAQtsB,KAEnBsrB,GAAOA,EAAGhwB,OAAS,GACnB4wB,EAAc/K,EAAGnhB,EAAGsrB,EAE5B,CAKJ,cAFQe,EAAM,WACdlL,EAAE1mB,KAAK6uB,EAAiBmC,WAAWY,EAAOtL,GAvB1B,CAACI,EAAGnhB,EAAGkS,EAAG4O,KACtB,GAAS,WAAL9gB,EAAgB,CAChB,MAAMusB,EAAK,GACX,IAAK,IAAIC,KAAKta,EACVia,EAAoBI,EAAIC,EAAGta,EAAEsa,IAIjC,OAFArL,EAAE1mB,KAAK8xB,EAAGh1B,KAAK,KACfupB,EAAO8K,OAAQ,GACR,CACX,CACA,OAAO,CAAK,KAcTzK,EAAE5pB,KAAK,GAClB,CA7CIX,EAAEkU,KAAKxP,OAAS,GAChB6lB,EAAE1mB,KAAK,UAAY7D,EAAEkU,KAAKvT,KAAK,KAAO,KA8C1C,IAAK,IAAIyI,KAAKpJ,EAAEgwB,OAAQ,CACpB,IAEI0E,EAAKc,EADG,IADJx1B,EAAEgwB,OAAO5mB,KAGbsrB,GAAOA,EAAGhwB,OAAS,GACnB4wB,EAAc/K,EAAGnhB,EAAGsrB,EAE5B,CAEA,OAAOnK,EAAE5pB,KAAK,GAElB,CAEA,qBAAAk1B,CAAsB71B,GAClB,MAAMuqB,EAAI,GAEV,IAAK,IAAInhB,KAAKpJ,EAAG,CACb,IACI2qB,EAAI,IADA3qB,EAAEoJ,IAGVmhB,EAAE1mB,KAAK,mBAAqBuF,GAC5BmhB,EAAE1mB,KAAK,KACP,IAAIiyB,EAAK,GACT,IAAK,IAAIF,KAAKjL,EAAG,CACb,IAAIoL,EAAKpL,EAAEiL,GACPG,IACAA,EAAK,QAAQljB,KAAKkjB,GAAM,IAAMA,EAAK,IAAMA,EACzCD,EAAGjyB,KAAK+xB,EAAI,IAAYG,GAEhC,CACAxL,EAAE1mB,KAAKiyB,EAAGn1B,KAAK,MACf4pB,EAAE1mB,KAAK,IACX,CACA,OAAO0mB,EAAE5pB,KAAK,GAClB,CACA,gBAAAq1B,CAAiBh2B,GACb,MAAMuqB,EAAI,GAOV,OANAvqB,EAAEE,SAAQkJ,IACN,IAAIkS,EAAIlS,EACRmhB,EAAE1mB,KAAK,eA6GnB,SAAwB0mB,EAAGI,GACvB,IAAImL,EAAK,GAGT,IAAK,IAAIF,KAAKjL,EAAG,CACb,IAAIoL,EAAKpL,EAAEiL,GACPG,IACAA,EAAK,QAAQljB,KAAKkjB,IAAuB,iBAAR,EAAoB,IAAMA,EAAK,IAAMA,EACtED,EAAGjyB,KAAK+xB,EAAI,IAAYG,GAEhC,CACAxL,EAAE1mB,KAAKiyB,EAAGn1B,KAAK,KACnB,CAxHYs1B,CAAe1L,EAAGjP,GAClBiP,EAAE1mB,KAAK,IAAI,IAER0mB,EAAE5pB,KAAK,GAClB,CACA,yBAAAu1B,CAA0Bl2B,GAEtB,OADUm2B,EAAY,wBAAyBn2B,EAEnD,CACA,yBAAAo2B,CAA0Bp2B,GAEtB,OADUm2B,EAAY,wBAAyBn2B,EAEnD,CACA,eAAAq2B,CAAgBr2B,GACZ,MAAMuqB,EAAI,GAiBV,OAhBAvqB,EAAE6xB,MAAM3xB,SAASolB,IACb,IAAIgR,EAAK,GAELhR,EAAEwM,MACFwE,EAAGzyB,KAAKyhB,EAAEwM,KACV,CAAC,QAAS,WAAW,WAAW5xB,SAASkJ,IACjCkc,EAAElc,IACNktB,EAAGzyB,KAAKyhB,EAAElc,GAAE,KAGhBktB,EAAG5xB,OAAS,IACZ4xB,EAAKA,EAAG31B,KAAK,KAAK,IAClB4pB,EAAE1mB,KAAK,WAAayyB,GACxB,IAGG/L,EAAE7lB,OAAS,EAAI6lB,EAAE5pB,KAAK,IAAM,IACvC,CACA,iBAAA41B,CAAkBv2B,GACd,MAAMuqB,EAAK,GAYX,OAXAvqB,EAAEE,SAASolB,IACP,MAAMtlB,EAAI,GACV,CAAC,SAAS,OAAOE,SAAQkJ,IACjBkc,EAAElc,IACFpJ,EAAE6D,KAAKyhB,EAAElc,GACb,IAEApJ,EAAE0E,OAAO,GACT6lB,EAAE1mB,KAAK,cAAc7D,EAAEW,KAAK,KAAK,IACrC,IAEG4pB,EAAE5pB,KAAK,GAClB,CACA,aAAA61B,CAAcx2B,GACV,MAAMuqB,EAAI,GACV,IAAInhB,EAAI,KACR,IAAKA,KAAKpJ,EAAE,CACR,IAAI2qB,EAAI,GACA3qB,EAAEoJ,GACF,WAAJA,IACAuhB,GAAKvhB,GAET,IAAIE,EAAI6qB,EAAYn0B,EAAEoJ,IAClBE,IACAqhB,GAAK,IAAIrhB,EAAE,KAEXqhB,IACAJ,EAAE1mB,KAAK,UACP0mB,EAAE1mB,KAAK8mB,GAEf,CACA,OAAOJ,EAAE5pB,KAAK,GAClB,CACA,qBAAA81B,CAAsBz2B,GAClB,MAAMuqB,EAAI,GAEV,OADAA,EAAE1mB,KAAKsyB,EAAY,kBAAmBn2B,IAC/BuqB,EAAE5pB,KAAK,GAClB,CACA,gBAAA+1B,CAAiB12B,GACb,MAAMuqB,EAAI,GAEV,IAAI,IAAInhB,KAAKpJ,EAAE,CACX,IAAI2qB,EAAI,GACJrP,EAAItb,EAAEoJ,GAEV,GADAuhB,EAAE9mB,KAAK,aACA,WAAHuF,EAAa,CACb,IAAI7D,EAAM,WAAWsN,KAAKzJ,GAAK,GAAI,IACnCuhB,EAAE9mB,KAAK0B,EAAI6D,EACf,CACAuhB,EAAE9mB,KAAK,KACP8mB,EAAE9mB,KAAKsyB,EAAY,GAAI7a,GAASqb,QAChChM,EAAE9mB,KAAK,KAEP0mB,EAAE1mB,KAAK8mB,EAAEhqB,KAAK,IAClB,CAEA,OAAO4pB,EAAE5pB,KAAK,GAClB,CACA,sBAAAi2B,CAAuB52B,GACnB,MAAMuqB,EAAI,GACJI,EAAI,GAKV,OAJAA,EAAE9mB,KAAK,KACP8mB,EAAE9mB,KAAKswB,EAAYn0B,IACnB2qB,EAAE9mB,KAAK,KACP0mB,EAAE1mB,KAAK,mBAAmB8mB,EAAEhqB,KAAK,KAC1B4pB,EAAE5pB,KAAK,GAClB,EA2BJ,SAASw1B,EAAYjzB,EAAKlD,EAAG62B,GACzB,MAAMtM,EAAI,GAEV,IAAK,IAAInhB,KAAKpJ,EAAG,CACb,IACI2qB,EAAI,IADA3qB,EAAEoJ,IAEVmhB,EAAE1mB,KAAKX,EAAM,IAAMkG,GACnBmhB,EAAE1mB,KAAK,KACP,IAAIiyB,EAAK,GACT,IAAK,IAAIF,KAAKjL,EAAG,CACb,IAAIoL,EAAKpL,EAAEiL,GACX,GAAIG,EACA,GAAmB,iBAAR,EAAkB,CACzB,IAAIvsB,EAAI2qB,EAAY4B,GAChBvsB,GAAMA,EAAE9E,OAAS,GACjBoxB,EAAGjyB,KAAK+xB,EAAI,IAAYpsB,EAChC,MACIusB,EAAK,QAAQljB,KAAKkjB,GAAM,IAAMA,EAAK,IAAMA,EACzCD,EAAGjyB,KAAK+xB,EAAI,IAAYG,EAGpC,CACAxL,EAAE1mB,KAAKiyB,EAAGn1B,KAAK,MACf4pB,EAAE1mB,KAAK,IACX,CACA,OAAO0mB,EAAE5pB,KAAK,GAClB,CAEAjB,EAAQgzB,iBAAmBA,EAC3BhzB,EAAQgpB,MAAQ,CACZoO,WAAY3C,E,8BC/ZhBpzB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,kBAAEuoB,GAAsB,EAAQ,OAChC,WAAEhT,GAAe,EAAQ,MACzB,oBAAE4O,GAAwB,EAAQ,OAClC,SAAEP,GAAa,EAAQ,OACvB,kBAAElC,GAAsB,EAAQ,MAChC8G,EAAY,EAAQ,OACpB,qBAAEjH,GAAyB,EAAQ,MACnC,cAAEsC,GAAkB,EAAQ,OAC5B,gBAAE/B,GAAoB,EAAQ,OAC9B,iBAAES,GAAqB,EAAQ,OAC/B,WAAEa,GAAe,EAAQ,MAEzBzN,EAAaJ,EAAWkT,WAAWD,GACnCE,EAAyB,IAAIH,EAOnC,SAASI,EAAiBnsB,GAGtB,OAFAA,EAAIA,EAAE7H,QAAQ,eAAgBoY,GAAMA,EAAE,GAAG3T,gBAAezE,QAAQ,UAAW,KACrE,GAAGyE,cAAgBoD,EAAEujB,UAAU,EAEzC,CAgBA,MAAM6I,GAON,MAAMC,EACF7oB,MACA+kB,SACArwB,IACAo0B,YACAC,iBAIAC,WAKA,WAAArgB,CAAY8D,GACR,IAAKA,EACD,MAAM,IAAInJ,MAAM,sBAEpB/P,KAAKyM,MAAQzM,KAAKwxB,SAAWxxB,KAAKmB,IAAM,GACxCnC,OAAOD,eAAeiB,KAAM,WAAY,CAAE2M,IAAG,IAAYuM,GAC7D,CAKA,cAAAwc,CAAehF,GACX,MAAMiF,EAAc,IAAM,IAAIN,EAC9B,GAAI3E,EAAK,CACL,MAAM,IAAEvvB,GAAQnB,KAChBA,KAAKu1B,aAAgBp0B,KAAOuvB,EAAOA,EAAIvvB,GAAO,OAASw0B,GAC3D,MACI31B,KAAKu1B,YAAcv1B,KAAK41B,oBAAoB51B,KAAKmB,MAAQw0B,IAE7D31B,KAAKiwB,MAAMS,EACf,CACA,KAAA/vB,GACIX,KAAKwxB,SAAW,GAChBxxB,KAAKmB,IAAM,GACXnB,KAAKyM,MAAQ,GACbzM,KAAKu1B,YAAc,IACvB,CAIA,MAAAM,GACI,MAAM,SAAErE,EAAQ,MAAE/kB,EAAK,YAAE8oB,GAAgBv1B,KACzC,IAAImN,EAAI,GASR,GAAIqkB,GAAY+D,EAAa,CACzB,MAAMO,EAAS,iBAIX3oB,EAHiB2oB,EAAOhlB,KAAKrE,GAAOmoB,QAGhC,IAbZ,SAAwB3rB,GACpBjJ,KAAKkuB,OAAS,IACHjlB,EAEXjJ,KAAKkR,SAAW,IACLjI,CAEf,CAMY,CAAmBwD,GAAOmoB,OAAOxzB,QAAQ00B,EAAQ,OAIzB,GAAvBrpB,EAAMmoB,OAAOjyB,QAAiB8J,EAAM9J,OAAS,EAAK8J,EAAQA,GAAOmoB,OAAOxzB,QAAQ00B,EAAQ,MAEjGP,EAAY/D,GAAYrkB,EACxBnN,KAAKyM,MAAQ,EACjB,CACJ,CAKA,KAAAwjB,CAAMS,GAEF1wB,KAAK61B,SACL,MAAM,SAAE3c,EAAQ,IAAE/X,EAAG,YAAEo0B,EAAW,WAAEE,GAAez1B,KAC/CmB,IACIuvB,GACAA,EAAIvvB,GAAOo0B,EACXv1B,KAAK+1B,eAAerF,EAAKvvB,EAAKo0B,MAElBE,GAAcvc,EAAS+U,QAC9B9sB,GAAOo0B,EACZv1B,KAAK+1B,eAAe7c,EAAS+U,OAAQ9sB,EAAKo0B,IAGtD,CACA,cAAAQ,CAAerF,EAAKvvB,EAAKo0B,GACRp0B,EAAIuB,MAAM,KACdC,OAAS,IACd3C,KAAKg2B,qBAAqBtF,GACpBvvB,KAAOnB,KAAKw1B,iBAAiB1jB,OAA2D,GAAjD9R,KAAKw1B,iBAAiB1jB,KAAK3Q,GAAKkN,QAAQqiB,KAC3EvvB,KAAOnB,KAAKw1B,iBAAiB1jB,OAC/B9R,KAAKw1B,iBAAiB1jB,KAAK3Q,GAAO,IAEtCnB,KAAKw1B,iBAAiB1jB,KAAK3Q,GAAKW,KAAK4uB,IAGjD,CACA,gBAAAuF,CAAiBp4B,EAAO03B,GACpB,IAAK,IAAIp0B,KAAOo0B,EACZ13B,EAAMsD,GAAOo0B,EAAYp0B,EAEjC,CACA,wBAAA+0B,GACI,MAAM,iBAAEV,GAAqBx1B,KAC7B,IAAKw1B,EAAkB,OACvB,MAAMrjB,EAAOnT,OAAO8S,KAAK0jB,EAAiB1jB,MAC1C,KAAOK,EAAKxP,OAAS,GAAG,CACpB,IAAIylB,EAAIjW,EAAKsE,QACb,MAAM0f,EAAO/N,EAAE1lB,MAAM,WACf0zB,EAAQp2B,KAAKw1B,iBAAiB1jB,KAAKsW,GACzC,KAAOgO,EAAMzzB,OAAS,GAAG,CACrB,MAAM4yB,EAAca,EAAM3f,QAAQ2R,GAGlC+N,EAAKh4B,SAAQqb,KACTA,EAAIA,EAAEob,UACGlE,IACL1wB,KAAKi2B,iBAAiBvF,IAAIlX,GAAI+b,GAErBc,IAGb,GAIR,CACJ,CACJ,CACA,QAAA9vB,GACIvG,KAAKk2B,0BACT,CACA,oBAAAF,CAAqBtF,GACZ1wB,KAAKw1B,mBACNx1B,KAAKw1B,iBAAmB,GACxBx1B,KAAKw1B,iBAAiBvH,OAAS,CAAC,EAChCjuB,KAAKw1B,iBAAiB1jB,KAAO,CAAC,GAGlC,MAAM,iBAAE0jB,GAAqBx1B,KAC7B,IAAIs2B,EAASt2B,KAAKw1B,iBAAiBnnB,QAAQqiB,GAO3C,OANe,GAAX4F,IACAt2B,KAAKw1B,iBAAiB1zB,KAAK4uB,GAC3B4F,EAASt2B,KAAKw1B,iBAAiB7yB,OAAS,EACxC3C,KAAKw1B,iBAAiBvH,OAAOqI,GAAU,IAAIjB,GAElCr1B,KAAKw1B,iBAAiBvH,OAAOqI,EAE9C,CACA,mBAAAV,CAAoBz0B,GAChB,MAAM,SAAE+X,GAAalZ,KACrB,OAAOA,KAAKu2B,gBAAgBp1B,EAAK+X,EAAS+U,OAC9C,CACA,mBAAAuI,CAAoBC,GAChB,MAAM,SAAEvd,GAAalZ,KACrB,OAAOA,KAAKu2B,gBAAgBE,EAAMvd,EAAS0Y,OAE/C,CACA,eAAA2E,CAAgBp1B,EAAKu1B,GACjB,OAAQv1B,KAAOu1B,EAAOA,EAAIv1B,GAAO,IACrC,EAEJ,MAAMw1B,GAs+BNh5B,EAAQi5B,eAxDR,MAQI,aAAOC,CAAO1lB,EAAK6Z,GACf,MAAM8L,EAAkB,IAAIlG,EACtBmG,EAAsB,IAAIzB,EAAmBwB,GAgBnD,IAAIE,GAAS,EAEThM,GACA,MACI,MAAM,MAAEhG,GAAUgG,EAClBgM,EAAShS,CACZ,EAHD,GAKJ5C,EAAW4C,MAAQgS,EA58B3B,SAAuB5U,EAAY2U,EAAqBE,GACpD,MAAM,uBAAEC,EAAsB,0BAAEC,EAAyB,gBAAEL,GAAoBG,EAGzEG,EAAc,WAKhB,OAJKN,EAAgBhG,SACjBgG,EAAgBhG,OAAS,CAAC,GAGvB,CAAEuG,MADMP,EAAgBhG,OAEnC,EAaMwG,EAAY,CACd5hB,KAAM,KACN6hB,kBAAmB,KACnBC,aAAc,KACdC,SAAU,GACVC,OAAO,EACPC,YAAa,KACbtK,YAAW,CAAC5gB,EAAO0gB,EAAW7F,EAAS6D,EAAQH,IACpCve,EAEX,cAAAmrB,CAAeC,EAAQ7M,GAEnB,MAAM,QAAE1D,GAAYuQ,EACpBtV,QAAQC,IAAI,qCAAsC8E,GAClD,IAAIoQ,GAAQ,EACZ,OAAQpQ,GACJ,IAAK,YACD6P,IACAD,IACAl3B,KAAK0V,KAAO,QACZqhB,EAAoBp2B,QACpBo2B,EAAoB9G,QACpB,MACJ,IAAK,YACL,IAAK,eACL,IAAK,eACD,MACJ,QACI,GAAI3I,GAAW,YAAYxW,KAAKwW,GAC5B,MAAM,IAAIvX,MAAM,kBAAkBuX,KAEtC,GAAIA,GAAW,QAAQxW,KAAKwW,GAAU,CAClC,MAAMwQ,EAAQxQ,EAAQuL,cAAczxB,QAAQ,KAAM,KAAKorB,UAAU,GAE7DxsB,KAAK0V,MACL1V,KAAKy3B,SAAS31B,KAAK,CAAC9B,KAAK0V,KAAM1V,KAAK03B,QACxC13B,KAAK0V,KAAOoiB,EACZJ,GAAQ,EAER,MAAMK,EAAO/3B,KAAK,WAAao1B,EAAiB0C,IAC5CC,GACAA,EAAKj1B,MAAM9C,KAEnB,CACAA,KAAK03B,MAAQA,EAGzB,EACA,mBAAAM,CAAoBrwB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAClDA,EAAQC,QAAS,EACjB,MAAM,aAAEnH,IA5DP+F,EAAgB/F,eACjB+F,EAAgB/F,aAAe,CAAC,GAE7B+F,GA0DH,OAAQxP,GACJ,IAAK,mBACD,MAAMyL,EAAKprB,EAAK4L,OAEhBvT,KAAKm4B,wBAAwBpF,EAAIhC,GACjC,MACJ,IAAK,mBAGD/wB,KAAKo4B,2BACL,MACJ,QACIH,EAAQC,QAAS,EAG7B,EACA,gBAAAG,CAAiB1wB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAE/C,MAAM,MAAEZ,GAAUD,IAElB,OADAa,EAAQC,QAAS,EACT5Q,GACJ,IAAK,cACD,MAAMyL,EAAKprB,EAAK4L,OACVoe,EAAMoB,KAAMsE,EAAQA,EAAMtE,GAAM,CAAC,EACvCsE,EAAMtE,GAAMpB,EACZ3xB,KAAK23B,YAAc,CAAEx2B,IAAK4xB,EAAIx1B,OAAQo0B,GACtC,MACJ,IAAK,eACD3xB,KAAKs4B,gBAAgB3wB,GACrB,MACJ,QACIswB,EAAQC,QAAS,EAG7B,EACA,eAAAI,CAAgB3wB,GACZ,MAAM,MAAE0vB,GAAUD,IACZmB,EAAQv4B,KAAK23B,YAAYx2B,IACzBA,EAAMwG,EAAK4L,OACXmd,EAAM2G,EAAMkB,GAClBv4B,KAAKm4B,wBAAwBh3B,EAAKuvB,EACtC,EACA,YAAA8H,CAAa7wB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAG3C,IAAIQ,EAAa,KAEjB,OAAQnR,GACJ,IAAK,sBAGDmR,EAAa9wB,EAAK8E,MACbzM,KAAKw3B,aAGNx3B,KAAKw3B,aAAakB,WAAaD,EAF/Bz4B,KAAKw3B,aAAe,CAAEkB,UAAWD,GAMrCR,EAAQC,QAAS,EACjB,MACJ,IAAK,YAEDhB,IACAl3B,KAAKu3B,kBAAoB,KACzBv3B,KAAK0V,KAAO,KACZuiB,EAAQC,QAAS,EAEjB,MACJ,IAAK,eACDD,EAAQC,QAAS,EACjBf,IACAsB,EAAaz4B,KAAKw3B,aAAakB,WAAW9D,OAC1C,MAAM+D,EAAO7B,EAAgBlF,OAAO6G,GACpCz4B,KAAKu3B,kBAAoB,CACrB,UAAakB,EACb,OAAUE,GAAQ,IAAIhC,GAE1B32B,KAAKw3B,aAAe,KACpBT,EAAoB51B,IAAMwG,EAAK8E,OAAOmoB,OACtCmC,EAAoBvF,SAAW,GAC/BuF,EAAoBtqB,MAAQ,GAC5BsqB,EAAoBrB,eAAe11B,KAAKu3B,kBAAkBtJ,QAItE,EACA,wBAAAmK,GACIrB,EAAoB51B,IAAM,KAC1B41B,EAAoBvF,SAAW,GAC/BuF,EAAoBtqB,MAAQ,GAC5BsqB,EAAoBxB,YAAc,IACtC,EAMA,uBAAA4C,CAAwBh3B,EAAKuvB,GACzB1wB,KAAKo4B,2BACLrB,EAAoB51B,IAAMA,EAC1B41B,EAAoBrB,eAAehF,EACvC,EACA,oBAAAkI,CAAqBjxB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAEnDnB,EAAgBjG,QAAUlpB,EAAK8E,MAAMrI,MAAM,GAAI,EACnD,EACA,iBAAAy0B,GACI,MAAM,OAAEC,GAAW94B,KACnB,GAAI84B,GAEmB,aAAfA,EAAO7f,KACP,MAAM,IAAIlJ,MAAM,4BAA8B+oB,EAAO7f,MAG7D,MAAM8f,EAAM,MACR,IAAIC,EAAO,CAAE/f,KAAM,YAAa3M,KAAM,GAAI6F,KAAM,KAAMumB,UAAW,KAAM5Q,OAAQ,KAAM4C,OAAQ,GAAIgG,IAAK,MAItG,OAHA1wB,KAAKo4B,2BACLrB,EAAoBrB,eAAe,MACnCsD,EAAKtI,IAAMqG,EAAoBxB,YACxBv1B,KAAK84B,OAASE,CACxB,EANW,GAUZ,OAHIF,IACA94B,KAAK84B,OAAOhR,OAASgR,GAElB,CAAEC,MACb,EACA,sBAAAE,GACIj5B,KAAKo4B,2BACLrB,EAAoBxB,YAAc,IAAIpH,EACtCnuB,KAAK84B,OAAS,CAAE7f,KAAM,WAAY3M,KAAM,GAAIokB,IAAKqG,EAAoBxB,aAChEuB,EAAgBtF,WACjBsF,EAAgBtF,SAAW,CAAC,EAEpC,EACA,qBAAA0H,CAAsBvxB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAEpD,OADAA,EAAQC,QAAS,EACT5Q,GACJ,IAAK,oBACDtnB,KAAK84B,OAAOxsB,KAAO3E,EAAK4L,OACxB,MACJ,IAAK,uBACDujB,EAAgBtF,SAASxxB,KAAK84B,OAAOxsB,MAAQtM,KAAK84B,OAAOpI,IACzD1wB,KAAK84B,OAAS,KACd/B,EAAoBxB,YAAc,KAClC,MACJ,QACI0C,EAAQC,QAAS,EAG7B,EACA,aAAAiB,GACIn5B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CAAE7f,KAAM,QAASyf,UAAW,KAAMU,SAAU,MACrDtC,EAAgBr3B,QACjBq3B,EAAgBr3B,MAAQ,CAAC,GAE7Bs3B,EAAoBxB,YAAc,IAEtC,EACA,gBAAA8D,GACItC,EAAoBxB,YAAc,KAClCv1B,KAAK84B,OAAS,KACd94B,KAAK03B,OAAQ,CACjB,EACA,YAAA4B,CAAa3xB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC3C,IAAIsB,GAAK,EACLC,EAAOx5B,KAAK84B,OACZW,EAAS9xB,EAAK8E,MAQditB,EAAM,GACV,OAAQpS,GACJ,IAAK,kBACGkS,EAAKd,UACLc,EAAKd,WAAae,EAElBD,EAAKd,UAAYe,EACrB,MACJ,IAAK,YAEDz5B,KAAKq5B,mBACLE,GAAK,EACL,MACJ,IAAK,eACDG,EArBR,SAAsB/zB,GAClB,IAAI4B,EAAI,GAIR,OAHI5B,EAAI+yB,WACJnxB,EAAEzF,KAAK6D,EAAI+yB,WAERnxB,EAAE5E,OAAS,EAAI4E,EAAE3I,KAAK,KAAO,SACxC,CAec+6B,CAAaH,GACd1C,EAAgBr3B,MAAMi6B,KACvB5C,EAAgBr3B,MAAMi6B,GAAO,CAAC,GAElC,IAAIE,EAAO9C,EAAgBr3B,MAAMi6B,GAAO5C,EAAgBr3B,MAAMi6B,GAAKD,GAAU,KACxEG,IACDA,EAAO,IAAIvJ,EACXyG,EAAgBr3B,MAAMi6B,GAAKD,GAAUG,GAEzC7C,EAAoBxB,YAAcqE,EAClCJ,EAAKJ,SAAWK,EAChB,MACJ,QACIF,GAAK,EAGbtB,EAAQC,OAASqB,CACrB,EAMA,QAAAM,CAASvS,EAASlI,GAAQ,GACtB,IAAKA,GAASpf,KAAK03B,QAAU,QAAQ5mB,KAAKwW,GAAU,CAChD,MAAM7f,EAAIzH,KAAKy3B,SAASvY,MAQxB,OAPIzX,GACAzH,KAAK0V,KAAOjO,EAAE,GACdzH,KAAK03B,MAAQjwB,EAAE,KAEfzH,KAAK0V,UAAOlK,EACZxL,KAAK03B,OAAQ,IAEV,CACX,CACJ,EACA,YAAAoC,CAAanyB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC3C,IAAIsB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACd,MAAM+sB,EAAOx5B,KAAK84B,OAClB,SAASiB,EAAaP,EAAM9I,EAAKvvB,GAC7B,GAAIq4B,EAAKvJ,MACL,OAEJ,MAAMlM,EAAO5iB,GAAO41B,EAAoB51B,IAClCu4B,EAAMF,EAAKQ,MAAMp7B,KAAK,OAAS,UAE/B8xB,aAAeJ,IAAkBvM,IAAQyV,EAAK9I,KAM3CoG,EAAgB5G,MAAMjC,OAAOyL,KAC9B5C,EAAgB5G,MAAMjC,OAAOyL,GAAO,CAAC,GAE5B,OAAT3V,EACA+S,EAAgB5G,MAAMjC,OAAOyL,GAAK3V,GAAQ2M,EAE1CoG,EAAgB5G,MAAMjC,OAAOyL,GAAOhJ,IAXxC8I,EAAK9I,IAAI3M,GAAQ2M,EACjBA,EAAM8I,EAAK9I,IACXoG,EAAgB5G,MAAMjC,OAAOyL,GAAOhJ,GAYxC8I,EAAKvJ,OAAQ,CACjB,CAEA,OAAQ3I,GACJ,IAAK,aACDkS,EAAKQ,MAAMl4B,KAAKkyB,GAChB,MACJ,IAAK,kBACD,GAAI8C,EAAgB5G,MAAM/d,KAAKxP,OAAS,EACpC,MAAM,IAAIoN,MAAM,sCAEpB,GAAIypB,EAAK1R,OACL,MAAM,IAAI/X,MAAM,iDAEpB+mB,EAAgB5G,MAAM/d,KAAKrQ,QAAQ03B,EAAKQ,OACxCh6B,KAAKq5B,mBACLr5B,KAAK65B,WACLN,GAAK,EACL,MACJ,IAAK,eACDxC,EAAoB51B,IAAM6yB,EAC1B+C,EAAoBxB,YAAc,IAAIlF,EACtC,MACJ,IAAK,YACD,IAAI4J,EAAKT,GAAM1R,OACVmS,IAGDF,EAAaP,EAAMzC,EAAoBxB,aACvCv1B,KAAKq5B,mBACLE,GAAK,GAETv5B,KAAK84B,OAASmB,EACdlD,EAAoBxB,YAAc0E,GAAIvJ,IACtCqG,EAAoB51B,IAAM,KAC1B,MAGJ,IAAK,iBACD,IAAIu4B,EAAM,KACNhJ,EAAMqG,EAAoBxB,YAC1BxR,EAAOgT,EAAoB51B,IAC/B,GAAIq4B,EAAK1R,OAAQ,CACb4R,EAAMF,EAAKQ,MAAMp7B,KAAK,MACtB,MAAMs7B,EAAQV,EAAK1R,OAAO4I,IACrBwJ,EAAMxP,OAAOgP,KACdQ,EAAMxP,OAAOgP,GAAO,CAAC,GAEzBQ,EAAMxP,OAAOgP,GAAK3V,GAAQ2M,EAC1BA,EAAMwJ,CACV,MACIH,EAAaP,EAAM9I,GAEnBA,EAAM8I,EAAK9I,IAEfqG,EAAoBxB,YAAc7E,EAClCqG,EAAoB51B,IAAM,KAE1B,MACJ,QACIo4B,GAAK,EAGbtB,EAAQC,OAASqB,CACrB,EACA,aAAAY,GACI,MAAMX,EAAOx5B,KAAK84B,OAClB,IAAIsB,EAAU,KAEd,GAAIZ,EAAM,CACN,GAAiB,SAAbA,EAAKvgB,KACL,MAAM,IAAIlJ,MAAM,wBAA0BypB,EAAKvgB,MAEnDmhB,EAAUZ,EACLY,EAAQ1J,MACT0J,EAAQ1J,IAAM,IAAIJ,EAG1B,CAEA,IAAI+J,EAAQD,GAAS1J,IACrB1wB,KAAK84B,OAAS,CAAE7f,KAAM,QAAS+gB,MAAO,GAAIlS,OAAQsS,EAAS1J,IAAK2J,EAAOpK,OAAO,GACzE6G,EAAgB5G,QAEjB4G,EAAgB5G,MAAQ,IAAIlC,GAEhC+I,EAAoBxB,YAAc8E,CACtC,EACA,gBAAAC,CAAiB3yB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC/C,MAAMc,EAAM/4B,KAAK84B,OACjB,IAAIW,EAAS9xB,EAAK4L,OAGlB,OADA0kB,EAAQC,QAAS,EACT5Q,GACJ,IAAK,sBACD,IAAIqF,EAAM,WAAW7b,KAAK2oB,GAE1B,GADAA,EAAS9M,EAAM8M,EAAOr4B,QAAQ,WAAY,KAAOq4B,EAC7CV,EAAIL,UACJK,EAAIL,YAAc/L,EAAM,GAAK,KAAO8M,MACjC,CACH,GAAI,mBAAmB3oB,KAAK2oB,GACxB,MAAM,IAAI1pB,MAAM,2CAEpBgpB,EAAIL,UAAYe,CACpB,CACA,MACJ,IAAK,iBACDV,EAAIzsB,KAAOmtB,EACXV,EAAI5mB,KAAOsnB,EAAOr4B,QAAQ,UAAW,KAAKsB,MAAM,KAChD,MACJ,IAAK,gBAED,MAAMguB,EAAMqG,EAAoBxB,YAChC,GAAI7E,EAAK,CACL,MAAM6J,EAvnB9B,SAA0BxB,GACtB,MAAMrC,EAAM,GAOZ,OANIqC,EAAIzsB,MACJoqB,EAAI50B,KAAKi3B,EAAIzsB,MAEbysB,EAAIL,WACJhC,EAAI50B,KAAKi3B,EAAIL,WAEVhC,EAAI/zB,OAAS,EAAI+zB,EAAI93B,KAAK,KAAO,SAC5C,CA8mBgD47B,CAAiBzB,GAIzC,GAHKjC,EAAgB7F,YACjB6F,EAAgB7F,UAAY,CAAC,GAE7B8H,EAAIjR,OAAQ,CACZiR,EAAIrO,OAAO5oB,KAAK4uB,GACV,eAAgBqI,EAAIjR,OAAO4I,MAC7BqI,EAAIjR,OAAO4I,IAAgB,WAAI,CAAC,GAEpC,IAAIuJ,EAAKlB,EAAIjR,OAAO4I,IAAgB,WAAE6J,GAClCN,EACA5J,EAASG,UAAUyJ,EAAIvJ,GAEvBqI,EAAIjR,OAAO4I,IAAgB,WAAE6J,GAAmB7J,CACxD,KAAO,CACH,IAAIuJ,EAAKnD,EAAgB7F,UAAUsJ,GAC/BN,EACA5J,EAASG,UAAUyJ,EAAIvJ,GAEvBoG,EAAgB7F,UAAUsJ,GAAmB7J,CAErD,CAEJ,CACA1wB,KAAKo4B,2BACDW,EAAIjR,QACJ9nB,KAAK84B,OAASC,EAAIjR,OAClBiP,EAAoBxB,YAAcwD,EAAIjR,OAAO4I,KAG7C1wB,KAAK84B,OAAS,KAElB,MACJ,QACIb,EAAQC,QAAS,EAG7B,EACA,YAAAuC,CAAa5C,EAAQ7M,EAAQ0P,GAAkB,GAC3C,GAAIA,EACA,OAEJ,IAAIvN,EAAYnC,EAAO2P,YACnBrT,EAAUuQ,EAAOvQ,QAErB,MAAMmS,EAAS5B,EAAOprB,OAAgB,CAAGA,MAAOue,EAAO4P,OAAQrnB,OAAQyX,EAAOrjB,OACxE,KAAE+N,GAAS1V,MACX,MAAEglB,GAAUgG,EAKlB,GAHAhG,GAASzC,QAAQC,IAAI,mCAAoC8E,EAASmS,EAAOlmB,QAGrEmC,EAAM,CACN,MAAMqiB,EAAO/3B,KAAK,UAAYo1B,EAAiB1f,IAC/C,GAAIqiB,EAAM,CACN,MAAME,EAAU,CAAEC,QAAQ,GAE1B,GADAH,EAAKj1B,MAAM9C,KAAM,CAACy5B,EAAQ5B,EAAQvQ,EAAS6F,EAAW8K,IAClDA,EAAQC,OACR,MAER,CAEA,GAAIl4B,KAAK65B,SAASvS,GACd,MAER,CAEA,OAAQA,GACJ,IAAK,YACDyP,EAAoBtqB,OAASgtB,EAAOhtB,MACpC,MACJ,IAAK,eACD0qB,IACAJ,EAAoBvF,SAAWiI,EAAOhtB,OAAOmoB,OAC7CmC,EAAoBtqB,MAAQ,GAC5B,MACJ,IAAK,eACD0qB,IACAJ,EAAoB51B,IAAMs4B,EAAOhtB,OAAOmoB,OACxCmC,EAAoBvF,SAAW,GAC/BuF,EAAoBtqB,MAAQ,GAC5BsqB,EAAoBrB,iBACpB,MACJ,IAAK,mBAEDyB,IACAJ,EAAoBvF,SAAW,GAC/BuF,EAAoBtqB,MAAQ,GAC5B,MACJ,IAAK,iBACD0qB,IACAJ,EAAoB51B,IAAM,GAC1B41B,EAAoBvF,SAAW,GAC/BuF,EAAoBtqB,MAAQ,GAIxC,EACA,KAAAwjB,GACIkF,EAAuBlF,MAAMntB,MAAMqyB,EAAwBp0B,UAC/D,EAEA,oBAAA85B,GACI76B,KAAKo4B,0BACT,EACA,mBAAA0C,CAAoBnzB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAElDA,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACd,OAAQ6a,GACJ,IAAK,qBACDyP,EAAoB51B,IAAM6yB,EAC1B+C,EAAoBxB,YAAc,IAAIhH,EACtC,MACJ,IAAK,oBACD,MAAMxK,EAAOgT,EAAoB51B,IAC5B21B,EAAgBiE,gBACjBjE,EAAgBiE,cAAgB,CAAC,GAErCjE,EAAgBiE,cAAchX,GAAQgT,EAAoBxB,YAC1Dv1B,KAAKo4B,2BACL,MACJ,QACImB,GAAK,EAGb,OAAOA,CACV,EArBgB,EAsBrB,EAGA,gBAAAyB,GACIh7B,KAAKo4B,2BACLrB,EAAoBxB,YAAc,IAAIvG,CAC1C,EACA,eAAAiM,CAAgBtzB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC9CA,EAAQC,OAAS,MACb,IAAIqB,GAAK,EAcT,OAbS5xB,EAAK8E,MAEL,kBADD6a,GAEKwP,EAAgB3F,WACjB2F,EAAgB3F,SAAW,IAE/B2F,EAAgB3F,SAASrvB,KAAKi1B,EAAoBxB,aAClDv1B,KAAKo4B,4BAGLmB,GAAK,EAGNA,CACV,EAhBgB,EAiBrB,EAEA,yBAAA2B,GACIl7B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CAAE7f,KAAM,sBAAuB9X,IAAK,KAAMg6B,MAAO,KAAMnB,MAAO,GAChF,EACA,wBAAAoB,CAAyBzzB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GACvDA,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACV+sB,EAAOx5B,KAAK84B,OAChB,OAAQxR,GACJ,IAAK,WACIwP,EAAgB1F,oBACjB0F,EAAgB1F,kBAAoB,CAAC,GAEzCoI,EAAKQ,MAAMl4B,KAAKkyB,GAChB,MACJ,IAAK,WACDh0B,KAAK84B,OAAO33B,IAAM6yB,EAClB,MAAM0F,EAAMF,EAAKQ,MAAMp7B,KAAK,KACtBo6B,EAAOlC,EAAgB1F,kBAC7BpxB,KAAKo4B,2BACAY,EAAKU,KACNV,EAAKU,GAAO,CAAC,GAEjBW,MAAQrB,EAAKU,GAAK1F,IAAO,MACrB,MAAM7mB,EAAI,IAAIkjB,EAEd,OADA2I,EAAKU,GAAK1F,GAAM7mB,EACTA,CACV,GACD4pB,EAAoBxB,YAAc8E,MAClC,MACJ,IAAK,YACDr6B,KAAK84B,OAAOqC,MAAQnH,EACpB,MACJ,IAAK,0BACDh0B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd,MACJ,QACIS,GAAK,EAGb,OAAOA,CACV,EAtCgB,EAuCrB,EAEA,yBAAA8B,GACIr7B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CAAE7f,KAAM,sBAAuB9X,IAAK,KAAMg6B,MAAO,KAAMnB,MAAO,GAChF,EACA,wBAAAsB,CAAyB3zB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GACvDA,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACV+sB,EAAOx5B,KAAK84B,OAChB,OAAQxR,GACJ,IAAK,WACIwP,EAAgBzF,oBACjByF,EAAgBzF,kBAAoB,CAAC,GAEzCmI,EAAKQ,MAAMl4B,KAAKkyB,GAChB,MAAM0F,EAAMF,EAAKQ,MAAMp7B,KAAK,KAC5B,IAAIy7B,EAAQvD,EAAgBzF,kBAAkBqI,IAAQ,MAClD,IAAIvsB,EAAI,IAAIkjB,EAEZ,OADAyG,EAAgBzF,kBAAkBqI,GAAOvsB,EAClCA,CACV,EAJqD,GAKtD4pB,EAAoBxB,YAAc8E,EAElC,MACJ,IAAK,0BACDr6B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd,MACJ,QACIS,GAAK,EAGb,OAAOA,CACV,EA5BgB,EA6BrB,EAGA,cAAAgC,GACIv7B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CACV7f,KAAM,UAAW9X,IAAK,KAAMg6B,MAAO,KAAMnB,MAAO,GAChDjK,IAAK,KAAMG,MAAO,KAAMC,SAAU,KAAMC,QAAS,KAEzD,EACA,aAAAoL,CAAc7zB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC5C,MAAM7P,EAAIpoB,KACVi4B,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACV+sB,EAAOpR,EAAE0Q,OAIb,OAHKhC,EAAgB9F,UACjB8F,EAAgB9F,QAAU,IAAInB,GAE1BvI,GACJ,IAAK,MACDkS,EAAKzJ,IAAMiE,EACX,MACJ,IAAK,gBACDwF,EAAKpJ,QAAU4D,EACf,MACJ,IAAK,cACG,SAASljB,KAAKkjB,KACdwF,EAAKtJ,MAAQ8D,GAEb,YAAYljB,KAAKkjB,KACjBwF,EAAKrJ,SAAW6D,GAEpB,MACJ,IAAK,aACD8C,EAAgB9F,QAAQf,MAAMuJ,GAC9B,MACJ,QACID,GAAK,EAGb,OAAOA,CACV,EA9BgB,EA+BrB,EAEA,iBAAAkC,GACIz7B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CACV7f,KAAM,YAAa0V,OAAQ,KAAMoB,IAAK,KAE9C,EACA,gBAAA2L,CAAiB/zB,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC/C,MAAM7P,EAAIpoB,KACVi4B,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACV+sB,EAAOpR,EAAE0Q,OAIb,OAHKhC,EAAgBxF,YACjBwF,EAAgBxF,UAAY,IAExBhK,GACJ,IAAK,YACDkS,EAAK7K,OAASqF,EACd,MACJ,IAAK,MACDwF,EAAKzJ,IAAMiE,EACX,MACJ,IAAK,gBACDh0B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd,MAAM,OAAEnK,EAAM,IAAEoB,GAAQyJ,EACxB1C,EAAgBxF,UAAUxvB,KAAK,CAAE6sB,SAAQoB,QACzC,MACJ,QACIwJ,GAAK,EAGb,OAAOA,CACV,EAzBgB,EA0BrB,EAGA,YAAAoC,GACI37B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CACV7f,KAAM,OAAQmgB,SAAU,GACxB1I,IAAK,IAAIL,GAEb0G,EAAoBxB,YAAcv1B,KAAK84B,OAAOpI,IACzCoG,EAAgB8E,QACjB9E,EAAgB8E,MAAQ,CAAC,EAEjC,EACA,WAAAC,CAAYl0B,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC1C,MAAM7P,EAAIpoB,KACVi4B,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLvF,EAAKrsB,EAAK8E,MACV+sB,EAAOpR,EAAE0Q,OACb,OAAQxR,GACJ,IAAK,gBACDkS,EAAKJ,SAASt3B,KAAKkyB,GACnB,MACJ,IAAK,MACDwF,EAAKzJ,IAAMiE,EACX,MACJ,IAAK,WACD,MAAM4F,EAAOJ,EAAK9I,IACZgJ,GAAOF,EAAKJ,SAASz2B,OAAS,EAAI62B,EAAKJ,SAASx6B,KAAK,MAAQ,OAAS,UAC5E,IAAIk9B,EAAOhF,EAAgB8E,MAAMlC,GAC7BoC,EACAzL,EAASG,UAAUsL,EAAMlC,GAEzB9C,EAAgB8E,MAAMlC,GAAOE,EAEjC55B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd,MACJ,QACIS,GAAK,EAGb,OAAOA,CACV,EA5BgB,EA6BrB,EAGA,qBAAAwC,GACI/7B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CACV7f,KAAM,iBACN+iB,QAASjF,EAAoB7d,SAAS+U,QAE1C8I,EAAoBxB,YAAc,IAAIlF,EACjCyG,EAAgBrF,gBACjBqF,EAAgBrF,cAAgB,CAAC,GAErCsF,EAAoBtB,WAAaqB,EAAgBrF,aAErD,EACA,oBAAAwK,CAAqBt0B,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GACnD,MAAM7P,EAAIpoB,KACVi4B,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLC,EAAOpR,EAAE0Q,OAab,MAXS,uBADDxR,GAIAtnB,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd/B,EAAoBtB,WAAa+D,EAAKwC,SAGtCzC,GAAK,EAGNA,CACV,EAhBgB,EAiBrB,EAGC,gBAAA2C,GACGl8B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CACV7f,KAAM,WACN9X,IAAM,UACNg7B,QAAS,MAEbpF,EAAoBxB,YAAc,IAAIlF,EACjCyG,EAAgB3G,WACjB2G,EAAgB3G,SAAW,CAAC,GAEhCnwB,KAAK84B,OAAOqD,QAAUrF,EAAgB3G,SAASnwB,KAAK84B,OAAO33B,MAAQ,CAAC,EACpE41B,EAAoBtB,WAAaz1B,KAAK84B,OAAOqD,QAC7CpF,EAAoB51B,IAAMnB,KAAK84B,OAAO33B,GAE1C,EACA,eAAAi7B,CAAgBz0B,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GAC9C,MAAM7P,EAAIpoB,KACVi4B,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLC,EAAOpR,EAAE0Q,OACT9E,EAAKrsB,EAAK8E,MACV4vB,EAAK,KACT,OAAQ/U,GACJ,IAAK,oBACDkS,EAAKr4B,IAAM6yB,EACXqI,EAAKvF,EAAgB3G,SAAS6D,GAC1BqI,GACAr8B,KAAK84B,OAAOqD,QAAUE,EACtBtF,EAAoBtB,WAAaz1B,KAAK84B,OAAOqD,UAG7CE,EAAK,CAAC,EACNr8B,KAAK84B,OAAOqD,QAAUE,EACtBtF,EAAoBtB,WAAaz1B,KAAK84B,OAAOqD,QAC7CrF,EAAgB3G,SAAS6D,GAAMqI,GAEnC,MACJ,IAAK,eAGD,IAAItY,EAAOyV,EAAKr4B,IACN,WAAN4iB,IACA+S,EAAgB3G,SAASpM,GAAQyV,EAAK2C,SAG1Cn8B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd/B,EAAoBtB,WAAa+D,EAAKwC,QACtC,MACJ,QACIzC,GAAK,EAGb,OAAOA,CACV,EArCgB,EAsCrB,EAEA,sBAAA+C,GACIt8B,KAAKo4B,2BACLp4B,KAAK84B,OAAS,CACV7f,KAAM,kBACNkjB,QAAS,MAGbpF,EAAoBxB,YAAc,IAAIlF,EACjCyG,EAAgByF,iBACjBzF,EAAgByF,eAAiBxF,EAAoBxB,YAG7D,EACA,qBAAAiH,CAAsB70B,EAAMkwB,EAAQvQ,EAAS6F,EAAW8K,GACpD,MAAM7P,EAAIpoB,KACVi4B,EAAQC,OAAS,MACb,IAAIqB,GAAK,EACLC,EAAOpR,EAAE0Q,OAWb,MATS,wBADDxR,GAEAtnB,KAAKo4B,2BACLp4B,KAAK84B,OAAS,KACd/B,EAAoBtB,WAAa+D,EAAKwC,SAGtCzC,GAAK,EAGNA,CACV,EAdgB,EAerB,GAEJnX,EAAWlJ,SAAWoe,CAE1B,CA2CQmF,CAAcra,EAAY2U,EAAqB,CAC3CI,0BAvBJ,WACIJ,EAAoBlB,QACxB,EAsBIqB,uBArBJ,WAEQI,EAAUC,oBACLT,EAAgBlF,QACjBkF,EAAgB7E,YAEpB6E,EAAgBlF,OAAO0F,EAAUC,kBAAkBmB,WAC/CpB,EAAUC,kBAAkBtJ,OAExC,EAY4B6I,oBAE5B,MAAMQ,EAAYlV,EAAWlJ,SACvBwjB,EAAUta,EAAW9W,OAAO6F,EAAK,CACnC,QAAA5K,GACIwwB,EAAoB9G,QACpB8G,EAAoBxwB,UACxB,IASJ,MAN+B,mBAAnBykB,GAAQ1f,QAChB0f,EAAO1f,OAAOoxB,GAEa,mBAAnB1R,GAAQc,QAChBd,EAAOc,OAAOgL,GAEXhiB,KAAKC,UAAU+hB,EAAiB,KAAM,EACjD,E,4BC3rCJ93B,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAGpD,MAAMkwB,EACFC,gBAAkB,EAClBA,UAAkB,EAElB,oBAAWC,GACP,OAAOF,GAAM,CACjB,CACA,UAAOna,CAAI3hB,EAAKoS,GACZ,GAAIA,GACIA,EAAQ0pB,EAAMG,SACd,OAGS,iBAAP,IACNj8B,EAAMiU,KAAKC,UAAUlU,GAAK,CAACgzB,EAAGtJ,IACZ,GAAVsJ,EAAElxB,OACK4nB,EAEI,iBAAL,EACC,CAAC,EAEG,gBAAL,EACC,GAEJA,KAGf,IAAI7Z,EAAO,GACX,GAAI3P,UACA,IAAI,IAAIsG,EAAI,EAAGA,EAAItG,UAAU4B,OAAQ0E,IACjCqJ,EAAK5O,KAAKf,UAAUsG,IAG5Bkb,QAAQC,IAAI,sBAAiB3hB,OAAU6P,EAC3C,CAKA,aAAOqsB,CAAOC,GACVL,GAAM,EAAWK,CACrB,EAGJr/B,EAAQg/B,MAAQA,C,8BC/ChB39B,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,iBAAE4c,GAAqB,EAAQ,OAC/B,MAAE1C,GAAU,EAAQ,MA+D1BhpB,EAAQs/B,MA5DR,MACI,cAAAC,CAAe9rB,EAAQ3E,GACnB,OAAkD,GAHtC,iBAGO/J,MAAM,KAAK2L,QAAQ+C,EAC1C,CASA,iBAAA+rB,CAAkB/rB,EAAQ3E,EAAOorB,EAAQ7M,EAAQpD,GAC7C,IAAI6R,EAAShtB,EACT2wB,EAAY3D,EAAO5L,YAAY3O,MAC/Bme,EAAc5D,EAAO7L,cAAc1O,MACnCoe,EAAcC,IACd9D,EAAO5L,YAAY/rB,KAAKy7B,EAAI51B,MAC5B8xB,EAAO7L,cAAc9rB,KAAKy7B,EAAI3C,OAAO,EAGrC4C,EAAY5V,GAAYiQ,EAAO4F,aAAe5F,EAAOjQ,SACrD8V,EAAa,QAAQ5sB,KAAKssB,IAAc,KAAKtsB,KAAKssB,GAClDO,EAAa,KAAOvsB,EAAS,IAC7BwsB,EAAkB59B,KAAKk9B,eAAe9rB,EAAQ3E,GAKlD,GAJImxB,IACAD,EAAa,MAEjBL,EAAW,CAAE1C,OAAQyC,EAAa11B,KAAMy1B,IACpCA,GAAaO,EAAY,CACzB,IAAI1D,EAAKtT,EAAMkX,eAAeF,GAC1BG,EAAK9S,EAAO+S,iBAAiBlG,EAAQoC,EAAIuD,GAS7C,GANKE,GACIE,GAEDN,EADa3W,EAAMqX,eAAe,IAAKnG,EAAQ2F,EAAWxS,IAI7D6M,EAAOnN,OAAO/nB,OAAS,GAAM3C,KAAKi+B,cAAcpG,EAAOnN,QAAS,CACjEM,EAAOkT,aACPlT,EAAOmT,oBACPnT,EAAOmT,oBACP,IAAIzS,EAAU,CAAC,EACf,MAAM0S,EAAWpT,EAAOqT,OAAM,EAAM3S,GACpCV,EAAOsT,qBACPhB,EAAW,CAAE1C,OAAQwD,EAAUz2B,KAAM+jB,EAAQ/jB,MACjD,MACI21B,EAAW,CAAE1C,OAAQkD,EAAIn2B,KAAMg2B,GAEvC,CACA,OAAOlxB,EAAMmhB,cAAchvB,KAAK,GACpC,CACA,aAAAq/B,CAAcvT,GACV,MAAM,WAAE1I,GAAe2E,EAAMG,QAC7B,OAAO9E,EAAWuc,aAAa7T,EACnC,E,8BC/DJ1rB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,MAAEwwB,GAAW,EAAQ,MAErBuB,EAAU,CACZvB,SAGJt/B,EAAQ6gC,QAAUA,C,6BCLlBx/B,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,IAAIgyB,EAAS,KAYb,MAAMC,EACF9B,cAAe,EAIftrB,GACA,WAAA8D,GACI,IAAIupB,EAAW,GACXC,EAAmB,GACnBC,EAAiB,GACjBC,EAAe,GAEnBF,EAAiBG,OAASL,EAAgBM,oBAI1ChgC,OAAOD,eAAeiB,KAAM,iBAAkB,CAAE2M,IAAG,IAAYiyB,IAC/D5/B,OAAOD,eAAeiB,KAAM,eAAgB,CAAE2M,IAAG,IAAYkyB,IAC7D7/B,OAAOD,eAAeiB,KAAM,SAAU,CAAE2M,IAAG,IAAYgyB,IACvD3/B,OAAOD,eAAeiB,KAAM,aAAc,CAAE2M,IAAG,IAAYmyB,IAC3D9/B,OAAOD,eAAeiB,KAAM,SAAU,CAAE2M,IAAG,IAAYiyB,EAAiBj8B,QAE5E,CACA,WAAIs8B,GACA,OAAqC,GAA9Bj/B,KAAKk/B,eAAev8B,MAC/B,CAEA,8BAAOw8B,CAAwBvR,GACvBA,KAAmB,WAAYA,KAC/BA,EAAcmR,OAASL,EAAgBM,oBAE/C,CAEA,wBAAOI,CAAkBxR,GACrB,OAAOA,EAAcmR,OAAS,CAAExb,IAC5B,IAAIwb,EAASxb,EAAEnf,MAAM,GAKrB,OAHI26B,EAAOM,GADR,OAAQ9b,EACKzO,KAAK4T,MAAM5T,KAAKC,UAAUwO,EAAE8b,KAE5BX,EAAgBY,sBACzBP,CACV,EAP6B,CAO3BnR,EAAcmR,QACbL,EAAgBM,mBACxB,CAMA,OAAA34B,CAAQoG,GACJ,IAAImuB,EAAS,KACTjzB,EAAO,KACX,GAAmB,iBAAT,GAEN,KADEizB,SAAQjzB,QAAO8E,IACZmuB,IAAWjzB,EACZ,MAAM,IAAIoI,MAAM,oBAEjB,CACH,GAAmB,iBAAT,EAIN,MAAM,IAAIA,MAAM,qBAHpB6qB,EAASjzB,EAAO8E,CAIpB,CACAzM,KAAKk/B,eAAehT,QAAQ0O,GAC5B56B,KAAKu/B,aAAarT,QAAQvkB,EAC9B,CAOA,UAAA63B,CAAWlT,EAAQ1tB,EAAO,IACtB,OAAOoB,KAAKk/B,eAAe96B,MAAMkoB,GAAQ1tB,KAAKA,GAAQ,GAC1D,CAOA,OAAA6gC,CAAQnT,EAAQ1tB,EAAO,IACnB,OAAOoB,KAAKu/B,aAAan7B,MAAMkoB,GAAQ1tB,KAAKA,GAAQ,GACxD,CAKA,UAAIg8B,GACA,OAAO56B,KAAKk/B,eAAetgC,KAAK,GACpC,CAKA,QAAI+I,GACA,OAAO3H,KAAKu/B,aAAa3gC,KAAK,GAClC,CAMA,IAAAA,CAAKA,GAED,OAAOoB,KAAKk/B,eAAetgC,KAAKA,GAAQ,GAC5C,CAIA,YAAA8gC,CAAa9gC,EAAO,IAChB,MAAM,eAAEsgC,EAAc,aAAEK,GAAiBv/B,KACzC,OAAO0+B,EAAgBiB,aAAaT,EAAgBK,EACvD,CAQD,mBAAOI,CAAaT,EAAgBK,EAAc3gC,EAAO,IACrD,IACIghC,EAAW,GACXC,EAAS,GACb,GAAIX,EAAeH,OAAQ,CACvB,MAAM3W,EAAI8W,EAAeH,OACzB3W,EAAE/V,OACF,MAAMytB,EAAM1X,EAAEiX,IAAM,CAAC,EACrB,IAAIU,EAAQ,CAACrJ,EAAKtO,EAAG2W,KACjB,IAAI5xB,EAAI,EACJ6yB,EAAI,GACR,MAAMJ,EAAW,GACXK,EAAUvB,EAAgBM,oBA2BhC,OA1BAtI,EAAIv4B,SAAQolB,IACR,GAAK6E,EAAEzlB,OAAS,GAAOylB,EAAE,IAAMjb,EAAI,CAC3B6yB,EAAEr9B,OAAS,IACXi9B,EAAS99B,KAAKk+B,EAAEphC,KAAKA,IACrBohC,EAAEr9B,OAAS,GAEfi9B,EAAS99B,KAAKyhB,GACd6E,EAAE3R,QACF,IAAIypB,EAAON,EAASj9B,OAAS,EACzBwK,KAAK2yB,GAELnZ,EAAMwZ,6BAA6BF,EAASC,EAAMJ,EAAI3yB,IAE1D8yB,EAAQn+B,KAAKo+B,EACjB,MACIF,EAAEl+B,KAAKyhB,GAEXpW,GAAG,IAEH6yB,EAAEr9B,OAAS,IACXi9B,EAAS99B,KAAKk+B,EAAEphC,KAAKA,IACrBohC,EAAEr9B,OAAS,GAEXo8B,IACAa,EAASb,OAASkB,GAEfL,CAAQ,EAGnBA,EAAWG,EAAMb,EAAgB9W,EAAEhkB,MAAM,IAAI,GAC7Cy7B,EAASE,EAAMR,EAAcnX,EAAEhkB,MAAM,GAEzC,MACIw7B,EAAS99B,KAAKo9B,EAAetgC,KAAKA,IAClCihC,EAAO/9B,KAAKy9B,EAAa3gC,KAAKA,IAElC,MAAO,CAAEgvB,cAAegS,EAAU/R,YAAagS,EACnD,CAKA,wBAAOb,GACH,MAAM3C,EAAK,GAEX,OADAqC,EAAgBY,oBAAoBjD,GAC7BA,CACX,CACA,0BAAOiD,CAAoBrhC,GACvBA,EAAEohC,GAAK,CAAC,CACZ,CAKA,cAAAe,CAAe7V,GACX,GAAkB,iBAAP,EACPvqB,KAAKk/B,eAAep9B,KAAKyoB,GACzBvqB,KAAKqgC,aAAa9V,OACf,CACH,MAAM,OAAEqQ,EAAM,KAAEjzB,EAAI,OAAEo3B,EAAM,aAAEQ,EAAY,eAAEL,GAAmB3U,EAC/D,GAAIgV,GAAgBL,EAChBl/B,KAAKsgC,UAAU,CAAE1S,cAAesR,EAAgBrR,YAAa0R,SAM7D,GAFAv/B,KAAKk/B,eAAep9B,KAAK84B,GACzB56B,KAAKqgC,aAAa14B,GACdo3B,EAAQ,CACF,WAAY/+B,KAAKk/B,iBACnBl/B,KAAKk/B,eAAeH,OAASL,EAAgBM,qBAEjD,MAAMkB,EAAOlgC,KAAKk/B,eAAev8B,OAAS,EAC1C3C,KAAKk/B,eAAeH,OAAOj9B,KAAKo+B,GACT,iBAAZ,IACD,OAAQlgC,KAAKk/B,eAAeH,QAC9BL,EAAgBY,oBAAoBt/B,KAAKk/B,eAAeH,QAE5DpY,EAAMwZ,6BAA8BngC,KAAKk/B,eAAeH,OAAQmB,EAAMnB,GAG9E,CAER,CACJ,CAKA,YAAAsB,CAAa9V,GACTvqB,KAAKu/B,aAAaz9B,KAAKyoB,EAC3B,CAMA,aAAAgW,CAAc3F,GAAQ,iBAAE4F,IACpB,GAAuB,iBAAZ,EACHA,GAAqB5F,GAAU4F,EAAiB5S,cAAchvB,KAAK,IACnEoB,KAAKogC,eAAe,CAAExF,SAAQjzB,KAAM64B,EAAiB3S,YAAYjvB,KAAK,MAItEoB,KAAKogC,eAAexF,OAErB,CACH,MAAM,QAAE6F,EAAO,MAAEC,GAAU9F,EAC3B,IAAK8F,GAAO9S,cAGR,YADA5tB,KAAKogC,eAAeK,GAKxB,GAAIA,GADKC,EAAM9S,cAAchvB,KAAK,IAI9B,YADAoB,KAAKogC,eAAe,CAAExF,OAAO6F,EAAS94B,KAAM,UAIhD3H,KAAKsgC,UAAUI,EAEnB,CACJ,CACA,oBAAOC,EAAc,YAAC9S,EAAW,cAAED,IAC/BC,EAAYlrB,OAAS,EACrBirB,EAAcjrB,OAAS,EACnB,WAAYirB,IACZA,EAAcmR,OAAOp8B,OAAS,EAC9B+7B,EAAgBY,oBAAoB1R,EAAcmR,QAE1D,CAMA,+BAAO6B,CAAyBnsB,EAAOmZ,GAEjC,MAAMiT,EAAK,GACXjT,EAAcmR,QAAQ5gC,SAAQosB,IAC1B,MAAMoC,EAAMiB,EAAcmR,OAAOM,GAAG9U,GAC9BuW,EAAWvW,EAAE9V,EACfkY,WACOiB,EAAcmR,OAAOM,GAAG9U,GAC/B5D,EAAMwZ,6BAA6BvS,EAAcmR,OAAQ+B,EAASnU,IAEtEkU,EAAG/+B,KAAKg/B,EAAS,IAErBlT,EAAcmR,OAAOp8B,OAAS,EAC9BirB,EAAcmR,OAAOj9B,QAAQ++B,EACnC,CAKA,SAAAP,EAAU,cAAE1S,EAAa,YAAEC,IACvB,MAAM,qBAAEkT,GAAwBpa,EAAMG,QAEtC,IAAIloB,EAAO6/B,IAAmBA,EAAS,IAAIsC,EAA+BtC,GAC1E7/B,EAAKgvB,cAAgBA,EACrBhvB,EAAKivB,YAAcA,EACnBjvB,EAAKoiC,WAAW,CAAEpT,cAAe5tB,KAAKk/B,eAAgBrR,YAAa7tB,KAAKu/B,cAC5E,CAIA,KAAAzpB,GACI,MAAM,eAAEopB,EAAc,aAAEK,GAAiBv/B,KACzCk/B,EAAev8B,OAAS,EACxB48B,EAAa58B,OAAS,EACtBu8B,EAAeH,OAAS,EAC5B,CAIA,WAAAkC,GACIjhC,KAAK8rB,OAAOnpB,OAAS,EACrB3C,KAAKkhC,WAAWv+B,OAAS,CAC7B,CAIA,QAAAw+B,GACInhC,KAAK8V,QACL9V,KAAKihC,aACT,CAIA,OAAAG,GACI,MAAM,eAAElC,EAAc,aAAEK,GAAiBv/B,KACzC,IAAIooB,EAAI,KACR,CAAC8W,EAAgBK,GAAcphC,SAAQkjC,IACnC,KAAOA,EAAQ1+B,OAAS,GAGpB,GAFAylB,EAAIiZ,EAAQniB,MACZkJ,EAAIA,EAAEgZ,UACFhZ,EAAEzlB,OAAS,EAAG,CACd0+B,EAAQv/B,KAAKsmB,GACb,KACJ,CACJ,GAER,CACA,SAAAkZ,GACI,MAAM,eAAEpC,EAAc,aAAEK,GAAiBv/B,KACzC,IAAIooB,EAAI,KACR,CAAC8W,EAAgBK,GAAcphC,SAAQkjC,IACnC,KAAOA,EAAQ1+B,OAAS,GAGpB,GAFAylB,EAAIiZ,EAAQnV,UACZ9D,EAAIA,EAAEgZ,UACFhZ,EAAEzlB,OAAS,EAAG,CACd0+B,EAAQv/B,KAAKsmB,GACb,KACJ,CACJ,GAER,CACA,IAAAwM,GACI50B,KAAKshC,YACLthC,KAAKohC,SACT,CAKA,WAAAG,GACI,MAAM,eAAErC,GAAmBl/B,KAC3B,OAAIk/B,EAAev8B,OAAS,EACjBu8B,EAAeA,EAAev8B,OAAS,GAE3C,IACX,CACA,eAAA6+B,GACI,MAAM,aAAEjC,GAAiBv/B,KACzB,OAAIu/B,EAAa58B,OAAS,EACf48B,EAAaA,EAAa58B,OAAS,GAEvC,IACX,CAIA,eAAA8+B,GACI,MAAM,eAAEvC,GAAmBl/B,KAC3B,GAAIk/B,EAAev8B,OAAS,EAAG,CAC3B,MAAM2nB,EAAM4U,EAAev8B,OAAS,EAC9B89B,EAAWvB,EAAe5U,GAC1B+U,EAAKX,EAAgBgD,yBAAyBxC,EAAgB5U,GACpE,OAAO,IAAIqX,EAAqBlB,EAASpB,EAC7C,CACA,OAAO,IACX,CAMA,+BAAOqC,CAAyBxC,EAAgB5U,GAC5C,IAAI+U,EAAK,KACT,MAAM,OAAEN,GAAWG,EACnB,GAAIH,EAAO,CACP,IAAIpS,EAAOoS,EAAOM,GAClB,GAAI/U,KAAO4U,EAAeH,OAAO,CAC7B,IAAIxlB,EAAI2lB,EAAeH,OAAOzU,GAE1B+U,GAAO9lB,KAAKoT,IACZ0S,EAAIA,EAAG9lB,GAEf,CACJ,CACA,OAAO8lB,CACX,CAKA,kBAAAuC,CAAmBC,GACf,MAAM,eAAE3C,GAAmBl/B,KAC3Bk/B,EAAehgB,MACfggB,EAAep9B,KAAK+/B,EACxB,CAQA,0BAAOC,CAAoBC,EAAY1C,EAAK,KACxC,MAAM,cAAEzR,EAAa,YAAEC,GAAgBkU,EACjC3Z,EAAIwF,EAAcxpB,MAAM,GAC9B,IAAI87B,GAAQ,EACZ,OAAQb,GACJ,IAAK,IAED,KAAOzR,EAAcmR,OAAOp8B,OAAS,GACjCu9B,EAAOtS,EAAcmR,OAAOtoB,eACpB2R,EAAE8X,UACFrS,EAAYqS,GAGxB,MACJ,IAAK,UAEDvZ,EAAMqb,kBAAkBpU,EAAeC,GACvClH,EAAMsb,qBAAqBrU,GAC3B,IAAIsU,EAAMrU,EAAYhf,QAAO2K,QAAUhO,IAALgO,IAGlC,OAFAqU,EAAYlrB,OAAS,EACrBkrB,EAAY/rB,QAAQogC,GACbrU,EAiCX,QACI,GAAmB,mBAAR,EACP,KAAOD,EAAcmR,OAAOp8B,OAAS,GACjCu9B,EAAOtS,EAAcmR,OAAOtoB,QAC5B+R,EAAIJ,EAAE8X,GACFb,EAAG7W,YACKJ,EAAE8X,UACFrS,EAAYqS,IAOxC,IAAIgC,EAAMrU,EAAYhf,QAAO2K,GAAKA,IAOlC,OANAqU,EAAYlrB,OAAS,EACrBkrB,EAAY/rB,QAAQogC,GAEpBtU,EAAcjrB,OAAS,EACvBu/B,EAAM9Z,EAAEvZ,QAAO2K,GAAKA,IACpBoU,EAAc9rB,QAAQogC,GACfH,CACX,EAGJ,MAAM,qBAAEJ,GAAyB,EAAQ,OACnC,qBAAEZ,GAAyB,EAAQ,MACnC,MAAEpa,GAAU,EAAQ,MAE1BhpB,EAAQ+gC,gBAAkBA,C,4BC5gB1B1/B,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAwBtD9O,EAAQwkC,qBArBR,MAUI,iBAAOC,CAAW7W,EAAW9e,EAAOorB,EAAQ7M,GACxCA,EAAOkT,aACPlT,EAAOoV,eAAe3zB,EAAOorB,GAC7B,IAAI4B,EAASzO,EAAO4P,OAChB8F,EAAQ1V,EAAOrjB,KAGnB,OAFAqjB,EAAOsT,qBAEA,CAAC1D,OAAOnB,EAAQ9xB,KAAK+4B,EAChC,E,4BCrBJ1hC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAsBtD9O,EAAQ0kC,yBAnBR,MAKI51B,MAKAwM,KAMA3M,K,8BClBJ,MAAM,gBAAEoyB,GAAoB,EAAQ,KAEpC1/B,OAAOD,eAAepB,EAAS,aAAc,CAAE8O,OAAO,IAEtD,MAAM61B,EACF,WAAAltB,CAAYmtB,GACR,MAAMna,EAAIpoB,KACVA,KAAKwiC,QAAWl2B,KACRi2B,GAGAj2B,KAAQ8b,GACDA,EAAE9b,EAIrB,CACA,eAAOm2B,GACH,OAAOC,CACX,CACA,WAAOpgB,CAAK3a,GACR,IAAIwF,EAAI,IAAIm1B,EACRK,EAAW,CAAC,EAChB3jC,OAAO8S,KAAKnK,GAAMxJ,SAASkJ,IACvB,IAAIE,EAAII,EAAKN,GACTy2B,EAAK,CAAEz2B,KAAKA,EAAIA,EAAE3E,MAAM,MAAQwc,MAAc7X,EAAEzI,KAAK,MAAhD,CAAyDyI,GAC9Dy2B,EAAGn7B,OAAO,IACVggC,EAAS7E,GAAM,GAGnB9+B,OAAOD,eAAeoO,EAAG9F,EAAG,CACxBsF,IAAK,WACD,MAAkB,mBAAP,EACApF,IAEJA,CACX,GACF,IAEN,IAAI,IAAIF,KAAKs7B,EACLt7B,KAAK8F,GAETnO,OAAOD,eAAeoO,EAAG9F,EAAG,CAAEoF,OAAO,IAEzC,OAAOU,CACX,EAIJ,MAAMu1B,EAAY,IAAIJ,GAAkB,GAGxC3kC,EAAQ2kC,kBAAoBA,C,8BCrD5BtjC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,QAAE+xB,GAAa,EAAQ,OACvB,MAAEvB,GAAUuB,EACZoE,EAAU,CACZ,eAAgB3F,GAEd4F,EAAM,CAAC,EAWbllC,EAAQmlC,0BAVR,MACI,UAAOC,CAAIC,GACP,KAAMA,KAAaH,GAAK,CACpB,MAAO5kC,EAAK2kC,EAAQI,GACpBH,EAAIG,GAAa,IAAI/kC,CACzB,CACA,OAAO4kC,EAAIG,EACf,E,2BCfJhkC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IA0CtD9O,EAAQslC,8BAxCR,MACI,GACA,GAEA,WAAA7tB,CAAY8tB,EAAWtb,GACnB5nB,MAAK,EAAckjC,EACnBljC,MAAK,EAAY4nB,CACrB,CACA,cAAIsb,GACA,OAAOljC,MAAK,CAChB,CACA,YAAI4nB,GACA,OAAO5nB,MAAK,CAChB,CAKA,IAAAmjC,CAAKC,EAAO5b,EAAW2D,EAAQ1e,EAAOorB,EAAQ7M,EAAQpD,GAClD,IAAIyb,EAAKrjC,KAAKkjC,WACVI,EAAO,KACPrJ,EAAKzS,EAAU,IAAIhnB,OAAO6iC,GAAKD,GAE/BG,EAAQ,CAACpY,EAAQ1e,EAAOorB,EAAQ7M,EADpBpD,GAAa5nB,KAAK4nB,UAE9B2V,EAAM,IAAKz9B,SAAS,SAAU,UAAUm6B,GAAKn3B,MAAM,KAAMygC,GAa7D,OAZI1kC,MAAMuQ,QAAQmuB,IACdtD,EAAKsD,EAAI9mB,QACT8sB,EAAM9sB,QACN8sB,EAAMrX,WAAWqR,GACjBgG,EAAMrX,QAAQf,GACdmY,EAAOrJ,EAAGn5B,QAAQyiC,KAGlBA,EAAQ,CAACpY,EAAQ1e,EAAOorB,EAAQ7M,EAAQpD,GAExC0b,EADU,IAAIxjC,SAAS,SAAS,QAAS,SAAU,SAAU,eAAem6B,EAAG,QACpEn5B,KAAK,KAAMyiC,IAEnBD,CACX,E,4BCxCJtkC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAOtD9O,EAAQ6lC,gBALO,CACV,IAAK,kBACL,IAAK,cACL,IAAK,kB,8BCLVxkC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,MAAEkwB,GAAU,EAAQ,OACpB,WAAE8G,GAAe,EAAQ,MA0N/B9lC,EAAQ+lC,qBAtNR,MAKI,GAKA,GAKA,GAKA,GAKA,GAKA,GAMA,WAAAtuB,GACI,MAAMuuB,EAAiB,GAEvB3jC,KAAK4jC,KAAO,SAAUC,GAClB,MAAM,WAAEC,EAAU,KAAElgC,EAAI,OAAE0oB,EAAM,SAAE7G,GAAazlB,KAC/C2jC,EAAe7hC,KAAK,CAAEgiC,aAAYlgC,OAAM0oB,SAAQ7G,aACtB,iBAAf,IACPzlB,KAAK8jC,WAAaD,EAE1B,EACA7jC,KAAK+jC,QAAU,KACX,MAAMrT,EAAMiT,EAAezkB,MAC3B,GAAIwR,EAAK,CACL,MAAM,WAAEoT,EAAU,KAAElgC,EAAI,OAAE0oB,EAAM,SAAE7G,GAAaiL,EAC/C1wB,KAAK8jC,WAAaA,EAClB9jC,MAAK,EAAU4D,EACf5D,MAAK,EAAYssB,EACjBtsB,MAAK,EAAkBylB,CAC3B,EAER,CAKA,aAAIue,GACA,OAAOhkC,MAAK,CAChB,CAIA,aAAIgkC,CAAUzZ,GACVvqB,MAAK,EAAeuqB,CACxB,CAMA,cAAIuZ,CAAWvZ,GACX,GAAS/e,MAAL+e,EAAgB,MAAM,IAAIxa,MAAM,qBAEpC/P,MAAK,EAAeuqB,EACpBvqB,MAAK,EAAUuqB,EACfvqB,MAAK,EAAY,EACjBA,MAAK,EAAkB,CAC3B,CACA,cAAI8jC,GACA,OAAO9jC,MAAK,CAChB,CACA,QAAI4D,GACA,OAAO5D,MAAK,CAChB,CACA,QAAI4D,CAAK2mB,GACLvqB,MAAK,EAAUuqB,CACnB,CACA,WAAI0Z,GACA,OAAOjkC,MAAK,EAAawsB,UAAUxsB,MAAK,EAC5C,CACA,YAAIkkC,GACA,OAAOlkC,MAAK,EAAawsB,UAAUxsB,MAAK,EAC5C,CAIA,UAAIssB,GACA,OAAOtsB,MAAK,CAChB,CACA,YAAIylB,GACA,OAAOzlB,MAAK,CAChB,CACA,UAAIssB,CAAO/B,GACPvqB,MAAK,EAAYuqB,CACrB,CAIA,YAAI9E,CAAS8E,GACT,MAAM4Z,EAAMnkC,MAAK,EACjB,GAAIuqB,GAAK4Z,EAAK,CACV,GAAI5Z,EAAI4Z,EACJ,MAAM,IAAIp0B,MAAM,6BAA+Bwa,EAAI,MAAQ4Z,GAE/DnkC,MAAK,EAAYA,MAAK,EACtBA,MAAK,EAAkBuqB,CAC3B,CACJ,CACA,KAAAjmB,GACItE,MAAK,EAAY,EACjBA,MAAK,EAAkB,CAC3B,CAMA,WAAAokC,CAAY3e,EAAU6G,GAClB,GAAIA,GACA,GAAIA,EAAS7G,EACT,MAAM,IAAI1V,MAAM,iDAGpBuc,EAAS7G,EAEbzlB,MAAK,EAAYssB,EACjBtsB,MAAK,EAAkBylB,CAC3B,CAMA,KAAA4e,CAAMC,EAAOtZ,GACT,MAAMuZ,EAAgBd,EAAWe,2BAA2BF,GACtDG,EAAiBhB,EAAWiB,sBAAsBJ,IAClD,QAAEL,EAAO,SAAEC,EAAQ,WAAEJ,EAAU,SAAEre,EAAQ,UAAEue,EAAS,OAAE1X,GAAWtsB,MACjE,MAAEglB,GAAUgG,GAAU,CAAEhG,OAAO,GACrC,IAAIiV,EAAK,KACT,GAAIwK,EAAgB,CAChB,GAAIT,GAA0B,GAAZve,IACdwU,EAAKqK,EAAM36B,KAAKm6B,GACZ7J,GAEA,OADAA,EAAG/1B,MAAO,EACH+1B,EAGf,IAAK+J,EAED,OADAhf,GAAS2X,EAAMna,IAAI,uCACZyX,CAEf,CACA,GAAIsK,GAEA,GADAtK,EAAKqK,EAAM36B,KAAKs6B,GACZhK,EAAI,CACJA,EAAG/1B,MAAO,EACV+1B,EAAGj3B,OAASspB,EACZ,IAAI4T,EAAOjG,EAAGj3B,MACV+wB,EAAK,KACL4Q,GAAQ,EACZ,KAAOzE,EAAOza,GAAU,CACpBkf,GAAQ,EACRzE,IACA,IAAI0E,EAAQd,EAAWtX,UAAU0T,GAEjC,GADAnM,EAAKuQ,EAAM36B,KAAKi7B,IACZ7Q,EAMA,MALAmM,GAAQnM,EAAG/wB,MACX+wB,EAAG/wB,MAAQk9B,EACXnM,EAAGpG,MAAQmW,EACX/P,EAAG7vB,MAAO,CAIlB,CACIygC,IAII1K,EAHClG,GACI,MAKTkG,IACAA,EAAGj3B,QAAUyiB,EAErB,OACQwU,IACRA,EAAKqK,EAAM36B,KAAKu6B,IASpB,OAPIjK,IACAA,EAAGj3B,OAASyiB,EACZwU,EAAGtM,MAAQmW,EACP7J,EAAGj3B,MAAQyiB,IACXwU,EAAK,OAGNA,CACX,E,4BC1NJj7B,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAiDtD9O,EAAQknC,qBA5CR,cAAmChmC,MAC/B,WAAAuW,GACI0vB,QACA,IAAIC,EAAW,GAEf/kC,KAAK4jC,KAAO,KACRmB,EAASjjC,KAAK9B,KAAKoE,MAAM,IACzBpE,KAAK8V,OAAO,EAEhB9V,KAAK+jC,QAAQ,KACT,IAAIiB,EAAMD,EAAS7lB,MACf8lB,IACAhlC,KAAK8V,QACLgvB,MAAMhjC,QAAQkjC,GAClB,CAER,CACA,KAAA/U,CAAMoR,EAASrW,GACNA,EAAOia,aACRH,MAAMhjC,KAAKu/B,EAEnB,CACA,IAAAv/B,CAAKu/B,EAASrW,GACV,IAAKA,EACD,MAAM,IAAIjb,MAAM,kBAEfib,EAAOia,aACRH,MAAMhjC,KAAKu/B,EAEnB,CACA,OAAAnV,CAAQmV,EAASrW,GACb,IAAKA,EACD,MAAM,IAAIjb,MAAM,kBAEfib,EAAOia,aACRH,MAAM5Y,QAAQmV,EAEtB,CACA,KAAAvrB,GACI9V,KAAK2C,OAAS,CAClB,E,4BC7CJ3D,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAUtD9O,EAAQunC,mBARR,MACIl1B,QACA9P,KACA,WAAAkV,GAEA,E,8BCPJpW,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IACtD,MAAM,MAAEkwB,GAAU,EAAQ,OACpB,SAAE/V,GAAa,EAAQ,OACvB,MAAED,GAAU,EAAQ,MA8G1BhpB,EAAQq3B,kBAhGR,MAEI,WAAA5f,GACI,IAAI+vB,EAIJnmC,OAAOD,eAAeiB,KAAM,aAAc,CAAE2M,IAAG,IAAYw4B,IAC3DnlC,KAAKolC,cAAgB,SAAU37B,GAC3B07B,EAAc17B,CAClB,CACJ,CAMA,UAAA47B,CAAWC,EAAW1K,EAAQ5P,GAC1BA,EAAOkT,aACPlT,EAAOmT,oBACP,MAAMoH,EAAWva,EAAOqT,OAAM,GAC9BrT,EAAOsT,qBACP1D,EAAOwF,eAAemF,EAC1B,CAKA,aAAAC,EAAc,gBAACC,EAAe,QAAEC,EAAO,MAAEC,IAEzC,CAKA,SAAAC,EAAU,SAACC,IAEX,CAIA,UAAAC,GAEA,CAKA,KAAA7V,EAAM,OAAC2K,EAAM,KAAEjzB,EAAI,OAAEmkB,EAAM,WAAEoV,EAAU,MAAEyE,EAAK,QAAED,EAAO,WAAEK,IACrD,IAAIvd,EAAIoS,EACJ38B,EAAI0nC,EACR,GAAInd,EAAE7lB,OAAS,EAAE,CACTojC,IACAja,EAAOI,QAAQ,IACfgV,EAAWhV,QAAQ,KAEvB,IAAIiK,EAAOl4B,EAAI,EAAIynC,EAAQ9jC,OAAO3D,GAAK,GACvC6tB,EAAOhqB,KAAKq0B,EAAO3N,GACnB0Y,EAAWp/B,KAAKq0B,EAAKxuB,EACzB,CACJ,CAOA,MAAAmkB,EAAO,OAACA,EAAM,SAAE+Z,IAEZ,OADS/Z,EAAOltB,KAAKinC,EAEzB,CAWA,WAAAxY,CAAY5gB,EAAOse,EAAQzD,EAAS6D,EAAQnG,EAAO6S,EAAQ7M,GACvD,MAAM,eAAEgb,GAAmBrf,EAAMG,QAC3BgH,EAAK,IAAIkY,EAMf,OALAlY,EAAG/C,OAASA,EACZ+C,EAAGxG,QAAUA,EACbwG,EAAGrhB,MAASA,EACZue,EAAOib,UAAYnY,EACnB9I,GAAOwd,QAAQ,iBAAmB7F,EAAMna,IAAI,eAAgB1N,KAAK4T,MAAM5T,KAAKC,UAAU+Y,KAClF3C,EACOA,EAAOkC,YAAY5gB,EAAOse,EAAQzD,EAASuQ,GAE/CprB,CACX,E,8BC9GJzN,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD,MAAM,MAAEkwB,GAAU,EAAQ,OACpB,gBAAE+B,GAAoB,EAAQ,KAkNpC/gC,EAAQuoC,oBA5MR,MAIIvlC,OAAQ,EAIRkG,MAKAk/B,WAEAI,cACAC,aACAC,UAAW,EAQXC,aAKAC,SAKAC,aAEA,iBAAAC,CAAkB9+B,GACd,IAAK3H,KAAKwmC,cAAgB7+B,EAKtB,OAJK9I,MAAMuQ,QAAQpP,KAAKwmC,gBACpBxmC,KAAKwmC,aAAe,CAACxmC,KAAKwmC,oBAE9BxmC,KAAKwmC,aAAa1kC,KAAK6F,GAG3B3H,KAAKwmC,aAAe7+B,CACxB,CAEA,QAAAuJ,GACI,MAAO,uBAAuBlR,KAAK63B,OAAO3mB,UAC9C,CAMA,kBAAAw1B,CAAmB/+B,GACf,MAAM,cAACimB,EAAa,YAAEC,GAAelmB,EAC/B+4B,EAAQ1gC,KAAK2H,KACbg/B,EAAKjG,EAAM9S,cAAcjrB,OAC/B+9B,EAAM9S,cAAc9rB,QAAQ8rB,GAC5B8S,EAAM7S,YAAY/rB,QAAQ+rB,GAE1B,MAAMoS,EAAUrS,EAAcmR,QAAQ36B,MAAM,GAC5C,GAAI67B,EAAQ,CACR,IAAI,IAAI9yB,EAAI,EAAGA,EAAK8yB,EAAQt9B,OAAQwK,IAAI,CACpC,IAAIy5B,EAAa3G,EAAQ9yB,GAAKw5B,EAE9B,GADA1G,EAAQ9yB,IAAMw5B,EACVx5B,KAAKygB,EAAcmR,OAAOM,GAAG,CAC7B,IAAI1S,EAAMiB,EAAcmR,OAAOM,GAAGlyB,UAC3BygB,EAAcmR,OAAOM,GAAGlyB,GAC/BwZ,MAAMwZ,6BAA6BvS,EAAcmR,OAAQ6H,EAASja,EACtE,CACJ,CACM+T,EAAM9S,cAAcmR,SACtB2B,EAAM9S,cAAcmR,OAAU,IAClC2B,EAAM9S,cAAcmR,OAAOj9B,QAASm+B,GACpCS,EAAM9S,cAAcmR,OAAOM,GAAK,IAAMqB,EAAM9S,cAAcmR,OAAOM,MAAQzR,EAAcmR,OAAOM,GAClG,CAEJ,CASA,WAAAjqB,CAAYmW,EAAWsb,EAASC,EAAOC,EAAW/b,GAC9ChrB,KAAK+lC,WAAac,EAAQG,QAAU,EAAI,EACxChnC,KAAKmmC,cAAgBU,EAAQG,QAC7BhnC,KAAKomC,cAAe,EACpB,IAAIa,EAAgBJ,EAAQnxB,KAG5B1W,OAAOD,eAAeiB,KAAM,YAAa,CAAC2M,IAAG,IAAU4e,IACvDvsB,OAAOD,eAAeiB,KAAM,SAAU,CAAC2M,IAAG,IAAUk6B,IACpD7nC,OAAOD,eAAeiB,KAAM,WAAY,CAAC2M,IAAG,IAAUo6B,IACtD/nC,OAAOD,eAAeiB,KAAM,cAAe,CAAC2M,IAAG,IAAUs6B,EACzD,GAAAz5B,CAAI+c,GACO,GAAHA,GACwB,yCAApBvqB,KAAK63B,OAAOvrB,MACZiW,QAAQC,IAAI,qBAGpBykB,EAAgB1c,CACpB,IAMA,SAAWuc,EAAOI,GACd,IAAIC,EAAWL,EACXM,GAAU,EAEV1G,EAAQ,KAIZ,GAAI1V,GAAQwV,kBAAkB5S,cAAchvB,KAAK,KAAKkoC,EAAM,CACxD,MAAM,YAAEjZ,EAAW,cAAED,GAAkB5C,EAAOwV,kBAC9CE,EAAQ,CAAE7S,YAAaA,EAAYzpB,MAAM,GAAIwpB,cAAgBA,EAAcxpB,MAAM,KAE3EwpB,cAAcmR,OAASL,EAAgBU,kBAAkBxR,EACnE,KAAK,CACD,IAAIxgB,EAAI,GACJnP,EAAI,GACJ6oC,EAAMnkC,OAAO,IACbyK,EAAEtL,KAAKglC,GACP7oC,EAAE6D,KAAKglC,IAEXpG,EAAQ,CAAC7S,YAAazgB,EAAGwgB,cAAc3vB,EAC3C,CACM,WAAYyiC,EAAM9S,gBACnB8S,EAAM9S,cAAcmR,OAASL,EAAgBM,qBAIlDkI,EAAa15B,IAAM,WACf45B,GAAS,CACb,EAIApoC,OAAOD,eAAemoC,EAAc,OAAQ,CAACv6B,IAAG,IACrC+zB,IAKX1hC,OAAOD,eAAemoC,EAAc,QAAS,CAACv6B,IAAG,IACtCy6B,IAEXpoC,OAAOD,eAAemoC,EAAc,cAAe,CAC/Cv6B,IAAG,IACQm6B,IAGf9nC,OAAOD,eAAemoC,EAAc,UAAW,CAC3Cv6B,IAAG,IACQw6B,EAEX,GAAA35B,CAAI+c,GAEIA,GAAK4c,IACLnc,EAAOhG,OAAOwd,QAAQ,mBAClB7F,EAAMna,IAAI,sCAAwC+H,EAAE,MACpDhI,QAAQC,IAAI,CAACqf,SAAUtX,EAAG8c,SAASF,KAEvCA,EAAW5c,EAEnB,IAEJvrB,OAAOD,eAAemoC,EAAc,SAAU,CAC1Cv6B,IAAG,IACQu6B,EAAarP,OAAOnN,QAGtC,CAnED,CAmEGoc,EAAO9mC,KACd,CAMA,SAAAsnC,CAAUtc,EAAQtV,GAEd1V,KAAK6G,MAAQ,CACT+zB,OAAQ5P,EAAOya,gBAAgB7K,OAC/B9O,OAAQd,EAAOc,OACf2Z,gBAAiBza,EAAOya,gBACxB,wBAAI8B,GACA,OAAOvnC,KAAKylC,gBAAgB7K,MAChC,EACA,QAAIllB,GACA,OAAOA,CACX,EAER,E,4BCjNJ1W,OAAOD,eAAepB,EAAS,WAA/B,CAA6C8O,OAAO,IAGpD,MAAM2c,EACF,WAAOwD,CAAKrZ,GACR,MAAMoZ,EAAM,GACZ,IAAI+T,EAaJ,OAZA/T,EAAI6a,UAAY,IAAIpe,EACpBpqB,OAAOD,eAAe4tB,EAAK,UAAW,CAAEhgB,IAAG,KACF,GAA7BggB,EAAIte,QAAQ,iBAExBrP,OAAOD,eAAe4tB,EAAK,SAAU,CAAEhgB,IAAG,IAC/B4G,IAEXvU,OAAOD,eAAe4tB,EAAK,OAAQ,CAAEhgB,IAAG,IAC7B+zB,EACR,GAAAlzB,CAAI+c,GACHmW,EAAQnW,CACZ,IACOoC,CACX,EAGJhvB,EAAQyrB,wBAA0BA,C,8BCvBlCpqB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,iBAAEg7B,GAAqB,EAAQ,KAC/B,MAAE9gB,GAAU,EAAQ,OACpB,MAAEgW,GAAU,EAAQ,OACpB,gBAAE+B,GAAoB,EAAQ,MAC9B,qBAAEgF,GAAyB,EAAQ,OACnC,qBAAEmB,GAAyB,EAAQ,OACnC,kBAAE7P,GAAsB,EAAQ,MAuBtC,MAAM3L,EAEF,GAYArG,UAAY,EAKZ0kB,WAAa,EAEbC,UAAW,EACXC,UAAW,EACXC,cAAe,EACfC,gBAAiB,EACjBC,YAAc,EACdC,SAMAC,WAMAC,aAKA3B,SAIA4B,KAAM,EAINC,KAAM,EAENC,OAAQ,EAKRlb,UAAY,GAKZmb,cAAe,EACfzhC,MAAQ,GACRkc,MAAQ,CACJpiB,MAAO,EACPC,IAAK,GAKT2nC,OAIAC,cAAgB,GAKhBC,iBAAkB,EAIlBC,UAAY,KAKZC,qBAAsB,EAKtBC,qBAAsB,EAKtBC,gBAAiB,EAMjBC,SAAW,EAKX7C,UAKA1E,YAKAf,iBAMAwD,UAKA+E,cAKA,gBAAIC,GACA,OAAOhpC,KAAKurB,WAAWyd,YAC3B,CAMAjD,WAMAkD,mBAKAC,uBAMAC,cAGA,gBAAIC,GACA,OAAOppC,MAAK,CAChB,CAOA,wBAAAqpC,CAAyBxR,GACrB,MAAM,qBAAEyR,GAAyBtpC,KACjC,QAAI63B,EAAO0R,8BACPD,EAAqBxnC,KAAK,CAAC+1B,SAAQl3B,OAAM,KAClC,EAGf,CACA,uBAAA6oC,GACI,MAAM,qBAAEF,GAAyBtpC,KACjC,OAAOspC,EAAqBpqB,KAChC,CAKA,uBAAAuqB,GACI,MAAM,qBAAEH,GAA0BtpC,KAClC,OAAIspC,EAAqB3mC,OAAO,GACpB2mC,EAAqBA,EAAqB3mC,OAAO,GAChDhC,KAGjB,CAMA,4BAAA+oC,GACI,MAAM,qBAAEJ,GAA0BtpC,KAClC,OAAIspC,EAAqB3mC,OAAO,EACrB2mC,EAAqBA,EAAqB3mC,OAAO,GAErD,IACX,CAUA,WAAAyS,CAAYgN,EAAYunB,EAAkBrS,EAAWsS,EAAiBC,GAClE,MAAM,MAAE7kB,GAAU5C,EACZ0nB,EAAgB,IAAIpG,EAAqB1jC,MACzC+pC,EAAyB,GAE/B,IAAI,SAAElE,EAAQ,QAAEH,GAAY,CAACG,SAASgE,GAAKhE,UAAYzjB,EAAW4nB,KAAKnE,UAAY,KAC/EH,QAASmE,GAAKnE,SAAWtjB,EAAW4nB,KAAKtE,SAAW,MACxD1lC,MAAK,EAAkB,IAAI6kC,EAC3B,IAAIoF,GAAgB,EAGhBC,EAAUL,GAAKlE,OAAS,EACxBwE,GAAgB,EACpB,MAAMC,EAAe,GACfC,EAAc,GACdC,EAAU,IACV,gBAAE/gB,EAAe,gBAAEmV,EAAe,MAAE/B,GAAUhW,EAAMG,QAC1D,IAAIyjB,EAA2B,KAC3BC,EAAoB,CACpB5mC,KAAM,EACNjD,MAAO,EACPC,IAAK,EAKL,UAAA6pC,CAAWznB,GACPhjB,KAAK4D,KAAOof,EACZhjB,KAAKW,MAAQX,KAAKY,IAAM,CAC5B,EAMA,WAAA8pC,CAAY/pC,EAAOC,GACfZ,KAAKW,MAAQA,EACbX,KAAKY,SAAsB,IAAT,EAAuBD,EAAQC,CACrD,GAEJ,MAAMoqB,EAAShrB,KACf,IAAI2qC,EAAc,EACdC,EAAsB,KAE1B,IAAK,IAAIvjC,KAAKwiC,GACkD,GAAxD,CAAC,QAAS,OAAQ,UAAW,YAAYx7B,QAAQhH,IAGrDrI,OAAOD,eAAeiB,KAAMqH,EAAG,CAC3BsF,IAAG,IACQk9B,EAAIxiC,KAwHvB,SAASwjC,EAAMtxB,GACX,OAASA,GAAiB,GAAZA,EAAE5W,MACpB,CACA,SAASmoC,EAAY1iB,GACjB,OAAgC,GAAzBppB,OAAO8S,KAAKsW,GAAGzlB,MAC1B,CAqQA,SAASooC,EAAgBjrB,GACrB,IAAIsI,EAAI4C,EACJggB,EAAO5iB,EAAEugB,oBACbvgB,EAAEugB,qBAAsB,EACxBsB,GAAe,EACf,IAAI5N,EAAKvc,IAGT,OAFAmqB,GAAgB,EAChB7hB,EAAEugB,oBAAsBqC,EACjB3O,CACX,CAvYAr8B,KAAKirC,WAAa,WACdjrC,KAAKkrC,WAAW,EAAG,EACvB,EACAlrC,KAAKkrC,WAAa,SAAUvqC,EAAOC,GAC/BZ,KAAK+iB,MAAMpiB,MAAQA,EACnBX,KAAK+iB,MAAMniB,SAAsB,IAAT,EAAuBD,EAAQC,CAC3D,EACAZ,KAAKmrC,sBAAwB,SAAUC,GACnC,OAAOA,IAAqBzB,CAChC,EACA3qC,OAAOD,eAAeisB,EAAQ,uCAAwC,CAClE,GAAAre,GACI,OAAO3M,KAAKmrC,sBAAsBnrC,KAAKylC,gBAC3C,IAIJzmC,OAAOD,eAAeisB,EAAQ,uBAAwB,CAACre,IAAG,IAAUo9B,IACpE/qC,OAAOD,eAAeisB,EAAQ,cAAe,CAACre,IAAG,IAAUm9B,IAC3D9qC,OAAOD,eAAeisB,EAAQ,aAAc,CAACre,IAAG,IAAUm9B,EAAchG,aACxE9kC,OAAOD,eAAeisB,EAAQ,OAAQ,CAACre,IAAG,IAC/Bm9B,EAAclmC,KACtB,GAAA4J,CAAI+c,GAAIuf,EAAclmC,KAAO2mB,CAAE,IAClCvrB,OAAOD,eAAeisB,EAAQ,aAAc,CAAEre,IAAK,WAAc,OAAOg+B,CAAa,IACrF3rC,OAAOD,eAAeisB,EAAQ,eAAgB,CAAEre,IAAK,WAAc,OAAO3M,KAAKuoC,QAAQ3N,MAAQ,IAC/F57B,OAAOD,eAAeisB,EAAQ,WAAY,CAAEre,IAAK,WAAc,OAAO2qB,CAAW,IACjFt4B,OAAOD,eAAeisB,EAAQ,YAAa,CAAEre,IAAK,WAAc,OAAOyV,CAAY,IACnFpjB,OAAOD,eAAeisB,EAAQ,kBAAmB,CAAEre,IAAK,WAAc,OAAOg9B,CAAkB,IAC/F3qC,OAAOD,eAAeisB,EAAQ,eAAgB,CAC1Cre,IAAK,WAAc,OAAOw9B,CAAe,EAAG,GAAA38B,CAAI+c,GAC5C4f,EAAgB5f,CACpB,IAEJvrB,OAAOD,eAAeisB,EAAQ,QAAS,CACnC,GAAAre,GACI,OAAO3M,KAAKqrC,KAAOrrC,KAAK2C,MAC5B,IAEJ3D,OAAOD,eAAeisB,EAAQ,cAAe,CACzCre,IAAK,WAAc,OAAOs9B,CAAe,IAG7CjrC,OAAOD,eAAeisB,EAAQ,SAAU,CAAEre,IAAK,WAAc,OAAOg9B,EAAiB/O,MAAQ,IAC7F57B,OAAOD,eAAeisB,EAAQ,OAAQ,CAAEre,IAAK,WAAc,OAAOg9B,EAAiBhiC,IAAM,IACzF3I,OAAOD,eAAeisB,EAAQ,mBAAoB,CAAEre,IAAG,IAAY69B,IACnExrC,OAAOD,eAAeisB,EAAQ,cAAe,CACzC,GAAAre,GACI,MAAM2+B,EAAUlpB,EAAWmpB,YAC3B,IAAIhkC,EAAI+jC,EAIR,OAHItrC,KAAKmtB,WAAWxqB,OAAS,IACzB4E,EAAIvH,KAAKmtB,UAAUpjB,OAAOuhC,IAEvB/jC,CACX,IAEJvI,OAAOD,eAAeisB,EAAQ,SAAU,CAAEre,IAAK,WAAc,OAAO3M,KAAK4D,KAAKjB,MAAQ,IACtF3D,OAAOD,eAAeisB,EAAQ,QAAS,CAAEre,IAAK,WAAc,OAAOqY,CAAO,IAC1EhmB,OAAOD,eAAeisB,EAAQ,aAAc,CAAEre,IAAK,WAAc,OAAO09B,CAAa,IACrFrrC,OAAOD,eAAeisB,EAAQ,YAAa,CAAEre,IAAK,WAAc,OAAOi9B,CAAiB,IACxF5qC,OAAOD,eAAeisB,EAAQ,MAAO,CACjCre,IAAK,WACD,OAAOm9B,EAAcrkB,QACzB,EACA,GAAAjY,CAAI+c,GACAuf,EAAcrkB,SAAW8E,CAC7B,IAKJvrB,OAAOD,eAAeisB,EAAQ,SAAU,CACpCre,IAAK,WACD,OAAOm9B,EAAcxd,MACzB,IAMJttB,OAAOD,eAAeisB,EAAQ,yBAA0B,CACpDre,IAAK,WAAc,OAAO49B,CAA0B,EAAG,GAAA/8B,CAAI+c,GACvDggB,EAA2BhgB,CAC/B,IAEJvrB,OAAOD,eAAeisB,EAAQ,SAAU,CACpCre,IAAK,WAAc,OAAOg9B,EAAiB7d,MAAQ,IAEvD9sB,OAAOD,eAAeisB,EAAQ,aAAc,CACxCre,IAAK,WAAc,OAAOg9B,EAAiBzI,UAAY,IAE3DliC,OAAOD,eAAeisB,EAAQ,QAAS,CACnCre,IAAG,IAAYu9B,EAKf,GAAA18B,CAAI+c,GACA2f,EAAU3f,CACd,IAEJS,EAAOwgB,oBAAsB,WACzB,MAAMpjB,EAAIpoB,KACV,OAAOooB,EAAExkB,KAAK4oB,UAAUpE,EAAErF,MAAMpiB,MAAOynB,EAAErF,MAAMniB,IACnD,EACAoqB,EAAOygB,cAAiBjyB,IACpB6wB,EAAYne,QAAQ1S,EAAE,EAE1BwR,EAAO0gB,YAAc,IACVrB,EAAY5zB,QAEvBuU,EAAO6f,MAAQA,EAEf7rC,OAAOD,eAAeisB,EAAQ,WAAY,CAACre,IAAG,IACnCk5B,IAsCX7a,EAAO2gB,UA1BP,WACI,IAAIpe,EAAQvuB,OAAO8S,KAAKkZ,GACpB4gB,EAAS,CAAC,EACdre,EAAMpvB,SAAQkJ,IACV,IAAI24B,SAAYhV,EAAO3jB,GACvB,GAAI,kBAAkByJ,KAAKkvB,GACvB,OACJ,IAAI6L,EAAK7sC,OAAOyO,yBAAyBud,EAAQ3jB,KAC5CwkC,GAAOA,EAAGl/B,KAAOk/B,EAAGr+B,OACrBo+B,EAAOvkC,GAAK2jB,EAAO3jB,GACvB,IAEJijC,EAAQpe,QAAQ,IAAK0f,GACzB,EAcA5gB,EAAO8gB,SAVP,WACI,IAAItjB,EAAI8hB,EAAQ7zB,QAChB,GAAI+R,EACA,IAAK,IAAInhB,KAAKmhB,EACVwC,EAAO3jB,GAAKmhB,EAAEnhB,EAG1B,EAWA2jB,EAAO+gB,kBAAoB,SAAUvjB,EAAG/b,EAAOo6B,GAG3C,GAAIgE,EAAMp+B,GACN,OAAO+b,EAEX,MAAM,SAAEtP,GAAalZ,KACrB,OAAIkZ,GAAU8yB,WACH9yB,EAAS8yB,WAAWxjB,EAAG/b,EAAOo6B,GAElC7mC,KAAKgsC,WAAWxjB,EAAG/b,EAC9B,EAQAue,EAAOghB,WAAa,SAAUpR,EAAQnuB,GAClC,MAAM,SAAEm7B,EAAQ,YAAEqE,GAAgBjsC,KAClC,IAAIwoB,EAAIoS,EACR,GAAIgN,EAAU,CACV,IAAIhpC,EAAO,IACPqtC,IACArtC,EAAO,IAEX4pB,EAAI,CAACA,EAAE4Y,UAAW30B,EAAM60B,aAAa1iC,KAAKA,GAC1CoB,KAAK4nC,UAAW,CACpB,MACIpf,GAAK/b,EAET,OAAO+b,CACX,EA8BAwC,EAAOoV,eAAiB,SAAU3zB,EAAOo6B,EAAS3b,GAAQ,EAAMghB,GAAM,GAElE,IAAKz/B,EAED,OAGJ,MAAM,MAAEuY,EAAK,gBAAEygB,GAAoBzlC,KACnCglB,GAAOwd,QAAQ,oBAIf,IAAI/B,EAAUh0B,EAgBV0/B,EAAa,KAEjB,GAAqB,iBAAX,EAjBS,EAAC1/B,EAAO9E,EAAMk/B,EAAS3b,KACtC,IAAIuV,EAAUh0B,EACVi0B,EAAQ/4B,EACZ,GAAI4iC,EACA99B,EAAQ89B,EAAyB99B,EAAOo6B,EAAS3b,EAAOlrB,UAEvD,CACGkrB,IACAuV,EAAUzgC,KAAKosC,8BAA8BvF,EAASpG,IAE1D,MAAM1B,EAAS8H,EAAQwF,aACvB5G,EAAgBrF,eAAe,CAC3BxF,OAAQ6F,EAAS94B,KAAM+4B,EAAO3B,UACtC,GAOAuN,CAAa7/B,EAAMmuB,OAAQnuB,EAAM9E,KAAMk/B,GAAS,GAChDpG,EAAUzV,EAAO4P,OACjBuR,EAAa,CAAC54B,OAAQ9G,EAAM9E,KAAM8E,MAAOA,EAAMmuB,aAE9C,GAAInuB,EAAM9J,OAAS,EACpB,GAAI4nC,EACA99B,EAAQ89B,EAAyB99B,EAAOo6B,EAAS3b,EAAOlrB,UAEvD,CACGkrB,IACAuV,EAAUzgC,KAAKosC,8BAA8BvF,EAASpG,IAG1D,MAAM1B,EAAU8H,EAAQwF,aAExB5G,EAAgBrF,eAAe,CAC3BxF,OAAQ6F,EAAS94B,KAAM8E,EAAOsyB,UACtC,CAEJ8H,EAAQp6B,MAAQ0/B,GAAc,CAAE54B,OAAQ9G,EAAOA,MAAOg0B,GAClDyL,GACA9pB,EAAWmqB,iBAAiB1F,EAASpG,EAASzV,GAC9CyV,GAAS7L,OAAOjyB,OAAO,IACvBqoB,EAAO0d,UAAY,KAE3B,EAEA1d,EAAOwhB,QAAU,CAAC3F,EAAS4F,KAElB5F,EAAQ6F,aAAeD,EACxBzhB,EAAO0d,UAAY+D,EAEnBzhB,EAAO0d,UAAY,IACvB,EAEJ1d,EAAOohB,8BAAgC,SAAUvF,EAASpG,GACtD,MAAM,SAAEvnB,EAAQ,YAAEyhB,EAAW,OAAExP,GAAWnrB,KAC1C,GAAIkZ,GAAUmU,YAAa,EAnG/B,SAA0BwK,EAAQ8C,GAC1BvY,EAAWuqB,gBAAgB9U,IACa,mBAA3BA,EAAsB,iBAAoBA,EAAO+U,mBAC1DjS,EAAYlkB,OAExB,CA+FQo2B,CAAiBhG,EAAQhP,OAAQ8C,GAI7BkM,EAAQv6B,OAASu6B,EAAQiG,eAAiBnS,EAAYzO,QAAQ2a,EAAQv6B,MAG1E,MAAMgb,EArGd,SAAoBuQ,GAChB,KAAOA,GAAQ,CACX,GAAIA,EAAOvQ,QACP,OAAOuQ,EAAOvQ,QAElB,GAAIuQ,EAAOkV,WACHlV,EAAOkV,UAAUzlB,QACjB,OAAOuQ,EAAOkV,UAAUzlB,QAIhCuQ,EAASA,EAAO/P,MACpB,CACA,OAAO,IACX,CAuFwBklB,CAAWnG,GAC3BpG,EAAUvnB,EAASmU,YAAYoT,EAAS9F,EAAarT,EAAS6D,EAAQnG,EAAO6hB,EAAS7b,EAC1F,CACA,OAAOyV,CACX,EAOAzV,EAAOiiB,mBAAqB,SAAUC,EAAa1P,EAAW2P,GAC1D,MAAM,OAAEtV,EAAM,MAAEuL,GAAU8J,EAE1B,IAAIE,EAAO5P,GAAa7W,EAAM0mB,cAAcxV,GAC5C,GAAIiT,EAAYsC,GACZ,OAEJ,IAAIxZ,EAAK,KAIT,GADAA,EAAKrK,EAAgBI,gBAAgByZ,EAAOvL,EAAOvrB,MAC/CsnB,EAAI,CACJuZ,EAAYA,GAAc,CAAC,EAC3B,IAAI9Q,EAAK0O,GAAiB,IACdnX,EAAG9I,OAAO9qB,KAAKkZ,SAAUk0B,GAAM,EAAOptC,KAAK26B,YAAa36B,KAAMmtC,KAI1E,OAFAD,EAAYI,YAAcjR,EAC1Br8B,KAAKwgC,iBAAmB2M,EACjB9Q,CACX,CACA,OAAO,IACX,EACArR,EAAO+S,iBAAmB,SAAUwP,EAAYC,EAAU5lB,EAAUulB,GAChE,IAAIC,EAAOxlB,GAAY,IAAK2lB,EAAW3lB,YAAa2lB,EAAW9P,aAC/D,GAAIqN,EAAYsC,GACZ,OAAII,EAAS,GAAG7qC,OAAO,EACZqoB,EAAOohB,8BAA8BmB,EAAYC,EAAS,SACrE,EAEJ,MAAM,OAAE3V,GAAW0V,GACb,MAAEvoB,GAAUhlB,KACZooB,EAAIpoB,KACJytC,EAAgB,SAAUhhC,EAAO2f,EAAK9a,EAAI4H,EAAU8R,GACtD,MAAM,OAAED,EAAM,OAAEI,EAAM,MAAEnG,EAAK,QAAEsC,GAAY0D,EAC3C,GAAIoB,EAAI7E,SACJ9a,EAAQka,EAAMyG,kBAAkB3gB,EAAO2f,EAAI7E,SAAUgmB,EAAWnK,MAAOhb,OACpE,CAEH,MAAMiX,EAAK,GACX5yB,EAAQ2V,EAAW4K,iBAAiBZ,EAAK3f,EAAO4yB,GAChD5yB,EAAQyM,EAASmU,YAAY5gB,EAAOse,EAAQzD,EAAS6D,EAAQnG,EAAOoH,EAAIhE,EAC5E,CACA,OAAO3b,CAEX,EACAuY,GAAOwd,QAAQ,kBAAoB7F,EAAMna,IAAI,4BAA8BqV,GAC3E,IAAInH,EAAM8c,EACN5Z,EAAKrK,EAAgBI,gBAAgB+G,EAAKmH,EAAOvrB,MACrD,GAAIsnB,EAAI,CACJuZ,EAAaA,GAAc,CAAC,EAC5B,IAAI9Q,EAAK0O,GAAgB,IACZnX,EAAG9I,OAAO9qB,KAAKkZ,SAAUk0B,EAAMK,EAAeztC,KAAK26B,YACxDvS,EAAG+kB,KAUX,OANAI,EAAW3H,UAAYvJ,EACvBr8B,KAAKwgC,iBAAmB2M,EACxBnoB,GAAOwd,QAAQ,mBACX7F,EAAMna,IAAI,mCACVD,QAAQC,IAAI,CAACkrB,SAASrR,KAEnBA,CACX,CACA,OAAO,IACX,EA0BArR,EAAO2iB,cAAgB,SAAUP,EAAMvG,EAAS2G,GAG5C,IAAIr7B,EAAO,GACXA,EAAKy7B,QAAU,CAAC,EAChB,IAAIC,EAAO,KACX,IAAK,IAAIxmC,KAAK+lC,EAAM,CAChBj7B,EAAKrQ,KAAKuF,GACV,IAAIpJ,EAAImvC,EAAK/lC,GACb,KAAMA,KAAKmmC,GAAW,CAClBprB,EAAW0rB,UAAU,KACrB,QACJ,CACA,IAAIrhC,EAAQ+gC,EAASnmC,GAGjBpJ,EAAEupB,YACF/a,EAAQka,EAAMsG,qBAAqBxgB,EAAOxO,EAAEupB,YAE5CvpB,EAAEqO,OACFuhC,EAAO,IAAIE,wBACXF,EAAKvhC,KAAOrO,EAAEqO,KACd6F,EAAKy7B,QAAQvmC,GAAK,CACdwwB,OAAQgW,EACRphC,MAAOA,IAGf+gC,EAASnmC,GAAKoF,CAClB,CACA,OAAO0F,CACX,EAMA6Y,EAAOgjB,OAAS,SAAUC,EAAaC,GAC/BA,EACAluC,KAAKmuC,YAAY/J,YAAY6J,EAAaC,GAE1CluC,KAAKqrC,IAAM4C,CAEnB,EAKAjjB,EAAOojB,cAAgB,UAAU,MAAEvnC,IAC/B8iC,EAAmB9iC,EAAM4+B,eAC7B,EACAza,EAAOqjB,UAAY,SAAU/8B,IACzBq4B,EAAmB,IAAIjL,GACNptB,GAAKA,CAC1B,EAIA0Z,EAAOkT,WAAa,WAChByM,IACAP,EAAatoC,KAAK,CACdgqB,OAAQ9rB,KAAK8rB,OACb2Z,gBAAiBzlC,KAAKylC,kBAE1BzlC,KAAKquC,UAAU,gBACnB,EAKArjB,EAAOsT,mBAAqB,WACxB,IAAI1D,EAASwP,EAAalrB,MACtB0b,IACA56B,KAAKouC,cAAc,CAAEvnC,MAAO+zB,IAC5B+P,IAER,EAMA3f,EAAOiF,MAKH,SAAU8V,GAAa,GACnB,MACM,OAAEnL,EAAM,KAAEjzB,EAAI,OAAEmkB,EAAM,WAAEoV,EAAU,MAAEyE,EAAK,gBAAEF,EAAe,SAAEvsB,GADrDlZ,KAEPujC,EAAQ,CAAE3I,SAAQ9O,SAAOnkB,OAAMu5B,aAAYyE,QAAOD,UAASD,kBAAiB6I,KAFrEtuC,KAE2E+lC,cACpF7sB,GAAU+W,MACV/W,EAAS+W,MAAMntB,MAAM,KAAM,CAACygC,KAEvBqH,IACDA,EAAsB,IAAI5V,GAE9B4V,EAAoB3a,MAAMsT,IAE9BoG,EAAiB7zB,OACrB,EAEJkV,EAAOqT,MAOH,SAAUvoB,EAAOy4B,GACb,MACM,OAAE3T,EAAM,OAAE9O,EAAM,SAAE5S,EAAQ,WAAEgoB,EAAU,gBAAEuE,GADjCzlC,KAEb,IAAIuZ,EAAI,GACJ5R,EAAO,KAgBX,OAdI4R,EADAL,GAAU4S,OACN5S,EAAS4S,OAAOhpB,MAAM,KAAM,CAAC,CAAE83B,SAAQ9O,SAAQoV,aAAY2E,WAAUyI,KALhEtuC,QAOL8rB,EAAOltB,KAAKinC,GAEpBl+B,EAAOu5B,EAAWtiC,KAAKinC,GAEnB/vB,IACIy4B,IACAA,EAAQrN,WAAav5B,EACrB4mC,EAAQC,QAAU/I,EAAgB/F,gBAEtC+F,EAAgBtE,WAChBrV,EAAOnpB,OAAS,GAEb4W,CACX,EACJyR,EAAOqa,WAKH,WACA,MAAM,SAAEnsB,GAAalZ,MACf,SAAE6lC,GAAazjB,EAAWqsB,SAChC,OAAIv1B,GAAUmsB,WACHnsB,EAASmsB,WAAWQ,EACvB7lC,KAAKylC,gBAAiBzlC,KAAM,CAC5BiwB,MAAO,KACHjwB,KAAKiwB,OAAO,IAIb7N,EAAWge,eAAeyF,EAAU7lC,KAEnD,CACJ,CAQA,cAAA0uC,CAAeC,EAAe/T,GAC1B,IAAIgU,EAAQhU,EAAOj4B,OACnB,MAAMixB,EAAK+a,EAAcE,gBAUzB,OATIjb,IACgB,mBAAN,EACNgH,EAASrP,UAAUqP,GACG,iBAAR,GAAqBhH,EAAGtoB,SACtCsvB,EAAShH,EAAGtoB,OAAOsvB,IAGvB56B,KAAK4D,KAAOg3B,EAAS5P,OAAOpnB,KAAK4oB,UAAUoiB,IAExC,CAACE,SAAUlU,EAAQgU,MAAOhU,EAAOj4B,OAC5C,CAIA,SAAAosC,GACyB,MAAjB/uC,KAAKgoC,SAELhoC,KAAKgoC,SAAW,CACZviB,SAAU,EACVupB,QAAS,KACTv6B,MAAO,IAIXzU,KAAKgoC,SAASviB,SAAW,EACzBzlB,KAAKgoC,SAASgH,QAAS,KACvBhvC,KAAKgoC,SAASvzB,MAAQ,EAE9B,CACA,gBAAIgQ,GACA,OAAOzkB,KAAK0nC,WAAa1nC,KAAKssB,MAClC,CAIA,KAAAhoB,GACItE,KAAK4nC,SACL5nC,KAAK2oC,oBACL3oC,KAAKyoC,gBACLzoC,KAAKmoC,IACLnoC,KAAKooC,IACLpoC,KAAKgkC,UACLhkC,KAAKsoC,aACLtoC,KAAK6nC,aACL7nC,KAAK8nC,gBACL,EACA9nC,KAAKgjB,UAAY,EACjBhjB,KAAK+nC,YAAc,EACnB/nC,KAAK8oC,SAAW,EAEhB9oC,KAAKumC,SAAW,KAChBvmC,KAAKwgC,iBAAmB,KACxBxgC,KAAKivC,gBAAkB,KACvBjvC,KAAKopC,aAAatzB,QAClB9V,KAAKkvC,aACT,CACA,kBAAAC,GACI,MAAMnkB,EAAShrB,KACf,GAAIA,KAAKyoC,iBAAmBzd,EAAOwd,cAAc7lC,OAAS,EAAG,CAEzD,IAAI8R,EAAQuW,EAAOwd,cAAc7lC,OACjC,KAAO8R,EAAQ,GAAG,CACd,IAAI26B,EAAKpkB,EAAO0gB,cACZtjB,EAAI4C,EAAOwd,cAActpB,MAC7B,GAAIkwB,IAAOhnB,EACP,MAAM,IAAIrY,MAAM,yBAEpB0E,IACA,IAAI46B,EAAKrkB,EAAO4P,OAChB5P,EAAOojB,cAAchmB,GACjBinB,EAAG1sC,OAAS,GACZqoB,EAAOoV,eAAeiP,EAE9B,CACJ,CACJ,CACA,WAAAH,GACIlvC,KAAK0oC,UAAY,KACjB1oC,KAAKkpC,uBAAyB,KAC9BlpC,KAAK+oC,eAAgB,CACzB,CAOA,aAAAuG,CAAc/kB,EAAG9E,EAAU6G,GACvBtsB,KAAKmuC,YAAYrK,WAAavZ,EACb/e,MAAZia,GAA2BA,GAAU,GACtCzlB,KAAKokC,YAAY3e,EAAU6G,EAEnC,CAOA,WAAA8X,CAAY3e,EAAU6G,GAClBtsB,KAAKmuC,YAAY/J,YAAY3e,EAAU6G,EAC3C,CAOA,eAAAijB,CAAgB1I,EAAS2I,GACrBxvC,KAAKkvC,cACLlvC,KAAKmvC,qBAEDtI,EAAQsC,gBACRnpC,KAAKmpC,cAAgBtC,EAAQsC,eAE7BtC,EAAQ0C,6BACJvpC,KAAK0pC,gCAAgC7C,GAErC7mC,KAAKwpC,yBAGjB,CACA,iBAAAiG,GAEA,CAQA,mBAAAC,CAAoBjuC,EAAMomB,GACtB,MAAMmD,EAAShrB,KACf,IAAIwvC,EAAOxkB,EAAO2kB,oBAAoBluC,EAAMomB,GAC5C,GAAI2nB,EAAM,CAEN,IAAIpR,EAAWpT,EAAO4P,OAClBgV,EAAS5kB,EAAOrjB,KACpBqjB,EAAOojB,cAAcoB,GACjBpR,GACApT,EAAOya,gBAAgBrF,eACnB,CACA7sB,OAAO6qB,EAAUz2B,KAAMioC,GAEnC,CACA,OAAOJ,CACX,CAKA,oBAAIK,GACA,OAAO7vC,KAAKgkC,WAAchkC,KAAK4D,MAAQ5D,KAAK8jC,UAChD,CAOA,mBAAA6L,CAAoB9X,EAAQhQ,GAAa,GACrC,GAAI7nB,KAAKutC,WAAW5qC,OAAS,EAAG,CAC5B,GAAI3C,KAAKutC,WAAW,GAAG1V,SAAWA,EAC9B,OAAO73B,KAAKutC,WAAW92B,QAE3B,GAAIoR,EACA,MAAM,IAAI9X,MAAM,0CAExB,CACA,OAAO,IACX,CACA,oBAAA+/B,GACI9vC,KAAKiwB,QACL,IAAIwQ,EAAUzgC,KAAKq+B,OAAM,GACrBoC,EAAQ99B,OAAS,GACjB3C,KAAKylC,gBAAgBrF,eAAeK,EAE5C,CACA,gBAAAsP,CAAiBj6B,EAAO4V,GACpB,MAAMV,EAAShrB,KACf,IAAIygC,EAAUzV,EAAO4P,OACjBoV,EAAMhlB,EAAOqT,OAAM,EAAM3S,GAI7B,OAHI5V,GACAkV,EAAOya,gBAAgB3vB,QAEpBk6B,EAAIvP,CACf,CACA,mBAAAwP,GACI,OAAIjwC,KAAKutC,WAAW5qC,OAAS,EAClB3C,KAAKutC,WAAW,GAEpB,IACX,CAMA,aAAA2C,EAAc,OAAEtV,EAAS,KAAI,SAAEuV,GAAW,EAAK,aAAE/J,GAAe,EAAK,MAAEtwB,GAAQ,IAE3E,IADA8kB,EAASA,GAAU56B,KAAK46B,SACTA,EAAOj4B,OAAS,EAC3B,GAAIwtC,EACAnwC,KAAKiwB,MAAMmW,OACV,CACD,IAAI7sB,EAAIvZ,KAAK46B,OACTrhB,EAAE5W,QACF3C,KAAK8rB,OAAOhqB,KAAKyX,EAEzB,CAEAzD,GACA9V,KAAKylC,gBAAgB3vB,OAE7B,CAIA,kBAAIs6B,GACA,OAAOpwC,KAAKutC,WAAW5qC,OAAO,EAAG3C,KAAKutC,WAAW,GAAK,IAC1D,CAEA,iBAAApP,GACIn+B,KAAKglB,OAAOwd,QAAQ,6BAA+B7F,EAAMna,IAAI,+BAC7D,MAAM,SAAEtJ,EAAQ,OAAE4S,EAAO,WAAEoV,GAAclhC,KACzCqpB,EAAiBgnB,sBAAsB,CAAEn3B,WAAU4S,SAAQoV,cAC/D,CAMA,YAAAoP,CAAax6B,GACT,MAAMy6B,EAAW,CAAC,EAElB,MAAO,CAAC3V,OADQ56B,KAAKq+B,MAAMvoB,EAAOy6B,GACT5oC,KAAM4oC,EAASrP,WAC5C,CACA,4BAAOmP,EAAsB,SAAEn3B,EAAQ,OAAE4S,EAAM,WAAEoV,IACzChoB,GAAUilB,kBACVjlB,EAASilB,kBAAkB,CAAErS,OAAQA,KAErCA,EAAOhqB,KAAK,IACZo/B,EAAWp/B,KAAK,IAExB,CACA,sBAAI0uC,GACA,MAAM,gBAAE/K,GAAoBzlC,KAC5B,MAAO,CACH4tB,cAAgB6X,EAAgB7X,cAChCC,YAAc6Q,EAAgB7Q,YAEtC,CAIA,eAAI4iB,GACA,MAAO,CACH7V,OAAQ56B,KAAK46B,OACbjzB,KAAO3H,KAAK2H,KACZmkB,OAAS9rB,KAAK8rB,OAAO1nB,MAAM,GAC3B88B,WAAalhC,KAAKkhC,WAAW98B,MAAM,GACnC86B,eAAiBl/B,KAAKylC,gBAAgBvG,eACtCK,aAAev/B,KAAKylC,gBAAgBlG,aAE5C,CAEA,eAAAmR,GACI,IAAIC,EAAM3wC,KAAKkoC,cAAc0I,cAAgB5wC,KAAKkoC,cAAc57B,KAChE,OAAIqkC,EAIO,IAAItU,EAFFr8B,KAAK6wC,UAAUC,kBAEVH,GAEX3wC,KAAK6wC,UAAUE,cAC1B,EAKJpzC,EAAQ0rB,iBAAmBA,C,4BC3nC3BrqB,OAAOD,eAAepB,EAAS,WAA/B,CAA6C8O,OAAO,IAIpD,MAAMukC,UAAkCjhC,MACpC,WAAAqF,CAAYvU,EAAKowC,EAAS7pC,EAAOxD,GACzBA,IACA/C,GAAO,OAAO+C,GAElBkhC,MAAMjkC,GACN7B,OAAOD,eAAeiB,KAAM,UAAW,CAAC2M,IAAG,IAAUskC,IACrDjyC,OAAOD,eAAeiB,KAAM,QAAS,CAAC2M,IAAG,IAAUvF,GACvD,EAIJzJ,EAAQqzC,0BAA4BA,C,4BChBpChyC,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAgCpD9O,EAAQgkC,qBA1BR,MACI,GACA,GAEA,WAAAvsB,CAAYwlB,EAAQyE,GAChBr/B,MAAK,EAAY46B,EACjB56B,MAAK,EAAQq/B,CACjB,CACA,QAAAnuB,GACI,OAAOlR,MAAK,CAChB,CACA,UAAI46B,GACA,OAAO56B,MAAK,CAChB,CACA,YAAIkxC,GACA,OAAqB,MAAdlxC,MAAK,CAChB,CACA,QAAIgqC,GACA,OAAIhqC,KAAKkxC,SACElxC,MAAK,EAET,IACX,E,6BC3BJ,MAAM,MAAE2mB,GAAU,EAAQ,MAE1B3nB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAItD,MAAMs0B,EAIFlT,YAIAD,cAEA,WAAAxY,GACA,CAOA,wBAAO+7B,CAAkBC,GAAS,YAACvjB,EAAW,cAAED,IAC5C,IAAIyjB,EAAS,IAAItQ,EACjBsQ,EAAOxjB,YAAcA,EACrBwjB,EAAOzjB,cAAgBA,EACvByjB,EAAOrQ,WAAWoQ,EACtB,CAKA,UAAApQ,CAAWoQ,GACP,MAAM,YAACvjB,EAAW,cAAED,GAAiB5tB,KAC/BsxC,EAAUF,EAASxjB,cAAcjrB,OACvCyuC,EAASxjB,cAAc9rB,QAAQ8rB,GAC/BwjB,EAASvjB,YAAY/rB,QAAQ+rB,GAC7B,MAAM,OAAEkR,GAAYnR,GACd,gBAAE8Q,GAAoB/X,EAAMG,QAElC,GAAIiY,EAAO,CACF,OAAQA,GACTL,EAAgBY,oBAAoBP,GAKlC,WAAYqS,EAASxjB,gBACvBwjB,EAASxjB,cAAcmR,OAASL,EAAgBM,qBAEpD,IAAI6M,EAAK,EACL0F,EAAKH,EAASxjB,cAAcmR,OAChCA,EAAO5gC,SAAQqzC,IACX,MAAMtR,EAAOsR,EAAUF,EACjB,OAAQC,GACV7S,EAAgBY,oBAAoBiS,GAExCA,EAAGzvC,KAAKo+B,GACR,IAAIuR,EAAMD,KAAWzS,EAAOM,GAAIN,EAAOM,GAAGmS,GAAW,KACrD7qB,EAAMwZ,6BAA6BoR,EAAIrR,EAAMuR,GAC7C5F,GAAI,GAEZ,CACJ,EAKJluC,EAAQojC,qBAAsBA,C,8BCtE9B/hC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IACtD,MAAM,qBAAEilC,GAAyB,EAAQ,OACnC,eAAEC,GAAmB,EAAQ,OAC7B,gBAAE7vB,GAAoB,EAAQ,MAyFpCnkB,EAAQi0C,iBAvFR,MACIlM,QAAU,KACVG,SAAW,KACXgM,mBAAoB,EACpB5F,aAAc,EACd6F,YAAcJ,EAAqBK,IAKnCC,WAAY,EACZrM,MAAQ,EACR/hC,KAAO,EAIPquC,qBAAuB,IAIvBC,6BAA8B,EAM9BC,gBAOAC,cAAgB,SAUhB,UAAArqB,CAAWC,EAAQC,EAAWtgB,EAAMugB,EAAQC,GACxC,OAAQF,GACJ,IAAK,cACD,GAAIypB,EAAqBW,QAAQ1qC,GAC7B,OAAOA,EAEX,MAAM,IAAIoI,MAAMkY,EAAY,kBAChC,IAAK,kBACD,IAAIkD,EAAS,KAIb,GAHIxjB,aAAgBma,IAChBqJ,EAASxjB,GAEO,iBAAV,EACNwjB,EAASrJ,EAAgBwwB,aAAa3qC,OACnC,CACH,MAAM,GAAC2J,EAAE,OAAE6Z,GAAUxjB,EAErBwjB,EAASrJ,EAAgBwwB,aAAa3qC,EAC1C,CACA,OAAOwjB,EAEf,OAAOxjB,CACX,CAKA,wBAAA4qC,GACI,OAAOZ,EAAea,QAAQxyC,KAAK8xC,YACvC,CAMA,sBAAAW,CAAuBC,GACnB,IAAIjrC,EAAIzH,KAAKiyC,qBAIb,MAHkB,iBAAP,IACPxqC,EAAIA,EAAE/E,MAAM,OAES,GAAlB+E,EAAE4G,QAAQqkC,EAErB,E,8BC1FJ1zC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,gBAAEiyB,GAAoB,EAAQ,MAC9B,0BAAEiU,EAAyB,SAAE/rB,GAAa,EAAQ,MAClD,iBAAE6gB,GAAqB,EAAQ,KAC/B,MAAE9gB,GAAU,EAAQ,OACpB,eAAEisB,GAAmB,EAAQ,OAC7B,MAAEjW,GAAU,EAAQ,MAM1B,MAAMkW,UAA8BF,EAChCrmC,KAAO,iCACPm5B,gBACAhkC,KACAqxC,YAAc,EACdC,cACAC,SAAU,EACVC,QAAS,EACTlU,QAAS,EACTmU,iBAIAC,iBAIAC,gBAIA,aAAIC,GACA,OAAO,CACX,CACA,WAAAj+B,GACI0vB,QACA9kC,KAAKylC,gBAAkB,IAAI/G,EAC3B1+B,KAAKylC,gBAAgBn0B,GA/BR,qBAgCb,IAAIgiC,EAAU,CAAEC,OAAO,EAAOP,SAAS,GAGvChzC,KAAKogC,eAAiB,SAAU7V,EAAGmG,GAC/B,GAAIA,EAAK,CACL,MAAM,QAACmW,EAAO,WAAE2M,GAAc9iB,EAC9B,GAAImW,GAAW2M,GAA+B,GAAhB3M,EAAQnxB,KAAY,CAC9C,IAAI+qB,EAAUzgC,KAAKylC,gBAAgB7K,OACnCrQ,EAAIipB,EAAWC,iBAAiB5M,EAAQnxB,KAAM+qB,EAASlW,GACvDvqB,KAAKylC,gBAAgB3vB,OACzB,CACJ,CAEA,OADA9V,KAAKylC,gBAAgBrF,eAAe7V,GAC7BA,CACX,EACAvqB,KAAK8V,MAAQ,WACT9V,KAAKylC,gBAAgB3vB,OACzB,EACA9W,OAAOD,eAAeiB,KAAM,QAAS,CAAE2M,IAAG,IAAY2mC,IACtDt0C,OAAOD,eAAeiB,KAAM,SAAU,CAAE,GAAA2M,GAAQ,OAAO3M,KAAKylC,gBAAgB7K,MAAQ,IACpF57B,OAAOD,eAAeiB,KAAM,QAAS,CAAE,GAAA2M,GAAQ,OAAO3M,KAAKyB,MAAMyI,KAAO,IACxElL,OAAOD,eAAeiB,KAAM,MAAO,CAAE,GAAA2M,GAAQ,OAAO3M,KAAKyB,MAAMb,GAAK,IACpE5B,OAAOD,eAAeiB,KAAM,UAAW,CAAE,GAAA2M,GAAQ,OAAO3M,KAAKyB,MAAMgmB,OAAS,IAC5EzoB,OAAOD,eAAeiB,KAAM,QAAS,CAAE,GAAA2M,GAAQ,OAAO3M,KAAKyB,MAAMuB,KAAO,IACxEhE,OAAOD,eAAeiB,KAAM,WAAY,CACpC,GAAA2M,GACI,OAAO3M,KAAKyB,MAAM8lB,QACtB,EACA,GAAA/Z,CAAI+c,GACA,MAAM,IAAIxa,MAAM,qCACpB,IAMJ,MAAMqY,EAAIpoB,KACVhB,OAAO8S,KAAK+gC,EAAsB/zC,WAAWX,SAAQolB,IAC7C,SAASzS,KAAKyS,IAElBvkB,OAAOD,eAAeqpB,EAAG7E,EAAG,CACxB5W,IAAK,WAED,OAAOyb,EAAE3mB,KAAO2mB,EAAE3mB,KAAK4F,QAAKmE,CAChC,GACF,GAGV,CACA,wBAAIkoC,GACA,OAAO,CACX,CACA,yBAAIC,GACA,OAAO,CACX,CACA,oBAAIC,GACA,OAAO5zC,KAAKyB,KAAKmyC,gBACrB,CACA,sBAAIC,GACA,OAAO7zC,KAAKyB,KAAKoyC,kBACrB,CACA,sBAAIC,GACA,OAAO9zC,KAAKyB,KAAKqyC,kBACrB,CACA,YAAIvsB,GACA,OAAOvnB,KAAKyB,MAAM8lB,QACtB,CACA,WAAIlZ,GACA,OAAOrO,KAAKyB,MAAM4M,OACtB,CACA,YAAI0lC,GACA,OAAO/zC,KAAKyB,MAAMsyC,QACtB,CAEA,UAAIlc,GACA,OAAO73B,KAAKyB,MAAMo2B,MACtB,CAGA,iBAAAmc,CAAkB9G,EAAaliB,EAAQggB,EAAMiJ,EAAezE,GACxD,MAAM,KAAE/tC,EAAI,OAAEqmB,GAAW9nB,MACnB,UAAEurB,EAAS,WAAEgiB,GAAeviB,EAE5BkpB,EAAQl0C,KAAK46B,OACnB,IAAIuZ,EAAM,KACNC,EAAM,CAAExwC,KAAMonB,EAAOpnB,KAAMynC,IAAKrgB,EAAOqgB,KAI3C,GAHA4I,EAAcjpB,EAAQggB,GACtBzf,EAAU8oB,cAAc5yC,EAAMupB,GAEP,GAAnBopB,EAAIxwC,KAAKjB,OAGT,OAFAqoB,EAAOya,gBAAgBrF,eAAe8T,GACtCl0C,KAAK8V,QACE,KAMX,GAFAkV,EAAOskB,cAAc4E,EAAM,GAEb,MAAVpsB,EACA,MAAM,IAAI/X,MAAM,8BAQpB,OANIokC,EAAMn0C,KAAKs0C,kBAAkBpH,EAAaliB,EAAQwkB,EAAM/tC,GAE5DupB,EAAOpnB,KAAOwwC,EAAIxwC,KAClBonB,EAAOqgB,IAAM+I,EAAI/I,IACbmE,GAAM3X,QAAUp2B,GACpBupB,EAAO0kB,oBAAoBjuC,GACpB0yC,CACX,CAKA,oBAAAI,CAAqBvpB,GACjB,MAAM5C,EAAIpoB,KACV,IAAIw0C,GAAY,EACZC,GAAoB,EACxB,SAASC,EAAoB1pB,GACzB,IAAI2pB,EAAW3pB,EAAO4P,QACjB4Z,GAAcG,EAAShyC,OAAS,GACjCylB,EAAEgY,eAAeuU,EAGzB,CACA,SAASV,EAAcjpB,EAAQggB,GACvBwJ,IAGJE,EAAoB1pB,GACpBA,EAAO4pB,uBAAyB5J,EAAKhgB,OAAO9R,SAC5Cs7B,GAAY,EAChB,CACA,SAASK,EAAoB/sB,GAIzBA,EAAOpS,KAAOs1B,EAAK8J,UACvB,CACA,MAAM9J,EAAO5iB,EAAEmrB,MACf,GAAKnrB,EAAE4qB,QAUChI,EAAKljB,SACLkjB,EAAKljB,OAAOpS,KAAOk9B,EAAemC,eAX1B,CAEZ3sB,EAAE4qB,SAAU,EACZ,MAAM,OAAElrB,GAAWM,EAAE3mB,KACjBqmB,IACAkjB,EAAKljB,OAASA,EAEdkjB,EAAK8J,WAAahtB,EAAOpS,KAEjC,CAMA,OAAO,SAAU63B,EAAYviB,GAGzBA,EAAOud,OAASngB,EAChB,MAAM,MAAEpD,GAAUgG,EACZ5I,EAAapiB,KACEgrB,EAAOqgB,IAA5B,IACI5K,EAAUrY,EAAEwS,OAChB,MAAM,KAAEn5B,GAAS2mB,EACX8rB,EAAQlpB,EAAOpnB,KAAK4oB,UAAUxB,EAAOqgB,KAC3C,IAAIpR,EAAI+a,EACR,MAAM3K,EAAcrf,EAAOuiB,WAC3BvoB,GAAS2X,EAAMna,IAAI,4BACnB,IACSwoB,EAAKgI,UAKNhI,EAAKgI,SAAU,KAGhB/Y,KAAI+a,YAAa5yB,EAAW6yB,kBAAkBf,EAAO3G,EAAYviB,EAAQuiB,GAChF,CAAE,MAAOngC,GAOL,MALWi9B,EAAY5zB,QACnBu0B,EAAKuI,OACLU,EAAcjpB,EAAQggB,GAE1BhgB,EAAOpnB,KAAOwkB,EAAEwS,OAAS5P,EAAOpnB,KAAK4oB,UAAUxB,EAAOqgB,KAChDj+B,CACV,CAEA,IAAIoiC,EAAOxkB,EAAO0kB,oBAAoBnC,GAAY,GAC9CiC,IACAiF,GAAoB,GAGxBjF,EAAQnF,EAAY1nC,OAAS,EAAKqoB,EAAO2kB,oBAAoBluC,GAAM,GAAS,KACvEupC,EAAKuI,QACNvI,EAAKhgB,OAAS,CACV9R,SAAU8R,EAAO4pB,wBAGrB5pB,EAAO4pB,uBAAyB,CAACrqB,EAAGsc,EAAS3b,EAAOF,KAChD,IAAIyV,EAAUzV,EAAO4P,OACrB,MAAM,WAAE4Y,GAAexoB,EAAOO,UACxBqO,EAAO,CAACiN,UAAS2M,cAcvB,OAbItoB,IAAU9C,EAAE3mB,KAAK8pB,YACjBhB,EAAIS,EAAOohB,8BAA8BvF,EAAStc,IAIlDkW,EAAQ99B,OAAS,GACb89B,GAAWzV,EAAO0d,YACtBtgB,EAAEgY,eAAeK,EAAS7G,GAC1B5O,EAAOya,gBAAgB3vB,SAGvByU,EAAE5nB,OAAS,GACXylB,EAAEgY,eAAe7V,EAAGqP,GACjBrP,CAAC,EAEZygB,EAAKuI,OAAQ,GAGjBvoB,EAAOkgB,WAAWlgB,EAAOqgB,KACzB,IAAI9jC,EAAI,KACR,MAAM2tC,EAAWrC,EAAsBsC,qBAAqB/sB,EAAGmlB,EAAYvC,EAAM5oB,EAAY6xB,EAAeY,GAO5G,GANAzsB,EAAE8qB,iBAAmB,CAACzS,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,KAC3D,MAAM/nC,EAAIytC,EAASzU,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,GAE5D,OADAkF,EAAoB1pB,GACbvjB,CAAC,EAGRujB,EAAOmd,KAAc,MAANlO,GAA4B,MAAZ+a,EAC/B,OAAO5sB,EAAE4rB,kBAAkBzG,EAAYviB,EAAQggB,EAAMiJ,EAAezE,GAExE,GAAIxkB,EAAOqd,MAKP,OAFW6M,EAASpyC,MAAMkoB,EAAOO,UAAW,CAACkV,EAASyT,EAAO3G,EAAYtT,EAAIjP,EAAQwkB,IAMzF,IAKI,GAJa,MAARA,GAAkB/O,EAAQ99B,OAAS,IAEpC89B,EAAU,KAETrY,EAAE2W,OAAQ,CACX,MAAMqW,EAAchzB,EAAWizB,oCAAoC9H,EAAY,KAAM,GAAI,KAAMviB,GAC/F5C,EAAE2W,QAAS,EACXqW,EAAYF,SAAWA,CAC3B,CAEA3tC,EAAI6a,EAAWkzB,iBAAiB,CAC5Brb,KACAuV,OACAwF,WACAd,QACAhH,YAAazrC,EACbupB,OAAQA,EACRyV,UACAyU,WACAK,eAAc,CAACrI,EAAagH,EAAOlpB,KAC3BkpB,EAAMtf,OAAOjyB,OAAS,GACtBqoB,EAAOoV,eAAe8T,EAAOhH,GAEjCliB,EAAOqgB,KAAO6I,EAAMvxC,OAChB6sC,GACAxkB,EAAOygB,cAAc+D,GACdA,EAAK3X,QAET0V,KAIXnlB,EAAE6qB,QAAU7qB,EAAE2W,QACd/T,EAAO0kB,oBAAoBnC,GAAY,EAG/C,CAAE,MAAOngC,GAKL,OAHAmV,QAAQC,IAAI,mBAAoBpV,GAChCsnC,EAAoB1pB,GACpB5I,EAAWozB,aACJ,IACX,CAGA,GAFAd,EAAoB1pB,GACpBA,EAAOud,OAAS,KACZhhC,KAAOA,aAAakgC,GACpB,MAAM,IAAI13B,MAAM,qBAEpB,OAAKqY,EAAE6qB,QACC1rC,IAAM6gB,EAAE3mB,KAKT8F,EAJQgmC,CAKnB,CACJ,CAaA,iBAAA+G,CAAkBpH,EAAaliB,EAAQwkB,EAAMjC,EAAYkI,EAAe9yC,EAAQ+yC,GAC5E,MAAM,OAAE5tB,EAAM,aAAE6tB,EAAY,aAAEC,EAAY,QAAEvnC,GAAY6+B,GAClD,YAAEiB,GAAgBnjB,EACxBmjB,EAAY7pC,QACZ6pC,EAAYrK,WAAa4R,GAAU,GAEnC1qB,EAAOkgB,WAAWlgB,EAAOqgB,KACzB,IAAIwK,EAAYF,EACZhvB,EAAMmvB,gBAAgBH,EAActnC,EAASunC,GAAgB,GAEjE,GAAIC,EAAUlzC,OAAS,EAAG,CAEtB,IAAI8E,EAAIkf,EAAMovB,8BAA8B/qB,EAAOpnB,KAAMiyC,EAAW7qB,EAAQlD,GAM5E,GALI0nB,GACIA,GAAM3X,QAAU0V,GAChBviB,EAAOojB,cAAcoB,GAGzB/nC,EAIA,OAFA+nC,EACIxkB,EAAO0kB,oBAAoBxC,GAAa,GACrCzlC,EAGX,GAAe,OAAXqgB,EAAiB,CAGjB,IAAIkuB,EAAUP,EAAgB9yC,EAC1BszC,EAAUjrB,EAAOpnB,KAAK4oB,UAAU,EAAGwpB,GAIvC,OAHAhrB,EAAOoV,eAAe6V,EAASjrB,EAAO6lB,UAAUqF,oBAChDlrB,EAAOpnB,KAAOonB,EAAOpnB,KAAK4oB,UAAUwpB,GACpChrB,EAAOqgB,IAAM,EACN,IACX,CAEJ,CACA,OAAe,OAAXvjB,GAEAkD,EAAOoV,eAAepV,EAAOpnB,KAAMonB,EAAO6lB,UAAUqF,oBACpDlrB,EAAOqgB,IAAMrgB,EAAOroB,OACb,MAEJmlB,CACX,CAWA,2BAAOqtB,CAAqB/sB,EAAGmlB,EAAYvC,EAAM5oB,EAAY6xB,EAAeY,GACxE,MAAO,CAACpU,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,KAC7C,MAAM,OAAE1nB,GAAWolB,GACb,UAAE3hB,GAAcP,GAChB,SAAE+oB,GAAaxG,EACrBnlB,EAAE6qB,QAAS,EAEX,IAAIrE,EAAQ5jB,EAAOqgB,IAEf9F,EAAWnd,EAAEwS,OACbub,EAAe,KACfC,EAAiB,EAMrB,GALAprB,EAAOmjB,YAAY7pC,QAEnB6xC,EAAexvB,EAAM0vB,eAAenC,EAAOH,EAAU/oB,GACrDA,EAAOkgB,WAAWlgB,EAAOqgB,KACzB+K,EAAiBD,EAAanzC,MAAQmzC,EAAa7pB,QAC9C6pB,EACD,MAAM,IAAIpmC,MAAM,mBAEpB,MAAMic,EAAOmqB,EAAa,GACpBG,EAASpC,EAAM1nB,UAAU,EAAG2pB,EAAanzC,OAC/CkxC,EAAQA,EAAM1nB,UAAU2pB,EAAanzC,MAAQgpB,EAAKrpB,QAClD,MAAM4zC,EAAShR,EAAW+Q,EAAStqB,EAC7B0pB,EAAS7C,EAAsB2D,gBAAgBjrB,EACjDgrB,EAAQvrB,EAAQkiB,GAWpB,GAVAliB,EAAOpnB,KAAO8xC,EAASxB,EACvBD,EAAcjpB,EAAQggB,GAGtBvK,EAAUzV,EAAO+kB,kBAAiB,GAClCP,GAAQxkB,EAAOojB,cAAcoB,GACzB/O,EAAQ99B,OAAS,GACjBqoB,EAAOya,gBAAgBrF,eAAeK,GAE1ClV,EAAU8oB,cAAcnH,EAAaliB,GACjClD,EAAQ,CAIR,GAFA+sB,EAAoB/sB,IAEN,IADDolB,EAAY7+B,QAErB,MAAM,IAAI0B,MAAM,0CAiBpB6+B,EAAQ8G,EAAO/yC,OAASyzC,EACxB,IAAItH,EAAW4G,EAAOlpB,UAAU,EAAGoiB,GAWnC,QAVGE,WAAUF,SAAU5jB,EAAO0jB,eAAetmB,EAAG0mB,IAEhD9jB,EAAOqgB,IAAMuD,EACb5jB,EAAOkgB,WAAWlgB,EAAOqgB,KACzBrgB,EAAOoV,eAAe0O,EAAU9jB,EAAO6lB,UAAU4F,sBAG7C3uB,GAAWolB,EAAYxiB,OAAO/nB,OAAS,GACvCuqC,EAAYxiB,OAAOvsB,SAAQolB,GAAKuE,EAAO4C,OAAO5oB,KAAKyhB,KAEhDuE,CACX,CAEA,OAAOM,EAAEksB,kBAAkBpH,EAAaliB,EAAQwkB,EAAMjC,EAClD6I,EACApqB,EAAKrpB,OAAQ+yC,EAAO,CAEhC,CASA,sBAAOc,CAAgBjrB,EAAWmrB,EAAW1rB,EAAQkiB,GACjD,MACMyJ,EAAS,CAACD,GAChB,IAAIxC,EAAQ3oB,EAAUyB,iBAAiBkgB,EAAawJ,EAFzC,GAEwD1rB,EAAQ2rB,GAC3E,MAAMnZ,EAAY0P,EAAY0J,gBAAkB1J,EAAYtlB,SAI5D,OAHI4V,IACA0W,EAAQvtB,EAAMkwB,aAAa3J,EAAa1P,EAAW0W,EAAO,GAAIlpB,IAE3DkpB,CACX,CAMA,KAAAvzC,CAAMqqB,GACFhrB,KAAK8yC,YAAc9nB,EAAO8d,QAC9B,EAGJnrC,EAAQk1C,sBAAwBA,C,4BCjgBhC7zC,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD,MAAM6c,UAAiCvZ,MACnC+mC,GAEA,WAAA1hC,CAAYpF,GAAS,UAACgT,IAClB8hB,MAAM90B,GACNhQ,KAAK82C,GAAK9zB,CACd,EAEJrlB,EAAQ2rB,yBAA2BA,C,4BCXnCtqB,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAO,IAWrD9O,EAAQqoC,eATR,MACIjb,OACAzD,QACA7a,MAIAsqC,W,6BCTJ/3C,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,aAAEuqC,GAAiB,EAAQ,OAC3B,yBAAE3U,GAA6B,EAAQ,OACvC,MAAE1b,GAAU,EAAQ,OACpB,SAAEC,GAAa,EAAQ,OACvB,YAAEyB,GAAgB,EAAQ,OAC1B,WAAES,GAAe,EAAQ,OACzB,MAAE6T,GAAU,EAAQ,OACpB,kBAAE3H,GAAsB,EAAQ,OAChC,iBAAE4c,GAAqB,EAAQ,OAC/B,iBAAEnK,GAAqB,EAAQ,KAC/B,YAAE5gB,GAAgB,EAAQ,OAC1B,gBAAE0C,GAAoB,EAAQ,OAC9B,gBAAEmV,GAAoB,EAAQ,MAC9B,iBAAErV,GAAqB,EAAQ,OAC/B,qBAAEqoB,GAAyB,EAAQ,OACnC,iBAAEuF,EAAgB,eAAErE,EAAc,gCAAEsE,GAAoC,EAAQ,OAChF,oBAAEhR,GAAwB,EAAQ,OAClC,WAAEzC,GAAe,EAAQ,OACzB,UAAEpc,GAAc,EAAQ,OACxB,0BAAE2pB,GAA8B,EAAQ,OACxC,eAAEhL,GAAmB,EAAQ,OAC7B,kBAAE1D,GAAsB,EAAQ,OAChC,8BAAEW,GAAkC,EAAQ,MAC5C,0BAAEH,GAA8B,EAAQ,OACxC,qBAAE/B,GAAyB,EAAQ,MACnC,gBAAEyC,GAAoB,EAAQ,MAiCpC,IAAI2T,EAIAC,EAxBJzwB,EAAMG,QAAU,CACZuB,cACAzB,WACA6gB,mBACA5gB,cACA0C,kBACAmV,kBACArV,mBACAqoB,uBACA/U,QACA8G,aACApc,YACA2pB,4BACA3O,2BACA2D,iBACA1D,oBACAW,gCACAlC,wBAWJ,MAAM/e,EAKFq1B,WAIA9vB,SAIA+vB,WAIAtU,UAOAuU,kBAIAvyB,MAKAypB,SAMAhnB,QAMAsD,OAEAysB,mBAEAC,kBAEAC,UAKAC,KAKAC,eAKAjwC,KAKAizB,OAOA,0BAAWid,GACP,OAAOT,CACX,CAIA,0BAAWS,CAAgBprC,GACvB2qC,EAAsB3qC,CAC1B,CAKA,uBAAWqrC,GACP,OAAOX,CACX,CAIA,uBAAWW,CAAavtB,GACpB4sB,EAAkB5sB,CACtB,CACA,2BAAOwtB,CAAqBlgB,EAAQ7M,GAChC,MAAO,CACH1D,QAASuQ,EAAOvQ,QAChB6F,UAAWnC,EAAO2P,YAClBrO,OAAQtB,EAAOsB,OACf7H,aAAcuG,EAAOvG,aACrBhY,MAAOorB,EAAOprB,OAAgB,CAAGA,MAAOue,EAAO4P,OAAQrnB,OAAQyX,EAAOrjB,MAE9E,CAIAuR,SAMA8+B,SAMAhO,KAKA,WAAA50B,GAII,IAAI6iC,EACAC,EACAC,EAAS,CACTzd,gBAAiB,EACjB0d,aAAc,MAElBp4C,KAAKglB,OAAQ,EACbhlB,KAAKunB,SAAW,GAChBvnB,KAAKs3C,WAAa,CAAC,EAMnBt4C,OAAOD,eAAeiB,KAAM,WAAY,CAAE2M,IAAG,IAAYsrC,EAAe,GAAAzqC,CAAIf,GAASwrC,EAAaxrC,CAAM,IAIxGzN,OAAOD,eAAeiB,KAAM,OAAQ,CAAE2M,IAAG,IAAYwrC,IACrDn5C,OAAOD,eAAeiB,KAAM,WAAY,CAAE2M,IAAG,IAAYurC,IAGzDl4C,KAAK8tC,UAAa1gC,IACdpN,KAAKq4C,SAASv2C,KACV0hC,EAAgBp2B,GACnB,EAELpN,KAAKs4C,eAAiB,SAAU9vB,GAC5B0vB,EAAa1vB,SACNxoB,KAAKs4C,cAChB,CAGJ,CAEA,UAAA9C,GAEI,KAAM,WAAYx1C,MAAO,CACrB,MAAMooB,EAAIpoB,MACV,WACI,IAAIu4C,GAAQ,EACZv5C,OAAOD,eAAeqpB,EAAG,SAAU,CAC/Bzb,IAAG,IACQ4rC,EAEX,GAAA/qC,CAAI+c,GACAguB,EAAQhuB,CACZ,GAEP,CAVD,EAWJ,CAEJ,CAIA,gBAAAgiB,CAAiB1F,EAASpG,EAASzV,GAC/BhrB,KAAKwzC,YAAYjH,iBAAiBvsC,KAAM6mC,EAASpG,EAASzV,GAI1DA,EAAOgZ,WAAY,EACnBhZ,EAAOsd,cAAe,EACtBtd,EAAOwtB,YAAa,EACpBxtB,EAAO9B,eAAiB,KACxB8B,EAAOuW,YAAcvW,EAAOya,gBAAgBhE,kBAE5CzW,EAAOoe,aAAatnC,KAAKkpB,EAAOuW,YAAavW,EACjD,CAIA,YAAI6a,GACA,OAAO7lC,KAAKy4C,SAAS5S,QACzB,CAIA,YAAIA,CAASp5B,GACTzM,KAAKy4C,SAAWhsC,CACpB,CACA,SAAAisC,GACI,MAAMzvC,EAAI,aACV,IAAIytB,EAAM13B,OAAO8S,KAAK9R,MAClBsqB,EAAMoM,EAAIroB,QAAQpF,GAGtB,cAFQytB,EAAIpM,GACZoM,EAAIxK,QAAQjjB,GACLytB,CACX,CAOA,aAAAiiB,CAAcC,EAAY36C,EAAG46C,GACzB,MAAMC,EAAY,CACdvxB,SAAStpB,GACEY,MAAMuQ,QAAQnR,GAEzBq5C,WAAWr5C,GACc,iBAAP,EAElB+mB,MAAM/mB,GACmB,kBAAP,GAAoB,eAAe6S,KAAK7S,GAE1DwwC,SAASxwC,GACQ,MAALA,GAA4B,iBAAP,EAEjC+kC,UAAU/kC,GACO,MAALA,GAA4B,iBAAP,GAGrC,IAAIs0B,EAAIumB,EAAUF,GAClB,GAAIrmB,IAAMA,EAAEt0B,GAAI,CACZ,GAAI46C,EACA,MAAM,IAAI9oC,MAAM,IAAI6oC,mBAExB,OAAO,CACX,CACA,OAAO,CACX,CASA,UAAA7wB,CAAWC,EAAQC,EAAWtgB,EAAMugB,GAChC,MAAM6wB,EAAiB/wB,EAAOgxB,kBAAoBpyB,EAE5C8B,EAAQ,CACV1D,MAAM/mB,GACgB,kBAAP,EACHA,EACOqkC,EAAkBG,WAEtB,KAEJH,EAAkBhgB,KAAKrkB,GAElC,UAAAo5C,CAAWp5C,EAAG+pB,GACV,MAAMixB,EAAS,CAAC,EAChB,IAAK,IAAI5xC,KAAKpJ,EAAG,CACb,IAAIuqB,EAAIvqB,EAAEoJ,GACN6xC,EAAO,IAAIhU,EAEf,GADAgU,EAAKh5C,KAAOsH,SAASH,GACH,iBAAP,EACP6xC,EAAKlpC,QAAUwY,MACZ,CACH,MAAM,QAAExY,EAAO,IAAEmpC,EAAG,QAAEC,GAAY5wB,EAClC0wB,EAAKC,IAAMA,EACXD,EAAKlpC,QAAUA,EACfkpC,EAAKE,QAAUA,CACnB,CACAH,EAAO5xC,GAAK6xC,CAChB,CACA,OAAOD,CACX,EACA1xB,SA7BaZ,EAAM2B,wBAAwBN,EAAQpB,EAAUyB,GA8B7D,UAAAivB,CAAWr5C,EAAG+pB,GACV,IAAIuE,EAAO,CAAC,EACR1B,EAAK,KACT,MAAM,SAAE9S,GAAaiQ,EACrB,IAAK,IAAI3gB,KAAKpJ,EACV4sB,EAAK,IAAIkuB,EACTjwB,EAAWC,UAAUf,EAAQ6C,EAAI5sB,EAAEoJ,GAAIA,EAAGwjB,GAC1C7C,EAAOqxB,WAAWxuB,GAClB0B,EAAKllB,GAAKwjB,EAGd,OADA7C,EAAOsxB,cAAgB,KAChB/sB,CACX,EACAvH,MAAM/mB,GACgB,kBAAP,EACAA,IAEDA,EAEdwwC,SAAQ,CAACxwC,EAAG+pB,IACC,MAAL/pB,EACO,KAEH6qB,EAAWC,UAAUf,EAAQ,IAAI4pB,EAAkB3zC,GAG/D8sB,OAAM,CAAC9sB,EAAG+pB,IACFnpB,MAAMuQ,QAAQnR,GACPA,EAEJ,MAGf,IAAIkrB,EAAKT,EAAMT,GACf,OAAIkB,EACOA,EAAGxhB,EAAMqgB,EAAQE,GAErBvgB,CACX,CAOA,WAAO2a,CAAKhW,EAAMitC,GACd,MAAM5xC,EAAO,QAAQ,KAAmB2E,EAAO,oBAC/C,OAAI3E,EACOqa,EAAWkT,WAAWvtB,EAAM4xC,GAEhC,IACX,CAOA,iBAAOrkB,CAAWvtB,EAAM4xC,GACpB,MAAMC,EAAS,CAAC,EAChB,IAAIC,EAAsB,KAC1BzC,EAAa0C,OACb,MAAMnuB,EAAY5E,EAAMgzB,cAAc33B,EAAYra,EAAM,CACpD,UAAA0xC,CAAWzwB,IACDA,aAAahC,GAAcgC,aAAa/B,IAAkB+B,EAAM,MAClE5oB,KAAK45C,aAAahxB,EAAEtc,KAE5B,EACA,YAAAstC,CAAa3wC,GACLA,EAAEtG,QAAU,IAChB62C,EAAOvwC,GAAK,EAChB,GACDswC,GA+BH,OA9BAv6C,OAAOD,eAAewsB,EAAW,gBAAiB,CAAE5e,IAAG,IAAY6sC,IACnEjuB,EAAUsuB,wBAA0B,WAChC,GAA2B,MAAvBJ,EACA,OAAOA,EAEX,IAAI1hC,EAAW,CAAC,EACZ+hC,EAAS,GACb,IAAK,IAAIzyC,KAAKmyC,EAAQ,CAClB,GAAS,UAALnyC,EACA,MAAM,IAAI0I,MAAM,sBAEpB1I,EAAE3E,MAAM,KAAKvE,SAAQyqB,IAEjBjC,EAAMozB,WAAWnxB,OAAGpd,EAAWuM,GAC/B,IAAI9O,EAAI2f,EAAElmB,MAAM,KAAK,IACK,GAAtBo3C,EAAOzrC,QAAQpF,IACf6wC,EAAOh4C,KAAKmH,EAChB,GAER,CAEA,OADAwwC,EAAsB,CAAEO,WAAYF,EAAQ/hC,YACrC0hC,CACX,EACKluB,EAAUkjB,WACXljB,EAAUkjB,SAAW,IAAImD,GAG7B5yC,OAAOD,eAAewsB,EAAW,aAAc,CAAE5e,IAAG,IAAY4e,EAAUkjB,SAAS8D,6BACnFvzC,OAAOD,eAAewsB,EAAW,oBAAqB,CAAE5e,IAAG,IAAY4sC,IACvEvC,EAAaiD,UACN1uB,CACX,CACA,0BAAO2uB,GACH,OAAO,IAAItI,CACf,CACA,KACI,MAAM,SAAE14B,GAAalZ,KACrB,IAAI6qB,EAAK,KAQT,OAPI3R,IAGI2R,EAFqB,mBAAd,EAEF3R,EAASpW,MAAM9C,MAEfkZ,GAEN2R,GAAM,IAAImK,CACrB,CAMA,GAAgBhK,GACZ,MAAM6e,EAAM7e,GAAUhrB,KAAKyuC,UAAYzsB,EAAWk4B,sBAElD,IAAI5iB,EAAYt3B,MAAK,IAEjB2pC,EAAmB,IAAIjL,EAC3BiL,EAAiBr4B,GAAK,WACtB,MAAMs4B,EAAkB,CACpBuQ,qBAAsB,IAAIC,EAC1BC,aAAc,IAAIC,EAClBvJ,eAAgB,IAAIwJ,EACpBrE,mBAAoB,IAAIsE,EACxB/D,qBAAsB,IAAIgE,EAC1BC,4BAA6B,IAAIA,EACjC5J,iBAAkB6J,GAEtB,IAAI3C,EAAW,IAAI3uB,EAAiBrpB,KAAM2pC,EAAkBrS,EAAWsS,EAAiBC,GAExF,OADA7pC,KAAKs4C,eAAeN,GACbA,CACX,CAOA,WAAA4C,CAAYjzC,EAAMyJ,EAAQ4Z,GACtB,MAAM,IAAIjb,MAAM,0BACpB,CACA,UAAA8qC,GACI,IAAI,MAAE71B,GAAUhlB,KACA,QAAVglB,GAA6BxZ,MAATwZ,GAAwBA,aAAiBsd,IAG/Dtd,EADkB,kBAAX,EACCA,EAAQsd,EAAkBG,WAAa,MACxCzd,GAAWA,aAAiBsd,EAG3B,KAFAA,EAAkBhgB,KAAK0C,GAGnChlB,KAAKglB,MAAQA,EACjB,CAOA,MAAA1Z,CAAO3D,EAAMqjB,EAAO,MAKhB,GAJAhrB,KAAK66C,aACL7D,EAAa0C,QAGR76C,MAAMuQ,QAAQzH,GAAO,CACtB,GAAqB,iBAAV,EAGN,MAAM,IAAIoI,MAAM,sBAFjBpI,EAAOA,EAAKjF,MAAM,KAG1B,CACA,QAA+B,IAAnB1C,KAAc,UACtB,MAAM,IAAI+P,MAAM,4BAEpB,IAAI,SAAEioC,EAAQ,KAAEhO,GAAQhqC,KAKnBg4C,EAG2B,GAAxBhO,EAAKtP,iBACLsd,EAAS1zC,QAHb0zC,EAAWh4C,MAAK,EAAgBgrB,GAOpCgtB,EAAS9P,aAAeld,EAGxB,IAAI8vB,EAAe,KACf14B,EAAapiB,KACb+6C,GAAa,EAEjB,MAAM,MAAE/1B,EAAK,SAAE6gB,GAAamS,GACtB,QAAEtS,EAAO,UAAEsM,GAAchyC,KAAKyuC,SAE/BzuC,KAAKgqC,MAAMtP,kBACZsd,EAAS5R,cAAe,GAExBpmC,KAAKgqC,MAAMtP,kBACXqgB,GAAa,GAGjB,MAAMC,EAAiB,CAAC1vB,EAASN,KAC7B,GAAIA,EAAOuW,aAAayI,MAAMiR,QAAS,CACnC,MAAMxzC,EAAIujB,EAAOuW,YAAYrwB,WAE7B,KAAOoa,EAAQ3oB,OAAS,GAAM2oB,EAAQ4vB,SAASzzC,IAC3C6jB,EAAUA,EAAQkB,UAAU,EAAGlB,EAAQ3oB,OAAS8E,EAAE9E,OAAS,GAAGy+B,SAEtE,CACA,OAAO9V,CAAO,EAMZ6vB,EAAa,KACf,MAAM,WAAE3H,GAAepxB,EAEvB,SAASg5B,EAAwBC,EAAkBrwB,GAC/C,MAAM,IAAEqgB,GAAQrgB,EAChB,IAAKqwB,GAAoBrwB,EAAO6d,gBAAmB7d,EAAOjI,MAAMpiB,MAAQ0qC,EAAM,CAC1E,IAAIiQ,EAAKtwB,EAAOpnB,KAAK4oB,UAAUxB,EAAOjI,MAAMpiB,MAAO0qC,GAC/CiQ,EAAG1mB,OAAOjyB,OAAS,GACnBqoB,EAAOoV,eAAekb,EAAItwB,EAAO0lB,mBACrC1lB,EAAOkgB,WAAWG,GAClBrgB,EAAO6d,gBAAiB,CAC5B,CACJ,CACA,MAAM0S,EAAqBn5B,EAAW4nB,KAAKtP,gBAAkB,GACvD,YAAEyT,EAAW,aAAE/E,GAAiB4O,EACtC,IAAIwD,EAAkB,EAmItB,GAjIA7zC,EAAKxJ,SAASyF,IAEVo0C,EAAStQ,WAAa8T,EACtBA,GAAmB53C,EAAKjB,OAAS,EAEjC,IAAI04C,GAAmB,EAEvB,GADAjS,EAAatzB,QACT9V,KAAKy7C,OACL,OAKJ,MAAMzwB,EAASgtB,EAQf,GAPAhzB,GAAOwd,QAAQ,cAAgB7F,EAAMna,IAAI,SAAWw1B,EAASh1B,UAAY,OAASpf,GAClFo0C,EAAS/M,aACTkD,EAAYrK,WAAalgC,EACzBo0C,EAASrQ,UAAW,EACpBqQ,EAASh1B,YACTg1B,EAASjQ,YAAc,EACvBiQ,EAAShU,WAAY,EACjB8W,EAAc,CACd,IAAKA,EAAajjB,OAAO6jB,eACrB,MAAM,IAAI3rC,MAAM,WAAW+qC,EAAaxuC,kCAE5C0rC,EAASrQ,SAAWmT,EAAajjB,OAAO6b,qBACxCsE,EAASpQ,UAAW,EACpBkT,EAAe14B,EAAWu5B,cAAcb,EAAc9C,EAE1D,KAAO,CACH,IAAI4D,EAAab,IAAe/I,EAAYgG,EAASp0C,KAAK09B,YAAc0W,EAASp0C,KAC7Eo0C,EAAS7O,gBACTyS,EAAY5D,EAAS7O,cAAgByS,EACrC5D,EAAS7O,cAAgB,MAG7B,IAAI0S,EAAiB7D,EAASp0C,KAAKjB,OAASi5C,EAAUj5C,OAEtDq1C,EAAStQ,YAAcmU,EAEvB1N,EAAYrK,WAAa8X,EACzBb,GAAa,CACjB,CACA,GAAIn3C,EAAKjB,QAAU,EACf,OAEJ,IAAIm5C,EAAK9D,EAASr1C,OACd0oC,EAAM2M,EAAS3M,IACnBjpB,EAAW25B,gBAAgB/D,EAAkB,GAAP3M,IAAc2M,EAAS1P,cAC7D0P,EAASjJ,YACT,IAAIiN,EAAY3Q,EAChB,KAAOA,EAAMyQ,GAAI,CAKb,GAJA9D,EAASrQ,UAAW,EACpB0T,GAAmB,EACnBrD,EAASjQ,YAAc,EACvBiU,EAAY3Q,EACRyP,EACA9C,EAASrQ,UAAW,EACpBqQ,EAAS9M,WAAW8M,EAAS3M,KAC7ByP,EAAe14B,EAAWu5B,cAAcb,EAAc9C,QAGtD,GADA8C,EAAen0B,EAAMs1B,kBAAkBj8C,KAAKunB,SAAUywB,GAClD8C,EACA96C,KAAK+7C,gBAAgB/D,EAAUA,EAAShU,WACxCgU,EAAS9M,WAAWG,EAAKyP,EAAa93C,OACtC83C,EAAe14B,EAAWu5B,cAAcb,EAAc9C,GACtDoD,GAAwB,EAAOpD,OAC5B,CACHA,EAASjQ,YAAc,EACvB,IAAIvkB,EAAIw0B,EAASp0C,KAAK4oB,UAAUwrB,EAAS3M,KACpCkQ,IACD/3B,EAAIA,EAAE4d,WACN4W,EAAS1P,eACT9kB,EAAIu3B,IAAe/I,EAAYxuB,EAAE8d,YAAc9d,GAE/CA,EAAE7gB,OAAS,IACX3C,KAAK+7C,gBAAgB/D,EAAUA,EAAShU,WACxCgU,EAAS5X,eAAe5c,EAAGw0B,EAAStH,oBAExCsH,EAAS3M,IAAMyQ,CACnB,CAqBJ,GAnBAzQ,EAAM2M,EAAS3M,IACfyQ,EAAK9D,EAASr1C,OACd,CAAEqoB,IACE,MAAM,SAAEgd,GAAahd,EACrB,GAAIgxB,GAAa3Q,EAAK,CAMlB,GAJIrD,EAASgH,SAAW8L,IACpB9S,EAASgH,QAAU8L,GAEvB9S,EAASviB,SAAW4lB,EAChBrD,EAASvzB,MAAQ,EAClB,MAAM,IAAI1E,MAAM,0BAA4B+E,KAAKC,UAAUizB,IAG9DA,EAASvzB,OACb,MACIuzB,EAASvzB,MAAQ,CAExB,EAhBD,CAgBGujC,GACCh4C,KAAKy7C,OACL,OAEJL,EAAwBC,EAAkBrD,EAC9C,CACAoD,EAAwBC,EAAkBrD,GAE1CA,EAASpQ,UAAW,EAChBkT,IACIgB,GAAMzQ,GAGF2M,EAAS5P,KAAM,EACX0S,EAAaoB,mBAAmBlE,IAChCA,EAAS7J,YAAY/J,YAAYiH,EAAKA,GAE1CyP,EAAe14B,EAAW+5B,wBAAwBrB,EAAc9C,GAChEA,EAAS5P,KAAM,GAMnBpoC,KAAKo8C,wBAAwBtB,EAAc9C,IAGnDxE,EAAW6I,wBAAwBvB,EAAc9vB,EAAO,IAExDhrB,KAAKy7C,OAEL,OADAz7C,KAAKy7C,QAAS,EACP,KAgCX,GA9BA,CAAEzwB,IAEE,GAAI8vB,EACA,GAAK96C,KAAKgqC,KAAKtP,iBAeX,GAAIogB,EAAahzB,OACb,MAAM,IAAI/X,MAAM,gCAhBQ,CAM5B,IALAiV,GAAS2X,EAAMna,IAAI,YAAcs4B,EAAa5pC,YAC9C8Z,EAAOmd,KAAM,EACbnd,EAAOmjB,YAAY7pC,QAGZw2C,GAIHA,EAAe14B,EAAWu5B,cAAcb,EAAc9C,GACtDhtB,EAAOmjB,YAAY7pC,QAEvB0mB,EAAOmd,KAAM,CACjB,CAKP,EAtBD,CAsBG6P,GAEHhzB,GAAOwd,QAAQ,SACX7F,EAAMna,IAAI,aACVD,QAAQC,IAAI,CACRmjB,MAAOqS,EAASrS,SAGnBqS,EAASzK,WAAW5qC,OAAS,GAAoC,GAA7B3C,KAAKgqC,KAAKtP,gBAAuB,CACtE,MAAM4hB,EAAct8C,KAAKwzC,WAEzB,KAAOwE,EAASzK,WAAW5qC,OAAS,GAAG,CACnC,IAAI6sC,EAAOwI,EAAStM,cACpB1rC,KAAKu8C,yBAAyB/M,EAAMwI,EAAUsE,EAClD,CAEJ,MACItE,EAASzK,WAAW5qC,OAAS,EAEjCq1C,EAAS/nB,QACT,IAAI3E,EAAU,GAEd,IAAKtrB,KAAKgqC,MAAMtP,iBAAoBsd,EAAS7qB,UAAUxqB,OAAS,EAC5D,MAAM,IAAIoN,MAAM,0BAEpB,IAAK/P,KAAKgqC,MAAMtP,iBAAmB16B,KAAKkZ,SAAU,CAE9C,MAAM,SAAEA,GAAalZ,KAAKg4C,UACpB,WAAElS,EAAU,UAAEF,EAAS,YAAE4W,GAAgBtjC,EAC3CsjC,EACAlxB,EAAUpS,EAASsjC,YAAY,CAAE1wB,OAAQksB,EAASlsB,OAAQ+Z,WAAUH,UAAS1a,OAAQhrB,KAAKg4C,YAE1F1sB,EAAU0sB,EAASlsB,OAAOltB,KAAKinC,GAAUzE,UACzC9V,EAAU0vB,EAAe1vB,EAAS0sB,IAGlCpS,IACAta,GAAWpS,EAAS0sB,UAAU,CAAEC,cAEhCC,IACAxa,GAAWpS,EAAS4sB,aAE5B,MACIxa,EAAU0sB,EAASlsB,OAAOltB,KAAKinC,GAC1B7lC,KAAKgqC,MAAMtP,kBACZpP,EAAUA,EAAQ8V,UAClB9V,EAAU0vB,EAAe1vB,EAAS0sB,IAK1C,OADAh4C,KAAKg4C,SAASvS,gBAAgBtE,WACvB7V,CAAO,EAElB,IAAIA,EAAU,KACd,IACIA,EAAU6vB,IACwB,GAA7Bn7C,KAAKgqC,KAAKtP,iBAAuD,mBAArB1P,GAAQzkB,UACrDykB,EAAOzkB,SAAS,CAAEglB,UAAWvrB,MAErC,CAAE,MAAOoN,GACDpN,KAAK0S,OACA7T,MAAMuQ,QAAQpP,KAAK0S,SACpB1S,KAAK0S,MAAQ,CAAC1S,KAAK0S,QAEvB1S,KAAK0S,MAAM5Q,KAAKsL,EAAE4C,UAGlBhQ,KAAK0S,MAAQtF,EAAE4C,QAEnBgV,GAASzC,QAAQ7P,MAAM,WAAatF,EAAE4C,QAC1C,CAEA,OADAgnC,EAAaiD,UACN3uB,CACX,CACA,eAAAywB,CAAgB/wB,EAAQgZ,GAAY,GAC5BhZ,EAAO4d,oBACP5d,EAAO4d,qBAAsB,GAGjC5d,EAAOgZ,UAAYA,EACfhZ,EAAOsd,eACFtd,EAAOya,gBAAgBxG,UACxBjU,EAAOiF,QACPjF,EAAOsd,cAAe,GAE1Btd,EAAOgZ,WAAY,GAE3B,CAMA,uBAAAmY,CAAwBjP,EAAaliB,GACjC,MAAM,MAAEhG,GAAUgG,EAClBhG,GAAS2X,EAAMna,IAAI,+BAAiC0qB,EAAYh8B,YAChE,IAAI+oB,EAAK,KACL+a,EAAW,KACXd,EAAQlpB,EAAOpnB,KAAK4oB,UAAUxB,EAAOqgB,KAIzC,QADGpR,KAAI+a,YAAah1C,KAAKi1C,kBAAkBf,EAAOhH,EAAaliB,IAC3DiP,GAAmB,MAAZ+a,GAGP/a,GAAM+a,GACFA,EAAS5R,MAAMpgC,OAASi3B,EAAGj3B,MAHxBhD,KAAK27C,cAAczO,EAAaliB,GAWvCgqB,EAEIA,EAASyH,gBAEEz8C,KAAK08C,uBAAuB1H,EAAU,GAAI,KAAMhqB,EAAQ,KAAM,KAAM,IAAI,GAGhFhrB,KAAK27C,cAAc3G,EAAUhqB,GAEjCkiB,CACX,CACA,qBAAAyP,CAAsB3H,EAAUhqB,GAG5B,OAFAhrB,KAAK48C,2BAA2B5H,EAAUhqB,GAC/BhrB,KAAK27C,cAAc3G,EAAUhqB,EAE5C,CAOA,uBAAAoxB,CAAwBvV,EAAS7b,EAAQ5L,GAAQ,GAE7C,MAAM,WAAEo0B,GAAexzC,KACnB6mC,EAAQgW,eACRrJ,EAAWsJ,mBAAmB98C,KAAM6mC,EAAS7b,EAAQ5L,GAErDpf,KAAK+8C,gBAAgB/xB,EAAQ6b,EAASznB,EAE9C,CACA,wBAAA49B,CAAyBvc,EAASoG,EAAS7b,GACvCA,EAAOya,gBAAgB3vB,QACvBkV,EAAOoV,eAAeK,EAASoG,GAC/B7b,EAAOiF,QACPwQ,EAAUzV,EAAOqT,OAAM,GACvBrT,EAAOya,gBAAgBrF,eAAeK,EAASoG,EACnD,CAQA,wBAAAoW,CAAyBplB,EAAQ7M,EAAQwkB,GAGrC,MAAM,gBAAE0N,EAAe,MAAE9Z,EAAK,iBAAEwQ,GAAqB/b,EACrD,IAAIoC,EAAK,GACLqK,EAAQ,GACZ,IAAKsP,EAAkB,CACnB,GAAwBpoC,MAAnB0xC,GAAsD,OAApBA,EAEnC,GAAIA,aAA2Bja,EAA+B,CAC1D,MAAM9X,EAAS2X,EAA0BC,IAAI/iC,KAAKgjC,WAElD,IAAIma,EAAUD,EAAgB/Z,KAAKC,GAC9B5a,GAAM7B,EAAMy2B,kBAAkBz2B,EAAM02B,cAAc70B,GAAI4a,IACvDjY,EAAQqkB,GAAM7nC,KAAMkwB,EAAQ7M,GAChC,GAAIwkB,EAIA,OAFAA,EAAK8N,QAAUH,EACfljB,EAAKtT,EAAMkX,eAAe,IACnB5D,CAEf,MACIqK,EAAQ3d,EAAMy2B,kBAAkBF,EAAiB9Z,QAGjDoM,GAAuC,QAA9BA,EAAK3X,OAAOj3B,IAAIsQ,aACzBozB,EAAQ3d,EAAMy2B,kBAAkBz2B,EAAM02B,cAAcxlB,EAAOj3B,KAAMwiC,IAGzEkB,EAAQA,EAAQA,EAAMljC,QAAQ,MAAO,IAAM,EAC/C,CAKA,OAJA64B,EAAGn4B,KAAKwiC,GACRrK,EAAGnQ,QAAU,CAAC,CAAC,EAAGwa,EAAM3hC,SACxBs3B,EAAGj3B,MAAQ,EACXi3B,EAAGtM,MAAQ,KACJsM,CACX,CACA,wBAAAsiB,CAAyB/M,EAAMxkB,EAAQsxB,GAEnC,MAAM,OAAEzkB,GAAW2X,EACbmH,EAAS9e,EAAOuL,MACtB,GAAIvL,EAAOA,OAAO8b,sBACd,MAAM,IAAI5jC,MAAM,kBAEpB,GAAI8nB,EAAO+b,iBACP,OAEJ,IAAItP,EAAQ,GAER2R,EADSjrB,EAAOpnB,KACD4oB,UAAUmqB,EAAO3zC,OAEF,QAA9BwsC,EAAK3X,OAAOj3B,IAAIsQ,aAChBozB,EAAQ3d,EAAMy2B,kBAAkBz2B,EAAM02B,cAAcxlB,EAAOj3B,KAAM+1C,EAAQ,QAC7ErS,EAAQA,EAAMljC,QAAQ,MAAO,IAC7Bk7C,EAAYiB,yBAAyB,CAAEvyB,SAAQwkB,SAC/C,IAAIvV,EAAK,GACL1H,EAAI,KAIR,GAHA0H,EAAGn4B,KAAKwiC,GACRrK,EAAGnQ,QAAU,CAAC,CAAC,EAAGwa,EAAM3hC,SACxBs3B,EAAGj3B,MAAQ,EACP60B,EAAOmP,QAAS,CAChBhc,EAAOpnB,KAAO0gC,EACdtZ,EAAOqgB,IAAM,EACb,IAAI5K,EAAUzV,EAAO4P,OASrB,OARArI,EAAI+pB,EAAYkB,oBAAoB,CAChC9nC,KAAMmiB,EAAOniB,KACbklB,OAAQ6F,EACRzV,OAAQA,EACRO,UAAWvrB,OAGfuyB,EAAS,MAALA,EAAYid,EAAK8N,QAAUtyB,EAAOqT,OAAM,GAAQ9L,EAC7CvyB,KAAKy9C,uBAAuBlrB,EAAG+R,EAAOzM,EAAQoC,EAAIjP,EAAQwkB,EACrE,CAEA,MAAMkO,EAAMzH,EAAQtzC,OAKpB,OAJAs3B,EAAGj3B,MAAQ06C,EACXzH,GAAW3R,EACXtZ,EAAOqgB,IAAMqS,EACb1yB,EAAOkgB,WAAWwS,GACX19C,KAAKy9C,uBAAuB,GAAIxH,EAASpe,EAAQoC,EAAIjP,EAAQwkB,EACxE,CAEA,gBAAAmO,CAAiB9W,EAAS7b,GACtB,OAAO6b,EAAQG,UAAYhc,EAAO2c,QACtC,CAMA,WAAAiW,CAAY5yB,GACRA,EAAO2a,QACP,MAAM,OAAE7Z,EAAM,QAAE4Z,EAAO,MAAEC,EAAK,gBAAEF,EAAe,SAAEvsB,GAAa8R,EACtB,mBAA5B9R,GAAUssB,eAClBtsB,EAASssB,cAAc,CAAE5K,OAAQ,GAAI6K,kBAAiB3Z,SAAQ4Z,UAASC,UAK3E3a,EAAO+a,YAAa,CACxB,CAKA,SAAAwF,GACI,MAAO,CAACvrC,KAAKgjC,UACjB,CAOA,iBAAA6a,CAAkBxT,EAAazpC,GAAM,GAEjC,GAAIypC,aAAuBxjB,EACvB,OAAOwjB,EAAYziB,SAEvB,MAAM,OAAEiQ,GAAWwS,EACnB,IAAKxS,EACD,OAAO,KAGX,GAAa,GADCA,EAAOwb,UACL,CACZ,MAAM7qB,EAAI5nB,EAAMi3B,EAAO4F,YAAc5F,EAAOimB,cAC5C,MAAO,IAAKjmB,EAAOjQ,YAAaY,EACpC,CACA,MAAO,IAAKqP,EAAOjQ,SACvB,CAOA,kBAAAm2B,CAAmBlmB,EAAQ7M,GACvB,MAAM,KAAE1e,EAAI,cAAEwgC,EAAa,UAAEuG,GAAcxb,GACrC,UAAE1K,GAAcnC,EAElB1e,GAAsB,GAAb+mC,IAAqBvG,IAC9BnmB,EAAMoG,YAAYzgB,EAAM6gB,GACxB0K,EAAOiV,eAAgB,EAE/B,CACA,8BAAAkR,CAA+BnX,EAAS7b,GACpChrB,KAAKi+C,2BAA2BpX,EAAS7b,GACzCA,EAAOkgB,WAAWlgB,EAAOqgB,IAC7B,CAMA,aAAAsQ,CAAc9U,EAAS7b,GACnB,IAAK6b,EAAS,OACT7b,EAAO2c,UACR3nC,KAAKg+C,+BAA+BnX,EAAS7b,GAGjD,MAAM,UAAEqoB,GAAcxM,EAAQhP,OAC9B73B,KAAK+9C,mBAAmBlX,EAAS7b,GACjCA,EAAO+c,cAEP,MAAM7P,EAASl4B,KAAKk+C,gBAAgB7K,EAAWroB,IAC3C,EAAEpC,EAAGoC,IAAWpC,EAAE2rB,qBAAuB3rB,EAAE2rB,qBAAqBvpB,GAAU,KAA1E,CAAgF6b,EAAQhP,OAAQ7M,GACpG,IAAKkN,GAA8B,mBAAZ,EACnB,MAAM,IAAInoB,MAAM,+CAAiDsjC,GAErE,IAAIc,EAAMjc,EAAOp1B,MAAM9C,KAAM,CAAC6mC,EAAS7b,IAEvC,OADAhrB,KAAKm+C,wBAAwBtX,EAASsN,EAAKnpB,GACpCmpB,CACX,CAWA,qBAAAiK,CAAsBvX,EAASp6B,EAAO22B,EAAOpY,EAAQgI,EAAS9H,GAAQ,GAClE,IAAI9I,EAAapiB,KACjB,MAAM,YAAE0nB,EAAW,qBAAEiB,GAAyBke,EAC9C,IAAIp/B,EAAI27B,EAER,GADApQ,EAAUA,GAAW,CAAC,GACjBtL,EAED,OADAsL,EAAQqrB,UAAW,EACZ5xC,EAEX,IAAI0pB,EAAOzO,EAKX,GAHIyO,aAAgBtN,IAChBsN,EAAO,CAACA,KAERt3B,MAAMuQ,QAAQ+mB,GAuBb,CACD,IAAImoB,EAAO33B,EAAM02B,cAAc31B,GAC/B,MAAM62B,EAAQ51B,EACd,IAAIvhB,EAAQm3C,GAAOn3C,MACnB,MAAMo2B,EAAY+gB,GAAO32B,SAEzB,GAAIxgB,EAAO,CACP,IAAIulB,EAAM4xB,EAAMC,UAAY,IACxB5qB,EAAKjN,EAAMy2B,kBAAkBmB,EAAMla,MAAO58B,GAC9C,GAAI,QAAQqJ,KAAK6b,GAAM,CACnB,IAAIplB,EAAIH,EAAM0J,KAAK8iB,GACnB,GAAIjH,IACa,KAAPA,IAAgBplB,GAAe,MAAPolB,GAAgB,GAE1C,OADAqG,EAAQqrB,UAAW,EACZ5xC,CAGnB,MAAO,GAAI,UAAUqE,KAAK6b,GAAM,CAC5B,IAAI8xB,EAAMr3C,EAAM8J,WAAW9P,QAAQ,QAAS,IAC5C,IACa,MAAPurB,GAAiBiH,GAAM6qB,GAChB,MAAP9xB,GAAiBiH,GAAM6qB,IAErB7qB,GAAM6qB,EAEN,OADAzrB,EAAQqrB,UAAW,EACZ5xC,CAGnB,CACJ,CAGA,OADQka,EAAM+3B,cAAcjyC,EAAO2V,EAAYk8B,EAAM72C,EAAGo/B,EAAS7b,EAAQwS,EAAWtS,EAExF,CApDI,IAHAiL,EAAOA,EAAK/xB,MAAM,GAGX+xB,EAAKxzB,OAAS,GAAG,CACpB,MAAMylB,EAAI+N,EAAK1f,SACT,WAAEysB,EAAU,MAAE97B,EAAK,SAAEwgB,GAAaQ,EACxC,GAAK8a,GAID97B,EAAO,CACP,MAAM6yB,EAAK,CAAEokB,UAAU,EAAM52C,IAAG62C,KAAM,MAChCK,EAASh4B,EAAMi4B,iBAAiB1b,EAAYz2B,EAAO2b,EAAG6R,GAC5D,GAAIA,EAAGokB,SAAU,CACb,MAAM,KAAEC,GAASrkB,EAGjB,OAFQtT,EAAM+3B,cAAcC,EAAQv8B,EAAYk8B,EAAM72C,EAAGo/B,EAAS7b,EAAQpD,EAAUsD,EAGxF,CACJ,CACJ,CAqCJ,OADA8H,EAAQqrB,UAAW,EACZ5xC,CACX,CAMA,eAAAyxC,CAAgBjlC,EAAM+R,GAElB,MAAO,CACH,EAAKA,EAAO9R,UAAU2lC,sBAAwB7+C,KAAK8+C,sBACnD,EAAK9zB,EAAO9R,UAAU6lC,mBAAqB/+C,KAAKg/C,mBAChD,EAAKh0B,EAAO9R,UAAU+lC,kBAAoBj/C,KAAKk/C,kBAC/C,EAAKl0B,EAAO9R,UAAUimC,sBAAwBn/C,KAAKo/C,uBACrDnmC,EACN,CACA,qBAAAmmC,CAAsBvnB,EAAQ7M,GAC1B,MAAM,OAAElD,GAAW+P,EACnB,IAAI4U,EAAY5U,EAAOuL,MAAM,GACzB/D,EAAK,GAaT,OAZAr/B,KAAK+9C,mBAAmBlmB,EAAQ7M,GAChCyhB,EAAYzsC,KAAKgtB,iBAAiB6K,EAAQ4U,EAAWpN,EAAIrU,EAAQ6M,EAAOuL,OAAO,GAC3EqJ,EAAU9pC,OAAS,IACf08B,EAAG13B,KACHqjB,EAAOya,gBAAgBrF,eAAe,CAClCb,aAAcF,EAAG13B,KAAKkmB,YACtBqR,eAAgBG,EAAG13B,KAAKimB,gBAG5B5C,EAAOoV,eAAef,EAAG13B,KAAMkwB,IAEvC7M,EAAO9B,eAAiB2O,EACjB/P,CAEX,CACA,cAAAu3B,CAAe9R,EAAYviB,GAAQ,KAAE/R,IACjC,MAAM,SAAEC,GAAalZ,KACjBkZ,GAAU0e,gBACV1e,EAAS0e,eAAe2V,EAAYviB,EAAQ,CAAE/R,OACjDsS,UAAWvrB,KACX06B,gBAAiB16B,KAAKgqC,KAAKtP,gBAAkB,GAElD,CAMA,aAAA2Z,CAAc9G,EAAYviB,GACtB,MAAM,UAAEmC,GAAcnC,GAChB,SAAE9R,GAAalZ,KAEjBkZ,GAAUuhB,cACVvhB,EAASuhB,aAAa8S,EAAYviB,EAAO,CAC7C0P,gBAAiB16B,KAAKgqC,KAAKtP,gBAAkB,KAC1C1Y,EAAW+1B,qBAAqBxK,EAAYviB,IAC5ChrB,MAECutC,EAAW+R,sBACXt/C,KAAKu/C,yBAAyBhS,EAAYviB,GAEzCuiB,EAAwB,eAAMpgB,EAAUxqB,OAAS,IAClDgkB,EAAM64B,cAAcjS,EAAWjhC,KAAM6gB,GACrCogB,EAAWT,eAAgB,GAG3B9hB,EAAO0hB,aACPnqB,QAAQC,IAAI,aAEpB,CAYA,gBAAAi9B,CAAiBhT,EAAW5F,EAAS7b,EAAQ2B,EAAKyW,EAAOlY,GAAQ,GAC7DkY,EAAQA,GAASyD,EAAQzD,MACzB,MAAMsc,GAAex0B,GAAQ,CAAC,EAE9B,GADAuhB,EAAYzsC,KAAKgtB,iBAAiB6Z,EAAS4F,EAAW9f,EAAK3B,EAAQhrB,KAAK2/C,eAAevc,GAAQsc,GAC3Fx0B,EAAO,CACP,GAAIyB,EAAIizB,QAGJ,OAFAjzB,EAAIhlB,KAAO+3C,EAAatO,SAASvjB,YAAYjvB,KAAK,IAClD+tB,EAAIykB,SAAWsO,EAAatO,SACrB3E,EAEX,MAAMzB,EAAOyB,EACbA,EAAYzsC,KAAK6/C,kBAAkBpT,EAAW9f,EAAKka,EAAS7b,IAExB,GAA/B2B,EAAIte,QAAQ,gBAA0Bo+B,GAAazB,IACpDre,EAAIhlB,KAAOqjC,EAEnB,CACA,OAAOyB,CACX,CAQA,eAAAqT,CAAgBrT,EAAW5F,EAASrJ,GAChC,MAAMuiB,EAAUlZ,EAAQmZ,gBAAkBnZ,EAAQz/B,MAElD,GADAo2B,EAAYqJ,EAAQoZ,mBAAqBziB,EACpCiP,EAAU9pC,OAAS,GAAM,EAAa,CAGvC,MAAMg0C,EAASoJ,EAAUA,EAAQp2C,KAAK8iC,GAAa,KACnD,GAAIkK,EAEAA,EAAO3zC,MAAQ6jC,EAAQzD,MAAMpgC,MAC7B6jC,EAAQzD,MAAMzgC,OAAS,EACvBkkC,EAAQzD,MAAMtZ,QAAU6sB,EAAO7sB,QAC/B6sB,EAAOx4C,SAAQolB,GAAKsjB,EAAQzD,MAAMthC,KAAKyhB,UAEvC,GAAyB,GAArBsjB,EAAQwM,UACR,MAAM,IAAItjC,MAAM,sEAE5B,CACA,MAAO,CAAEytB,YACb,CACA,iBAAAqiB,CAAkBpT,EAAW9f,EAAKka,EAAS7b,GACvC,IAAIwS,EAAYqJ,EAAQjf,SAaxB,OAZiC,GAA7B+E,EAAIte,QAAQ,gBACTmvB,aAAcx9B,KAAK8/C,gBAAgBrT,EAAW5F,EAASrJ,KAE3B,GAA/B7Q,EAAIte,QAAQ,gBACRmvB,IACAiP,EAAYzhB,EAAOiiB,mBAAmBpG,EAASrJ,IAGnDqJ,EAAQtf,UAAU5kB,OAAS,IAE3B8pC,EADkB9lB,EAAMyG,kBAAkBqf,EAAW5F,EAAQtf,SAAUsf,EAAQzD,MAAOpY,IAC7DyhB,GAEtBA,CACX,CAEA,cAAAkT,CAAevc,GAEX,OADmBpjC,KACAgqC,KAAKtP,gBAAkB,EADvB16B,KAEJgqC,KAAKoO,aAAehV,CACvC,CACA,qBAAA8c,CAAsBrZ,EAAS7b,EAAQwkB,GACnC,OAAOyH,EAAiBn0C,MAAM9C,KAAM,CAAC6mC,EAAS7b,EAAQwkB,GAC1D,CAIA,mBAAA2Q,CAAoBtZ,EAASjjC,EAAMonB,GAC/B,MAAMopB,EAAM,CAAExwC,KAAMonB,EAAOpnB,KAAMynC,IAAKrgB,EAAOqgB,KAC7C,IAAI/H,EAAO,KAWX,OATIuD,EAAQ4V,iBAERz8C,KAAKq1C,oCAAoCxO,EAAS,KAAM,GAAIA,EAAQkN,SAAU/oB,GAElFA,EAAOskB,cAAc1rC,GACrBonB,EAAOqd,OAAQ,EACf/E,EAAOtjC,KAAK27C,cAAc9U,EAAS7b,GACnCA,EAAOqd,OAAQ,EACfrd,EAAOskB,cAAc8E,EAAIxwC,KAAMwwC,EAAI/I,IAAMrgB,EAAOqgB,KACzC/H,CACX,CAWA,gBAAAtW,CAAiB6Z,EAAS15B,EAAGkyB,EAAIrU,EAAQoY,EAAOlY,GAAQ,GACpD,GAAI2b,EAAQnf,YAAa,CAErB,MAAMsL,EAAU,CAAEqrB,UAAU,GACtB+B,GAAmB,IAAVl1B,EAAiB,CAAC,EAAIA,EACrC/d,EAAInN,KAAKo+C,sBAAsBvX,EAAS15B,EAAGi2B,GAASyD,EAAQzD,MAAOpY,EAAQgI,EAASotB,GAChFptB,EAAQqrB,WACRhf,EAAGv9B,KAAK,eACRu9B,EAAG13B,KAAOy4C,EAAOhP,SAEzB,CAUA,OATIvK,EAAQrf,YAA4C,GAA9B6X,EAAGhxB,QAAQ,iBAEjClB,EAAIwZ,EAAMsG,qBAAqB9f,EAAG05B,EAAQrf,WAC1C6X,EAAGv9B,KAAK,cAERkpB,GAAWA,EAAgB,WAAK6b,EAAQwZ,qBACxClzC,EAAIwZ,EAAMsG,qBAAqB9f,EAAG05B,EAAQwZ,oBAC1ChhB,EAAGv9B,KAAK,uBAELqL,CACX,CACA,mBAAAmzC,CAAoBzoB,EAAQ7M,GACxB,MAAM7d,EAAI0qB,EAAOprB,MAAM8G,OACjB6vB,EAAQ,CAACj2B,GACTkyB,EAAK,GACX,GAAIxH,EAAOnQ,YAAY,CAEnB,IAAIngB,EAAIvH,KAAKgtB,iBAAiB6K,EAAQ1qB,EAAGkyB,EAAIrU,EAAQoY,GAAO,GAO5DpY,EAAOya,gBAAgB3vB,QACvBkV,EAAOya,gBAAgBrF,eAAe74B,EAE1C,CACJ,CASA,eAAAg5C,CAAgBrT,EAAazgC,EAAOue,EAAQw1B,GAAe,EAAMC,EAAuB,MACpF,IAAI,MAAEz7B,EAAK,SAAE9L,GAAa8R,GACtB,WAAEwoB,GAAexzC,KACrBglB,GAAOwd,QAAQ,oBAAsB7F,EAAMna,IAAI,0BAA4B/V,EAAQ,KACnF,IAAIi0C,EAAkC,GAAvBj0C,EAAMmoB,OAAOjyB,OAC5B,GAAIqoB,EAAO+a,YAAc2a,EACrB,OAGJ,IAAIC,EAAY31B,EAAO6lB,UAAUsJ,qBACjC1tC,EAAQ+mC,EAAWoN,mBAAmBn0C,EAAOygC,EAAaliB,GACtD01B,IAEAC,EAAY31B,EAAO6lB,UAAU6J,6BAEjC,IAAI5e,EAAO,IAAI2L,EACf3L,EAAK+kB,IAAI,CAAEhpB,OAAQ4oB,GAAwBE,EAAW/8C,KAAMonB,EAAOpnB,KAAMZ,OAAQ,EAAGwwC,eAEpF0D,EAAgChK,EAAaliB,GAC7C,MAAM81B,EAAY,KACdtN,EAAWuN,qBAAqBt0C,EAAOygC,EAAYx3B,KAAMomB,EAAM9Q,EAAO,EAEtEw1B,GACAtT,EAAYxiB,OAAO5oB,KAAKg6B,GAExB5iB,GAAU8nC,eACV9nC,EAAS8nC,eAAe,CAAEnrB,OAAQirB,EAAW5T,cAAavlC,KAAM8E,EAAOue,SAAQ8Q,SAE/EglB,IAKJ5T,EAAYx3B,KAAOomB,EAAKpmB,IAC5B,CAUA,sBAAAgnC,CAAuBxP,EAAagH,EAAOnN,EAAW/b,EAAQ+C,EAAQyhB,EAAM/O,EAASwgB,GAAW,GAC5F,MAAM,MAAEj8B,GAAUgG,GACZ,MAAEoY,GAAU8J,GACZ,WAAEsG,GAAexzC,KACvB,IAAIkhD,EAAcl2B,EAAOpnB,KAAKjB,OAI9B,GAFAqiB,GAAOwd,QAAQ,iBAAmB7F,EAAMna,IAAI,+BAAiC0qB,EAAYh8B,YAEvD,GAA9Bg8B,EAAY2P,eAKZ,OAHA7xB,EAAOqgB,IAAM6B,EAAYlqC,MACNhD,KAAKmhD,6BAA6BjU,EAAa,GAAInG,EAAW/b,GAKrF,IAAIo2B,EAAap2B,EAAOgZ,UACpBqd,EAAenU,EAAYlG,UAAYkG,EAAYoU,iBAAmBpU,EAAYqU,eAKtF,GAJIF,GACArhD,KAAK48C,2BAA2B1P,EAAaliB,GAAQ,GAGrDwkB,EAAM,CACN,MAAMgS,EAAahS,EAAK3X,QACnB2pB,GAActU,GAAiBliB,EAAOqgB,IAAMjI,EAAMpgC,SACnDgoB,EAAOkgB,WAAWlgB,EAAOqgB,IAAKjI,EAAMpgC,OACpChD,KAAKyhD,+BAA+BD,EAAYx2B,EAAQwkB,IAE5DxkB,EAAOuiB,WAAWrhB,QAAQsjB,EAC9B,MACIA,EAAOxvC,KAAKq1C,oCAAoCnI,EAAa,KAAMzM,EAASsG,EAAW/b,GAM3F,GAJIq2B,GACA7N,EAAWkO,uBAAuBlS,GAEtCxkB,EAAOgZ,UAAYod,EACfH,GACK/M,EAAMtf,OAAOjyB,OAAS,GAAO6sC,EAAU,QACxCxkB,EAAOoV,eAAe8T,EAAOhH,GAEjCliB,EAAOqgB,IAAM6V,MACV,CACH,IAAIjnB,EAAI+a,EAER,KADG/a,KAAI+a,YAAah1C,KAAKi1C,kBAAkBf,EAAOhH,EAAaliB,IAC3DiP,IAAO+a,EAAU,CAEjB,IAAI2M,EAASh7B,EAAM0vB,eAAenC,EAAOhH,EAAY6G,SAAU/oB,GAC3DyV,EAAUzgC,KAAK4hD,wBAAwBpS,EAAMxkB,GACjDA,EAAOya,gBAAgBrF,eAAeK,GACtC,IAAIohB,EAAU72B,EAAOqgB,IAAMsW,EAAO3+C,MAAQ2+C,EAAOr1B,OACjDtB,EAAOkgB,WAAWlgB,EAAOqgB,IAAKwW,GAC9B,IAAIC,EAAQ92B,EAAO2kB,oBAAoBzC,GAAa,GASpD,OARAliB,EAAOojB,cAAc0T,GACjB92B,EAAOqgB,KAAOwW,EACd7hD,KAAKg+C,+BAA+B9Q,EAAaliB,GAEjDA,EAAOqgB,IAAMwW,EAAUF,EAAOr1B,OAElCtsB,KAAKq0C,cAAcnH,EAAaliB,GAChCA,EAAO6d,gBAAiB,EACjBqE,EAAYplB,MACvB,CAGI,GAAIktB,EAAU,CACV,IAAI+M,EAAiB/2B,EAAOpnB,KAAK4oB,UAAUxB,EAAOqgB,IAAK2J,EAAS5R,MAAMpgC,OAQtE,OANI++C,EAAep/C,OAAS,GACxB3C,KAAKugD,gBAAgBrT,EAAa6U,EAAgB/2B,GAEtDA,EAAOkgB,WAAWlgB,EAAOqgB,KACzBrrC,KAAK+9C,mBAAmB7Q,EAAaliB,GAC1BhrB,KAAK27C,cAAc3G,EAAUhqB,EAE5C,CAIR,CACA,OAAOkiB,CACX,CAIA,mCAAA8U,CAAoCnb,EAAS7b,EAAQqY,GACjD,MAAMoJ,EAAYpJ,EAAG52B,MACrB,GAAIo6B,EAAQob,uBAAwB,CAChC,IAAIv6C,EAAI1H,KAAKyuC,SAASgE,uBAAuBhG,EAAU7X,QACvDyO,EAAG4e,uBAAyBv6C,CAChC,CACJ,CACA,6BAAAw6C,CAA8Brb,EAAS7b,EAAQqY,GAAI,KAAEmM,EAAI,MAAEpM,EAAK,MAAEh8B,IAC9D,IAAIqlC,EAAYrJ,EAAM,GACtB,MAAM,OAAEtb,GAAW+e,EACbyV,EAAct8C,KAAKwzC,WACzB,IAAI9rC,EAAI27B,EAAG4e,uBAIX,GAHYzS,IAA8B,GAApB/C,EAAU9pC,QAA4C,GAA3B8pC,EAAU7X,OAAOjyB,SACzD25C,EAAY6F,gBAAgB3S,EAAK3X,OAAOniB,KAAMsV,KACnD6b,EAAQub,mBACD,CAQP,GAPA/e,EAAGnL,QAAS,EAEZuU,EADiB9lB,EAAM0vB,eAAejT,EAAMzV,MAAOvmB,EAAO4jB,GACnC,GACnB6b,EAAQob,yBACRv6C,EAAI1H,KAAKyuC,SAASgE,uBAAuBhG,EAAU7X,SAGnD9M,GAA2B,GAAhBsb,EAAM9W,OAAc,CAM/B,GAJIkjB,GAAQ9nC,GACR40C,EAAY+F,iBAAiBxb,EAAS7b,GAGtClD,EAAOw6B,UAAUt/C,OAASogC,EAAMpgC,MAAO,CACvC,IAAIq5B,EAAKr8B,KAAKmgD,oBAAoBr4B,EAAQ2kB,EAAU7X,OAAQ5J,GAQ5D,OAPItjB,IAAMsjB,EAAOya,gBAAgBxG,UAC7BjU,EAAOiF,QACH4W,EAAQG,UAER3K,EAAKr8B,KAAKuiD,iBAAiBv3B,EAAQ6b,EAASxK,EAAIwK,EAAQ2b,mBAGzDnmB,CACX,CACA,GAAIwK,EAAQ4b,YACR,OAAOziD,KAAK0iD,aAAa7b,EAAS/e,EAAQkD,EAAQ6b,EAAQ2b,gBAElE,CACA,OAAO16B,CACX,CACJ,CACA,kBAAA66B,CAAmBl2C,EAAOue,GACtBA,EAAOoV,eAAe3zB,EAAO,IAAIm2C,EACrC,CASA,cAAAC,CAAejoB,EAAQjzB,EAAMkwB,EAAQ7M,EAAQkhB,GAAQ,GACjD,MAAM1jB,EAAI,CAAEoS,SAAQjzB,SACd,MAAEqd,EAAK,gBAAEygB,GAAoBza,EACnCrE,EAAMm8B,oBAAoBt6B,EAAGqP,GAC7B7S,GAAOwd,QAAQ,yBACX7F,EAAMna,IAAI,6BACVD,QAAQC,IAAIgG,IAEhBid,EAAgBrF,eAAe5X,GAC3B0jB,GACAlsC,KAAKusC,iBAAiB1U,EAAQrP,EAAGwC,EAEzC,CACA,uBAAA+3B,CAAwBlc,EAAS7b,EAAQqY,EAAI2f,GACzC,MAAM,IAAEr2B,EAAG,KAAE6iB,EAAI,YAAEyT,GAAgBD,EACnC,IAAIvW,EAAYpJ,EAAG52B,MACfi0B,EAAQ2C,EAAG17B,KACf,MAAMygB,EAAIpoB,KAEJs8C,EAAct8C,KAAKwzC,WACnB9rC,EAAI27B,EAAG4e,yBAA0B,EACjCiB,EAAWl4B,EAAOub,UAAYvb,EAAOgZ,UACrCmf,EAAmB,CAAC1W,EAAW/L,EAAO1V,KAC3Bxf,MAATk1B,EACAtY,EAAEy6B,eAAepW,EAAW/L,EAAOmG,EAAS7b,GAAQ,GAEpDA,EAAOoV,eAAeqM,EAAW5F,EACrC,EAGJ,GAAIn/B,IAAOm/B,EAAQhB,UAAc7a,EAAO4P,OAAOj4B,OAAS,GAAO8pC,EAAU9pC,OAAS,EAAI,CAElF,IAAmC,GAA/BgqB,EAAIte,QAAQ,eACR60C,GAEAljD,KAAK2iD,mBAAmB33B,EAAOub,SAAUvb,GAG7Cm4B,EAAiB1W,EAAW/L,EAAO1V,OAEhC,CACH,GAAKA,EAAO0d,WAAa+D,EAErB,OADAzsC,KAAKq0C,cAAcxN,EAAS7b,GACrB6b,EAAQ/e,SAGdkD,EAAO2d,qBAAwB8D,EAAU7X,OAAOjyB,OAAS,KACtDugD,GAEAl4B,EAAOya,gBAAgBrF,eAAepV,EAAOub,UAEjD4c,EAAiB1W,EAAW/L,EAAO1V,GAC/BA,EAAO2d,sBACP3d,EAAO2d,qBAAsB,GAGzC,CACI6G,GAAQ9nC,GACR40C,EAAY+F,iBAAiBxb,EAAS7b,GAE1CA,EAAOwhB,QAAQ3F,EAAS4F,GACxBzsC,KAAKojD,gBAAgBvc,EAAS7b,GAC9BqY,EAAGggB,YAAa,EAChBrjD,KAAK+8C,gBAAgB/xB,EAAQ6b,EACjC,CACJ,CACA,eAAAuc,CAAgBvc,EAAS7b,GACjB6b,EAAQN,SACRvb,EAAOub,SAAWM,EAAQN,SAE1Bvb,EAAOub,SAAW,IAE1B,CAQA,mBAAA+c,CAAoBzc,EAAS0c,EAAeC,EAASx4B,GACjD,KAAOu4B,EAAc5gD,OAAS,GAAG,CAC7B,IAAIs1B,EAAUsrB,EAAc9sC,QACxBuN,EAAM,KACNy/B,EAAU,KACVC,EAAW,KACXC,EAAc,KAOlB,GALI9kD,MAAMuQ,QAAQ6oB,KACdjU,EAAMiU,EAAQ,GACdwrB,EAAUxrB,EAAQ,GAClB0rB,EAAe,KAAK1rB,EAAWA,EAAQ,GAAK,MAE5CjU,IACA0/B,EAAW1/B,EAAIlhB,MAAM2gD,EAAS,CAAC5c,EAAS7b,EAAQw4B,EAASG,IACrDH,EAAQtrB,QAKR,OAJIsrB,EAAQI,aACR5jD,KAAK6jD,mBAAmBhd,GAE5B7mC,KAAKq0C,cAAcxN,EAAS7b,GACrB04B,CAGnB,CACJ,CACA,sBAAAI,CAAuBtU,EAAM/C,EAAWzhB,GAcpC,OAbIwkB,GAAQA,EAAKlJ,eACbmG,EAAY+C,EAAKlJ,aAAemG,EAChC+C,EAAKlJ,aAAe,KAEpBtb,EAAOkT,aACPlT,EAAOoV,eAAeqM,EAAW+C,EAAK3X,QAEtC4U,EAAYzhB,EAAO4P,OACnB5P,EAAOya,gBAAgB3vB,QACvBkV,EAAOsT,qBACPkR,EAAK9kB,OAAO5oB,KAAK,IAAIiiD,EAAoBtX,KAGtCA,CACX,CAQA,kBAAAuS,CAAmBnY,EAAS7b,GAExBA,EAAOhG,OAAOwd,QAAQ,gBAAkB7F,EAAMna,IAAI,kCAAoCqkB,EAAQ31B,YAC9F8Z,EAAOnkB,MAAQ,QACf,MAAM,OAAEihB,EAAM,MAAEsb,EAAK,MAAEh8B,EAAK,gBAAEo7C,GAAoB3b,GAC5C,WAAE2M,GAAexzC,KACvBgrB,EAAOid,WAAapB,EACpB,MAAM2I,EAAOxkB,EAAOilB,sBACpB,IAEI+T,EAAkBC,EAFlBxX,EAAYrJ,EAAM,GAClBgT,EAAiBhT,EAAMpgC,MAAQogC,EAAM9W,OAGzC,MAAM43B,GAAel5B,EAAOod,KAAQpd,EAAOpnB,KAAKjB,QAAUyzC,EAM1D,GAJI8N,IACAl5B,EAAO+d,eAAgB,IAGtBmb,GAAgBl5B,EAAOqgB,KAAO+K,IAAqBvP,EAAQ4b,YAAc,CAE1E,GAAI5b,EAAQgW,eAGR,OAFA78C,KAAKo8C,wBAAwBvV,EAAS7b,GAAQ,GAC9CA,EAAOke,uBAAyBrC,EACzB7mC,KAAKmkD,mBAAmBH,EAAkBC,EAAqBj5B,EAAQ6b,EAAQ/e,QAE1F,GAAIkD,EAAOod,IACP,OAAOtgB,EAGX,IAAIwb,EAAOtjC,KAAKokD,kBAAkBvd,EAAS7b,GAM3CA,EAAOqgB,IAAMrgB,EAAOroB,OACpB,IAAIo/C,EAAiB/2B,EAAOpnB,KAAK4oB,UAAU4pB,EAAgBprB,EAAOqgB,KAWlE,OAVI0W,EAAentB,OAAOjyB,OAAS,GAC/B3C,KAAKugD,gBAAgB1Z,EAASkb,EAAgB/2B,GAK9CsY,IACAA,EAAOtjC,KAAKqkD,iBAAiB/gB,EAAMtY,GACnCA,EAAOsd,cAAe,GAEnBhF,CACX,CACAmJ,EAAYzsC,KAAK8jD,uBAAuBtU,EAAM/C,EAAWzhB,GAEzDA,EAAOqgB,IAAM+K,EACb,MAAMzpB,EAAMvD,EAAwBwD,KAAK6f,GAIzCA,EAAYzsC,KAAKy/C,iBAAiBhT,EAAW5F,EAAS7b,EAAQ2B,GAG9D,MAAM23B,EAAyC,GAA3B7X,EAAU7X,OAAOjyB,OAC/B4hD,EAAev5B,EAAO0d,UAE5B,IAAIua,EAAgBj4B,EAAOgZ,WAAasgB,GACnCC,GAAiBA,GAAgB1d,EAAQ6F,aACzC6X,GAAiBA,GAAgB9X,GACpB,IAAbA,EASL,IAJKwW,GAAepc,EAAQ6F,aAAe7F,EAAQ2d,mBAAqBx5B,EAAOy5B,QAC3ExB,GAAe,GAGfn7B,IAAWm7B,GAAen7B,EAAO8rB,iBAAkB,CAEnD,IAAI3Z,EAAKnS,EAAOw6B,SACZroB,GAAOmc,GAAkBnc,EAAGj3B,SACzBghD,mBAAkBC,uBAAwBjkD,KAAK0kD,uBAC9C58B,EAAQ+e,EAAS5M,EAAIuV,EAAMxkB,EAAQ,GAAI,GAAIoY,EAAMpgC,MAAO,SAEpE,CAEA,IAAIwgD,EAAU,CACVtrB,QAAQ,EACRzrB,MAAOggC,EACP5lC,MAAO,QACP+8C,aAAa,EACbX,cACAhB,wBAAwB,EACxBt6C,KAAMglB,EAAIhlB,MAEV47C,EAAgB,CAChB,CAACvjD,KAAMA,KAAKgiD,qCACZ,CAAChiD,KAAMA,KAAK2kD,2BAA4B,CAAEnC,oBAC1C,CAACxiD,KAAMA,KAAKkiD,8BAA+B,CAAE1S,OAAMpM,QAAOh8B,UAC1D,CAACpH,KAAM,SAAU6mC,EAAS7b,EAAQqY,GAC9B,GAAIA,EAAG4f,YAGH,OAFA5f,EAAGnL,QAAS,EACZmL,EAAGugB,aAAc,EACb/c,EAAQG,SAAWH,EAAQ/e,OAEpB9nB,KAAKuiD,iBAAiBv3B,EAAQ6b,EAASA,EAAQ/e,OAAQ06B,IAE9D3b,EAAQ/e,QAER9nB,KAAK+8C,gBAAgB/xB,EAAQ6b,EAAQ/e,QAElC+e,EAAQ/e,OAEvB,GACA,CAAC9nB,KAAMA,KAAK+iD,wBAAyB,CAAEp2B,MAAK6iB,UAE5ClM,EAAOtjC,KAAKsjD,oBAAoBzc,EAAS0c,EAAeC,EAASx4B,GACrE,OAAIw4B,EAAQtrB,OACDl4B,KAAKmkD,mBAAmBH,EAAkBC,EAAqBj5B,EAAQsY,IAElFtjC,KAAK6jD,mBAAmBhd,GAEnB2c,EAAQH,YACTrjD,KAAK+iD,wBAAwBlc,EAAS7b,EAAQw4B,EAAS,CAAE72B,MAAK6iB,SAElExvC,KAAKq0C,cAAcxN,EAAS7b,GAE5BwoB,EAAWoR,0BAA0B/d,EAAS7b,EAAQwkB,GAElD3I,EAAQ4b,YACDziD,KAAK0iD,aAAa7b,EAAS/e,EAAQkD,EAAQ6b,EAAQ2b,iBAEvDxiD,KAAKmkD,mBAAmBH,EAAkBC,EAAqBj5B,EAAQlD,GAClF,CAOA,gBAAAu8B,CAAiBxd,EAAS7b,GACtB,IAAIsY,EAAOuD,EAEX,KAAOvD,GAAM,CACT,MAAMuhB,EAAQ75B,EAAO2kB,oBAAoBrM,GAAM,GACzCwhB,EAAW95B,EAAOylB,YACxBzlB,EAAOojB,cAAcyW,GACrB75B,EAAOya,gBAAgBrF,eACnB,CACIlB,eAAgB2lB,EAAMl9C,KAAKimB,cAC3B2R,aAAcslB,EAAMl9C,KAAKkmB,cAGjC7C,EAAOya,gBAAgBrF,eACnB0kB,EAASn9C,MAEb3H,KAAKq0C,cAAc/Q,EAAMtY,GACzBsY,EAAOA,EAAKxb,MAChB,CACA,OAAOwb,CACX,CACA,eAAAyZ,EAAgB,SAAEjU,GAAYjR,GAC1BiR,EAAWjR,EAAOniB,KAClB3U,UAAU,GAAG+nC,SAAWA,CAC5B,CAMA,wBAAAyW,CAAyBrS,EAAaliB,GAClC,MAAM,UAAEmC,GAAcnC,EAChB1e,EAAO4gC,EAAY6X,YACzB,GAAIz4C,GAAQ4gC,EAAYoS,qBAAsB,CAC1C,KAAKnyB,EAAUxqB,OAAS,GAKpB,MAAMoN,MAAM,uBAJZ4W,EAAM64B,cAAclzC,EAAM6gB,GAC1B+f,EAAYoS,sBAAuB,CAK3C,CACJ,CAMA,0BAAA0F,CAA2B9X,EAAaliB,GACpC,MAAM,UAAEmC,GAAcnC,EAChB1e,EAAO4gC,EAAY6X,YACrBz4C,IAAS4gC,EAAYoS,uBACrB34B,EAAMoG,YAAYzgB,EAAM6gB,GACxB+f,EAAYoS,sBAAuB,EAE3C,CAOA,iCAAA2F,CAAkCptB,EAAQ7M,GACtC,MAAMwkB,EAAOxkB,EAAOolB,eACd8U,EAAe1V,EAAK2V,YAC1B,IAAIhe,EAAWqI,EAAK8N,QAChBzW,EAAU2I,EAAK3X,OACfutB,EAASje,EAASke,WAAWH,GAAgB/d,EAAS3a,UAAU04B,EAAaviD,QAAUwkC,EAE3F,MAAM,WAAEqM,GAAexzC,MACjB,cAAE4tB,EAAa,YAAEC,GAAgB2hB,EAAK7nC,KAC5C,GAAIu9C,EAAaviD,OAAS,EAAG,CACzB,IAAI2nB,EAAMsD,EAAcvf,QAAQ62C,GAChC,MAAMv9C,EAAOkmB,EAAYvD,GAEzBklB,EAAK3oC,MAAM4+B,gBAAgBrF,eAAe,CAAExF,OAAQsqB,EAAcv9C,SAClE,IAAI29C,EAAS,EACb,KAAOh7B,GAAO,GACVuD,EAAYpX,QACZmX,EAAcnX,QACd6T,IACAg7B,IAEA13B,EAAcmR,SACdL,EAAgBkC,yBAAyB0kB,EAAQ13B,GACjD8Q,EAAgBoD,oBAAoB,CAAEjU,cAAaD,iBAAiB,WAE5E,CAMA,GAJA4hB,EAAKnJ,UAAW,EAChBmJ,EAAKpJ,cAAe,EACpBS,EAAQya,gBAAiB,EACzBthD,KAAKulD,oCAAoC1tB,EAAQ7M,GAC7Co6B,EAAOziD,OAAS,EAAG,CAEnBqoB,EAAOkT,aACPlT,EAAOmT,oBAEPnT,EAAOya,gBAAgBrF,eAAe,CAAEb,aAAc1R,EAAaqR,eAAgBtR,IACnF5C,EAAOiF,QACP,MAAMwQ,EAAUzV,EAAOslB,cAAa,GACpCtlB,EAAOsT,qBACP8mB,EAAS3kB,EAAQ7F,OAEjB8D,EAAgBiC,cAAc,CAAE/S,gBAAeC,gBAC/CD,EAAc9rB,KAAK2+B,EAAQ7F,QAC3B/M,EAAY/rB,KAAK2+B,EAAQ94B,KAG7B,CACA6nC,EAAK8N,QAAU8H,EACf5V,EAAKnJ,UAAW,EAChBmJ,EAAKzJ,WAAa,EAClByN,EAAWzN,WAAWyJ,EAC1B,CAOA,kBAAAgW,CAAmB3tB,GAAQ,MAAE8N,IACzB9N,EAAO4tB,+BAAgC,EACvC5tB,EAAO0pB,eAAiB,CACpB5b,MAAOA,EAEf,CAOA,qBAAAmZ,CAAsB5R,EAAaliB,GAC/BA,EAAOnkB,MAAQ,YAAa,MAAM,WAAE2sC,GAAexzC,MAC7C,MAAEglB,EAAK,KAAEphB,EAAI,WAAE2pC,GAAeviB,GAC9B,OAAElD,EAAM,SAAE+d,EAAQ,MAAEzC,GAAU8J,EACpCloB,GAAOwd,QAAQ,oBAAsB7F,EAAMna,IAAI,0CAA4C0qB,EAAYh8B,YAEvG,IAKI+oB,EAAI+a,EAAUjnB,EALdgZ,EAAY,KACZ2e,GAAS,EACTxR,EAAQ,GACR1E,EAAO,KACP/O,EAAU,KAKd,GAAK8M,EAAW5qC,OAAS,IAAO6sC,EAAOxkB,EAAO2kB,oBAAoBzC,GAAa,IAC3EwY,GAAS,EACTjlB,EAAUzgC,KAAK4hD,wBAAwBpS,EAAMxkB,OAC1C,KAAIkiB,EAAYvsC,MAiEnB,MAAM,IAAIoP,MAAM,uBAAyBm9B,GAjEf,CAE1B,IAAI1P,EAAY,KACZmoB,EAAe,CAAE/qB,OAAQ,KAAMjzB,KAAM,MACzC,GAAIulC,EAAY1lB,UAAW,CAEvB,IAAIilB,EAAYS,EAAY9J,MAAM,GAC9BzW,EAAM,GACVg5B,EAAah+C,KAAO8kC,EACpBA,EAAYzsC,KAAKy/C,iBAAiBhT,EAAWS,EAAaliB,EAAQ2B,EAAK,MAAM,IAC5C,GAA7BA,EAAIte,QAAQ,eACZmvB,EAAY0P,EAAY+S,mBAAqB,OAC1CziB,aAAcx9B,KAAK8/C,gBAAgBrT,EAAWS,EAAa1P,KAGlEmoB,EAAa/qB,OAAS6R,CAC1B,CAGA,MAAMU,EAAa,CAAC,EACpB,GAAqE3hC,MAAjEwf,EAAOiiB,mBAAmBC,EAAa1P,EAAW2P,GAA0B,CAC5E,MAAMyY,EAAgB1Y,EAAYI,YAClCqY,EAAa/qB,OAAS5P,EAAOohB,8BAA8Bc,EAAa0Y,GACxED,EAAah+C,KAAO,CAChBkmB,YAAa,CAAC+3B,GACdh4B,cAAe,CAAC+3B,EAAa/qB,QAErC,MACI+qB,EAAa/qB,OAASsS,EAAYI,YAClCqY,EAAah+C,KAAOwlC,EAExBzO,EAAgBS,wBAAwBwmB,EAAah+C,KAAKimB,eAC1Dsf,EAAYvsC,OAAQ,EAChBusC,EAAYlG,UAGPkG,EAAYuP,iBACbz8C,KAAKwlD,mBAAmBtY,EAAaliB,IAEzCkiB,EAAY3D,6BACZve,EAAOqe,yBAAyB6D,GAEpCltC,KAAK6lD,mBAAmB3Y,GAAa,EAAMliB,GACvClD,EACIA,EAAOkf,UAAYlf,EAAOw5B,gBAAkBthD,KAAKi+B,cAAciP,EAAaliB,IAExEuiB,EAAW5qC,OAAS,GACpB3C,KAAKilD,kCAAkC/X,EAAaliB,GAIxD6a,GAA6B,GAAhB7a,EAAO2a,QAEf3a,EAAOob,eACRpb,EAAOob,cAAe,IAIlC,MAAMtO,EAAQoV,EAAYx3B,KAC1B89B,EAAWsS,sBAAsBhuB,EAAO9M,GACxChrB,KAAKglD,2BAA2B9X,EAAaliB,GAC7CkiB,EAAYI,YAAcqY,EAAa/qB,OACvCsS,EAAY6Y,UAAYJ,EAAah+C,KACrC3H,KAAKq/C,eAAenS,EAAaliB,EAAQ,CAAE/R,KAAM,aACrD,CAEA,CAKA,GAJAwnB,EAAUilB,EAASxY,EAAYI,YAAc7M,EAC7CsG,EAAYmG,EAAY6G,SACxBG,EAAQtwC,EAAK4oB,UAAUxB,EAAOqgB,MAEzBqa,GAAU16B,EAAOqd,MAGlB,OAFApO,EAAKiT,EAAYoV,UAAY,CAAC,IAC9BroB,EAAGj3B,MAAQ,EACJhD,KAAKy9C,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,GAGhF,GAAIxkB,EAAOmd,IAMP,OAFAlO,EAAKj6B,KAAKi9C,yBAAyB/P,EAAaliB,EAAQwkB,GACxD/O,EAAU+O,EAAK8N,QACRt9C,KAAKy9C,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,GAGhF,GAAoB,GAAhB0E,EAAMvxC,OAAa,GAGhBs3B,KAAI+a,WAAUjnB,UAAW/tB,KAAKi1C,kBAAkBf,EAAOhH,EAAaliB,IACvE,MAAMg7B,EAAOh7B,EAAOod,IACpB,GAAInO,IAAoB,MAAZ+a,GAAqB,GAAS,CACtC,IAAIiR,EAAW/mD,KAAKD,IAAI+rB,EAAOqgB,IAAKpR,EAAGj3B,OAIvC,GAFAgoB,EAAOqgB,IAAM4a,EAEO,GAAhBhsB,EAAG,GAAGt3B,OAAa,CACnB,IAAIujD,EAAchZ,EAAYsV,gBAC9B,GAAI0D,EAAa,CACb,MAAMv5B,EAAM,GACZu5B,EAAclmD,KAAKy/C,iBAAiByG,EAAahZ,EAAaliB,EAAQ2B,EAAK,MAAM,GACjF8T,GAAWylB,EACP1W,IACAA,EAAK7nC,KAAKimB,cAAc9rB,KAAKokD,GAC7B1W,EAAK7nC,KAAKkmB,YAAY/rB,KAAKokD,GAEnC,CACJ,CACA,OAAOlmD,KAAKy9C,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,EAChF,CAEA,OADAxvC,KAAKq1C,oCAAoCnI,EAAasC,EAAM/O,EAASyM,EAAY6G,SAAU/oB,GACpFkiB,CACX,CAEA,IAAIiZ,EAAOn7B,EAAOqgB,IAClB,GAAIqa,EAAQ,CACR,IAAItP,EAAiBlJ,EAAY9J,MAAMpgC,MAAQkqC,EAAY9J,MAAM9W,OAEjE65B,EAAO/P,EACPprB,EAAOqgB,IAAM+K,CACjB,CAGA,GAFAlC,EAAQtwC,EAAK4oB,UAAU25B,GAEnBjZ,EAAYuP,iBAAmBiJ,EAC/B,OAAO1lD,KAAK08C,uBAAuBxP,EAAagH,EAAOnN,EAAW/b,EAAQ,KAAM,KAAMyV,GAAS,GAOnG,KAFGxG,KAAI+a,WAAUjnB,UAAW/tB,KAAKi1C,kBAAkBf,EAAOhH,EAAaliB,IAEnE+C,EACA,MAAM,IAAIhe,MAAMge,GAEpB,OAAgB,MAAZinB,EAEU,MAAN/a,EAEIiT,EAAYuP,gBAELz8C,KAAK08C,uBAAuBxP,EAAagH,EAAOnN,EAAW/b,EAAQ+C,EAAQyhB,EAAM/O,GAAS,IAErGzgC,KAAK48C,2BAA2B1P,EAAaliB,GAI7ChrB,KAAKq1C,oCAAoCnI,EAAasC,EAAM/O,EAASsG,EAAW/b,GAC5EkpB,EAAMtf,OAAOjyB,OAAS,GACtB3C,KAAKugD,gBAAgBrT,EAAagH,EAAOlpB,GAE7CA,EAAOqgB,IAAMrgB,EAAOpnB,KAAKjB,OACpB89B,EAAQ99B,OAAS,GAAM3C,KAAKgqC,KAAKtP,kBAClC1P,EAAOya,gBAAgBrF,eACnB,CACIlB,eAAgBgO,EAAY6Y,UAAUn4B,cACtC2R,aAAc2N,EAAY6Y,UAAUl4B,cAG5C4S,EAAU,MAEPyM,GAKAltC,KAAKy9C,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,GAMrE,MAANvV,GAAgB+a,EAAS5R,MAAMpgC,MAAQi3B,EAAGj3B,OAC3ChD,KAAK48C,2BAA2B1P,EAAaliB,GAEzCgqB,EAASyH,iBAITz8C,KAAKq1C,oCAAoCnI,EAAasC,EAAM/O,EAASsG,EAAW/b,GAEzEhrB,KAAK08C,uBAAuB1H,EAAUd,EAAOnN,EAAW/b,EAAQ+C,EAAQ,KAAM,IAAI,IAKtF/tB,KAAKomD,2BAA2BtjD,MAAM9C,KAAM,CAC/Cg1C,EAAU9H,EAAasC,EAAM/O,EAASsG,EAAW/b,KAIrDgqB,EAAS5R,MAAMpgC,OAASi3B,EAAGj3B,MACvBgyC,EAASqR,YAIFrmD,KAAKy9C,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,GAEzExtB,EAAWskC,gBAAgBtmD,KAAMktC,EAAa8H,EAAU/a,EAAIuV,EAAM/O,EAASsG,EAAW/b,EAAQ,KAAMkpB,GAGxGl0C,KAAKy9C,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,EAEpF,CACA,iBAAA4U,CAAkBvsB,EAAQ7M,GACtB,MAAM,OAAElD,GAAW+P,EACnB,IAAItwB,EAAIyjB,EAAOolB,gBAEX,IAAE/E,EAAG,KAAEznC,EAAI,SAAEklC,GAAa9d,EAC1BxC,EAAI,KAIR,GAHIjhB,GAAGswB,QAAUA,GACb73B,KAAKumD,mBAAmB1uB,EAAQA,EAAOyqB,SAAUt3B,GAEjDlD,IACAvgB,EAAIyjB,EAAOolB,eACP7oC,GAAGswB,QAAU/P,GAAQ,CACrB,IAAImS,EAAK,CAAC,IACVA,EAAGj3B,MAAQ,EACXi3B,EAAGnQ,QAAU,GACbtB,EAAIxoB,KAAKumD,mBAAmBz+B,EAAQmS,EAAIjP,EAAQ,CAC5Cw7B,gBAAiB1d,GAEzB,CAOJ,OAJA9d,EAAOqgB,IAAMA,EACbrgB,EAAOpnB,KAAOA,EACdonB,EAAO8d,SAAWA,EAEXtgB,CACX,CAcA,iBAAAysB,CAAkBf,EAAOhH,EAAaliB,EAAQy7B,EAAmB5+B,GAAa,GAC1E,IAAImtB,EAAW,KACX/a,EAAK,KACL8M,EAAYmG,EAAY6G,SAExBhmB,EAAS,KACb04B,EAAoBA,GAAqBvZ,EACzC,MAAM,SAAE3lB,GAAa2lB,EACfnN,EAASxY,GAAaA,EAAS5kB,OAAS,EACxC+jD,EAAqB,CAACzsB,EAAI8M,KAC5B9M,EAAG0sB,YAAc5f,EACjB9M,EAAGhhB,KAAO,QACVghB,EAAG3N,OAAS2N,EAAG,GAAGt3B,MAAM,EAE5B,IACIqyC,EAAWjV,EAAQpZ,EAAMs1B,kBAAkB10B,EAAUyD,EAAQy7B,GAAqB,IAItF,CACA,MAAOr5C,GACH,GAAIya,EACA,MAAMza,EAEV2gB,EAAS,CACLmmB,QACAlxC,MAAOoK,EAAEhG,MAAMpE,MAAQgoB,EAAOqgB,IAEtC,CAEA,GAAItE,EAAW,CAIX,GADA9M,EAAKjP,EAAOmjB,YAAY9J,MAAM0C,GAC1B9M,EAEAysB,EAAmBzsB,EAAI8M,QACpB,GAAI/b,EAAO8Y,YAAcoQ,EAAO,CACnC,MAAM,YAAE/F,GAAgBnjB,EAExB,IAAIymB,EAAMhO,EAAWmjB,mBAAmB7f,GACpC55B,EAAIs2B,EAAWojB,qCAAqCpV,GAEpDvmB,EAAQ,KACR/d,GAAKA,EAAExK,OAAS,IAGhBuoB,EADe,IAAK1qB,OAAO2M,EAAG,KAAMxD,KAAKwkC,EAAYlK,UAGzD,MAAM6iB,EAAS/f,EAAUp9B,KAAKwkC,EAAYlK,SACtC6iB,EAEI7sB,EADA/O,GAAUA,EAAMloB,OAAS8jD,EAAOnkD,OAC3BuoB,EAEA47B,EAEF57B,IACP+O,EAAK6sB,GAEL7sB,IACAA,EAAGj3B,OAASmrC,EAAY7hB,OACxBo6B,EAAmBzsB,EAAI8M,GAE/B,CACAmG,EAAYoV,SAAWroB,CAC3B,CAIA,OAHIA,GAAMiT,EAAY6Z,kBAAkB9sB,EAAIjP,KACxCiP,EAAK,MAEF,CAAEA,KAAI+a,WAAUjnB,SAC3B,CACA,0BAAAkwB,CAA2BpX,EAAS7b,EAAQg8B,EAAO16B,EAAQk0B,GAAe,IACtEwG,EAAQA,GAASh8B,EAAOwgB,uBACd7oC,OAAS,IACf2pB,EAASA,GAAU,IACdtB,EAAOgZ,WAAcgjB,EAAMpyB,OAAOjyB,OAAS,IAC5C3C,KAAKugD,gBAAgB1Z,EAASmgB,EAAOh8B,EAAQw1B,GAEjDx1B,EAAOqgB,KAAQ/e,GAAU06B,EAAMrkD,OAEvC,CAMA,aAAAs7B,CAAciP,EAAaliB,GACvB,MAAM,OAAElD,GAAWolB,EACnB,IAAI3lC,GAAI,EACR,MAAM0/C,EAA8Bn/B,GAAQm/B,4BAQ5C,OAPIA,IACA1/C,EAAIvH,KAAKknD,qBAAqB,CAC1Bx8B,OAAQ,CAACwiB,GACTrG,QAAS/e,EACT4Q,UAAWuuB,KAGZ1/C,CACX,CASA,aAAA4/C,CAActgB,EAAS7b,GAAQ,QAAEirB,EAAO,QAAExV,EAAO,MAAEC,EAAK,YAAE0mB,IACtD,MAAMh/B,EAAIpoB,MACJ,OAAE8nB,GAAW+e,GACb,gBAAEpB,GAAoBza,EAC5B,IAAIq8B,EAAc,EAClB,GAAI5mB,EAAQ99B,OAAS,EAAG,CAEpB,GAAIykD,EAAa,CACb,GAAI1mB,EAAM9S,cAAchvB,KAAK,KAAO6hC,EAChC,MAAM,IAAI1wB,MAAM,6BAEpB2uB,EAAgBoD,oBAAoBpB,EAAO,WAC3CD,EAAUC,EAAM9S,cAAchvB,KAAK,GACvC,CAGA6mC,EAAgBlF,cAAc,CAAEE,UAASC,SAAS1V,GAClDyV,EAAU,EACd,CAEA,GADyC,GAAnBoG,EAAQwM,WAAkB4C,EAAQtzC,OAAO,GAAOszC,EAAQrhB,OAAOjyB,OAAS,EAC7E,CAKb,GAHIkkC,EAAQ4e,gCAAkC5e,EAAQygB,UAClDzgB,EAAQygB,SAAU,GAElBx/B,GAAQy/B,mBAAoB,CAC5B,IAAIhgD,EAAIyjB,EAAO4P,OACf5P,EAAOya,gBAAgB3vB,QACnBvO,EAAE5E,OAAS,EACXqoB,EAAOc,OAAOhqB,KAAKyF,GAEnByjB,EAAOmT,oBACX/V,EAAEm4B,gBAAgB1Z,EAASoP,EAASjrB,GACpCA,EAAOiF,QACP1oB,EAAIyjB,EAAOqT,OAAM,GACjBrT,EAAOya,gBAAgBrF,eAAe74B,EAC1C,MAEI6gB,EAAEm4B,gBAAgB1Z,EAASoP,EAASjrB,GACpCq8B,EAAcpR,EAAQtzC,OAE1BszC,EAAU,EACd,CAEA,OADAjrB,EAAO8d,SAAWjC,EAAQnxB,KACnB,CAAEugC,UAASxV,UAAS4mB,cAC/B,CAOA,0BAAA1C,CAA2B9d,EAAS7b,EAAQ3a,EAAM,CAAE6nB,QAAQ,GAAS8qB,GACjE,MAAM,MAAEh+B,GAAUgG,EAClB,IAAIiN,GAAU,EACVyI,EAAQsiB,GAAQR,gBACpB,GAAah3C,MAATk1B,EACA,OAEJ,IAAIrE,EAAK,KACTrX,GAAS2X,EAAMna,IAAI,oCAAsCqkB,GACzDx2B,EAAIuzC,YAAc5jD,KAAKwnD,oBAAoB3gB,EAASx2B,EAAIxJ,OACxD,IAAI4gD,EAAW5gB,EAAQ/e,OAYvB,OAXI2/B,IAEIprB,EADAorB,EAASzgB,QACJhnC,KAAKuiD,iBAAiBv3B,EAAQ6b,EAAS4gB,EAAU/mB,GAEjD1gC,KAAK0nD,sBAAsB7gB,EAAS4gB,EAAUz8B,EAAQ0V,IAInEzI,GAAU,EAEV5nB,EAAI6nB,QAFM,EAGHmE,CACX,CACA,mBAAAmrB,CAAoB3gB,EAAShgC,GACzB,MAAa,SAATA,GACQggC,EAAQzD,MAAM,GAAGzgC,OAAS,CAG1C,CASA,gBAAA4/C,CAAiBv3B,EAAQ6b,EAASzM,EAASzyB,EAAO,GAAIsoB,GAAQ,GAC1D,MAAM,WAAEujB,GAAexzC,KAIvB,GAHIiwB,GAAUjF,EAAO2a,MAAQ,GACzB3a,EAAOiF,QACXjF,EAAO2a,MAAQzmC,KAAKD,MAAM+rB,EAAO2a,MAAO,GACpCkB,GAAWzM,EACX,OAAOp6B,KAAK0nD,sBAAsB7gB,EAASzM,EAASpP,EAAQrjB,EAEpE,CACA,qBAAA+/C,CAAsB7gB,EAASzM,EAASpP,EAAQrjB,GAC5C,MAAM,WAAE6rC,GAAexzC,KACvB,IAAI2nD,EAAK3nD,KAAK0iD,aAAa7b,EAASzM,EAASpP,EAAQrjB,GAErD,OADA6rC,EAAWoU,sCAAsCD,EAAI38B,EAAQ,CAAEtV,KAAMmxB,EAAQnxB,KAAMmnC,eAAgBziB,EAAQyiB,iBACpG8K,CACX,CACA,YAAAjF,CAAa7b,EAASxK,EAAIrR,EAAQrjB,EAAO,IACrC,MAAM,MAAEqd,GAAUgG,EAMlB,GALAhG,GAAS2X,EAAMna,IAAI,oBAAsBqkB,GACrCA,GAASG,UACThnC,KAAKwzC,WAAWqU,YAAYhhB,GAC5BA,EAAQG,SAAU,GAElB3K,EACJ,CACI,MAAM,SAAEimB,GAAajmB,EAKrB,IAAI5C,EAAS9xB,EACTmgD,EAAQ,KAMZ,GALqB,iBAAV,IACPruB,EAAS9xB,EAAK8E,MACdq7C,EAAQngD,EAAKsR,MAGbqpC,GAAaA,EAAS,IAAM7oB,EAAS,CACrC,IAAIjW,EAAI6Y,EAAG0X,SAASpqC,KAAK8vB,IAAW,CAAEx7B,IAClCA,EAAE6rB,QAAU,CAAC,CAAC,EAAG7rB,EAAE,GAAG0E,SACtB1E,EAAE+E,MAAQ,EACH/E,GAHyB,CAIjC,CAACw7B,IAEJjW,EAAExgB,OAASgoB,EAAOqgB,IAClBhP,EAAGimB,SAAW9+B,CAClB,CACA6Y,EAAKr8B,KAAKmgD,oBAAoB9jB,EAAI5C,EAAQzO,GAC1C,IAAIyV,EAAUzV,EAAO4P,OACjBktB,GACArnB,EAAUzV,EAAOqT,OAAM,GAAQoC,EAC/BzV,EAAOoV,eAAeK,EAAS,IAAIsnB,EAAsBD,EAAO,CAAE9/B,OAAQhoB,KAAKgoD,kBAAmBrgD,WAElGqjB,EAAOiF,OAEf,CACA,OAAOoM,CACX,CAcA,sBAAAqoB,CAAuB58B,EAAQ+e,EAAS5M,EAAIuV,EAAMxkB,EAAQyV,EAASyT,EAAOkC,EAAgBvvC,EAAQ,aAE9F,IAAIo9C,EACAD,EACJ,MAAMiE,EAAkBj9B,EAAO6c,aAmB/B,OAlBI/f,IAAWmgC,GAAwC,GAApBngC,EAAOurB,YACrCvrB,EAAO8rB,kBAAoB/M,EAAQ+M,oBAEpCoQ,EAAmB,CACf9P,QACArN,UACA2I,OACA1nB,SACA8S,OAAQ6F,EACR4K,IAAK+K,EACLxyC,KAAMonB,EAAOpnB,KACb0oB,OAAQtB,EAAOsB,OACfg2B,SAAUroB,EACViuB,WAAapgC,EAAO8rB,kBAAoB/M,EAAQ+M,iBAChD/sC,SAEJo9C,EAAsBjkD,KAAKmoD,uBAExB,CAAElE,sBAAqBD,mBAClC,CASA,gBAAAoE,CAAiBvhB,EAAS7b,EAAQwkB,GAC9B,GAAIxkB,EAAOmd,IAAK,CACZ,GAAIqH,EAAM,CACN,MAAM6Y,EAAS7Y,EAAK7nC,KACpB,GAAI0gD,EAAOz6B,cAAcjrB,OAAS,EAC9B,OAAO0lD,CAEf,CACA,OAAOxhB,EAAQkf,SACnB,CACA,OAAOvW,GAAM7nC,MAAQk/B,EAAQkf,SACjC,CAWA,sBAAAtI,CAAuBhd,EAASyT,EAAOrN,EAAS5M,EAAIjP,EAAQwkB,GAExD,MAAM,MAAExqB,GAAUgG,GACZ,OAAElD,GAAW+e,EACnB,IACIyhB,EADAlS,EAAiBnc,EAAGj3B,MAAQi3B,EAAG,GAAGt3B,OAElCszC,EAAUjrB,EAAOqgB,IAAMpR,EAAGj3B,MAAQgoB,EAAOpnB,KAAK4oB,UAAUxB,EAAOqgB,IAAKpR,EAAGj3B,OAAS,GAChFghD,EAAmB,KACnBC,EAAsB,KAC1B,MAAM77B,EAAIpoB,KACJs8C,EAAcl0B,EAAEorB,WAChByU,EAAkBj9B,EAAO6c,aACzBrB,EAAegJ,GAAMhJ,aAC3B,IAAI+hB,EAAK,KACL7nB,EAAQ,KAKZ,GAHA1b,GAAOwd,QAAQ,wBAA0B7F,EAAMna,IAAI,oDAAoDqkB,KACvG7b,EAAOid,WAAapB,EAEhBL,EAAc,CACd,IAAIj/B,EAAI+0C,EAAYkM,oBAAoBhiB,EAAc,KAAMxb,GAC5DyV,GAAWl5B,EAAEkhD,MACbjZ,EAAKhJ,aAAe,IACxB,GACGwd,mBAAkBC,uBAAwBjkD,KAAK0kD,uBAAuB58B,EAAQ+e,EAAS5M,EAAIuV,EAAMxkB,EAAQyV,EAASyT,EAAOkC,IAI5H,IAAIsS,GAAS,EACD,MAARlZ,IACAxkB,EAAOkT,aACPwqB,GAAS,GAEb1oD,KAAKu/C,yBAAyB1Y,EAAS7b,KAEpCu9B,KAAI7nB,SAAU,MACb,MAAMioB,EAAS,CAAEJ,GAAI,GAAI7nB,MAAO,IAChC,OAAOunB,EAAkBU,EAAS,MAC9B,GAAI1uB,EAAG,GAAGt3B,OAAS,EAAG,CAClB,IAAIimD,EAAM59B,EAAO+S,iBAAiB8I,EAAS5M,GAI3C,OAHWzuB,MAAPo9C,IACAA,EAAM59B,EAAOohB,8BAA8BvF,EAAS5M,EAAG,KAEpD,CAAEsuB,GAAIK,EAAKloB,MAAOzG,EAAG,GAChC,CACH,EARiC,IAQ1B0uB,CACX,EAXgB,IAcjB39B,EAAO6c,cAAe,EACtB,IAAIghB,GAAe,EACfxB,EAAc,EAgClB,GA1BArnD,KAAK6jD,mBAAmBhd,EAAS7b,KAK9BirB,UAASxV,UAAS4mB,eAAgB/K,EAAYwM,kBAAkB,CAC/DjxB,OAAQgP,EACR7b,SACAyV,UACAC,MAAO1gC,KAAKooD,iBAAiBvhB,EAAS7b,EAAQwkB,GAC9C4X,aAAa,EACbvxB,OAAOmU,GACI5hB,EAAE++B,cAActgB,EAAS7b,EAAQ,CAAEirB,UAASxV,aAAauJ,GAAQ,CAAC,OAI7Eqd,IACAiB,EAAeppD,KAAKC,IAAIi3C,EAAgBprB,EAAOsB,OAAS+6B,EAAc,IAItExgB,EAAQG,UAAYH,EAAQ0a,gBAE5BvhD,KAAKuiD,iBAAiBv3B,EAAQ6b,EAAS,KAAM,MAAM,GAGnDA,EAAQG,SAAWH,EAAQ0a,eAAgB,CAK3C,GAFAsH,GAAe,EAEXhiB,EAAQ4e,8BAA+B,GACpC8C,KAAI7nB,SAAU4b,EAAYyM,+BAA+B3gC,EAAGye,EAAS7b,EAAQyV,EAC5E,CAAE8nB,KAAI7nB,WACV,MAAM6P,EAAW,CAAC,EAClB9P,EAAUzV,EAAO+kB,kBAAiB,EAAMQ,GACxCvlB,EAAOc,OAAOhqB,KAAK2+B,GACnBzV,EAAOkW,WAAWp/B,KAAKyuC,EAAS/B,QAAQ3gB,YAAYjvB,KAAK,IAC7D,MACI09C,EAAY0M,0CAA0C5gC,EAAGye,EAAS7b,GAEtEyV,EAAU,GAEVzgC,KAAKuiD,iBAAiBv3B,EAAQ6b,EAAS,KAAM,MAAM,EACvD,OAEO0hB,MAAOjM,EAAY2M,2BAA2BjpD,KAAM6mC,EAAS7b,EAC5D,CAAEu9B,KAAI/Y,OAAM7nC,KAAMsyB,EAAG,MAuB7B,GAnBIsuB,EAAG5lD,OAAS,IACZqoB,EAAOya,gBAAgBrF,eAAemoB,GACtCA,EAAK,IAMTvoD,KAAKo8C,wBAAwBvV,EAAS7b,GAElC69B,IACA79B,EAAOiF,QACPwQ,EAAUzV,EAAOslB,cAAa,GAC9BtlB,EAAOya,gBAAgBrF,eAAeK,GAGlC+O,IACA3I,EAAQG,QAAUwI,EAAKrJ,gBAEnB,MAARqJ,GAGKA,EAAK3X,QAAUgP,EAAU,CAE1BpG,EAAUzV,EAAOylB,YAGjB,IAAIyY,EAAc,MAEb1Z,EAAKnJ,UAAYQ,EAAQG,SAG1Bhc,EAAOc,OAAOhqB,KAAK2+B,EAAQ7F,QAC3B6F,EAAUzV,EAAOqT,OAAM,IAEnBmR,EAAKnJ,UAAYve,IAAWA,EAAOkf,SAAWH,EAAQsiB,mBAAmBniB,SAAYwI,EAAK2V,YAAYxiD,OAAS,KAE5G89B,UAASyoB,eAAgBlpD,KAAKopD,4BAA4B3oB,EAASoG,EAAS2I,EAAMxkB,IAG7FA,EAAOojB,cAAcoB,GAErB8M,EAAY+M,mCAAmCjhC,EAAGye,EAASpG,EAAS+O,EAAMxkB,GAC1EyV,EAAU,GACNyoB,GACAl+B,EAAOolB,eAAe3J,kBAAkByiB,EAEhD,CAiBJ,GAZAlkC,GAAOwd,QAAQ,kBAAqBqE,EAAQnc,OAAO/nB,OAAS,GAAMg6B,EAAMna,IAAI,uBAAuBqkB,EAAQv6B,aAAau6B,EAAQnc,OAAO/nB,iBAEnIkkC,GAAS/e,QAAQw/B,UACjBzgB,EAAQ/e,OAAOw/B,SAAU,GAGT,GAAhBrtB,EAAG,GAAGt3B,SACNyzC,EAAiBl3C,KAAKD,IAAI+rB,EAAOqgB,IAAK+K,IAG1CprB,EAAOgjB,OAAOoI,EAAgBkS,GAE1BI,EAAQ,CACR,MAAMY,EAAat+B,EAAOylB,YAC1BzlB,EAAOsT,qBACHgrB,EAAW1uB,OAAOj4B,OAAS,GAI3BqoB,EAAOoV,eAAekpB,EAAYziB,GAAS,GAAM,GAEhDgiB,IAAiBhiB,EAClB4e,gCAAiC5e,EAAQG,QAIlC6hB,GACPvM,EAAYiN,oBAAoB1iB,EAAQnxB,KAAMsV,GAJ1ClD,GAA2B,GAAhB+e,EAAQnxB,MACnBsV,EAAOiF,OAKnB,CAwBA,IAtBK4W,EAAQp6B,OAAS+iC,IAElB3I,EAAQp6B,MAAQ,CACZ8G,OAAQyX,EAAOrjB,KACf8E,MAAOue,EAAO4P,SAKtB56B,KAAKsgD,oBAAoBzZ,EAAS7b,GAGlChrB,KAAKq0C,cAAcxN,EAAS7b,GAE5BA,EAAOukB,gBAAgB1I,EAAS2I,GAGhCxvC,KAAKojD,gBAAgBvc,EAAS7b,GAK1BlD,GAAU+e,EAAQ4b,YAAa,CAC/B,IAAI/hB,EAAQmG,EAAQ2b,gBACpB,OAAOxiD,KAAK0iD,aAAa7b,EAAS/e,EAAQkD,EAAQ0V,EACtD,CAEA,OAAO1gC,KAAKmkD,mBAAmBH,EAAkBC,EAAqBj5B,EAAQlD,EAClF,CASA,kBAAAq8B,CAAmBH,EAAkBC,EAAqBj5B,EAAQw+B,GAC9D,OAAIxF,GAAoBC,EACbA,EAAoBnhD,MAAM9C,KAAM,CAACgkD,EAAkBh5B,IAEvDw+B,CACX,CAOA,2BAAAJ,CAA4B3oB,EAASoG,EAAS2I,EAAMxkB,GAChD,MAAMy+B,EAAcz+B,EAAOolB,eAC3B,IAAI8Y,EAAc,KAElB,GAA0C,IAAtCzoB,EAAQpyB,QAAQmhC,EAAK2V,aAAoB,CACzC,IAAIzH,EAAMlO,EAAK2V,YAAYxiD,OACvB+mD,EAAMjpB,EAAQjU,UAAU,EAAGkxB,GAC/BwL,EAAczoB,EAAQjU,UAAUkxB,GAEhC19C,KAAK4hD,wBAAwB6H,EAAaz+B,EAAQ0+B,EAAK,IACvDjpB,EAAU,EACd,CACA,MAAO,CAAEA,UAASyoB,cAEtB,CACA,kBAAA3C,CAAmB1uB,EAAQiG,EAAI9S,GAAQ,MAAEkpB,EAAQ,GAAE,SAAEpL,IACjD,IAAI0G,EAAO,KACPma,EAAY3pD,KAAKy9C,uBACjBhd,EAAU,KAyBd,OAvBA3C,EAAKA,GAAM,CAAC,IACRjG,EAAOp2B,MAASupB,EAAOuiB,WAAW5qC,OAAS,GAC3C6sC,EAAOxkB,EAAO2kB,oBAAoB9X,EAAOp2B,MAAM,GAC/C+tC,EAAOxkB,EAAO2kB,oBAAoB9X,GAAQ,GAC1C8xB,EAAYna,EAAK0F,UAAYyU,EAC7B9xB,EAASA,EAAOp2B,MAEhB+tC,EAAOxkB,EAAO2kB,oBAAoB9X,GAAQ,GAI9C4I,EAAU+O,EAAOxvC,KAAK4hD,wBAAwBpS,EAAMxkB,GAAU,GAI9DA,EAAOmjB,YAAYvK,KAAK,IACxB9F,EAAGnQ,MAAQ,GACXmQ,EAAG96B,MAAQ,EACXgoB,EAAO6c,cAAe,EACtBhQ,EAAOyqB,SAAWxkB,EAClBjG,EAAS8xB,EAAU7mD,MAAM9C,KAAM,CAACygC,EAASyT,EAAOrc,EAAQiG,EAAI9S,EAAQwkB,IACpExkB,EAAO6c,cAAe,EACtB7c,EAAOmjB,YAAYpK,UACZlM,CACX,CAMA,uBAAAsmB,CAAwB18C,EAAMsH,EAAIiiB,GAC9B,MAAM,WAAEwoB,GAAexzC,KACZ,OAAP+I,EAEAyqC,EAAWoW,uBAAuBnoD,EAAMupB,IAGxCjiB,EAAG2M,KAAOsV,EAAO8d,SACb//B,IAAOtH,IACPupB,EAAOsd,cAAe,GAGlC,CAOA,qBAAA6f,CAAsBne,EAAMhf,GACxB,MAAM,OAAElD,EAAM,SAAEw6B,EAAQ,MAAEz7C,GAAUmjC,GAC9B,YAAEmE,GAAgBnjB,EACxB,IAAIxH,EAAI,KACR,MAAM0wB,EAAQlK,EAAKpmC,KAAK4oB,UAAUwd,EAAKqB,KACjCwe,EAAgB7+B,EAAOqgB,IACvBye,EAAW9+B,EAAOpnB,KACxB,IAAImmD,EAAiB5b,EAAY7hB,OAC7BpB,GAAQ,EACRg9B,EAAYle,EAAKke,UACjBpqB,EAAK,KACLksB,EAAmB,CAACnyB,EAAQiG,EAAIgL,KAChCjR,EAAOniB,KAAOozB,EACd,IAAImhB,EAAcjqD,KAAKumD,mBAAmB1uB,EAAQiG,EAAI9S,EAAQ,CAAEkpB,QAAOpL,aAEvE,OADA9oC,KAAKm+C,wBAAwBtmB,EAAQoyB,EAAaj/B,GAC3Ci/B,CAAW,EAElBC,EAAkBL,EAClBM,EAAqB,SAATtjD,EACZsjD,IACAD,EAAkBlgB,EAAKqB,KAE3B,IAAI+e,EAAUjc,EAAYlK,QACtBomB,EAAWlc,EAAY7hB,OAGvBo5B,EAA+B,GAAtBpD,EAAS,GAAG3/C,OAErB2nD,GAAkB,EACtB,KAAO5E,GAAU1b,EAAKliB,SAAWogC,GAAaoC,GAAmBtgB,EAAKliB,OAAO8rB,mBAAmB,CAC5FpwB,EAAIwmB,EAAKliB,OACT,MAAM,SAAEisB,GAAavwB,EAGrB,GAAgB,MAAZuwB,EAAkB,CAElB7oB,GAAQ,EACR,KACJ,CACA,GAAI4S,EAAKiW,EAASpqC,KAAKygD,GAAU,CAC7B,IAAI7wC,EAAKukB,EAAG96B,MAAQqnD,EAChB3M,EAAM5f,EAAG,GAAGn7B,OACZ4nD,EAAyB,GAAP7M,EACtB,KAAMnkC,GAAK+oC,EAASt/C,OAAUunD,GAAoBD,IAAoBC,GAAmBjI,EAASt/C,OAASuW,EAAImkC,GAMxG,EAGEnkC,EAAI+oC,EAASt/C,QAAWunD,KACzBR,EAAiBG,GACrB,KACJ,CAXQI,IAAoBC,GAAmBjI,EAASt/C,OAASuW,EAAImkC,EAC7D5f,EAAG96B,OAASqnD,EAAW3M,EAEvB5f,EAAG96B,OAASqnD,EAChB7mC,EAAIwmC,EAAiBxmC,EAAGsa,EAAI9S,EAAO8d,UAQvC5d,GAAQ,CACZ,MAEI,GADA4S,EAAKiW,EAASpqC,KAAKuqC,GACfpW,EAAI,CACJ,GAAKA,EAAG96B,MAAQknD,GAAoB5H,EAASt/C,MASzC,MAPA86B,EAAG96B,OAASknD,EAEQ,GAAhBpsB,EAAG,GAAGn7B,SAEN6gB,EAAIwmC,EAAiBxmC,EAAGsa,EAAI9S,EAAO8d,WAK3C5d,GAAQ,CACZ,KAAO,CACH,GAAIA,EAAO,CACP,GAAIF,EAAOmd,IAAK,CACZ3kB,EAAIwmC,EAAiBxmC,EAAG,MACxBwmB,EAAKliB,OAAStE,EACd,KACJ,CACI,KAGR,CACAA,EAAI,IACR,CAEJwmB,EAAKliB,OAAStE,EACd0kC,GAAY,EACZoC,IAAkB9mC,GAAI,CAAEA,IACpB,MAAM,SAAEuwB,GAAavwB,EACrB,OAAOigB,EAAW+mB,mBAAmBzW,EACxC,EAHqB,CAGnBvwB,EACP,CAEA,GAAI2mC,GAAa,GAAW3mC,EAAG,CAC3B,MAAMujB,EAAYvjB,EAAEuwB,SAChBhN,IACAjJ,EAAKiJ,EAAUp9B,KAAKuqC,GAChBpW,GAAuB,GAAhBA,EAAG,GAAGn7B,QAAiBm7B,EAAG96B,MAAQknD,GAAmB5H,EAASt/C,QACrE86B,EAAG96B,OAASknD,EACZ1mC,EAAIwmC,EAAiBxmC,EAAGsa,IAGpC,CAKA,OAJA9S,EAAOqgB,IAAMwe,EACb7+B,EAAOpnB,KAAOkmD,EAGV5+B,GACAF,EAAOmjB,YAAY7hB,OAASu9B,EACrBrmC,IAEXwH,EAAOmjB,YAAY7hB,OAASy9B,EACrBjiC,EACX,CAMA,oBAAAo/B,EAAqB,OAAEx8B,EAAM,QAAEmc,EAAO,UAAEnO,IACpC,GAAqB,GAAjBhO,EAAO/nB,OACP,OAAO,EAEX,MAAM8nD,EAAW//B,EAAOtmB,MAAM,GAC9B,GAAIs0B,EAAW,CACX,IAAInxB,GAAI,EACJ6gB,EAAI,KACJ8a,EAAaljC,KAAK65C,0BACtB,MAAM1nC,EAAO+wB,EAAW8W,WAAWnrC,QAAQ2K,IAEb,GAAnBA,EAAEnL,QAAQ,OAClBzP,KAAK,KACR,IAAIuqB,EAAK,IAAIrpB,SAAS,WAAY,QAAS,SAAU,UAAUqS,yBAA4BumB,MAC3F,KAAO+xB,EAAS9nD,OAAS,GAAG,CACxBylB,EAAIqiC,EAASh0C,QAEb,IACIlP,EAAI4hB,EAAGrmB,MAAM,CAAE4nD,MAAOtiC,GAAK,CACvB8a,EAAWnrB,SAAUqQ,EAAGye,GAChC,CACA,MAAOz5B,GAEH,OADAmV,QAAQ7P,MAAM,WAAYtF,IACnB,CACX,CACA,GAAI7F,EACA,OAAO,CAEf,CACA,OAAO,CACX,CACA,OAAO,CACX,CAKA,kBAAAs8C,CAAmBhd,EAAS7b,GACxB,MAAM,OAAElD,GAAW+e,EACd/e,IAELA,EAAO4C,OAAO5oB,KAAK,CACfwK,KAAMu6B,EAAQv6B,KACdurB,OAAQgP,IAEZ7mC,KAAK6lD,mBAAmBhf,GAAS,EAAO7b,GAC5C,CAMA,mBAAOuT,CAAa7T,GAChB,IAAIigC,GAAS,EAIb,OAHAjgC,EAAOvsB,SAAQgP,IACXw9C,EAASA,GAAWx9C,EAAE0qB,OAAc,OAAC,IAElC8yB,CACX,CAUA,mCAAAtV,CAAoCxO,EAAS2I,EAAM/O,EAASsG,EAAW/b,GAanE,OAZIwkB,GACAA,EAAK8N,QAAU7c,GACVzV,EAAOuiB,WAAW5qC,OAAS,GAAOqoB,EAAOuiB,WAAW,KAAOiC,IAC5DxkB,EAAOygB,cAAc+D,KAEpBxvC,KAAKyuC,SAASuD,UAGnBxC,EAAOxvC,KAAK4qD,wBAAwB5/B,EAAQ6b,EAASpG,EAASsG,GAC1D/b,EAAOyd,iBACPzd,EAAOwd,cAAc1mC,KAAK0tC,IAE3BA,CACX,CAOA,cAAAqb,CAAe7/B,EAAQrjB,GACnBqjB,EAAOhG,OAAS2X,EAAMna,IAAI,4BAC1BwI,EAAOojB,cAAczmC,EACzB,CAQA,uBAAAijD,CAAwB5/B,EAAQ6b,EAASC,EAAOC,GAC5C/b,EAAOhG,OAAOwd,QAAQ,uBAAyB7F,EAAMna,IAAI,iCAAmCskB,EAAQ,KACpG,IAAIgkB,EAAa,KACjB,MAAMxO,EAAct8C,KAAKwzC,WACrB3M,EAAQG,SAAWH,EAAQkkB,gBAAkBlkB,EAAQ4V,kBAErDqO,EAAahkB,EACbA,EAAQ,IAER9b,EAAO4pB,yBACP5pB,EAAO4pB,uBAAuB9N,EAAOD,GAAS,EAAO7b,GACrD8b,EAAQ,IAEZ,MAAMhL,EAAO,IAAIoK,EAAoBlmC,KAAM6mC,EAASC,EAAOC,EAAW/b,GA2BtE,OAxBAA,EAAOygB,cAAc3P,GAErBA,EAAKwL,UAAUtc,EAAQ6b,EAAQnxB,MAE/BsV,EAAOqjB,UAAUrjB,EAAOuiB,WAAW5qC,QAEnCqoB,EAAO8d,SAAWhN,EAAKkvB,YAEvBhgC,EAAOgZ,WAAY,EAEnBhZ,EAAO2d,qBAAsB,EAEzB9B,EAAQ/e,SACRkD,EAAOsd,cAAe,GAE1BgU,EAAYwJ,sBAAsB96B,EAAO8d,SAAU9d,GAC/C8/B,IACAhvB,EAAKwK,aAAewkB,EACpB9/B,EAAO8d,SAAWwT,EAAY2O,YAIlCjgC,EAAOwhB,QAAQ3F,EAAS,IAEjB/K,CACX,CAQA,uBAAA8lB,CAAwBpS,EAAMxkB,EAAQ4P,EAAQ6tB,GAC1C,IAAI,QAAEnL,EAAO,OAAEzlB,EAAM,YAAEmzB,EAAW,cAAEE,EAAa,aAAE1kB,GAAiBgJ,EAChE7nC,EAAO,KACX,MAAM20C,EAAct8C,KAAKwzC,WAGzB,IAAI2X,EAAe,KAFW3/C,MAAVovB,GAAkCpvB,MAATi9C,GAIzC0C,EAAengC,EAAOya,gBAAgB/F,aAAa,IACnD9E,EAAS5P,EAAO4P,OAChBjzB,EAAOqjB,EAAOrjB,KACd8gD,EAAQz9B,EAAOqT,OAAM,EANP,CAAC,KAQfzD,EAASA,GAAU,GACnB6tB,EAAQA,GAAS,IAErB,MAAM2C,EAAiB5b,EAAKnJ,UAAaiX,GAAW9N,EAAK2V,YACzD,IAAIkG,EAAY,KACZ7b,EAAKlJ,eACL1L,EAAS56B,KAAK8jD,uBAAuBtU,EAAM5U,EAAQ5P,GACnDqgC,EAAYxzB,EAAO0O,UAGvB,MAAMz5B,EAAQ,CACV+qB,SAAQ+C,SAAQ6tB,QAAOz9B,SACvBsyB,UACA31C,OACAypC,SAAU5B,EAAK7nC,KACf+N,KAAMs1C,EACNE,gBACAnlB,WAAYyJ,EAAKzJ,WACjBqlB,iBACA5kB,eACAzE,WAAYopB,GAiBhB,OAfA7N,EAAUhB,EAAYgP,uBAAuBx+C,GAEzC0iC,EAAKwb,aAAel+C,EAAM4I,KAC1B85B,EAAKwb,YAAcl+C,EAAM4I,KAClBsV,EAAO8d,UAAY0G,EAAKwb,cAC/Bxb,EAAKwb,YAAchgC,EAAO8d,UAG9B0G,EAAK8N,QAAUA,EACf9N,EAAKzJ,WAAa,EAClByJ,EAAK0b,cAAgBp+C,EAAMo+C,cAE3B1b,EAAKjJ,SAAW8kB,EAChB7b,EAAKhJ,aAAe15B,EAAM05B,aAC1BgJ,EAAKhiC,MACE8vC,CACX,CAEA,iBAAAiO,CAAkB1kB,EAASmO,EAAU/a,EAAIuV,EAAM/O,EAASzV,EAAQ+b,GAC5D,MAAM,WAAEyM,GAAexzC,KAEvB,OADAA,KAAK48C,2BAA2B5H,EAAUhqB,GACtCgqB,EAAS5R,MAAM,GAAGzgC,OAGe,GAA5BqoB,EAAOuiB,WAAW5qC,QAAiBqoB,EAAOuiB,WAAW,KAAO1G,GAC7D7mC,KAAKq1C,oCAAoCxO,EAAS2I,EAAM/O,EAASsG,EAAW/b,GAEvEhrB,KAAK27C,cAAc3G,EAAUhqB,EAQ9C,CAOA,kBAAA66B,CAAmBhf,EAAS6e,EAAQ16B,GAChC,MAAM,OAAElD,EAAM,kBAAEqhC,EAAiB,4BAAElC,GAAgCpgB,EACnE,GAAI/e,GAAUqhC,EAAmB,CAC7B,MAAMr5B,EAAQ,CAAC,UAAW,YAC1BA,EAAM3xB,SAAQolB,IACV,KAAMA,KAAKuE,EAAO0jC,oBAAuBjoC,KAAK4lC,EAAoB,CAC9D,IAAI3gC,EAAI2gC,EAAkB5lC,GACtBA,GAAKuM,EAAM,IACPtH,GAAK,IACLA,EAAIxoB,KAAKknD,qBAAqB,CAC1Bx8B,OAAQmc,EAAQnc,OAChBmc,UACAnO,UAAWuuB,KAInBn/B,EAAOvE,IAAMiF,IACbV,EAAOvE,GAAKiF,EACZV,EAAO0jC,kBAAkBjoC,GAAKA,EAEtC,KAICmiC,EAGD1lD,KAAKyrD,kCAAkC3jC,EAAQkD,GAAQ,GAFvDhrB,KAAKulD,oCAAoC1e,EAAS7b,EAI1D,CACJ,CAOA,iCAAAygC,CAAkC5kB,EAAS7b,EAAQ4yB,GAC/C,MAAM,kBAAE4N,EAAiB,eAAElK,EAAc,eAAEC,GAAmB1a,IACzD,YAAa2kB,IAAuBlK,GAAmBC,IAGnD3D,IACD/W,EAAQya,gBAAiB,GAE7Bza,EAAQ0a,eAAiB,CACrB5b,MAAO3a,EAAO2a,OAElBiY,GAAe59C,KAAK49C,YAAY5yB,GAExC,CACA,mCAAAu6B,CAAoC1e,EAAS7b,GACzC,MAAM,OAAElD,GAAW+e,EAEf/e,GAAW,YAAaA,EAAO0jC,mBAAuB3kB,EAAsB,gBAC5E7mC,KAAKyrD,kCAAkC3jC,EAAQkD,GAAQ,EAG/D,CAQA,qBAAA0gC,CAAsBxe,EAAagH,EAAOlpB,GACtC,MAAM+b,EAAYmG,EAAY6G,SAC9B,IAAI4X,EAAgB3rD,KAAKmhD,6BAA6BjU,EAAagH,EAAOnN,EAAW/b,GAGrF,OAFAA,EAAOqgB,IAAMrgB,EAAOpnB,KAAKjB,OACzB3C,KAAKq1C,oCAAoCsW,EAAe,KAAM,GAAI5kB,EAAW/b,GACtE2gC,CACX,CAKA,mBAAAC,GACI,OAAO,IAAI/Y,CACf,CASA,4BAAAsO,CAA6BjU,EAAagH,EAAOnN,EAAW/b,GAExD,IAAI6gC,EAAiB7rD,KAAK4rD,sBAC1BC,EAAepqD,KAAOyrC,EACtB2e,EAAe/Y,YAAc9nB,EAAO8d,SAEpC+iB,EAAe1Y,iBAAmBnoB,EAAOuiB,WAAWnpC,MAAM,GAC1DynD,EAAezY,gBAAkBpoB,EAAOmC,UAAU/oB,MAAM,GACpD8vC,GAASA,EAAMvxC,OAAS,GACxBkpD,EAAezrB,eAAe8T,GAGlC,IAAIyX,EAAgB,IAAIlkB,EACpBvH,EAAOgN,EAAY7+B,QAavB,OAZAs9C,EAAc9K,IAAI,CACdhpB,OAAQg0B,EACR9X,SAAU7G,EAAY6G,SACtB3Q,MAAO8J,EAAY9J,MACnBx/B,KAAMonB,EAAOpnB,KACbkkB,OAAQolB,GAAaplB,OACrBP,SAAU2lB,EAAYyI,aACtB3yC,MAAOk9B,EACPsT,WAAYxzC,KAAKwzC,aAErBqY,EAAe9Y,cAAgB/nB,EAAOqgB,IACtCwgB,EAAelrD,MAAMqqB,GACd2gC,CACX,CAOA,0BAAA/O,CAA2B1P,EAAaliB,EAAQ8gC,GAAO,GACnD,MAAMxP,EAAct8C,KAAKwzC,WAErBtG,EAAYlG,UAAYkG,EAAYoU,iBACpCwK,GAAQ9rD,KAAKwlD,mBAAmBtY,EAAaliB,GAC7CsxB,EAAYyP,qBAAqB/rD,KAAMktC,EAAaliB,GAE5D,CAOA,8BAAAy2B,CAA+BvU,EAAaliB,EAAQwkB,GAC5CxkB,EAAOjI,MAAMpiB,OAASqqB,EAAOjI,MAAMniB,MACnCZ,KAAKi+C,2BAA2B/Q,EAAaliB,EAAQ,KAAM,MAAM,GACjEhrB,KAAK4hD,wBAAwBpS,EAAMxkB,GACnCA,EAAOkgB,WAAWlgB,EAAOqgB,KAEjC,CAKA,wBAAA+a,GACI,OAAO,SAAUpR,EAAU9H,EAAasC,EAAM/O,EAASsG,EAAW/b,GAC9D,MAAM,MAAEhG,GAAUgG,EAClB,IAAI,SAAE8d,GAAa9d,EACP,MAARwkB,GACAxvC,KAAK+9C,mBAAmB7Q,EAAaliB,GAIzC,IAAIghC,EAAUhsD,KAAKq1C,oCAAoCnI,EAAasC,EAAM/O,EAASsG,EAAW/b,GAe9F,OAdA8d,EAAWkjB,EAAQhB,YAGnBhgC,EAAOkgB,WAAWlgB,EAAOqgB,IAAK2J,EAAS5R,MAAMpgC,OACzCgoB,EAAOjI,MAAMpiB,OAASqqB,EAAOjI,MAAMniB,MACnCZ,KAAKi+C,2BAA2B/Q,EAAaliB,EAAQ,KAAM,MAAM,GACjEghC,EAAQhB,YAAcliB,EACtB9oC,KAAK4hD,wBAAwBoK,EAAShhC,GACtCA,EAAOkgB,WAAWlgB,EAAOqgB,MAE7BrrC,KAAK48C,2BAA2B1P,EAAaliB,GAC7ChrB,KAAK48C,2BAA2B5H,EAAUhqB,GAC1ChG,GAAOwd,QAAQ,gBAAkB7F,EAAMna,IAAI,qBAAuBwyB,EAAS9jC,YAChElR,KAAK27C,cAAc3G,EAAUhqB,EAE5C,CACJ,CAMA,gBAAAsqB,EAAiB,GACbrb,EAAE,SAAE+a,EAAQ,QAAEvU,EAAO,KAAE+O,EAAI,YAAEtC,EAAW,OAAEliB,EAAM,MAAEkpB,EAAK,SACvDgB,EAAQ,UACR+W,EAAS,eAAE1W,IAEX,IAAI2W,GAAwB,EAC5B,MAAMnlB,EAAYmG,EAAY6G,SACxB3rB,EAAIpoB,KAIV,OAHAk1C,EAAWA,GAAY9sB,EAAEq1B,uBACzBlI,EAAiBA,GAAkBntB,EAAEsjC,sBACrCO,EAAYA,GAAa7jC,EAAEg+B,2BACX,MAAZpR,EAmBW,MAAN/a,GAAgB+a,EAAS5R,MAAMpgC,MAAQi3B,EAAGj3B,MAEpCipD,EAAUnpD,MAAMslB,EAAG,CAAC4sB,EAAU9H,EAAasC,EAAM/O,EAASsG,EAAW/b,IAG5EgqB,EAAS5R,MAAMpgC,OAASi3B,EAAGj3B,MACpBgf,EAAWskC,gBAAgBl+B,EAAG8kB,EAAa8H,EAAU/a,EAAIuV,EAAM/O,EAASsG,EAAW/b,EAAQkqB,GAG/FA,EAASpyC,MAAMslB,EAAG,CAACqY,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,IA1BzD,MAANvV,EAUOib,EAASpyC,MAAMslB,EAClB,CAACqY,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,KAT9C0c,GAAwB,EAExB9jC,EAAEm4B,gBAAgBrT,EAAagH,EAAOlpB,GACtCA,EAAOqgB,IAAMrgB,EAAOpnB,KAAKjB,OAwB7BupD,GACA9jC,EAAEitB,oCAAoCnI,EAAasC,EAAM/O,EAASsG,EAAW/b,GACtEkiB,IAIXh0B,SAASizC,OAAO/oB,MAAM,GAAI8J,GAE1BliB,EAAOgjB,OAAOoI,gBACPlJ,EAAYplB,QACvB,CACA,sBAAOw+B,CAAgBl+B,EAAG8kB,EAAa8H,EAAU/a,EAAIuV,EAAM/O,EAASsG,EAAW/b,EAAQkqB,EAAUhB,GAE7F,MAAM,MAAElvB,GAAUgG,EAElBhG,GAAOwd,QAAQ,sBACX7F,EAAMna,IAAI,6BAGd,IAAI8gB,EAAO,KACX4Q,EAAQA,GAASlpB,EAAOpnB,KAAK4oB,UAAUxB,EAAOqgB,KAC9C,IAAIrH,EAAYkJ,EAAYuP,gBAAkBzxB,EAAOgZ,eAAYx4B,EAajE,OAVI83B,EADA4R,EACOA,EAASpyC,MAAMslB,EAAG,CAACqY,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,IAE5DpnB,EAAEq1B,uBAAuBhd,EAASyT,EAAOhH,EAAajT,EAAIjP,EAAQwkB,GAEzExL,IACAhZ,EAAOgZ,UAAYA,EACfA,IACAhZ,EAAO4d,qBAAsB,IAG9BtF,CACX,CACA,eAAAqJ,CAAgB9U,GACZ,OAAOA,aAAkB8a,CAC7B,CAOA,mBAAAyZ,CAAoBC,EAAIx0B,EAAQ7M,GAC5BA,EAAOoV,eAAeisB,EAAIx0B,GAC1B7M,EAAOiF,QACPjF,EAAOmT,mBACX,EAGJ,MAAMwU,UAAkC/rB,EACpC,aAAI0lC,GAAc,OAAO,CAAM,EAkBnC,MAAMC,UAA8B5Z,EAChCrrB,QAAU,WACVE,UAAY,CAAC,SAAU+C,GACnB,OAAuB,GAAnBA,EAAEqK,OAAOjyB,OAAoB,GAAW4nB,CAChD,EAAG,aACH,UAAA8hB,GACI,OAAO1lB,EAAM6lC,cAAcxsD,KAC/B,EAGJ,MAAMo6C,UAAoCmS,EACtCjgD,KAAO,iCAMP,eAAAsgC,GACI,OAAO,CACX,EAGJ,MAAM8N,UAAoCN,EACtC,WAAAhlC,GACI0vB,QACA9kC,KAAKysD,cAAgB,CACjBxR,SAAS,EAEjB,EAKJ,MAAMV,UAA8BgS,EAChCjgD,KAAO,8BAGX,MAAMkuC,UAAkC+R,EACpCjgD,KAAO,8BAEX,MAAMmuC,UAAoC8R,EACtCjgD,KAAO,gCACP,aAAI+mC,GACA,OAAOqZ,GACX,EAGJ,MAAMpS,UAA4BiS,EAC9BjgD,KAAO,4BAQX,MAAMquC,UAA2B4R,EAC7B,WAAAn3C,CAAYnM,GACR67B,QACA9kC,KAAKsM,KAAOrD,CAChB,EAEJ,MAAM25C,UAA0BjQ,EAC5B,aAAIU,GACA,OAAOqZ,GACX,EAGJ,MAAM3I,UAA4BpR,EAC9BrmC,KAAO,wBACP,aAAI+mC,GACA,OAAOqZ,GACX,CACA,WAAAt3C,CAAY3I,GACRq4B,QACA9lC,OAAOD,eAAeiB,KAAM,QAAS,CAAE2M,IAAG,IAAYF,GAC1D,EAEJ,MAAMs7C,UAA8BpV,EAChC,aAAIU,GACA,OAAOqZ,GACX,CACA,WAAAt3C,CAAY6D,GAAM,OAAE+O,EAAM,KAAErgB,IAOxB,GANAm9B,QACqB,iBAAV,IACP7rB,EAAOA,EAAK7X,QAAQ,IAAK,KACzBpB,KAAKsnB,QAAU3f,GAAM2f,SAAWrO,EAChCjZ,KAAKsM,KAAO3E,GAAM2E,MAAQ2M,GAE1BtR,EAAM,CAEN,MAAMmK,EAAO9S,OAAO8S,KAAKnK,GACnBglD,EAAS3tD,OAAO8S,KAAK9R,MAE3B,CAAC,OAAQ,SAAS7B,SAAQkJ,IACtB,MAAMijB,EAAMxY,EAAKzD,QAAQhH,IACZ,IAATijB,UACQxY,EAAKwY,EAAK,IAG1B,MAAMsiC,EAAQ96C,EAAKjD,QAAQ0U,IAA6B,IAAvBopC,EAAOt+C,QAAQkV,KAC1C6E,EAAIpoB,KACV4sD,EAAMzuD,SAASqb,IACXxa,OAAOD,eAAeqpB,EAAG5O,EAAG,CAAE7M,IAAG,IAAYhF,EAAK6R,IAAQ,GAElE,CACJ,EAGJmN,EAAMG,QAAU,IACTH,EAAMG,QACT9E,cAGJrkB,EAAQqkB,WAAaA,EACrBrkB,EAAQgpB,MAAQA,EAChBhpB,EAAQipB,SAAWA,EACnBjpB,EAAQmrB,WAAaA,EACrBnrB,EAAQg1C,0BAA4BA,EAEpC,MAAM,sBAAEE,GAA0B,EAAQ,OACpC,mBAAE3N,GAAuB,EAAQ,OACjC,qBAAE2nB,GAAyB,EAAQ,OACnC,qBAAEhkC,GAAyB,EAAQ,OACnC,wBAAEO,GAA4B,EAAQ,MAI5CzC,EAAMG,QAAQ+rB,sBAAwBA,C,4BClkHtC,MAAMd,EAAM,QACN+a,EAAQ,QACRC,EAAS,SACTC,EAAS,SACTC,EAAS,SACf,MAAMvb,EACF,cAAWK,GAAM,OAAOA,CAAK,CAC7B,gBAAW+a,GAAQ,OAAOA,CAAO,CACjC,iBAAWC,GAAS,OAAOA,CAAQ,CACnC,iBAAWC,GAAS,OAAOA,CAAQ,CACnC,iBAAWC,GAAS,OAAOA,CAAQ,CAMnC,cAAO5a,CAAQ1qC,GAEX,OAAmE,GAA5D+pC,EAAqBwb,qBAAqB7+C,QAAQ1G,EAC7D,CACA,yBAAOulD,GACH,MAAO,CACHnb,EAAI+a,EAAOC,EAAQC,EAAQC,EAEnC,EAEJtvD,EAAQ+zC,qBAAuBA,C,8BC1B/B1yC,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD9O,EAAQg0C,oBAAiB,EACzB,MAAM,MAAEhV,GAAU,EAAQ,OACpB,qBAAEoE,GAAyB,EAAQ,MACnC,gBAAErC,GAAoB,EAAQ,KAG9ByuB,EAAwB,CAAC,EA21B/BxvD,EAAQg0C,eAv1BR,MACIyb,aAEA,UAAArnB,EAAW,YAAEilB,GAAenkB,EAASwmB,GACjCrC,EAAcsC,EACdvsD,UAAU,GAAGiqD,YAAcA,CAC/B,CACA,sBAAAtJ,EAAuB,YAACsJ,IAGxB,CAQA,oBAAAjK,CAAqBp5C,EAAM+N,EAAMmxB,EAAS7b,GACtC,MAAM,gBAAEya,GAAoBza,EAC5B,OAAQtV,GACJ,KAAK43C,EACL,KAAKC,EACD5lD,EAAOA,EAAK25B,YACZ,IAAIb,EAAUzV,EAAO4P,OACjB6F,EAAQ99B,OAAS,IACjBqoB,EAAOc,OAAOhqB,KAAK2+B,GACnBgF,EAAgB3vB,SAEpBkV,EAAOoV,eAAez4B,EAAMk/B,GAC5BnxB,EAAOq/B,EACP,MACJ,KAAKA,EACD/pB,EAAOoV,eAAez4B,EAAMk/B,GAC5B,MACJ,KAAK2mB,GAED7lD,EAAOA,EAAK25B,aACH3+B,OAAS,IACdqoB,EAAOoV,eAAez4B,EAAMk/B,GAC5BnxB,EAAOq/B,GAEX,MACJ,KAAK0Y,GACD9lD,EAAOA,EAAK25B,aACH3+B,OAAS,IACdqoB,EAAOsd,cAAgBtd,EAAOmT,oBAC9BnT,EAAOoV,eAAez4B,EAAMk/B,GACxB7b,EAAOc,OAAOnpB,OAAS,IACvBqoB,EAAOiF,QACPwV,EAAgBrF,eAAepV,EAAOqT,OAAM,KAEhD3oB,EAAOq/B,GAEX,MACJ,KAAK2Y,GACD/lD,EAAOA,EAAK25B,aACH3+B,OAAS,IACdqoB,EAAOoV,eAAez4B,EAAMk/B,GAC5B7b,EAAOiF,QACPva,EAAOq/B,GAEX,MACJ,QACI,MAAM,IAAIhlC,MAAM,+BAAiC2F,GAEzDmxB,EAAQnxB,KAAOA,CACnB,CAKA,wBAAAi4C,EAAyB,KAAEj4C,EAAI,aAAE4yB,EAAY,UAAEtE,GAAahZ,GACxD,MAAM5d,EAAIrM,UAAU,GACpB,OAAQ2U,GACJ,KAAKk4C,EACL,KAAKL,EACL,KAAKD,EACL,KAAKG,EACL,KAAKI,EACD7pB,GAAY,EACZsE,GAAe,EAMvBl7B,EAAEk7B,aAAeA,EACjBl7B,EAAE42B,UAAYA,EACVhZ,IACAA,EAAOgZ,UAAYA,EACnBhZ,EAAOsd,aAAeA,EACtBtd,EAAO8d,SAAWpzB,EAE1B,CAMA,sBAAAk0C,EAAuB,KAAEl0C,EAAI,eAAEmnC,IAAkB,aAAEvU,EAAY,KAAE1kC,EAAI,IAAEynC,EAAG,OAAE1oC,IAExE,MAAMqoB,EAASjqB,UAAU,GAQzB,OANI87C,GAAkBiR,EAAsBC,2BACpCr4C,GAAQ43C,IACR53C,EAAOq/B,EACPzM,EAAgB+C,GAAO1oC,GAAYiB,EAAKw9B,UAAUz+B,QAAU0oC,GAG5D31B,GACJ,KAAK43C,EACL,KAAKE,EACL,KAAKD,EACDjlB,GAAe,EAGvBtd,EAAOsd,aAAeA,CAC1B,CAMA,kBAAAsY,CAAmBn0C,EAAOorB,EAAQ7M,GAI9B,OAHIhrB,KAAKotD,eACL3gD,EAAQA,EAAM20B,WAEX30B,CACX,CAIA,cAAIw+C,GACA,OAAOlW,CACX,CACA,qBAAA+Q,CAAsBpwC,EAAMsV,GACxB,OAAQtV,GACJ,KAAK43C,EACL,KAAKE,EACDxiC,EAAOgZ,WAAY,EAI/B,CACA,qCAAA4jB,CAAsC9/B,EAAQkD,GAAQ,eAAE6xB,IACpD,GAAI/0B,EACAA,EAAOpS,KAAO43C,MACX,CACH,IAAIU,EAAejZ,EACf8H,GAAkBiR,EAAsBG,gBACxCD,EAAeV,GAEnBttD,KAAK4pD,uBAAuB,CAAEl0C,KAAMs4C,EAAcnR,kBAAkB7xB,EACxE,CACJ,CAKA,WAAA68B,CAAYhwB,GACHA,EAAc,SAAMA,EAAOniB,MAAQq/B,IACpCld,EAAOniB,KAAO43C,EAEtB,CACA,mBAAAY,EAAoB,QAAE5Q,EAAO,OAAEzlB,EAAM,OAAE7M,EAAM,MAAEy9B,EAAK,OAAE7tB,EAAM,WAAEuzB,EAAU,UAAEC,IACtE,IAAI3hD,EAAQ,GACRiJ,EAAOmiB,EAAOniB,KAMlB,OALIy4C,IACA1hD,GAASmuB,EACTllB,EAAO43C,GAGJ,CAAE7gD,QAAO6wC,QADhBA,EAAUA,EAAQlc,UACO1rB,OAC7B,CAMA,uBAAA2mC,CAAwBxkB,EAAQ7M,GAC5B,GAAI6M,EAAQ,CACR,MAAM2X,EAAOxkB,EAAOuiB,WAAW,IACzB,eAAEsP,EAAc,KAAEnnC,GAASmiB,EACjC,IAAIw2B,EAAmBrjC,EAAOya,gBAAgBxG,QACzC4d,GAAkBiR,EAAsBC,2BAA+Br4C,GAAQq/B,IAChF/pB,EAAO8d,SAAWwkB,EAClBz1B,EAAOniB,KAAO43C,EAET9d,EAAKwb,aAAejW,GAAc,IACnCvF,EAAKwb,YAAcsC,GAG/B,CACJ,CACA,mBAAA9E,CAAoBhiB,EAAciiB,EAAOz9B,GACrCA,EAAOkT,aACP,IAAI32B,EAAI,GAWR,OAVE1I,MAAMuQ,QAAQo3B,GAAiCA,EAAjB,CAACA,IAC7BroC,SAAQkJ,IACJ2jB,EAAOya,gBAAgBrF,eAAe/4B,GACtC2jB,EAAOiF,OAAO,IAER,OAAVw4B,GACAz9B,EAAOc,OAAOhqB,KAAK2mD,GACvBlhD,EAAIyjB,EAAOqT,OAAM,GACjBrT,EAAOsT,qBAEA,CAAEmqB,MADTA,EAAQlhD,EAEZ,CAMA,8BAAA+mD,CAA+B7oB,EAAiB1D,GAC5C,MAAM,cAAEnU,EAAa,YAAEC,GAAgBkU,EACvC0D,EAAgBrF,eAAe,CAC3BlB,eAAgBtR,EAChB2R,aAAc1R,GAEtB,CAKA,sBAAAy9B,EAAuB,QAAEhO,EAAO,OAAEzlB,EAAM,MAAE4wB,EAAK,OAAE7tB,EAAM,KAAEjzB,EAAI,SAAEypC,EAAQ,OAAEpmB,EAAM,KAAEtV,EAAI,eAAE01C,EAAc,cACjGF,EAAa,aAAE1kB,EAAY,WAAEzE,IAC7B,IAAIwsB,EAAM,GACV,MAAM,MAAEvpC,EAAK,SAAEuhB,EAAQ,gBAAEd,GAAoBza,EAC7CtV,EAAelK,MAARkK,EAAoBq/B,EAAYr/B,EACvC,MAAM84C,EAASztD,UAAU,GACzB,IAAIqtD,EAAa3F,EAAM9lD,OAAS,EAC5BwrD,EAAcvzB,EAAOj4B,OAAS,EAClC,IAAKyrD,IAAcD,EACf,OAAO7Q,EAEP9W,MAIGiiB,SAAUzoD,KAAKwoD,oBAAoBhiB,EAAciiB,EAAOz9B,IAC3Dwb,EAAe,MAInB,IAAIioB,OADmC,IAAhB52B,EAAW,KACDkd,EAAYld,EAAOniB,KAEpDsP,GAAOwd,QAAQ,uBACX7F,EAAMna,IAAI,iCACVD,QAAQC,IAAI,CAAE86B,UAAS1iB,SAAQ6tB,QAAO/yC,OAAM/N,UAGhD,MAAM+mD,EAAY,KACd,MAAMhhC,EAAY,CAAC,EACb+S,EAAUzV,EAAOqT,OAAM,EAAM3Q,GACnC6gC,GAAO9tB,EACPkuB,EAAe,CAAE/zB,OAAQ6F,EAAS94B,KAAM+lB,EAAU/lB,MAAO,EAEvDgnD,EAAiB,EAAG/zB,SAAQjzB,WAC9BypC,EAASxjB,cAAc9rB,KAAK84B,GAC5BwW,EAASvjB,YAAY/rB,KAAK6F,EAAK,EAG7BinD,EAAsB,EAAG/gC,cAAaD,oBACxCmT,EAAqBoQ,kBAAkBC,EAAU,CAAEvjB,cAAaD,iBAAgB,EAEpF,IAAIihC,GAAqB,EAEzB,MAAMC,EAAwB,CAACzvB,EAAG,aAC1BwvB,IACJnwB,EAAgBoD,oBAAoBC,EAAY1C,GAChDzE,EAASmH,EAAWnU,cAAchvB,KAAK,IACvCiwD,GAAqB,EAAI,GAIxBh3B,EAAOk3B,mBAAmBC,kBAAoB,WAAWl+C,KAAKwsC,KAAczlB,EAAOnN,OAAO/nB,OAAS,GACpGmsD,IAMJ,MAAMG,EAAa,CAAC,EACpB,OAAQv5C,GACJ,KAAK43C,EACDwB,IAEIP,EADAhoB,EACM3L,EAEA56B,KAAKkvD,uBAAuBlkC,GAAQ,EAAMy9B,EAAO7tB,EAAQuzB,EAAYC,GAE3EG,EAAI5rD,QAAU,EACd8rD,EAAoBnB,EAEpB2B,EAAW/tB,WAAaqtB,EAC5B,MACJ,KAAKhB,EAGDviC,EAAOmT,oBACP,IAAI1xB,EAAQ,KACTA,QAAOiJ,OAAM4nC,WAAYt9C,KAAKkuD,oBAAoB,CAAE5Q,UAASzlB,SAAQ4wB,QAAO7tB,SAAQ5P,SAAQmjC,aAAYC,eAC3GpjC,EAAOya,gBAAgBrF,eAAe3zB,GACtCue,EAAOiF,QACPs+B,EAAMvjC,EAAOqT,OAAM,EAAM4wB,GACzB,MACJ,KAAKzB,EACDxiC,EAAOmT,oBACHiwB,GACApjC,EAAOc,OAAOhqB,KAAK2mD,GACnB0F,IACA1oB,EAAgBrF,eAAexF,GAC/B5P,EAAOiF,SAEXs+B,EAAMvjC,EAAOqT,OAAM,EAAM4wB,GACrBR,GAAqBlB,IACrBkB,EAAoBnB,GAExB,MACJ,KAAKG,EACGW,IACApjC,EAAOc,OAAOhqB,KAAK2mD,GACnB8F,EAAMvjC,EAAOqT,OAAM,GACnB+vB,GAAY,GAEZD,IACKC,GACDpjC,EAAOmT,oBAEXnT,EAAOya,gBAAgBrF,eAAexF,EAAO0G,aAC7CtW,EAAOiF,QACPs+B,GAAOvjC,EAAOqT,OAAM,IAExB,MACJ,KAAK8wB,EACGf,IACApjC,EAAOmT,oBACPnT,EAAOc,OAAOhqB,KAAK2mD,GACnB8F,EAAMvjC,EAAOqT,OAAM,IAEnBzD,EAAOj4B,OAAS,IACX,QAAQmO,KAAKwsC,KACdA,GAAW32B,EAAMyb,WAAWpX,EAAOya,gBAAiB,IAAK5N,EAAQ7M,IAErEujC,GAAO3zB,GAEX,MAEJ,KAAKw0B,EAEDpkC,EAAOmT,oBACHiwB,IACApjC,EAAOc,OAAOhqB,KAAK2mD,GACnBiG,KAEAP,IAEAzvB,EAAgBoD,oBAAoBC,EAAY,WAChD/hC,KAAKsuD,+BAA+B7oB,EAAiB1D,IAGzD/W,EAAOiF,QACPs+B,EAAMvjC,EAAOqT,OAAM,EAAM4wB,GACrBjkC,EAAO8d,UAAYpzB,IACnB+4C,EAAoB/4C,GAExB,MACJ,KAAKq/B,EACGqZ,IACApjC,EAAOmT,oBACPnT,EAAOc,OAAOhqB,KAAK2mD,GACnBiG,KAEA9zB,EAAOj4B,OAAS,IAChB4rD,GAAO3zB,EACPg0B,EAAoB7sB,IAExB,MACJ,KAAK6rB,EACD5iC,EAAOmT,oBACHgwB,IACA1oB,EAAgBrF,eAAexF,GAC/B5P,EAAOiF,SAEXs+B,EAAMvjC,EAAOqT,OAAM,GACnB3oB,EAAOg4C,EACP,MACJ,KAAKA,EACDa,EAAMvuD,KAAKkvD,uBAAuBlkC,GAAQ,EAAMy9B,EAAO7tB,EAAQuzB,EAAYC,GAC3EK,EAAoB1Z,EACpB,MACJ,KAAK8Y,IACEvQ,UAASiR,OAAQvuD,KAAKqvD,cAAc/R,EAASmL,EAAO7tB,EAAQuzB,EAAYC,EAAWhD,EAAgB6D,EAAY7d,IAC5G,eAAgB6d,IAClBA,EAAuB,WAAIltB,EAAWlU,YAAYjvB,KAAK,KAE3D,MAEJ,QACI,MAAM,IAAImR,MAAM,qBAAuB2F,GAW/C,MATI,eAAgBu5C,GAChBL,EAAoB,CAAE/gC,YAAa,CAACohC,EAAW/tB,YAAatT,cAAe,CAAC2gC,KAGhF12B,EAAOniB,KAAO+4C,EACdzuD,KAAKsvD,oCAAoCz3B,EAAQ7M,GACjDwjC,EAAO94C,KAAOmiB,EAAOniB,KACrB84C,EAAOtD,cAAgBA,EACvBsD,EAAOhoB,aAAeA,EACf8W,EAAUiR,CACrB,CAUA,aAAAc,CAAc/R,EAASmL,EAAO7tB,EAAQuzB,EAAYC,EAAWhD,EAAgB6D,GACzE,IAAIV,EAAM,GAOV,OANI9F,EAAM9lD,OAAS,IACf4rD,GAAO9F,GAEP7tB,EAAOj4B,OAAS,IAChB4rD,GAAO3zB,GAEJ,CAAE0iB,UAASiR,MACtB,CAMA,mCAAAe,CAAoCz3B,EAAQ7M,GACxC,MAAM,KAAEtV,EAAI,eAAEmnC,GAAmBhlB,GAC3B,aAAEyQ,EAAY,UAAEtE,GAAchZ,EACpChrB,KAAK2tD,yBAAyB,CAAEj4C,OAAMmnC,iBAAgBvU,eAActE,aAAahZ,EACrF,CACA,sBAAAkkC,CAAuBlkC,EAAQukC,EAAa9G,EAAO7tB,EAAQuzB,EAAYC,GACnE,MAAM,gBAAE3oB,GAAoBza,EAE5BukC,GAAevkC,EAAOmT,oBAClBiwB,GACApjC,EAAOc,OAAOhqB,KAAK2mD,GAEnB0F,IACA1oB,EAAgBrF,eAAexF,GAC/B5P,EAAOiF,SAEX,IAAIs+B,EAAMvjC,EAAOqT,OAAM,GACvB,OAAOkwB,EAAI35B,OAAOjyB,OAAS,EAAI4rD,EAAM,EACzC,CAMA,UAAAiB,CAAW3S,GACP,OAAQA,GAAkBiR,EAAsBG,eAC3CpR,GAAkBiR,EAAsBC,yBACjD,CAMA,uBAAA0B,CAAwB/5C,GACpB,OAAQA,GACJ,KAAK+3C,EACL,KAAKF,EACD,OAAO,EAGf,OAAO,CACX,CAOA,gBAAAhhB,CAAiBhhB,EAAWsM,EAAQprB,EAAOue,GACvC,IAAI,KAAEtV,GAASmiB,EACf,MAAM,MAAE7S,GAAUgG,EAClB,GAAIA,EAAOuiB,WAAW5qC,OAAS,EAAG,CAC9B,MAAM6sC,EAAOxkB,EAAOuiB,WAAW,GAC/BvoB,GAAOwd,QAAQ,yBACX7F,EAAMna,IAAI,4CACVD,QAAQC,IAAK/V,IAGborB,EAAOglB,gBAAkBiR,EAAsBC,2BAE3C/tD,KAAKyvD,wBAAwBjgB,EAAKwb,eAC9BhgC,EAAOgZ,WAAwD,GAA1ChZ,EAAOpnB,KAAK09B,YAAYjzB,QAAQ5B,GACrD+iC,EAAKwb,YAAcsC,EAEnB9d,EAAKwb,YAAcmE,EAInC,CACIt3B,EAAOgO,WACPnwB,EAAO43C,GAEXz1B,EAAOniB,KAAOA,CAGlB,CACA,cAAAg6C,CAAenkC,EAAWsM,EAAQ7M,EAAQyV,EAAS8nB,GAC/C,OAAO1wB,EAAO/P,MAClB,CACA,cAAO0qB,CAAQlmC,GACX,GAAIA,KAAQ6gD,EACR,OAAOA,EAAsB7gD,GAEjC,IAAIkc,EAAI,KACJmnC,EAAQrjD,EAAO,aACnB,MAAMsjD,EAAWC,EACjB,IACIpoD,EADK,IAAI3H,SAAS,MAAO,UAAU6vD,oBAAwBA,MACpD7sD,MAAM8W,WAAY,CAACg2C,IAC9B,GAAInoD,EAGA,OAFA+gB,EAAI,IAAI/gB,EACR0lD,EAAsB7gD,GAAQkc,EACvBA,EAEX,MAAM,IAAIzY,MAAM,gCACpB,CAUA,oBAAA+/C,CAAqBjpB,EAASpG,EAASzV,EAAQwkB,GAC3C,IAAIugB,EAAW,GAgBf,OAfI/kC,EAAO2a,MAAQ,IACV6J,EAAKpJ,cAAwC,GAAvBoJ,EAAK8N,QAAQ36C,SAKhC6sC,EAAK2V,YAAYxiD,QAAU6sC,EAAK8N,QAAQ1oB,OAAOjyB,QAC/CqoB,EAAOiF,QAEX8/B,EAAW/kC,EAAOqT,OAAM,GAAQoC,IAGpCzV,EAAOiF,QACP8/B,EAAW/kC,EAAOqT,OAAM,IAErB,CAAE0xB,WACb,CAOA,0BAAA9G,CAA2B19B,EAAWykC,EAAahlC,GAAQ,GAAEu9B,EAAE,KAAE/Y,IAE7D,MAAM,OAAE1nB,EAAM,KAAEpS,EAAI,SAAEmwB,EAAQ,eAAEgX,GAAmBmT,EACnD,IAAIC,EAAOpT,GAAkBiR,EAAsBG,eAAkB,EACjEiC,GAAY,EAmBhB,GAlBIpoC,EAEIA,EAAOpS,KADPu6C,EACc3C,EAIA53C,GAIlBw6C,EAAaF,EAAYt6C,MAAQ05C,EAC7Ba,EACAD,EAAYt6C,KAAO43C,EAGnBttD,KAAKsvD,oCAAoCU,EAAahlC,IAG1D6xB,GAAkBiR,EAAsBC,2BAExC,GAAI/tD,KAAKmwD,yBAAyBnlC,IAC7Bu9B,EAAG5lD,OAAS,EAAI,CACjBqoB,EAAOkT,aACPlT,EAAOmT,oBACPnT,EAAOya,gBAAgBrF,eAAemoB,GACtCv9B,EAAOiF,QACP,IAAIwQ,EAAUzV,EAAOqT,OAAM,GAC3BrT,EAAOsT,qBACPtT,EAAOya,gBAAgBrF,eAAeK,GACtC8nB,EAAK,EACT,OAGA,GADA2H,EAAYA,GAAc1gB,GAAMwb,aAAesC,EAC3C4C,EAAW,CACXllC,EAAOkT,aACPlT,EAAOmT,oBACPnT,EAAOya,gBAAgBrF,eAAemoB,GACtCv9B,EAAOiF,QACP,IAAIwQ,EAAUzV,EAAOqT,OAAM,GAC3BrT,EAAOsT,qBACPtT,EAAOya,gBAAgBrF,eAAeK,GACtC8nB,EAAK,EACT,CAEJ,MAAO,CAAEA,KACb,CACA,wBAAA4H,EAAyB,OAAEv1B,EAAM,UAAEoJ,IAC/B,OAAOA,GAAapJ,EAAOl4B,MAAM,MAAMC,OAAS,CACpD,CAQA,gBAAA8wC,CAAiB/9B,EAAMklB,EAAQuxB,GAC3B,OAAOvxB,EAASuxB,CACpB,CAQA,kCAAA9C,CAAmC99B,EAAWsb,EAASpG,EAAS+O,EAAMxkB,GAClE,MAAM,OAAElD,EAAM,QAAEkf,GAAYH,EAC5B,IAAIupB,GAAe,EACnB,GAAItoC,EAAQ,CACR,MAAM,KAAEpS,EAAI,OAAEgV,EAAM,mBAAE68B,GAAuBz/B,EAC7C,GAAIy/B,GACA,GAAK78B,EAAO/nB,OAAS,EACb+S,GAAQ43C,IAERtiC,EAAOkT,aACIlT,EAAOya,gBACbrF,eAAeK,GACpBzV,EAAOiF,QACPwQ,EAAUzV,EAAOqT,OAAM,GACvBrT,EAAOsT,qBACPtT,EAAOc,OAAOhqB,KAAK2+B,GACnBA,EAAU,SAEX,GAAIuG,IAAYhc,EAAOya,gBAAgBxG,QAAS,CACnD,IAAI9xB,EAAI6d,EAAO4P,OACfztB,EAAI6d,EAAOqT,OAAM,GAAQlxB,EACzB6d,EAAOc,OAAOhqB,KAAKqL,EAAIszB,GACvBA,EAAUzV,EAAOqT,OAAM,GACvBvW,EAAOpS,KAAO63C,CAClB,OAEA6C,GAAe,CAEvB,CAEI3vB,GAAS3U,QAAQnpB,OAAS,GAC1BqoB,EAAOc,OAAOhqB,QAAQ2+B,EAAQ3U,QAE9B2U,GAASS,YAAYv+B,OAAS,GAC9BqoB,EAAOkW,WAAWp/B,QAAQ2+B,EAAQS,YAItC,MAAMmvB,EAAarlC,EAAOuiB,WAAW5qC,OAAS,EAAKqoB,EAAOuiB,WAAW,GAAK,KACrE6iB,GAGGC,GAAaA,EAAU9pB,WACvBhb,EAAUo3B,mBAAmB0N,EAAU9pB,SAAUvb,GACjDqlC,EAAU9pB,SAAW,MAED,iBAAb,EACPvb,EAAOoV,eAAeK,EAASoG,GAE/B7b,EAAOya,gBAAgBrF,eAAeK,IAT1CzV,EAAOya,gBAAgBrF,eAAeK,GAYtCuG,GAAWqpB,GAEPA,EAAUrF,aAAejW,IAEzBsb,EAAUrF,YAAc6C,EACxB7iC,EAAO8d,SAAWunB,EAAUx4B,OAAOniB,KAC7B43C,EAGlB,CAOA,yBAAA1I,CAA0B/sB,EAAQ7M,EAAQwkB,GACtCA,EAAOA,GAAQxkB,EAAOolB,eACtB,IAAI,QAAEkN,EAAO,YAAE0N,GAAgBxb,GAAQ,CAAC,EACxC,MAAM8gB,EAAgB9gB,GAAM3X,QACtB,eAAEglB,GAAmBhlB,EAC3B,IAAI,aAAEyQ,EAAY,SAAEQ,EAAQ,UAAEvd,GAAcP,EAC5C,OAAQ6xB,GACJ,KAAKiR,EAAsBG,cACvB3lB,GAAe,EACfQ,EAAWwkB,EACX,MACJ,KAAKQ,EAAsBC,0BAEvB,GAAKzQ,GAAS36C,OAAS,GAAOqoB,EAAOoe,aAAazmC,OAAS,GAAOqoD,IAAgBoE,GAAiBpE,GAAesC,EAAgB,CAC9HhlB,GAAe,EACf0iB,EAAcjW,EACdvF,EAAKwb,YAAcjW,EACnBvF,EAAK3X,OAAOniB,KAAOsV,EAAO8d,SAAWsmB,EACrC,MAAMmB,EAAW14B,EAAO24B,uBACxB,IAAIC,EAA6BjlD,MAAZ+kD,EAAwB,IAAMA,EACnD,GAAIE,EAAgB,CAChB,IAAIjoC,EAAI2Z,EAAqBC,WAAW7W,EAAWklC,EAAgB54B,EAAQ7M,GAC3EA,EAAOya,gBAAgBp/B,QAAQmiB,EACnC,CACA+C,EAAUq2B,wBAAwBpS,EAAMxkB,GACxCsd,GAAe,EACfQ,EAAW0G,EAAK3X,OAAOniB,IAC3B,KAAO,CACH,IAAIg7C,EAAStB,EACTkB,GAAetpB,SAA6B,GAAjBsW,GAAS36C,SACpC6sC,EAAKwb,YAAcwC,GAEvBllB,GAAe,EACfQ,EAAW4nB,CACf,EAKR1lC,EAAOsd,aAAeA,EACtBtd,EAAO8d,SAAWA,CACtB,CACA,mBAAAygB,CAAoB7zC,EAAMsV,GACdtV,IACC83C,IACD93C,EAAO63C,GAGfviC,EAAO8d,SAAWpzB,EAClBsV,EAAOgZ,UAAYhkC,KAAK2wD,YAAYj7C,EACxC,CACA,WAAAi7C,CAAYj7C,GACR,OAAOA,GAAQ63C,CACnB,CAIA,iBAAAzE,EAAkB,OAAEjxB,EAAM,OAAE7M,EAAM,OAAE6K,EAAM,QAAE4K,EAAO,MAAEC,EAAK,YAAE0mB,GAAc,IACtE,OAAOvxB,EAAO,CAAEgC,SAAQ4I,UAASC,QAAO0mB,eAAep8B,EAC3D,CAMA,6BAAA4lC,CAA8BC,EAAK7lC,GAC/B6lC,EAAI7F,YAAc6C,CACtB,CAOA,oBAAA9B,CAAqBxgC,EAAW2hB,EAAaliB,GAGzC,GAFAkiB,EAAYoU,gBAAiB,EAC7B/1B,EAAUqyB,YAAY5yB,IACjBA,EAAO8lC,qCAAsC,CAC9C,IAAIC,EAAM/lC,EAAOqT,OAAM,GACvB,GAAI0yB,EAAIpuD,OAAS,EACb,MAAM,IAAIoN,MAAM,oCAAsCghD,EAE9D,CACA7jB,EAAYx3B,KAAO83C,EACnB,MAAM,OAAE1lC,GAAWolB,EACfplB,IACAA,EAAOpS,KAAOq/B,EAEtB,CAQA,yCAAAiU,CAA0Cz9B,EAAWykC,EAAahlC,GAC9D,MAAM,KAAEtV,GAASs6C,EACjB,GAAQt6C,IACC43C,EAAL,CAEI,IAAI7sB,EAAUzV,EAAO4P,OACrB5P,EAAOmT,oBACP,IAAI4xB,EAAW/kC,EAAOqT,OAAM,GACxBoC,EAAQ99B,OAAS,GACjBqoB,EAAOc,OAAOhqB,KAAK2+B,GAEvBzV,EAAOya,gBAAgBrF,eAAe2vB,GACtCC,EAAYt6C,KAAOq/B,CACd,CAEjB,CACA,4BAAAic,CAA6Bn5B,EAAQ7M,GACjC,MAAM,KAAEtV,GAASmiB,EACjB,IAAIk4B,EAAW/kC,EAAO4P,OAGtB,OADAm1B,GAAY/kC,EAAOqT,OAAM,GAClB0xB,CACX,CACA,gBAAA1N,CAAiBxqB,EAAQ7M,GAErB6M,EAAOniB,KAAO+3C,EACdztD,KAAKsvD,oCAAoCz3B,EAAQ7M,EACrD,CACA,oBAAAimC,CAAqB9L,EAAavqB,GAC9B,MAAO,CAACuqB,EAAavqB,GAAQh8B,KAAK,KACtC,CACA,uBAAAsyD,CAAwBr5B,EAAQmrB,EAAQh4B,GACpC,IAAI,KAAEtV,GAASmiB,EACXtwB,EAAIy7C,EAYR,OAXQttC,IACC+3C,IACDziC,EAAOkT,aACPlT,EAAOmT,oBACPnT,EAAOc,OAAOhqB,KAAKyF,GACnBA,EAAIyjB,EAAOqT,OAAM,GACjBrT,EAAOsT,qBACP5oB,EAAOq/B,GAGfld,EAAOniB,KAAOA,EACPnO,CACX,GAWJ,MAAM,gBAAE4pD,GAAoB,EAAQ,MAC9B,UAAEpc,EAAS,cAAEuY,EAAa,eAAEE,EAAc,aAAED,EAAY,wBAAEK,EAAuB,gBAAEC,EAAe,mBACpGJ,EAAkB,qBAAEC,EAAoB,kBAAEyB,EAAiB,YAAEC,EAC7D,sBAAEtB,EAAqB,eACvBlb,GAAmB,EAAQ,OACzB,iBAAEvpB,GAAqB,EAAQ,OAC/B,WAAErH,EAAU,MAAE2E,GAAU,EAAQ,MAChC,iBAAE8gB,GAAqB,EAAQ,KAC/B,qBAAEtF,GAAyB,EAAQ,MAGnC0tB,EAAU,CACZsB,kB,4BCn3BJnyD,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAcpD9O,EAAQo3C,UAXU,EAYlBp3C,EAAQ2vD,cAPc,EAQtB3vD,EAAQ6vD,eAXe,EAYvB7vD,EAAQ4vD,aAVa,EAWrB5vD,EAAQiwD,wBATwB,EAUhCjwD,EAAQ8vD,mBAbmB,EAc3B9vD,EAAQ+vD,qBAVqB,EAW7B/vD,EAAQkwD,gBAjBgB,EAkBxBlwD,EAAQwxD,kBAXkB,GAY1BxxD,EAAQyxD,YAXY,GA+BpBzxD,EAAQmwD,sBAAwB,CAC5B,iBAAIG,GACA,OAhBc,CAiBlB,EACA,qBAAImD,GACA,OAjBkB,CAkBtB,EACA,iBAAIC,GACA,OAlBc,CAmBlB,EACA,iBAAIC,GACA,OAlBc,CAmBlB,EACA,6BAAIvD,GACA,OAnB0B,CAoB9B,EACA,qCAAIwD,GACA,OApBkC,CAqBtC,GAIJ5zD,EAAQi1C,eAAiB,CACrBmC,UA/Dc,EAgEdyY,eA9DmB,EA+DnBC,mBA9DuB,EA+DvBF,aA9DiB,EA+DjBD,cA9DkB,EA+DlBM,wBA9D4B,EA+D5BC,gBApEoB,GAwExBlwD,EAAQs5C,iBAAmB,SAASpQ,EAAS7b,EAAQwkB,GAC7C,IAAI1X,EAAQ+O,EAAQnxB,KAChBq6C,EAAW,GACXtvB,EAAUzV,EAAO4P,OAEjB0hB,EAAct8C,KAAKwzC,WACvB,OAAQ1b,GACJ,KAjFK,EAgHL,KAAK,EAED9M,EAAOiF,QACPjF,EAAOmT,oBACP4xB,EAAW/kC,EAAOqT,OAAM,GACxBvG,EA/GM,EAiHN,MAhCJ,KAjFU,EAmFN,IAAIme,GAAU,EACe,GAAzBxV,EAAQ7L,OAAOjyB,QACfqoB,EAAOya,gBAAgB3vB,QACvB2qB,EAAU,GACVwV,GAAS,GAETjrB,EAAOiF,QAEX8/B,EAAW/kC,EAAOqT,OAAM,GACpB4X,GAAY8Z,EAASptD,OAAS,IAC9Bm1B,EAlGF,GAoGF,MACJ,KArGM,EAuGFi4B,EAAW/kC,EAAO4P,OAClBm1B,EAAW/kC,EAAOqT,OAAM,GAAQ0xB,EAChC,MACJ,KAvGe,EAyGXA,EAAW/kC,EAAOqT,OAAM,GAAMoC,EAC9B3I,EAxGM,EAyGN,MASJ,KArHW,EAsHH2I,EAAQ99B,OAAO,IACfqoB,EAAOiF,QACP8/B,EAAW/kC,EAAOqT,OAAM,GACxBvG,EA3HF,GA6HF,MACJ,KA1HS,IA2HHi4B,YAAYzT,EAAYwT,qBAAqBjpB,EAASpG,EAASzV,EAAQwkB,IACzE1X,EA3HM,EA4HN,MACJ,KA5HoB,EA6HhB9M,EAAOiF,QACP8/B,EAAW/kC,EAAOqT,OAAM,GAEpBvG,EADAi4B,EAASptD,OAAS,EAhIhB,EALJ,EA4IV,OADAkkC,EAAQnxB,KAAOoiB,EACRi4B,CACf,EASApyD,EAAQu5C,gCAHR,SAAyChK,EAAaliB,GAEtD,EAgBArtB,EAAQ6zD,cAVR,MACI,iBAAWC,GACP,MAJU,QAKd,CACA,eAAWC,GACP,MANQ,MAOZ,E,6BCpKJ1yD,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,iBAAE4c,GAAqB,EAAQ,OAC/B,iBAAEoe,GAAqB,EAAQ,KAC/B,eAAEkK,GAAmB,EAAQ,OAC7B,UAAEoD,EAAS,cAAEuY,EAAa,eAAEE,EAAc,aAAED,EAAY,wBAC1DK,EAAuB,mBAAEH,EAAkB,qBAC3CC,EAAoB,sBACpBI,GAA0B,EAAQ,OAEhC,MAAEnnC,GAAU,EAAQ,MAKpBgrC,EAAoB,CAAC5c,EAAWuY,GA8QtC3vD,EAAQwzD,gBA5QR,cAA8Bxf,EAC1BigB,eAAgB,EAShB,gBAAAne,CAAiB/9B,EAAMklB,EAAQuxB,GAC3B,OAAQz2C,IACC83C,EACD5yB,EAASA,EAAOwG,UAAY+qB,EAI7BrnB,MAAM2O,iBAAiB/9B,EAAMklB,EAAQuxB,EAChD,CAEA,mBAAA+B,EAAoB,QAAE5Q,EAAO,OAAEzlB,EAAM,OAAE7M,EAAM,MAAEy9B,EAAK,OAAE7tB,EAAM,WAAEuzB,EAAU,UAAEC,IACtE,GAAIpuD,KAAK4xD,cACL,OAAO9sB,MAAMopB,oBAAoBntD,UAAU,IAE/C,IAAI0L,EAAQ,GACRiJ,EAAOmiB,EAAOniB,KASlB,OARIy4C,IACA1hD,GAASmuB,EACTllB,EAAO43C,GAEXhQ,EAAUA,EAAQlc,UAClBpW,EAAOc,OAAOhqB,KAAKw7C,GACnBtyB,EAAOmT,oBAEA,CAAE1xB,QAAO6wC,QADhBA,EAAUtyB,EAAOqT,OAAM,GACE3oB,OAC7B,CAOA,eAAAysC,CAAgBzsC,EAAMsV,GAClB,OAAIA,EAAOya,gBAAgB9iC,OAAS,IAGO,GAApCgvD,EAAkBtjD,QAAQqH,EACrC,CAUA,8BAAAqzC,CAA+Bx9B,EAAWsM,EAAQ7M,EAAQyV,EAAS8P,GAC/D,IAAI,GAAEgY,EAAE,MAAE7nB,GAAU6P,EAChB8b,EAAK,GACLwF,EAAK,GACLC,EAAW9mC,EAAO4P,OAClBm3B,EAAS/mC,EAAOrjB,KAEpB,MAAM,gBAAE89B,EAAe,aAAE6C,GAAiBtd,EAC1C,IAAIgnC,GAAS,EAEThyD,KAAK4xD,gBAELE,EAAWA,EAAS1wB,WAEI,GAAxBvJ,EAAOnN,OAAO/nB,QACd0pD,EAAKyF,EACLD,EAAKE,EACDzpB,GACAtd,EAAOsd,cAAe,EACtBtd,EAAOkT,aACPlT,EAAOmT,oBACPnT,EAAOc,OAAOhqB,KAAKymD,EAAGjnB,aACtB+qB,GAAMrhC,EAAOqT,OAAM,GACnBrT,EAAOsT,uBAEP+tB,GAAM9D,EACNsJ,GAAMnxB,GAEV+E,EAAgB3vB,QAChB2vB,EAAgBrF,eAAe,CAACxF,OAAOyxB,EAAI1kD,KAAKkqD,IAChDpsB,EAAgBxE,cAChB+wB,GAAS,IAEThnC,EAAOya,gBAAgB3vB,QACvBkV,EAAOya,gBAAgBrF,eAAe0xB,GAElC9xD,KAAK4xD,cACA/5B,EAAOniB,MAAQ63C,GAA0C,GAAxB11B,EAAOnN,OAAO/nB,SAEhDqoB,EAAOya,gBAAgBrF,eAAemoB,EAAGnnB,WACzC4wB,GAAS,GAGRn6B,EAAOniB,MAAQ63C,GAA0C,GAAxB11B,EAAOnN,OAAO/nB,SAEhDqoB,EAAOklB,cAAc,CAAEp6B,OAAO,IAC9BkV,EAAOya,gBAAgBrF,eAAemoB,EAAGnnB,WACzCpW,EAAO8kB,uBACRkiB,GAAS,IAIpB,IAAIC,EAA4B,GAAjBp6B,EAAOnN,OAChBqqB,EAAYwY,EAoBlB,OAnBIyE,IACAzJ,EAAK,GACLsJ,EAAK,IAIT7mC,EAAO8d,SAAWmpB,EAClBjnC,EAAOgZ,UAAYhkC,KAAK2wD,YAAYsB,GAChC1J,GAAO1wB,EAAOglB,gBAAkBiR,EAAsBsD,oBACtDpmC,EAAOya,gBAAgBrF,eAAemoB,EAAGnnB,WACzC4wB,GAAS,GAETA,IACAzJ,EAAK,GACLsJ,EAAK,IAGTthB,EAASgY,GAAKA,EACdhY,EAAS7P,MAAQmxB,EACVthB,CACX,CAaA,aAAA8e,CAAc/R,EAASmL,EAAO7tB,EAAQuzB,EAAYC,EAAWhD,EAAgB6D,EAAY7d,GACrF,MAAM,gBAAE1S,GAAoB/X,EAAMG,QAClC,IAAIynC,EAAM,GA0BV,OAzBI9F,EAAM9lD,OAAS,IACf4rD,GAAO9F,GAEP7tB,EAAOj4B,OAAS,IAChB4rD,GAAO3zB,GAcX0iB,EAAW8N,EAA8B9N,GAXjClM,IAEA1S,EAAgBoD,oBAAoBsP,EAAU,WAC9CkM,EAAUlM,EAASxjB,cAAchvB,KAAK,KAGnC0+C,EAAQlc,WAMdphC,KAAK4xD,gBACN5mC,OAAOmT,oBACPnT,OAAOya,gBAAgBrF,eAAemuB,EAAIjtB,aAC1CtW,OAAOiF,QACPs+B,EAAMvjC,OAAOqT,OAAM,EAAM4wB,IAEtB,CAAE3R,UAASiR,MACtB,CACA,cAAAmB,CAAenkC,EAAWsM,EAAQ7M,EAAQyV,EAAS8nB,GAC/C,IAAI8D,EAAK,GAMT,OAL4B,GAAxBx0B,EAAOnN,OAAO/nB,SACd0pD,EAAK5rB,EAAQW,UAAYmnB,EAAGjnB,YAC5BtW,EAAOoV,eAAeisB,EAAIx0B,IAGvBA,EAAO/P,MAClB,CAEA,oBAAAmpC,CAAqB9L,EAAavqB,GAC9B,MAAO,CAACuqB,EAAavqB,GAAQh8B,KAAK,GACtC,CAQA,kBAAAk+C,CAAmBvxB,EAAWsb,EAAS7b,EAAQ5L,GAAM,GACjD,IAAIqhB,EAAUzV,EAAO4P,OACrB,MAAM,OAAE9S,EAAM,YAAEwlB,GAAgBzG,GAC1B,eAAEgW,EAAc,QAAE7V,EAAO,eAAEkrB,GAAmBrrB,EACpD,IAAIsrB,EAAmB,KACfrqC,GACA+e,EAAQnxB,KAAO43C,EACfttD,KAAKsvD,oCAAoCzoB,EAAS7b,KAGlDO,EAAUyxB,yBAAyBvc,EAASoG,EAAS7b,GACjC,GAAhBA,EAAO2a,QACP3a,EAAO2d,qBAAsB,GAErC,EAGJ,OAAQkU,GACJ,KAAKiR,EAAsBG,eAEnB7uC,GAAUynB,EAAQnc,OAAO/nB,OAAS,GAAO2qC,EAAY1Y,OAAOjyB,OAAO,IACpEwvD,IAEH,MACJ,KAAKrE,EAAsByD,mCACnBnyC,GAAWynB,EAAQnc,OAAO/nB,OAAO,IAAOqkC,GAAWkrB,KACnDC,IAEJ,MACJ,KAAKrE,EAAsBsD,kBAC3B,KAAKtD,EAAsBC,0BAC3B,KAAKD,EAAsBsD,kBAE3B,KAAKtD,EAAsBuD,cAE3B,KAAKvD,EAAsBwD,cACvB,MACJ,QACI,MAAM,IAAIvhD,MAAM,iCAAiC8sC,GAE7D,CAOA,mBAAAW,EAAoB,KAAE9nC,EAAI,OAAEsV,EAAM,OAAE4P,IAChC,IAAIrI,EAAI,KAWR,OAVQ7c,IACC63C,EACG3yB,EAAOj4B,OAAS,IAChB4vB,EAAIvH,EAAOqT,OAAM,GAAQzD,GAI7B5P,EAAOiF,QAGRsC,CACX,CACA,wBAAAgrB,EAAyB,KAAE/N,EAAI,OAAExkB,IAC7B,IAAIhrB,KAAK4xD,gBAGJpiB,EAAKpJ,cAAiBpb,EAAOc,OAAOnpB,OAAS,EAAI,CAClDqoB,EAAOc,OAAOhqB,KAAKkpB,EAAO4P,QAC1B,IAAI6F,EAAUzV,EAAOqT,OAAM,GAC3BrT,EAAOya,gBAAgBrF,eAAeK,GACtCzV,EAAO8kB,sBACX,CACJ,GAIJnyC,EAAQg0C,eAAiBA,C,eC/RzB3yC,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAKpD,MAAMqc,EACFvV,OACA5L,KACAoQ,SACAuhC,cACA8Y,aAIApZ,iBAIAqZ,qBAEA,WAAIr2B,GACA,OAAOh8B,KAAKsyD,SAChB,CAEA,WAAAl9C,GACIpV,KAAKsyD,UAAY,KACjBtyD,KAAKoyD,cAAe,CACxB,CAMA,UAAA/Y,CAAWxuB,GACH7qB,KAAK+X,UACL/X,KAAK+X,SAASshC,WAAWxuB,EAEjC,CAEA,KAAAnC,GAII,OAHA/iB,IAAM,IAAI3F,KAAKuT,OACfvT,KAAKsyD,UAAYtyD,KAAK2H,KACtBmhB,EAAWC,UAAU/oB,KAAM2F,IAAK3F,KAAK2H,MAC9BhC,GACX,CAUA,gBAAOojB,CAAUf,EAAQriB,EAAKgC,EAAMugB,EAAQ8K,GACxC,MAAMu/B,EAAgBvqC,EAAOoqC,aAO7B,IAAII,EAAa7sD,EAAIgzC,cACjB8Z,EAAe9sD,EAAIoiB,WAcvB,OApBQpiB,EAAI+yC,UACG/yC,EAAI+yC,YAER15C,OAAO8S,KAAKnM,IAIbxH,SAASkJ,IACf,IAAIsgD,EAAKhgD,EAAKN,QACE,IAAN,IAGN,IAAgBmrD,EAAW1vD,MAAM6C,EAAK,CAAC0B,EAAGsgD,EAAI4K,MAG9CE,IACA9K,EAAK8K,EAAa3vD,MAAM6C,EAAK,CAACqiB,EAAQ3gB,EAAGsgD,EAAIz/B,EAAQ8K,KAEzDrtB,EAAI0B,GAAKsgD,GAAE,IAERhiD,CACX,EAGJhI,EAAQmrB,WAAaA,C,4BC/ErB9pB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IACtD,MAAMimD,EAAelyD,OACfmyD,EAAc,MAChB,MAAMC,EAAMF,EAAa5zD,UAAU6K,KACnC,IAAiD,IAA7CipD,EAAI1hD,WAAW7C,QAAQ,iBACvB,OAAOukD,EACX,MAAM,IAAI7iD,MAAM,6BACnB,EALmB,GAMd8iD,EAAc,MAChB,MAAMD,EAAMF,EAAa5zD,UAAUgS,KACnC,IAAiD,IAA7C8hD,EAAI1hD,WAAW7C,QAAQ,iBACvB,OAAOukD,EACX,MAAM,IAAI7iD,MAAM,6BACnB,EALmB,GASpB,MAAMinC,EACFpa,SAAoB,GACpB,WAAO8c,GACH1C,GAAa,EAAW9qB,QAAQ,CAC5BviB,KAAM+oD,EAAa5zD,UAAU6K,KAC7BmH,KAAM4hD,EAAa5zD,UAAUgS,OAEjC4hD,EAAa5zD,UAAU6K,KAAOgpD,EAC9BD,EAAa5zD,UAAUgS,KAAO+hD,CAClC,CACA,cAAO5Y,GACH,MAAM5d,EAAK2a,GAAa,EAAWvgC,QAC/B4lB,IACAq2B,EAAa5zD,UAAU6K,KAAO0yB,EAAG1yB,KACjC+oD,EAAa5zD,UAAUgS,KAAOurB,EAAGvrB,KAEzC,EAGJkmC,EAAal4C,UAAU6K,KAAOgpD,EAC9B3b,EAAal4C,UAAUgS,KAAO+hD,EAE9Bl1D,EAAQq5C,aAAeA,C,eCxCvBh4C,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAmBpD9O,EAAQkvD,qBAbR,MAKI78C,QAKA9P,K,4BChBJlB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAUtD9O,EAAQm1D,yBAPR,MAKIC,c,4BCRJ/zD,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,WAAEg3B,GAAe,EAAQ,OACzB,MAAE9c,GAAU,EAAQ,MAuZ1BhpB,EAAQ8pC,iBAvYR,MAMI9mC,OAAQ,EAKR8kD,+BAAgC,EAKhCuN,wBAIAjwC,MAAQ,CACJihB,UAAW,EACXrjC,MAAO,EACPC,IAAK,GAKT8pB,OAAS,GAMTje,MAKA80C,eAKA+F,SAAU,EAKVhF,SAAW,KAKXxV,eAAgB,EAOhBwS,sBAAuB,EAKvByG,UAEA,oBAAIkN,GACA,OAAkC,IAA1BjzD,KAAKkzD,kBAAqD,MAAtBlzD,KAAKysD,aACrD,CAMA,kBAAAvQ,EAAmB,YAAC/N,EAAW,WAAElG,IAC7B,MAAM,OAAEvd,GAAW1qB,KAGnB,GADAioC,GADgBvd,EAAO/nB,OAAO,EAAI+nB,EAAOA,EAAO/nB,OAAO,GAAGk1B,OAAS,OACzCoQ,EACX,CACX,MAAM,QAAEhE,GAAYkK,GACd,IAAEvtC,EAAG,UAAEyyC,EAAS,MAAEjsC,GAAU6gC,EAClC,GAAe,GAAXoL,EAEA,OAAO5P,EAAW0vB,oBAAoB/rD,IAAUA,EAAMuC,KAAKs6B,GAE1D,GAAe,GAAXoP,EAEL,OAAO5P,EAAW0vB,oBAAoBvyD,IAASA,EAAI+I,KAAKs6B,EAEhE,CACA,OAAO,CACX,CACA,UAAAoI,GAEI,OAAO1lB,EAAM6lC,cAAcxsD,KAC/B,CACA,WAAAoV,GACI,IAAIg+C,EACAC,EACAC,EACAC,EACAC,EACAC,GAAY,EACZC,GAAa,EACbC,EAAgB,KAChBC,EAAc,KACdC,EAAsB,CAAC,EACvBC,GAAkB,EAClBC,EAAe,EACfC,EAAa,KACbC,EAAc,KACdC,GAAW,EACXC,EAAU,KAIdn1D,OAAOD,eAAeiB,KAAM,OAAQ,CAChC2M,IAAG,IAAYonD,EACf,GAAAvmD,CAAI+c,GACIA,GAAKwpC,IACLA,EAAexpC,EAEvB,IAMJvrB,OAAOD,eAAeiB,KAAM,iBAAkB,CAC1C,GAAA2M,GACI,QAAQ3M,KAAY,SAAI8zD,CAC5B,EAAG,GAAAtmD,CAAI+c,GACH,GAAkB,kBAAP,EACP,MAAM,IAAIxa,MAAM,qBAEhB/P,KAAKgnC,UACL8sB,EAAkBvpC,EAE1B,IAGJvrB,OAAOD,eAAeiB,KAAM,SAAU,CAAE2M,IAAG,IAAYymD,IACvDp0D,OAAOD,eAAeiB,KAAM,oBAAqB,CAAE2M,IAAG,IAAYknD,IAClE70D,OAAOD,eAAeiB,KAAM,UAAW,CACnC2M,IAAG,IAAY8mD,EAAc,GAAAjmD,CAAIf,GAE7B,GAAc,OAAVA,EACA,MAAM,IAAIsD,MAAM,6BAEpB0jD,EAAYhnD,CAChB,IAEJzN,OAAOD,eAAeiB,KAAM,WAAY,CACpC2M,IAAG,IACQ+mD,IAGf10D,OAAOD,eAAeiB,KAAM,SAAU,CAAE2M,IAAG,IAAY0mD,IACvDr0D,OAAOD,eAAeiB,KAAM,WAAY,CAAE2M,IAAG,IAAY2mD,IAEzDt0D,OAAOD,eAAeiB,KAAM,QAAS,CAAE2M,IAAG,IAAY4mD,IACtDv0D,OAAOD,eAAeiB,KAAM,QAAS,CAAE2M,IAAG,IAAYwnD,IAEtDn1D,OAAOD,eAAeiB,KAAM,OAAQ,CAAE2M,IAAG,IAAY6mD,IACrDx0D,OAAOD,eAAeiB,KAAM,cAAe,CACvC2M,IAAG,IAEuB,MAAjBgnD,GAA4CnoD,MAAjBmoD,EACrBJ,EAAQ,GACZI,EAEX,GAAAnmD,CAAI+c,GACAopC,EAAgBppC,CACpB,IAEJvrB,OAAOD,eAAeiB,KAAM,YAAa,CACrC2M,IAAG,IAAYinD,EAAgB,GAAApmD,CAAI+c,GAC/BqpC,EAAcrpC,CAClB,IAEJvrB,OAAOD,eAAeiB,KAAM,8BAA+B,CACvD,GAAA2M,GACI,MAAM,OAAEkrB,GAAW73B,KACnB,OAAO63B,EAAO0R,6BACH1R,EAAOglB,gBAAkBhlB,EAAOovB,2BAG/C,EAAG,GAAAz5C,CAAI+c,IArMnB,SAAYA,EAAG6pC,GACX,MAAMp0B,SAAW,EACjB,OAA6B,GAArBo0B,EAAM/lD,QAAQkc,KAAmC,GAArB6pC,EAAM/lD,QAAQ2xB,EACtD,EAmMoBvuB,CAAG8Y,EAAG,CAAC,eAAW/e,EAAW,gBAC7BxL,KAAKixC,QAAQ1H,4BAA8Bhf,EAEnD,IAGJvrB,OAAOD,eAAeiB,KAAM,UAAW,CACnC2M,IAAG,IACQunD,IAGfl1D,OAAOD,eAAeiB,KAAM,eAAgB,CACxC2M,IAAG,IACQqnD,IAGfh1D,OAAOD,eAAeiB,KAAM,YAAa,CACrC2M,IAAG,IACQsnD,IAQfj0D,KAAK6gD,IAAM,UAAU,OAAEhpB,EAAM,SAAEkc,EAAQ,MAAE3Q,EAAK,KAAEx/B,EAAI,OAAEkkB,EAAM,SAAEP,EAAQ,WAAEisB,EAAU,UAAEzG,EAAS,MAAE/pC,GAAQ,EAAG,MAAE6D,IACxGwsD,EAAWx7B,EACXy7B,EAAavf,EACbwf,EAAUnwB,EACV+wB,EAAUttD,EACV2sD,EAAS5vD,EACTwvD,EAAWtrC,EAEX2rC,EAAY57B,EAAOmP,QACnB0sB,EAAa77B,EAAOgO,UAAY2N,EAAWgc,WAAW33B,EAAOglB,gBAC7DmX,EAAazsC,EACb0sC,EAAclnB,EACdmnB,EAAUlxD,EAGV,SAAWolB,EAAG6oB,GACV,MAAM1jB,EAAQvuB,OAAO8S,KAAKsW,GACpBisC,EAAUr1D,OAAO8S,KAAKm/B,GAC5B,CAAC,UAAW,WAAY,eAAgB,+BAA+B9yC,SAAQqqB,WACpE6rC,EAAQA,EAAQhmD,QAAQma,GAAG,IAEtC6rC,EAAQl2D,SAAQkJ,IAEZ,IAAyB,GAArBkmB,EAAMlf,QAAQhH,GAEd,YADAkb,QAAQC,IAAI,4BAA8Bnb,EAAI,KAGlD,IAAIwkC,EAAK7sC,OAAOyO,yBAAyBwjC,EAAS5pC,KAC7CwkC,GAAOA,EAAM,KAAKA,EAAGn/B,WAEtB1N,OAAOD,eAAeqpB,EAAG/gB,EAAG,CAAEsF,IAAG,IAAYskC,EAAQ5pC,IACzD,GAEP,CAlBD,CAkBGrH,KAAMqzD,EACb,CACJ,CAIA,kBAAInB,GACA,MAAM,kBAAE1G,GAAsBxrD,KAC9B,OAAOwrD,GAAsB,YAAaA,CAC9C,CACA,sBAAIpJ,GACA,OAAOpiD,KAAK63B,QAAQuqB,kBACxB,CAEA,oBAAIxO,GACA,OAAO5zC,KAAK63B,QAAQ+b,gBACxB,CACA,sBAAIC,GACA,OAAO7zC,KAAK63B,QAAQgc,kBACxB,CACA,sBAAIC,GACA,OAAO9zC,KAAK63B,QAAQic,kBACxB,CACA,iBAAIiX,GACA,OAAO/qD,KAAK63B,QAAQkzB,aACxB,CAIA,eAAI1E,GACA,OAAOrmD,KAAK63B,QAAQwuB,WACxB,CAEA,mBAAI7D,GACA,IAAI55B,EAAI5oB,KAAK63B,QAAQ4qB,YACjBqF,SAAe,EACnB,MAAa,UAATA,EACOl/B,EAEE,WAATk/B,EACQl/B,EAAgB,QAAZpd,EAETod,CACX,CAIA,mBAAI6zB,GACA,OAAIz8C,KAAK63B,QAAQwuB,aAGVrmD,KAAK+qD,eAA0C,GAAxB/qD,KAAKojC,MAAM,GAAGzgC,MAChD,CAIA,sBAAI4kD,GACA,OAAOvnD,KAAKgnC,UAAYhnC,KAAKylD,6BACjC,CAEA,SAAIziD,GACA,OAAOhD,KAAKojC,OAAOpgC,KACvB,CACA,UAAIspB,GACA,OAAOtsB,KAAKojC,OAAO9W,MACvB,CACA,QAAIhgB,GACA,OAAOtM,KAAK63B,QAAQvrB,IACxB,CACA,YAAIsb,GACA,OAAO5nB,KAAK63B,QAAQjQ,QACxB,CACA,eAAI6V,GACA,OAAOz9B,KAAK63B,QAAQ4F,WACxB,CACA,iBAAIqgB,GACA,OAAO99C,KAAK63B,QAAQimB,aACxB,CACA,eAAIp2B,GACA,OAAO1nB,KAAK63B,QAAQnQ,WACxB,CACA,wBAAIiB,GACA,OAAO3oB,KAAK63B,QAAQlP,oBACxB,CACA,gBAAIitB,GACA,MAAM,aAAEA,GAAiB51C,KAAK63B,OAC9B,OAAO+d,GAAgB,MAC3B,CAIA,aAAIvC,GACA,OAAOrzC,KAAK63B,OAAOwb,SACvB,CAMA,kBAAIihB,GAEA,OAAO,CACX,CAIA,SAAItvC,GACA,OAAOhlB,KAAK63B,QAAQ7S,KACxB,CAKA,QAAA9T,GACI,MAAO,sBAAwBlR,KAAK63B,QAAQ3mB,WAAa,GAC7D,CAKA,qBAAIszC,GACA,MAAM98C,EAAI1H,KAAK0sC,YACf,GAAiB,iBAAP,EAAgB,CACtB,IAAI,kBAAE8X,GAAsB98C,GAAK,CAAC88C,mBAAkB,GACpD,OAAOA,CACX,CACA,OAAOxkD,KAAKwkD,iBAEhB,CAQA,iBAAAuC,CAAkBnmD,GAAK,UAACoiB,IACpB,OAAQhjB,KAAKojC,MAAMpgC,OAASpC,EAAIoC,OAC5BhD,KAAK6G,MAAMmc,WAAaA,CAChC,E,8BCvZJhkB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,WAAEqc,GAAe,EAAQ,OACzB,qBAAED,GAAyB,EAAQ,OACnC,MAAElC,GAAU,EAAQ,OACpB,WAAE8c,GAAe,EAAQ,OACzB,UAAEpc,GAAc,EAAQ,OACxB,qBAAEwlC,GAAyB,EAAQ,OACnC,YAAE0H,GAAgB,EAAQ,MAC1B,yBAAEzB,GAA6B,EAAQ,MAqB7C,MAAMlsC,EAIFmoC,kBAIAyF,UAIAptD,MAMA8hB,eAIAhf,MAIAtJ,IAMA6zD,YAMAC,MAKAC,cAKAzX,gBAKA5wC,KAKAy4C,YAIAt9B,QAIAH,QAIAC,SAKAse,SAKAmB,QAMAuC,4BAKA2pB,iBAKAzG,cAMAmI,oBAMA3N,4BAOAhF,uBASAvG,eAIAmZ,iBAKAltC,oBAAqB,EAMrBD,YAMAiB,qBAMA03B,mBAKAvC,cAKArgB,YAKA7V,SAKAuhC,kBAMA3hC,UAMAw4B,eAMAC,kBAMA6U,oBAKAjY,eAAiB,EAOjB2T,uBAKA9jB,YAMAnG,SAMA1e,WAOA+tB,aAMA/G,gBAKA+H,eAOA5S,WAAY,EAKZ+wB,oBAKA/vC,MAOAgwC,UAMAvS,YAOAwS,KAKA9rB,cAMAqb,kBAKA,WAAApvC,GACIpV,KAAKunB,SAAW,GAChBvnB,KAAKgnC,SAAU,EACfhnC,KAAK07C,gBAAiB,EACtB17C,KAAK60D,kBAAmB,EACxB70D,KAAKy0D,YAAc,EACnB,IAAIrB,EAAW,KACX8B,GAAc,EAElBl2D,OAAOD,eAAeiB,KAAM,SAAU,CAClC2M,IAAG,IAAYymD,EAAa,GAAA5lD,CAAI+c,GAC5B,KAAU,MAALA,GAAeA,aAAa3D,GAG7B,MAAM7W,MAAM,0BAFZqjD,EAAW7oC,CAGnB,IAEJvrB,OAAOD,eAAeiB,KAAM,cAAe,CACvC2M,IAAG,IACQuoD,EACR,GAAA1nD,CAAI+c,GACH2qC,EAAc3qC,CAClB,GAER,CACA,gBAAO4qC,CAAUF,GACb,OAAOxxB,EAAW0xB,UAAUF,EAChC,CACA,UAAAltC,CAAWC,EAAQC,EAAWtgB,EAAMugB,EAAQC,GAMxC,MAAM,SAAEvB,EAAQ,YAAEyB,EAAW,YAAExB,GAAgBF,EAAMG,QAC/CsB,EAAIpoB,KACJunB,EAAWZ,EAAM2B,wBAAwBN,EAAQpB,EAAUyB,GAC3Db,EAAYb,EAAMqC,4BAClBT,EAAgBkb,EAAW2xB,YAAYhtC,GACvCitC,EAAkB1uC,EAAMsC,qBAAqBb,GAyB7CM,EAAQ,CACV,eAAAw0B,CAAgBj0C,EAAG+e,GACf,GAAkB,iBAAP,EAAiB,CACxB,MAAM,8BAAEib,GAAkCtc,EAAMG,SAC1C,WAAEoc,GAAej6B,EACvB,IAAI,SAAE2e,GAAa3e,EAInB,OAHI2e,IACAA,EAAWytC,EAAgBztC,EAAUI,IAElC,IAAIib,EAA8BC,EAAYtb,EACzD,CACA,OAAO3e,CACX,EACA,WAAAw5C,CAAYx5C,EAAG+e,GACX,MAAM8/B,SAAe,GACf,yBAAEzlB,GAA6B1b,EAAMG,QACrCwuC,EAAOttC,EAAOutC,0BAA4BlzB,EAChD,GAAa,UAATylB,EAAmB,CAEnB,IAAIl/B,EAAI,IAAI0sC,EAEZ,OADAxsC,EAAWC,UAAUf,EAAQY,EAAG3f,GACzB2f,CACX,CACA,GAAa,WAATk/B,EACA,OAAO7+C,EAEX,GAAa,UAAT6+C,EACA,OAAO7+C,EAEX,MAAM,IAAI8G,MAAM,0BACpB,EACA,QAAAwX,CAASte,EAAG+e,EAAQE,EAAQC,GACxB,IAAIlqB,EAAIspB,EAASzkB,MAAMslB,EAAG,CAACnf,EAAG+e,EAAQE,EAAQC,IAI9C,OAHAlqB,EAAEE,SAASqqB,IACPA,EAAEV,OAASM,CAAC,IAETnqB,CACX,EACAiM,MAAOqe,EACP3nB,IAAK,SAAUqI,EAAG+e,EAAQE,EAAQC,GAC9B,MAAkB,iBAAP,GAES,GAAZlf,EAAEtG,OACK8gC,EAAW+xB,WAGnBjtC,EAActf,EAAG+e,EAAQE,EAAQC,EAC5C,EACAusC,MAAOnsC,EACPnhB,MAAOmhB,EACPW,eAAgBX,EAChBb,YA3EkB,CAACze,EAAG+e,EAAQC,EAAWE,KACzC,GAAkB,iBAAP,EAIP,OADaI,EAAczlB,MAAMslB,EAAG,CAACnf,EAAG+e,EAAQC,EAAWE,IAG/D,GAAkB,iBAAP,EAAiB,CACxB,IAAIS,EAAI,IAAIC,EAEZ,OADAC,EAAWC,UAAUf,EAAQY,EAAG3f,EAAGkf,GAC5BS,CACX,CACA,GAAI/pB,MAAMuQ,QAAQnG,GAAI,CAClB,IAAIhL,EAAI,GAMR,OALAgL,EAAE9K,SAAQ8K,IACN,IAAI2f,EAAI,IAAIC,EACZC,EAAWC,UAAUf,EAAQY,EAAG3f,EAAGkf,GACnClqB,EAAE6D,KAAK8mB,EAAE,IAEN3qB,CACX,CACA,OAAO,IAAI,EAuDX+hD,eAAgBz3B,EAChBisC,UAAW,SAAUvrD,EAAG+e,GACpB,MAAM6B,SAAY,EAClB,IAAI4rC,EAAM,CAAEzlD,QAAS,KAAM9P,KAAM,MACjC,GAAU,UAAN2pB,EACA4rC,EAAIzlD,QAAU6Z,OACX,GAAI5gB,EAAG,CACV,MAAM,KAAE/I,EAAI,QAAE8P,EAAO,KAAE0lD,GAASzsD,GAC1B,WAAEouC,GAAervB,EAAOrgB,KAC9B,GAAI+tD,GAAQre,GACJqe,KAAQre,EAAY,CACpB,MAAM,KAAEn3C,EAAI,QAAE8P,GAAY,CAAE9P,KAAMw1D,EAAM1lD,QAASqnC,EAAWqe,IAG5D,OAFAD,EAAIzlD,QAAUA,EACdylD,EAAIv1D,KAAOA,EACJu1D,CACX,CAGJA,EAAIzlD,QAAUA,EACdylD,EAAIv1D,KAAOA,CACf,CACA,OAAOu1D,CACX,EACA,oBAAA9sC,CAAqB1f,EAAG+e,GACpB,IAAIY,EAAI,IAAIC,EAEZ,OADAC,EAAWC,UAAUf,EAAQY,EAAG3f,EAAGkf,GAC5BS,CACX,EACAk1B,cAAeuX,EACf53B,YAAa43B,EACbztC,SAAUytC,EACVze,eAAgBye,EAChBpV,kBAAmBoV,EACnB7tC,YACA,iBAAAunC,CAAkB9wD,EAAG+pB,GACjB,GAAe,iBAAL,EAAc,CACxB,MAAMzO,EAAI,IAAIu5C,EAEd,OADAhqC,EAAWC,UAAUf,EAAQzO,EAAGtb,GACzBA,CACP,CACJ,EACA4nC,SAAQ,CAAC5nC,EAAG+pB,IACa,kBAAP,GAAmB/pB,EAErC,OAAA+oC,CAAQ/oC,EAAG+pB,GACP,IAAI6B,SAAY,EAChB,GAAU,UAANA,EAAgB,CAChB,IAAIjB,EAAI,IAAIvB,EAEZ,OADAyB,EAAWC,UAAUf,EAAQY,EAAG3qB,GACzB2qB,CACX,CACA,MAAa,WAANiB,GAAkB5rB,CAC7B,EACA,UAAA4pB,CAAW5pB,EAAG+pB,GACV,GAAkB,iBAAP,EAAiB,CACxB,IAAIzO,EAAI,IAAIszC,EAEZ,OADAtzC,EAAEvJ,QAAU/R,EACLsb,CACX,CACA,OAAOo8C,EAAU13D,EAAG+pB,EAAQ6kC,EAChC,GASJ,IAAI1jC,EAAKT,EAAMT,GACf,OAAIkB,EACOA,EAAGrmB,MAAMslB,EAAG,CAACzgB,EAAMqgB,EAAQE,EAAQC,IAEvCxgB,CACX,CACA,aAAAgxC,CAAcC,EAAY36C,EAAG46C,GACzB,MAAMC,EAAY,CACdvxB,SAAStpB,GACEY,MAAMuQ,QAAQnR,GAEzB0qB,qBAAqB1qB,GACI,iBAAP,GAGtB,IAAIs0B,EAAIumB,EAAUF,GAClB,GAAIrmB,IAAMA,EAAEt0B,GAAI,CACZ,GAAI46C,EACA,MAAM,IAAI9oC,MAAM,IAAI6oC,mBAExB,OAAO,CACX,CACA,OAAO,CACX,CAEA,aAAIvF,GACA,MAAM,MAAEnpC,EAAK,IAAEtJ,EAAG,MAAEwG,EAAK,eAAE8hB,GAAmBlpB,KACxC41D,EAAS51D,KAAK00D,MACpB,GAAIxqD,EAAO,CACP,GAAItJ,EACA,OA/gBM,EAghBL,GAAIg1D,EACL,OA/gBQ,CAihBhB,KAAO,IAAIxuD,EACP,OAnhBM,EAohBH,GAAI8hB,EACP,OAnhBgB,CAohBpB,CACA,OAAQ,CACZ,CAIA,oBAAI0qB,GACA,IAAIprB,EAAIxoB,KAAKY,IACb,QAAI4nB,GACOib,EAAWoyB,oBAAoBrtC,EAAEtX,WAGhD,CAIA,sBAAI4iC,GACA,IAAItrB,EAAIxoB,KAAKkK,MACb,QAAIse,GACOib,EAAWoyB,oBAAoBrtC,EAG9C,CAKA,iBAAIuiC,GACA,IAAI,MAAE7gD,EAAK,IAAEtJ,GAAQZ,KACrB,SAAIkK,IAAStJ,IACFZ,KAAK8zC,oBAAsB9zC,KAAK4zC,gBAG/C,CAIA,sBAAIwO,GACA,IAAI55B,EAAIxoB,KAAKoH,MACb,QAAIohB,GACOib,EAAWoyB,oBAAoBrtC,EAG9C,CAIA,wBAAIkrB,GACA,OAAO,CACX,CACA,WAAO9mB,CAAK/B,IACJA,EAAG3gB,OAAU2gB,EAAGjqB,KAAQiqB,EAAG6pC,QAE3B7pC,EAAGjqB,IAAM6iC,EAAW+xB,aAGF,GAAjB3qC,EAAGwoB,WAAqBxoB,EAAGtD,UAAU5kB,OAAS,GAC/CkoB,EAAGtD,SAASppB,SAAQqqB,IAChBqC,EAAGirC,SAASttC,EAAE,GAI1B,CAKA,QAAAstC,CAASvyC,IACAA,EAAE+D,SAAWtnB,KAAKsnB,UACnB/D,EAAE+D,QAAUtnB,KAAKsnB,QAEzB,CACA,aAAAyuC,GACI,MAAM,MAAE7rD,EAAK,MAAE9C,EAAK,eAAE8hB,GAAmBlpB,KAEzC,OAAQA,KAAKqzC,WACT,KAnmBU,EAomBV,KAlmBY,EAmmBR,OAAOnpC,EACX,KArmBM,EAsmBF,OAAO9C,EACX,KArmBgB,EAqmBU,OAAO8hB,EAEzC,CASA,KAAAmb,CAAM9qB,EAAGyR,EAAQy7B,EAAmBniB,GAChC,IAAI9gB,EAAI,KACR,MAAM,SAAE+D,GAAavnB,KAErB,KADAskC,EAAQA,GAAStkC,KAAK+1D,iBAGf,CAEH,GAAIxuC,EAAU,CACV,MAAMwM,EAAKpN,EAAMqvC,aAAazuC,EAAUhO,EAAGyR,EAAQy7B,GACnD,QAAI1yB,GACO,CAAEvQ,EAAGuQ,EAAGkiC,OAAQztC,EAAGuL,EAAGmiC,GAAIz0D,KAAMzB,KAAMunB,SAAUA,EAAUvkB,MAAO+wB,EAAG/wB,MAAOshC,MAAOvQ,EAAGuQ,MAGpG,CACA,MAAM,IAAIv0B,MAAM,kBAAoBwJ,EACxC,CACA,OAZIiK,EAAI8gB,EAAM36B,KAAK4P,GAYZ,CAAEiK,IAAGgF,EAAGxoB,KAAMgD,OAAQ,EAAGshC,QACpC,CAEA,cAAI6xB,GAOA,MANY,CACR,EAAKn2D,KAAKkK,MACV,EAAKlK,KAAKoH,MACV,EAAKpH,KAAK00D,MACV,EAAK10D,KAAKkpB,gBAEHlpB,KAAKqzC,UACpB,CAMA,QAAAU,CAASvwB,GACL,MAAM,IAAE5iB,GAAQZ,KAChB,IAAKY,GAASZ,KAAKY,eAAe2zD,GAAgB3zD,EAAIq+B,SAC/CrY,EAASuuC,UAAUv0D,GACtB,OAAO,KAKX,GAAsB,GAAlBZ,KAAKqzC,UAAgB,CACrB,IAAI7qB,EAAIxoB,KAAKY,IAAIsQ,WACboZ,EAAM9B,EAAE4tC,YAAY,KACpBC,EAAO,GAMX,OALI/rC,EAAO9B,EAAE7lB,OAAS,IAElB0zD,EAAO7tC,EAAEgE,UAAUlC,EAAM,GACzB9B,EAAIA,EAAEgE,UAAU,EAAGlC,EAAM,IAEtB3D,EAAM2vC,aAAa9tC,EAAGhF,EAAG6yC,EAAM,MAC1C,CACA,OAAO,IACX,CACA,QAAAE,CAAS/yC,GACL,GAAsB,GAAlBxjB,KAAKqzC,UAAgB,CACrB,IAAI7qB,EAAIxoB,KAAK00D,MAAMxjD,WACfoZ,EAAM9B,EAAE4tC,YAAY,KACpBC,EAAO,GAMX,OALI/rC,EAAO9B,EAAE7lB,OAAS,IAElB0zD,EAAO7tC,EAAEgE,UAAUlC,EAAM,GACzB9B,EAAIA,EAAEgE,UAAU,EAAGlC,EAAM,IAEtB3D,EAAM2vC,aAAa9tC,EAAGhF,EAAG6yC,EAAM,QAC1C,CACA,OAAO,IACX,CAEA,QAAAnlD,GACI,IAAI,KAAE5E,EAAI,MAAEpC,EAAK,IAAEtJ,EAAG,MAAEwG,EAAK,UAAE4tD,EAAS,UAAE3hB,GAAcrzC,KAqBxD,OApBeA,KAAK00D,MACpBpoD,GAAQ0oD,EAAY,IAAMA,EAAY,IAAM,OAAS1oD,EAahDA,IACDA,EAAOwI,KAAKC,UAAU,CAClBkE,KAAMo6B,KAIP,aAAa/mC,IACxB,EAKJ,MAAMqpD,EAAY,CAAC13D,EAAG+pB,EAAQwuC,KAC1B,IAAI3sC,SAAY,EAChB,GAAU,UAANA,EAAgB,CAChB,IAAIjB,EAAI,IAAI4tC,EAEZ,OADA1tC,EAAWC,UAAUf,EAAQY,EAAG3qB,GACzB2qB,CACX,CACA,MAAa,WAANiB,GAAkB5rB,CAAS,EAItCN,EAAQipB,SAAWA,C,8BC9uBnB5nB,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD,MAAM,SAAEma,GAAa,EAAQ,MAqD7BjpB,EAAQ0qB,YAnDR,cAA0BzB,EAMtB,WAAAxR,CAAY67B,GAER,GADAnM,UACKmM,GAAaA,aAAmBrqB,GACjC,MAAM,IAAI7W,MAAM,mCAGpB,SAAUqY,EAAG6oB,GACKjyC,OAAO8S,KAAKsW,GACpBjqB,SAAQkJ,IAIV,IAAIwkC,EAAK7sC,OAAOyO,yBAAyB2a,EAAG/gB,KACvCwkC,GAAOA,EAAM,KAAKA,EAAGn/B,WAEtB1N,OAAOD,eAAeqpB,EAAG/gB,EAAG,CAACsF,IAAG,IAAWskC,EAAQ5pC,IACvD,GAEP,CAZD,CAYGrH,KAAMixC,GAETjyC,OAAOD,eAAeiB,KAAM,UAAW,CAAE2M,IAAG,IAAUskC,GAC1D,CACA,KAAA5M,CAAM9qB,EAAGyR,EAAQy7B,GACb,OAAOzmD,KAAKixC,QAAQ5M,MAAM9qB,EAAGyR,EAAQy7B,EACzC,CAKA,aAAAsP,GACI,OAAO/1D,KAAKixC,QAAQ8kB,eACxB,CACA,QAAA7kD,GACI,IAAIjI,EAAIjJ,KAAKixC,QAAQ3kC,KAMrB,OALKrD,IAC+B,GAA5BjJ,KAAKunB,SAAS8rB,YACdpqC,EAAI,UAGL,gBAAgBA,IAC3B,CACA,QAAA8qC,CAASvwB,GACL,OAAOxjB,KAAKixC,QAAQ8C,SAASvwB,EACjC,E,6BCrDJxkB,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD,MAAM,WAAEg3B,GAAe,EAAQ,MAK/B,MAAM8wB,EACFvqB,KAEA,WAAA50B,CAAYsb,EAAKma,GACb,MAAM4rB,EAAO/lC,EACb,IAAIo3B,EACJ9oD,OAAOD,eAAeiB,KAAM,SAAU,CAAC2M,IAAG,IAAU8pD,IACpDz3D,OAAOD,eAAeiB,KAAM,QAAS,CAAC2M,IAAG,IAAUm7C,IACnD9oD,OAAOD,eAAeiB,KAAM,UAAW,CAAC2M,IAAG,IAAUk+B,IAErD7qC,KAAK02D,OAAStpD,IACVqpD,EAAK30D,KAAKsL,EAAE,EAEhBpN,KAAK22D,OAAQ,KAAMF,EAAK9zD,OAAS,CAAC,EAClC3C,KAAK42D,YAAerkC,IAChBu1B,EAAQv1B,CAAC,CAEjB,CACA,QAAArhB,GACI,OAAwB,GAApBlR,KAAK81B,OAAOnzB,OACL3C,KAAK81B,OAAO,GAAG5kB,WAEnBlR,KAAKgqC,KAAKxhB,CACrB,CACA,WAAOlG,CAAK4gB,EAAY2H,GACpB,IAAK3H,EACD,OAAO,KAEX,GAAI2H,EACA,OAAO,IAAI0pB,EAAY,CAACrxB,GAAa2H,GAEzC,IAAIgsB,EAAQ,KACZ,GAAwB,iBAAd,EAAuB,CAE7B,IAAIC,GADJ5zB,EAAaA,EAAWhyB,YACHklD,YAAY,KAC7BprC,EAASkY,EAAW1W,UAAUsqC,EAAI,GAEtC,GADA5zB,EAAaA,EAAW1W,UAAU,EAAGsqC,EAAI,GAAG1yD,MAAM,GAAG,GACjD4mB,EAAO,CACP,IAAI+rC,EAAU,IACY,GAAtB/rC,EAAO3c,QAAQ,MAAU0oD,EAAQj1D,KAAK,MAChB,GAAtBkpB,EAAO3c,QAAQ,MAAU0oD,EAAQj1D,KAAK,MAChB,GAAtBkpB,EAAO3c,QAAQ,OAAUwoD,EAAQ,KAEjCE,EAAQp0D,OAAO,IACfugC,EAAa,KAAK6zB,EAAQn4D,KAAK,IAAI,IAAIskC,EAE/C,CAEJ,CACA,IAAInK,EAAM0K,EAAWuzB,UAAU9zB,GAC3BtP,EAAKmF,EAAIvQ,EAET2B,EAAU,EACV8P,EAAK,KAELL,EAAO,GACPq8B,EAAS,YACTgB,EAAM,KACNC,GAAyC,GAA1Bn+B,EAAI/N,OAAO3c,QAAQ,KAQtC,GAPA0qB,EAAI/N,OAAS+N,EAAI/N,OAAO5pB,QAAQ,IAAI,IAChCy1D,IACA99B,EAAI/N,QAAS6rC,GAKbK,EAAa,CACb,IAAIC,EAAMp+B,EAAIvQ,EAAE9lB,MAAM,MAClB00D,EAAM,GACVD,EAAIh5D,SAAQkJ,IACRA,EAAIA,EAAEi6B,YACF,KAAKxwB,KAAKzJ,KACdA,EAAIA,EAAEjG,QAAQ,OAAQ,KACtBg2D,EAAIt1D,KAAKuF,GAAE,IAGfusB,EAAKwjC,EAAIx4D,KAAK,IACdm6B,EAAIvQ,EAAIoL,CACZ,CAGA,KAAOqG,EAAKg8B,EAAOtsD,KAAKiqB,IAAI,CAExBzJ,EAAU8P,EAAGj3B,MACb,IAAIq0D,EAAYzjC,EAAGpH,UAAU,EAAGrC,GAE5ByP,EAAK93B,KAAK,IAAItB,OAAO62D,EAAWt+B,EAAI/N,SAExC,IAAIssC,EAAM1jC,EAAGpH,UAAUrC,GAGvB,GAFAyJ,EAAKqjC,EAAMK,EAAIl2D,QAAQ60D,EAAQ,OAC/BgB,EAAMxzB,EAAW8zB,UAAUN,EAAK,EAAG,GAC/BhB,EAAOnlD,KAAKmmD,GAEZ,MAAM,IAAIlnD,MAAM,4CAEpB6pB,EAAK93B,KAAK,IAAItB,OAAOy2D,EAAK,MAC1B9sC,EAAU8sC,EAAIt0D,OACdixB,EAAKA,EAAGpH,UAAUrC,EACtB,CAKA,GAJIyJ,EAAGjxB,OAAO,GACVi3B,EAAK93B,KAAK,IAAItB,OAAOozB,EAAIgG,EAAKj3B,OAAO,EAAE,GAAIo2B,EAAI/N,SAG/C4O,EAAKj3B,OAAO,EAAE,CACd,IAAI60D,EAAU,IAAIjD,EAAY36B,GAAM,GAEpC,OADA49B,EAAQxtB,KAAOjR,EACRy+B,CACX,CACA,OAAO,IACX,CACA,IAAA1mD,CAAKyI,GACD,OAAuB,OAAhBvZ,KAAK2J,KAAK4P,EACrB,CACA,IAAA5P,CAAK4P,GACD,GAAIvZ,KAAKi/B,QACL,OAAO,KAEX,IAAIsf,GAAQ,EACRkZ,EAAKz3D,KAAK81B,OAAO1xB,QACjBk/B,EAAO,KACPo0B,EAAQ,KACRphC,EAAS,EACb,KAAMioB,GAAUkZ,EAAG90D,OAAO,GAEtB2gC,EADQm0B,EAAGhhD,QACF9M,KAAK4P,GACV+pB,EACW,MAAPo0B,EAEAA,EAAQp0B,GAIRo0B,EAAM,IAAMp0B,EAAK,GACjBhN,GAASgN,EAAK,GAAG3gC,OACjB4W,EAAIA,EAAEiT,UAAU8J,KAGpBioB,GAAQ,EACRmZ,EAAQ,MAGhB,OAAOA,CACX,EAGJ/5D,EAAQ42D,YAAcA,C,8BCxJtBv1D,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MACMkrD,EAAkB,sBAClBnC,EAAa,CACf7rD,KAAI,IACO,KAEXmH,KAAI,IACO,KAEXI,SAAQ,IACG,IAMf,MAAMuyB,EAMF,gBAAO0xB,CAAUF,GACb,OAAOA,IAASO,CACpB,CAIA,qCAAWoC,GAIP,MAAO,2BACX,CACA,2BAAWD,GACP,OAAOA,CACX,CAIA,uCAAWE,GAIP,MAAO,yBACX,CAOA,yBAAOrN,CAAmBlmB,GAGtB,OAFSb,EAAWm0B,2BACL9mD,KAAKwzB,EAExB,CAMA,iCAAOE,CAA2BF,GAE9B,MADW,gBACDxzB,KAAKwzB,EACnB,CAOA,kBAAO8wB,CAAYhtC,GACf,MAAM,MAAEzB,GAAU,EAAQ,OACpB,YAAE4tC,GAAgB,EAAQ,KAChC,OAAQ/rC,IACK,QAALA,IACAJ,EAAEi+B,aAAc,EAChB79B,EAAI,IAER,IAAIsvC,GAAW,EACN,IAALtvC,IACAsvC,GAAW,GAEf,IAAIrwD,EAAIkf,EAAM8B,WAAWD,EAAG,KAE5B,OADA/gB,EAAI8sD,EAAYjyC,KAAK7a,EAAGqwD,GACjBrwD,CAAC,CAEhB,CAOA,kCAAOswD,CAA4Bh1D,GAC/B,IAAIylB,EAAIib,EAAWu0B,cAAcj1D,EAAK0gC,EAAWm0B,4BACjD,OAAIpvC,EACOib,EAAWw0B,mBAAmBzvC,GAElCA,CACX,CAMA,2CAAOq+B,CAAqC9jD,GACxC,IAAIylB,EAAIib,EAAWu0B,cAAcj1D,EAAK0gC,EAAWo0B,8BACjD,OAAIrvC,EACOib,EAAWw0B,mBAAmBzvC,GAElCA,CACX,CACA,yBAAOyvC,CAAmBzvC,GAItB,MAHW,KAANA,EAAE,IAA4B,KAAfA,EAAEA,EAAE7lB,OAAO,KAC3B6lB,EAAIA,EAAEpkB,MAAM,GAAG,IAEZokB,EAAE9lB,MAAM,KAAKmM,QAAO2K,GAAKA,EAAE7W,OAAS,IAAG/D,KAAK,IACvD,CAMA,yBAAOgoD,CAAmBp+B,GAEtB,OADAA,EAAIA,EAAEtX,YACGsb,UAAU,EAAGhE,EAAE4tC,YAAY,KAAK,GAAGhyD,MAAM,GAAG,EACzD,CAKA,gBAAO4yD,CAAUxuC,GACb,IAAIwC,EAAS,GACb,GAAS,QAALxC,EACA,MAAO,CACHA,EAAG,MACHwC,SACAktC,WAAW,GAInB,IAAI7K,EAAU,iDACV8K,EAAU,KACd,GAAIA,EAAU9K,EAAQ1jD,KAAK6e,GAAI,CAC3B,IAAI4vC,EAAK,GACLD,EAAQE,SACRD,EAAKD,EAAQE,OAAOC,QAAU,GAC1BH,EAAQE,OAAOE,SACfJ,EAAQE,OAAOE,QAAQ71D,QAAQvE,SAAQkJ,IACnC+wD,EAAKA,EAAGh3D,QAAQiG,EAAG,GAAG,KAIlCmhB,EAAIA,EAAEpnB,QAAQisD,EAAS,IACvBriC,EAASotC,CACb,CACA,MAAO,CACH5vC,IACAwC,SAER,CAMA,4BAAO0Z,CAAsB8zB,GAIzB,MAAO,iBAAiB1nD,KAAK0nD,EAAItnD,WACrC,CAMA,0BAAOiiD,CAAoBqF,GAIvB,MAAO,iBAAiB1nD,KAAK0nD,EAAItnD,WACrC,CAOA,gBAAOunD,CAAUtrD,GACb,OAAOA,EAAE+D,WAAW9M,MAAM,GAAI,GAAGhD,QAAQ,MAAO,IACpD,CAOA,oBAAO42D,CAAcj1D,EAAKuhC,GAEtB,GAAoB,iBAAT,EACP,MAAM,IAAIv0B,MAAM,sBAGpB,IAAIwJ,EAAIxW,EACJygB,EAAI,EACJkvB,EAAK,GAET,SAASgmB,EAASn/C,EAAGvW,EAAOrC,EAAQ,IAAKC,EAAM,KAC3C,IAAIyG,EAAI,EACJy0C,EAAKviC,EAAE5W,OACX,MAAMg2D,EAAc31D,EACpB,IAAI41D,GAAU,EACd,KAAQvxD,EAAIy0C,GAAQz0C,EAAI,GAAOrE,EAAQ84C,GAEnCpJ,EAAKn5B,EAAEvW,EAAQ,GACX0vC,GAAM/xC,EACDi4D,GACDvxD,IAEGqrC,GAAM9xC,IACRg4D,GACDvxD,KAERuxD,EAAgB,MAANlmB,EACV1vC,IAMJ,OAHKA,EAAQ,EAAI84C,GAAQ,WAAWhrC,KAAKyI,EAAEvW,EAAQ,KAC/CA,IAEGuW,EAAEiT,UAAU,EAAGmsC,GAAep/C,EAAEiT,UAAUxpB,EAAQ,EAC7D,CAzBAshC,EAAQA,GAAS,kBA0BjB,IAAIu0B,GAAU,EACV7R,EAAQ,GACZ,KAAOxjC,EAAI8gB,EAAM36B,KAAK4P,IACdiK,EAAExgB,MAAM,GACoB,MAAduW,EAAEiK,EAAExgB,MAAM,IAEpBgkD,GAASztC,EAAEiT,UAAU,EAAGhJ,EAAExgB,MAAM,GAChCuW,EAAIA,EAAEiT,UAAUhJ,EAAExgB,MAAM,KAIhCuW,EAAIm/C,EAASn/C,EAAGiK,EAAExgB,OAClB61D,GAAU,GAOd,OALI7R,EAAMrkD,OAAO,GACTk2D,IACAt/C,EAAIytC,EAAMztC,GAGXs/C,EAAUt/C,EAAIxW,CACzB,CAEA,gBAAOw0D,CAAUx0D,EAAK0iB,EAAUhR,EAAQ,EAAG9T,EAAQ,IAAKC,EAAM,KAC1D,MAAMk7C,EAAK/4C,EAAIJ,OACf,IAAI+vC,EAAK,KACLomB,EAASrzC,EACb,KAAOA,EAAWq2B,GAAI,CAElB,GADApJ,EAAK3vC,EAAI0iB,GACLitB,GAAM/xC,EACN8T,SACG,GAAIi+B,GAAM9xC,GAEA,KADb6T,EACgB,CACZgR,IACA,KACJ,CAEJA,GACJ,CACA,OAAO1iB,EAAIypB,UAAUssC,EAAQrzC,EACjC,CAOA,0BAAOowC,CAAoBvxB,GACvB,IAAI/R,GAAI,EACJ/J,EAAI8b,EAAMpzB,WAGd,OAFAsX,EAAIA,EAAEgE,UAAU,EAAGhE,EAAE4tC,YAAY,KAAO,GAAGhyD,MAAM,GAAI,GACrDokB,EAAIib,EAAWu0B,cAAcxvC,EAAG,uBACvB,MAALA,IAGJA,EAAIA,EAAE9lB,MAAM,KAAK9D,KAAK,IAAIg2B,OAE1BrC,EAAgB,GAAZ/J,EAAE7lB,OACC4vB,EACX,CAKA,mBAAOwmC,CAAanwC,GAChB,MAAMkN,EAAS,cACf,IAAItS,EAAI,KACJgF,EAAI,GACJkqB,EAAK,KACT,KAAOlvB,EAAIsS,EAAOnsB,KAAKif,IAAI,CACvBJ,EAAII,EAAE4D,UAAU,EAAGhJ,EAAExgB,OAErB,IAAIqE,EAAI,EACJI,EAAImhB,EAAE4D,UAAUhJ,EAAExgB,MAAQwgB,EAAE,GAAG7gB,QAC/Bm5C,EAAKr0C,EAAE9E,OACP0oC,EAAM,EACV,KAAOA,EAAMyQ,GAAI,CAEb,GADApJ,EAAKjrC,EAAE4jC,GACG,KAANqH,GAEA,GADArrC,IACS,GAALA,EAAQ,CACHgkC,EAAM,EAAIyQ,GAAO,QAAQhrC,KAAKrJ,EAAE4jC,EAAM,KACvCA,IAGJ7iB,GADU/gB,EAAE+kB,UAAU,EAAG6e,GAAO5jC,EAAE+kB,UAAU6e,EAAM,GAElD,KACJ,MAEW,KAANqH,GACLrrC,IAEJgkC,GACJ,CACAziB,EAAIJ,CACR,CACA,OAAOI,CACX,EAGJ6a,EAAW+xB,WAAaA,EAExB73D,EAAQ8lC,WAAaA,C,8BCnVrBzkC,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAGpD,MAAM,MAAEka,GAAU,EAAQ,MAuC1BhpB,EAAQkrB,qBApCR,MAKIqa,WACAmB,MACAma,SAAW,IACXp3C,MACAwgB,SAEA,WAAAxS,GACA,CAEA,UAAA2S,CAAWC,EAAQC,EAAWtgB,EAAMugB,GAChC,MAAMK,EAAiBC,GACZ7B,EAAM8B,WAAWD,GAEtB6sC,EAAkB1uC,EAAMsC,qBAAqBjpB,MACnD,OAAO2mB,EAAMqyC,UAAUh5D,KAAM,CACzBkjC,WAAY3a,EACZnhB,MAAOmhB,EACPX,SAAWytC,GACZrtC,EAAQC,EAAWtgB,EAAMugB,EAChC,CACA,aAAAywB,CAAcC,EAAY36C,EAAG46C,GACzB,IAAIogB,EAAe1uC,GAAgB,iBAAL,EAC9B,OAAO5D,EAAMuyC,aAAal5D,KAAM,CAC5BqkC,MAAM40B,EACNza,SAASya,EACTza,SAASya,GACXrgB,EAAY36C,EAAG46C,EACrB,E,4BCtCJ75C,OAAOD,eAAepB,EAAS,aAAc,CAAE8O,OAAO,IAEtD,MAAM0sD,EAAY,CAAC,EAkCnBx7D,EAAQmkB,gBA9BR,MAOI,eAAOI,CAAS5Q,EAAI8nD,GAChBD,EAAU7nD,GAAM8nD,CACpB,CACA,qBAAOC,GACHr6D,OAAO8S,KAAKqnD,GAAWh7D,SAASqb,WACrB2/C,EAAU3/C,EAAG,GAG5B,CAMA,aAAO8/C,CAAOhoD,GACV,MAAMof,EAAMyoC,EAAU7nD,GACtB,OAAIof,EACO,IAAIA,EAER,IACX,E,8BCjCJ1xB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,WAAEqc,GAAe,EAAQ,OACzB,WAAE2a,GAAe,EAAQ,MAK/B,MAAM9c,EACFiW,iBAMA,wBAAOoF,CAAkBpU,EAAeC,GACpC,GAAIA,EAAYlrB,QAAUirB,EAAcjrB,OACpC,MAAM,IAAIoN,MAAM,6CAEpB,MAAMwpD,EAAS3rC,EAAcmR,OAAO36B,MAAM,GAC1C,IAAIo1D,EAAO,EACPt5B,EAAO,EACPolB,EAAS,EACTl9B,EAAIwF,EACJ8vB,EAAM9vB,EAAcjrB,OAExB,KAAO42D,EAAO52D,OAAS,GAAG,CACtBu9B,EAAe,GAARs5B,EAAYD,EAAO9iD,QAAU8iD,EAAOr6C,MAC3C,IAAIu6C,EAAO7rC,EAAcmR,OAAOM,GAAGa,IAAS,KACxCw5B,EAAoBx5B,GAAQolB,EAShC,GARImU,GAAQC,GAASD,EAAKxe,iBAEd7yB,EAAE8X,UACFrS,EAAYqS,UACZtS,EAAcmR,OAAOnR,EAAcmR,OAAO1wB,QAAQ6xB,WAClDtS,EAAcmR,OAAOM,GAAGa,IAGxB,GAARs5B,EAAW,CACX,IAAKE,EACD,MAEJpU,GACJ,KAAO,CACH,IAAKoU,EAAO,CACRF,EAAO,EACPlU,EAAS5H,EAAM,EACf6b,EAAOrtC,QAAQgU,GACf,QACJ,CACAolB,GACJ,CACJ,CAEA,GAAIz3B,EAAYlrB,QAAUirB,EAAcjrB,OACpC,MAAM,IAAIoN,MAAM,yBAExB,CAMA,oBAAOy8C,CAAc30B,GACjB,IAAIjO,EAAQ,KACZ,MAAM,iBAAEqpC,EAAgB,iBAAEC,EAAgB,cAAEzG,GAAkB50B,EAC9D,QAAIo7B,IAEIrpC,EAD0B,iBAAnB,EACC,CACJqxB,QAASiY,KACNzG,GAGC,CAACkN,UAAWzG,GAEjBtpC,EAGf,CACA,2BAAOqY,CAAqBrU,GACxB,MAAM,gBAAE8Q,GAAoB/X,EAAMG,QAE5B6F,EAAMiB,EAAcmR,OAAOM,GAC3BY,EAAUrS,EAAcmR,OAC9B,IAAI66B,EAAM,EACNC,EAAQ,GACZA,EAAM96B,OAASL,EAAgBM,oBAE/B,IAAK,IAAI86B,EAAK,EAAGA,EAAKlsC,EAAcjrB,OAAQm3D,IACftuD,MAArBoiB,EAAcksC,KAEdD,EAAM/3D,KAAK8rB,EAAcksC,IACrBA,KAAMntC,GACNktC,EAAM96B,OAAOj9B,KAAK83D,GAClBC,EAAM96B,OAAOM,GAAGu6B,GAAOjtC,EAAImtC,KACI,GAAxB75B,EAAQ5xB,QAAQyrD,IACvBD,EAAM96B,OAAOj9B,KAAK83D,GAEtBA,KAIRhsC,EAAcjrB,OAAS,EACvBirB,EAAc9rB,QAAQ+3D,GACtBjsC,EAAcmR,OAAS86B,EAAM96B,MAEjC,CAQA,mCAAOoB,CAA6BoR,EAAIrR,EAAMb,GAC1C,GAAuB,GAAnBxgC,MAAMuQ,QAAQmiC,GACd,MAAM,IAAIxhC,MAAM,kBAOpBwhC,EAAGlS,GAAGa,GAAQb,CAClB,CACA,0BAAOyjB,CAAoBt6B,EAAGqe,GACtBA,EAAQosB,mBACRzqC,EAAEuW,OAAS8H,EAAQwF,aAE3B,CAOA,oBAAOgB,CAAcxV,GACjB,MAAO,IAAKA,EAAOjQ,YAAaiQ,EAAOimB,cAC3C,CACA,kBAAOic,CAAYliC,GACf,MAAO,IAAKA,EAAOjQ,YAAaiQ,EAAO4F,YAC3C,CAEA,wBAAOu8B,GACH,OAAQxxC,IACK,QAALA,IACAJ,EAAEi+B,aAAc,EAChB79B,EAAI,IAER,IAAIsvC,GAAW,EACN,IAALtvC,IACAsvC,GAAW,GAEf,IAAIrwD,EAAIkf,EAAM8B,WAAWD,EAAG,KAE5B,OADA/gB,EAAI8sD,YAAYjyC,KAAK7a,EAAGqwD,GACjBrwD,CAAC,CAEhB,CAOA,qBAAOo2B,CAAepxB,EAAOkhB,GACzB,MAAMsM,EAAK,CAACxtB,GAIZ,OAHAwtB,EAAGj3B,MAAQ,EACXi3B,EAAGnQ,QAAU,CAAC,CAAC,EAAGrd,EAAM9J,SACxBs3B,EAAGtM,MAAQA,GAAS,KACbsM,CACX,CAEA,uBAAO2kB,CAAiBl3B,EAAajb,GAAO,MAAErF,EAAK,SAAEwgB,EAAQ,SAAE42B,EAAQ,MAAEna,GAASrR,GAC9E,IAAIsrB,EAAO33B,EAAM02B,cAAc31B,GAC/B,MAAM,EAAEjgB,GAAMurB,EAEd,GADAA,EAAQsrB,KAAOA,EACXl3C,EAAO,CACP,IAAIulB,EAAM6xB,GAAY,IAClB5qB,EAAKjN,EAAMy2B,kBAAkB/Y,EAAO58B,GACxC,GAAI,QAAQqJ,KAAK6b,GAAM,CACnB,IAAIplB,EAAIH,EAAM0J,KAAK8iB,GACnB,GAAIjH,IACa,KAAPA,IAAgBplB,GAAe,MAAPolB,GAAgB,GAE1C,OADAqG,EAAQqrB,UAAW,EACZ5xC,CAGnB,MAAO,GAAI,UAAUqE,KAAK6b,GAAM,CAC5B,IAAI8xB,EAAMr3C,EAAM8J,WAAW9P,QAAQ,QAAS,IAC5C,IACa,MAAPurB,GAAiBiH,GAAM6qB,GAChB,MAAP9xB,GAAiBiH,GAAM6qB,IAErB7qB,GAAM6qB,EAEN,OADAzrB,EAAQqrB,UAAW,EACZ5xC,CAGnB,CACJ,MAEIumB,EAAQqrB,UAAW,EAEvB,OAAO5xC,CACX,CAUA,qBAAOuxB,CAAevxB,EAAOorB,EAAQjQ,EAAUoD,GAC3C,IAAIyhB,EAAYhgC,EACZwtD,EAAWxtD,EAMfue,EAAOkT,aACPlT,EAAOoV,eAAeqM,EAAW5U,EAAQ7M,GACzCA,EAAOiF,QACP,IAAIse,EAAU,CAAE5mC,KAAM,MAKtB,OAJA8kC,EAAYzhB,EAAOqT,OAAM,EAAMkQ,GAC/B0rB,EAAW1rB,EAAQ5mC,KACnBqjB,EAAOsT,qBAEA,CACH,OAAUmO,EACV,KAAQwtB,EAGhB,CAMA,uBAAOC,CAAiB9oD,EAAQsf,GAC5B,IAAK,IAAIrpB,KAAKqpB,EACVtf,EAAO/J,GAAKqpB,EAAIrpB,EAExB,CAQA,wBAAO8yD,CAAkBlxD,EAAGshB,EAAG6vC,GAC3B,IAAIjtD,EAAI,EACJrP,EAAS,EACT0qB,EAAI,GAkBR,OAjBI4xC,IACA5xC,EAAI,yGAA2G4xC,EAAa,MAASnxD,EAAI,yBAE7IA,EAAEvG,MAAM,KAAKvE,SAASkJ,IACbvJ,GAGGqP,IACArP,GAAU,KAEdA,GAAUuJ,EAAI,IACd8F,KANArP,EAASuJ,EAAI,mBAAqBmhB,EAAI,GAO1C,IAEJ+B,OAAkB,IAAP,EAAqB,aAA6B,iBAAP,EAAkBzV,KAAKC,UAAUwV,GAAKA,IAAM,IAAMthB,EAAI,IAC5GnL,GAAUysB,EAAI,IAAI3oB,OAAOuL,GAAK,MAAQod,EAAI,IAEnCzsB,CACX,CAQA,iBAAOi8C,CAAW9wC,EAAGshB,EAAG7Q,GACpB,MAAO,EAAE0O,EAAGmC,EAAG7Q,KACX,IAAInS,EAAI,KAAUqhB,EAAI,KAAUyxC,EAAQ,KAAUxvC,EAAK,KAEvD,OADAN,OAAmB,IAAP,EAAqBA,EAAIthB,EACrB,GAAZmf,EAAEzlB,OAAoB4nB,GAC1BnC,EAAEjqB,SAAQkJ,IACG,MAALE,IAEAA,EAAIqhB,GAAKlP,EAASA,EAAOrS,GAAK,OAAS,CAAC,EACpCqS,IACAA,EAAOrS,GAAKE,IAGhB8yD,IACAxvC,EAAKjC,EACgB,iBAATA,EAAEvhB,KACVuhB,EAAEvhB,GAAK,CAAC,GAEZuhB,EAAEvhB,GAAKuhB,EAAEvhB,IAAM,CAAC,EAChBuhB,EAAIA,EAAEvhB,IAEVgzD,EAAQhzD,CAAC,IAGTwjB,EACAA,EAAGwvC,GAAS9vC,EAER7Q,IACAA,EAAO0O,EAAE,IAAMmC,GAGhBhjB,EACV,EA/BM,CA+BJ0B,EAAEvG,MAAM,KAAM6nB,EAAG7Q,EACxB,CAMA,kBAAOqT,CAAYzgB,EAAMye,GACrBA,EAAOmB,WAAW5f,EAAK5J,MAAM,KAAK+D,UACtC,CAMA,oBAAO+4C,CAAclzC,EAAMye,GACvB,MAAMxjB,EAAI+E,EAAK5J,MAAM,KAAK+D,UAC1B,KAAOc,EAAE5E,OAAS,GAAG,CACjB,MAAMylB,EAAI7gB,EAAEkP,QACZ,GAAIsU,EAAO,IAAM3C,EAGb,MAAM,IAAIrY,MAAM,6BAA+BqY,GAF/C2C,EAAOtU,OAIf,CACJ,CAEA,8BAAO6R,CAAwBN,EAAQpB,EAAUyB,GAE7C,MAAM0wB,EAAiB/wB,EAAOgxB,kBAAoBpyB,EAClD,OAAOD,EAAM2zC,YAAYvhB,EAAgB1wB,EAC7C,CASA,oBAAOsxB,CAAc4gB,EAAY5yD,EAAMoQ,EAAUwhC,GAC7C,IAAIvxB,EAAS,IAAIc,EAKjB,GAJAd,EAAOzU,OAASgnD,EAChBvyC,EAAOrgB,KAAOA,EACdqgB,EAAOxjB,SAAW,CAAC,EAEgB,iBAAxB,EAAkC,CACzC,MAAM,iBAAEw0C,EAAgB,qBAAEqZ,EAAoB,yBAAEkD,GAA6Bhc,EAC7EvxB,EAAOgxB,iBAAmBA,EAC1BhxB,EAAOqqC,qBAAuBA,EAC9BrqC,EAAOutC,yBAA2BA,CACtC,MACIvtC,EAAOgxB,iBAAmBO,EAK9B,OAHIxhC,IACAiQ,EAAOjQ,SAAWA,GAEf4O,EAAM6zC,SAASxyC,EAAQ,IAAIuyC,EAAc5yD,EAAM,KAC1D,CACA,eAAO6yD,CAASxyC,EAAQriB,EAAKgC,EAAMugB,GAC/B,OAAOY,EAAWC,UAAUf,EAAQriB,EAAKgC,EAAMugB,EACnD,CAMA,kBAAOoyC,CAAYC,EAAYE,GAC3B,IAAKA,QAAmD,IAAvB,EAC7B,MAAM,IAAI1qD,MAAM,6BAKpB,OAAO,SAAU9R,EAAG+pB,EAAQE,EAAQC,GAChC,IAAIoE,EAAO,GACPnE,EAAID,GAAUnoB,KAClB,MAAM,WAAEgiB,GAAe2E,EAAMG,QAiD7B,OAhDA7oB,EAAEE,SAASolB,IACP,MAAM,QAAEm3C,GAAYn3C,EACdo3C,EAAWp3C,EAAEq3C,QACnB,IAAI/vC,EAAK,KAAM9G,EAAO,KAAM6V,EAAO,KACnC,GAAI8gC,EACA,GAAkB,KAAdA,EAAQ,GAER32C,EAAO22C,EAAQluC,UAAU,GACrBzI,KAAQiE,EAAOxjB,SACfqmB,EAAK,IAAI4vC,EAAkBzyC,EAAOxjB,SAASuf,IAGvCmE,GAAWA,GAAUnE,GAASoE,EAC9B0C,EAAK,IAAI4vC,EAAkBryC,IAE3BwR,EAAO5R,EAAOrgB,KAAK2vC,WAAWvzB,GAC1B6V,IACA/O,EAAK,IAAI0vC,EACTvyC,EAAOxjB,SAASuf,GAAQ8G,EACxB/B,EAAWC,UAAUf,EAAQ6C,EAAI+O,EAAM7V,EAAMoE,GAAU0C,GACvD7C,EAAOqxB,WAAWxuB,GAClB0vC,EAAW3tC,KAAK/B,SAIzB,CAGH,MAAM,gBAAEgtB,GAAoB71B,EAC5B,GAAI61B,EACA,OAAOA,EAAgB75B,QAAQ08C,EAGvC,KAEC,IAAIC,EACL,MAAM,IAAI5qD,MAAM,2BAGhB8a,EAAK,IAAI0vC,EACTzxC,EAAWC,UAAUf,EAAQ6C,EAAItH,EAAG2E,EAAQC,GAAU0C,GACtD7C,EAAOqxB,WAAWxuB,EAEtB,CACIA,GACA0B,EAAKzqB,KAAK+oB,EACd,IAEG0B,CACX,CACJ,CAQA,gBAAOsuC,CAAU5F,EAAMp9B,EAAQ7M,GAEN,iBAAV,IACPiqC,EAAO,CAACA,IAEZ,MAAM6F,EAAS,CACX92B,UAAWhZ,EAAOgZ,UAClB+B,WAAY/a,EAAO+a,WACnBg1B,oBAAqB/vC,EAAOye,2BAEhC,KAAOwrB,EAAKtyD,OAAS,GAAG,CACpB,IAAIylB,EAAI6sC,EAAKx+C,QACb,GAAI2R,KAAK0yC,GACDA,EAAO1yC,GACP,OAAO,CAGnB,CACA,OAAO,CACX,CAOA,gBAAO4yC,CAAUxyC,EAAGwC,GAChB,IAAIutB,GAAQ,EAgBZ,OAfI/vB,EAAEwb,YACGhZ,EAAOgZ,YACRuU,GAAQ,KAGXA,GAAS/vB,EAAEysC,OACZ1c,EAAQ5xB,EAAMk0C,UAAUryC,EAAEysC,KAAMzsC,EAAGwC,KAElCutB,GAASvtB,EAAO9B,gBAAkBV,EAAEU,iBACrCqvB,GAAQ,GAEPA,GAAUvtB,EAAOke,wBAAwBrR,QAAUrP,IACpD+vB,GAAQ,EACRvtB,EAAOke,uBAAyB,MAE7BqP,CACX,CASA,mBAAOyd,CAAazuC,EAAUhO,EAAGyR,EAAQy7B,GAErC,IAAIyP,EAAK,KACL+E,EAAQ,KACRhF,EAAS,EACT3/B,GAAU,EACVuf,EAAYtuB,EACZ2zC,GAAa,EACjB,MAAM,YAAE/sB,EAAW,MAAEnpB,GAAUgG,EAC/BmjB,EAAYnK,UAAYhZ,EAAOgZ,UAC/B,MAAMm3B,EAAS,CAAC,CAAE5zC,SAAUA,EAAU9lB,KAAM,KAAMkwB,IAAK80B,EAAmBhyC,MAAO,EAAIrQ,MAAM,IAE3F,KAAO+2D,EAAOx4D,OAAS,GAAG,CACtB,MAAMy4D,EAAcD,EAAO1kD,QAC3B,IAAI6uC,EAAS,EACT+V,EAAaD,EAAY7zC,SAASnjB,MAAMg3D,EAAYh3D,OACxD,KAAOi3D,EAAW14D,OAAS,GAAG,CAC1B,IAAI6lB,EAAI6yC,EAAW5kD,QAEf+M,EAAI,KACJ/hB,EAAO,KACP65D,EAAa,KAGjB,IAFW30C,EAAMq0C,UAAUxyC,EAAGwC,GAEnB,CACP,IAAI,SAAEzD,GAAaiB,EACnB,MAAMsN,EAAStN,EAAEutC,gBACjB,IAAIxkB,EAAK,KACT,GAAIzb,EACAtS,EAAI2qB,EAAY9J,MAAMvO,EAAQ9K,GAC9BumB,EAAK,CACD/tB,IAAGgF,EAAGA,EAAGxlB,OAAQ,EAAGshC,MAAOxO,EAAQr0B,KAAM25D,EAAY35D,KACrD8lB,SAAU6zC,EAAY7zC,SACtBoK,IAAKypC,EAAYzpC,UAIrB,GAAIpK,EAAU,CACT4zC,EAAOr5D,KAAK,CAAEylB,SAAUA,EAAU9lB,KAAM+mB,EAAGmJ,IAAK80B,EAC7ChyC,MAAO6wC,EACPlhD,MAAO,IACPi3D,EAAW14D,OAAS,IACpBw4D,EAAOr5D,KAAK,CAAEylB,SAAU6zC,EAAY7zC,SAAU9lB,KAAM25D,EAAY35D,KAAMkwB,IAAK80B,EACvEhyC,MAAO6wC,EACRlhD,MAAQg3D,EAAY7zC,SAAS5kB,OAAS04D,EAAW14D,SACpD04D,EAAW14D,OAAS,GAExB,QACJ,CAEA4uC,MACG/tB,IAAGgF,IAAG/mB,OAAM8lB,YAAagqB,GAC5B+pB,GAA0B,GAAb/pB,EAAGvuC,MAAcsiD,EAAS/T,EAAGvuC,OAE1CwgB,KAAkB,GAAX8S,GAAkBA,EAAS9S,EAAExgB,SACpCszB,EAAS9S,EAAExgB,MACXkzD,EAAK1tC,EACLytC,EAASzyC,EACTy3C,EAAQx5D,EACRo0C,EAAYtuB,GAAYsuB,EACxBqlB,EAAYI,GAAchW,EAElC,CACAA,GAEJ,CACJ,CACA,OAAe,IAAX2Q,GAGG,CAAEC,KAAID,SAAQgF,QAAO1zC,SAAUsuB,EAAW7yC,MAAOk4D,EAC5D,CAQA,wBAAOjf,CAAkB10B,EAAUyD,EAAQy7B,EAAoB,MAC3D,MAAM,KAAE7iD,EAAI,MAAEohB,EAAK,MAAE2gB,EAAK,UAAE3iB,EAAS,YAAEmrB,EAAW,UAAEnK,GAAchZ,GAC5D,0BAAEgmB,GAA8BrqB,EAAMG,QAC5C,IAAIovC,EAAK,KACLD,EAAS,EACTgF,GAAS,EACT1hD,EAAI40B,EAAYjK,SACpB,MAAM,YAAE7b,GAAgB1B,EAAMG,QAC9B,IAAI9jB,EAQJ,KAPGkzD,KAAID,SAAQgF,QAAO1zC,WAAUvkB,SAAU2jB,EAAMqvC,aAAazuC,EAAUhO,EAAGyR,EAAQy7B,IAC9EwP,GACIA,EAAOjzD,MAAQgoB,EAAOroB,SACtBuzD,EAAK,KACLD,EAAS,MAGbC,EAAI,CAsBJ,GApBAlxC,GAAOwd,QAAQ,kBAAoBjgB,QAAQC,IAAI,kBAAmB,CAC9D,OAAU0zC,EAAGhlD,WACb5E,KAAM4pD,EAAG5pD,KACT1I,OACAynC,IAAK4qB,EAAOjzD,MACZ2iC,QACA41B,UAAwB,MAAbrF,EAAGpuC,OACdkf,QAASkvB,EAAGlvB,QACZvf,QAASyuC,EAAGzuC,QACZ+zC,MAAOtF,aAAc7tC,EACrB5b,MAAOwpD,EAAO,GACdwF,SAAUliD,EACV+S,OAAQ6hB,EAAY7hB,OACpBgY,MAAO4xB,EAAGC,WACVl9C,KAAsB,GAAhBi9C,EAAG7iB,UAAiB,YAAc,QACxCqoB,eAAyB,MAATT,EAChBnzC,OAAQouC,EAAGpuC,QAAQ5W,WACnBzP,KAAMw5D,GAAO/pD,WACb8yB,cAEAkyB,EAAGruC,WAAY,CACf,IAAIza,EAAI8oD,EAAGruC,WACPhnB,EAAoB,iBAAP,EAAkBuM,EAAE4C,QAAU,gBAE/C,MADAnP,EAAMA,EAAIO,QAAQ,UAAW,IAAM60D,EAAO,GAAK,KACzC,IAAIjlB,EAA0BnwC,EAAKq1D,EAAID,EAAQjzC,EACzD,CAEAizC,EAAO3pC,OAAS2pC,EAAO,GAAGtzD,OAE1B,IAAIinB,EAAQ,IAAI6d,EAMhB,OALA9gB,EAAMg1C,qBAAqB/xC,EAAOssC,EAAID,EAAQxP,EAAmBwU,EAAOr3D,EAAM2jB,EAAUvkB,EAAOgoB,EAAOO,UAAUioB,WAC5G,CACIxwB,UAAWgI,EAAOhI,YAGnB4G,CACX,CACA,OAAOssC,CACX,CAcA,2BAAOyF,CAAqB/xC,EAAOssC,EAAID,EAAQxP,EAAmBwU,EAAOr3D,EAAM2jB,EAAUvkB,GAAQ,EAAIwwC,EAAW,KAAM3sC,EAAQ,MAC1H+iB,EAAMi3B,IAAI,CACNhpB,OAAQq+B,EACRniB,SAAUmiB,EAAGniB,SAASkiB,GACtBryD,OACAw/B,MAAO6yB,EACPnuC,OAAQ2+B,EACRl/B,WACAwlB,UAAWkuB,EACXj4D,QACAwwC,aACA3sC,SAER,CASA,oCAAOkvC,CAA8BnyC,EAAM2jB,EAAUyD,EAAQy7B,GACzD,MAAM,MAAEzhC,EAAK,MAAE2gB,EAAK,UAAE3iB,EAAS,UAAEuI,GAAcP,GACzC,YAAE3C,EAAW,0BAAE2oB,GAA8BrqB,EAAMG,QACzD,IAAIovC,EAAK,KACLD,EAAS,EAETgF,EAAQ,KACRj4D,GAAS,EACb,MAAM,WAAEwwC,GAAejoB,EAGvB,KAFG2qC,KAAID,SAAQgF,QAAO1zC,WAAUvkB,SAAU2jB,EAAMqvC,aAAazuC,EAAU3jB,EAAMonB,EAAQy7B,IAEjFyP,EAAI,CAeJ,GAbIlxC,GACAzC,QAAQC,IAAI,oBAAqB,CAC7B,OAAU0zC,EAAGhlD,WACb5E,KAAM4pD,EAAG5pD,KAAM1I,OAAMynC,IACjB4qB,EAAOjzD,MAAO2iC,QAClB41B,UAAwB,MAAbrF,EAAGpuC,OACdkf,QAASkvB,EAAGlvB,QACZw0B,MAAOtF,aAAc7tC,EACrB5b,MAAOwpD,EAAO,GACd3xB,MAAO4xB,EAAGC,WACVnzD,UAGJkzD,EAAGruC,WAAY,CACf,IAAIza,EAAI8oD,EAAGruC,WAEX,MAAM,IAAImpB,EADgB,iBAAP,EAAkB5jC,EAAE4C,QAAU,gBACRkmD,EAAID,EAAQjzC,EACzD,CAEAizC,EAAO3pC,OAAS2pC,EAAO,GAAGtzD,OAG1B,IAAIinB,EAAQ,IAAI6d,EAEhB,OADA9gB,EAAMg1C,qBAAqB/xC,EAAOssC,EAAID,EAAQxP,EAAmBwU,EAAOr3D,EAAM2jB,EAAUvkB,EAAOwwC,GACxF5pB,CACX,CACA,OAAOssC,CACX,CAOA,mBAAOI,CAAa9tC,EAAGhF,EAAG6yC,EAAMh3B,GAmB5B,OAhBI7W,EAFO,OAAN6W,GAAuB,SAANA,EAEd7W,EAAEpnB,QAAQ,cAAc,CAACmiB,EAAGqF,IAErBpF,EAAEoF,KAMTJ,EAAEpnB,QAAQ,oBAAoB,CAACmiB,EAAGqF,IACtB,MAARrF,EAAE,GAAmBA,EACb,KAARA,EAAE,GACKA,EAAE,GAAKC,EAAEoF,GACbpF,EAAEoF,KAGjBJ,EAAI,WAAW1X,KAAK0X,GAAKA,EAAEpkB,MAAM,GAAI,GAAKokB,EACnC,IAAIhoB,OAAOgoB,EAAG6tC,GAAQ,GACjC,CAGA,wBAAOjZ,CAAkB50B,EAAG4a,EAAO/D,GAC/B,IAAIu8B,EAAKj1C,EAAM2vC,aAAa9tC,EAAG4a,EAAO,KAAM/D,GAG5C,OAFAu8B,EAAKA,EAAG1qD,WAAWsb,UAAU,GAAGpoB,MAAM,GAAI,GAAGhD,QAAQ,QAAS,KAC1DonB,EAAEpnB,QAAQonB,EAAGozC,EAErB,CAMA,oBAAOve,CAAc/Y,GACjB,IAAI9b,EAAI8b,EAAMpzB,WAEd,OADAsX,EAAIA,EAAEgE,UAAU,EAAGhE,EAAE4tC,YAAY,KAAO,GACjC5tC,CACX,CAMA,gBAAOwuC,CAAUxuC,GACb,OAAOib,EAAWuzB,UAAUxuC,EAChC,CACA,qBAAOqzC,CAAerzC,EAAG6tC,GACrB,IAAIzsC,EAAQjD,EAAMqwC,UAAUxuC,GAI5B,OAHI6tC,GAAiC,GAAvBzsC,EAAMoB,OAAOroB,SAAgD,GAA/BinB,EAAMoB,OAAO3c,QAAQgoD,KAC7DzsC,EAAMoB,QAAUqrC,GAEbzsC,CACX,CASA,iBAAOnB,CAAWD,EAAG6tC,GACjB,GAAkB,iBAAP,EAAiB,CACxB,IAAIzsC,EAAQjD,EAAMk1C,eAAerzC,EAAG6tC,GACpC,OAAO,IAAI71D,OAAOopB,EAAMpB,EAAGoB,EAAMoB,OACrC,CAAO,GAAkB,iBAAP,EAAiB,CAC/B,GAAIxC,aAAahoB,OAAQ,CAErBgoB,EAAIib,EAAWmjB,mBAAmBp+B,GAClC,IAAIoB,EAAQjD,EAAMk1C,eAAerzC,EAAG6tC,GAEpC,OADU,IAAI71D,OAAOopB,EAAMpB,EAAGoB,EAAMoB,OAExC,CACA,MAAM,OAAEA,EAAM,MAAEsZ,GAAU9b,EAC1B,OAAI8b,aAAiB9jC,QACjB8jC,EAAQ3d,EAAM2vC,aAAahyB,EAAMpzB,WAAY8Z,GACtCsZ,GAEJ,IAAI9jC,OAAO8jC,EAAOtZ,EAC7B,CACA,OAAOxC,CACX,CACA,2BAAOyE,CAAqB1C,EAAG/C,GAC3B,MAAMs0C,EAAQ,CACV,UAAAC,CAAWvzC,GACP,IAAIwzC,EAAK,GAIT,OAHAxzC,EAAE9lB,MAAM,KAAKvE,SAAQolB,IACjBy4C,EAAGl6D,KAAKyhB,EAAE04C,OAAO,GAAGp2D,cAAc0d,EAAEnf,MAAM,GAAGyuB,cAAc,IAExDmpC,EAAGp9D,KAAK,IACnB,EACAs9D,UAAU1zC,GACFA,EAAEpnB,QAAQ,OAAQ,KAG1B+6D,UAAU5xC,GACCA,EAAE1kB,cAEbu2D,UAAU7xC,GACCA,EAAEsI,cAEb+B,KAAKrK,GACMA,EAAEqK,OAObynC,MAAM9xC,GACKA,EAAE6W,UAObk7B,MAAM/xC,GACKA,EAAE+W,aAqCjB,OAlCA9Z,EAAUrpB,SAASqqB,IAIf,IAAIyR,EAAK,KACT,GAAIA,EAAK,uCAAuCtwB,KAAK6e,GAAI,CAErD,IAAIvf,EAAIzB,SAASyyB,EAAGo+B,OAAe,QAC/BzkC,EAAKqG,EAAGo+B,OAAe,OAC3B,GAAIpvD,EAAIshB,EAAE5nB,OAAQ,CACd,IAAI05B,EAAKpC,EAAG,GACZ,GAAU,KAANrG,EACArJ,EAAIA,EAAErZ,WAAWqrD,OAAOtzD,EAAGozB,QACxB,GAAU,KAANzI,EACPrJ,EAAIA,EAAErZ,WAAWsrD,SAASvzD,EAAGozB,QAE5B,GAAU,KAANzI,EAAW,CAChB,IAAIzmB,EAAIjO,KAAKuJ,OAAOQ,EAAIshB,EAAE5nB,QAAU,GAEpC4nB,GADAA,EAAIA,EAAErZ,WAAWqrD,OAAQpvD,EAAI,GAAM,EAAIlE,EAAIkE,EAAIlE,EAAIkE,EAAI,EAAGkvB,IACpDnrB,WAAWsrD,SAASvzD,EAAGozB,EACjC,CACJ,CACA,OAAO9R,CACX,CAEA,GAAI0P,EAAK,0BAA0BtwB,KAAK6e,GAAI,CACxC,IAAIrb,EAAIwZ,EAAM2vC,aAAar8B,EAAGo+B,OAAmB,WAAG,CAAC9tC,IAGrD,OAFApd,EAAIs2B,EAAWg1B,UAAUtrD,GACzBod,EAAIA,EAAEnpB,QAAQmpB,EAAGpd,EAErB,CAEAod,EAAkB,mBAAP,EAAoB/B,EAAE+B,GAAKuxC,EAAMtzC,GAAG+B,EAAE,IAE9CA,CACX,CAUA,mBAAO2uC,CAAa9wC,EAAG0wB,EAAWF,EAAY36C,EAAG46C,GAE7C,IAAItmB,EAAIumB,EAAYA,EAAUF,GAAc,KAC5C,GAAIrmB,IAAMA,EAAEt0B,GAAI,CACZ,GAAI46C,EACA,MAAM,IAAI9oC,MAAM,IAAI6oC,mBAExB,OAAO,CACX,CACA,OAAO,CACX,CAWA,gBAAOogB,CAAU5wC,EAAGM,EAAOV,EAAQC,EAAWtgB,EAAMugB,GAChD,IAAIiB,EAAKT,EAAQA,EAAMT,GAAa,KACpC,OAAIkB,EACOA,EAAGrmB,MAAMslB,EAAG,CAACzgB,EAAMqgB,EAAQE,IAE/BvgB,CACX,CACA,gCAAOqhB,GACH,OAAO,SAAU/f,EAAG+e,GAChB,GAAkB,iBAAP,EAAiB,CACxB,IAAIgY,EAAI,GAMR,OALA/2B,EAAEvG,MAAM,KAAKvE,SAASkJ,IAClBA,EAAEutB,OACEvtB,EAAE1E,OAAS,GACXq9B,EAAEl+B,KAAKuF,EAAE,IAEV24B,CACX,CACA,GAAInhC,MAAMuQ,QAAQnG,GACd,OAAOA,CAEf,CACJ,CAaA,oBAAOy1C,CAAcjyC,EAAO2V,EAAYq6C,EAAcr5B,EAAOyD,EAAS7b,EAAQpD,EAAUsD,GAAQ,GAC5F,IAAIzjB,EAAI27B,EACJs5B,EAAMD,EACN7zC,EAAI,GACR,MAAM,gBAAEW,GAAoB5C,EAAMG,SAC5B,SAAE5N,GAAa8R,EACrB,GAAIvjB,EAAG,CAIHmhB,EAAIjC,EAAMy2B,kBAAkBsf,EAAKj1D,GACjC,IAAI48B,EAAQzb,EAAExnB,QAAQ,yBAA0B,IAK5C2yB,EAAK,IAAIvzB,OAAOooB,EAAG,KACnB+zC,EAAMlwD,EAAMrL,QAAQqL,EAAO43B,GAAOjjC,QAAQ,QAAS,OAEnDooB,EAAUuK,EAAGpqB,KAAKgzD,GACtB,MAAMrxB,EAAUtgB,EAAO2P,YACjBiiC,EAAQh1C,GAAYxF,EAAWy7B,kBAAkBhX,GACvD,GAAIrd,GAAWozC,EAAO,CAClBn1D,EAAI8hB,EAAgBI,gBAAgBH,EAAS8hB,GAC7C,MAAM6B,EAAa,CAAC,EACpB,IAAI0vB,EAAMp1D,EAAEqjB,OAAO5R,EAAU0jD,GAAO,EAAOtxB,EAAStgB,EAAQmiB,EAAYjiB,GAIxE,MAHsB,iBAAX,IACPA,EAAMkmB,SAAWjE,GAEd0vB,CACX,CAEA,OADAx4B,EAAQA,EAAMjjC,QAAQ,SAAU,MACzBijC,CAEX,CASA,OAPIq4B,EAAMA,EAAIlwC,UAAU,GAAGpoB,MAAM,GAAI,GACtB,QAAPs4D,IACAA,EAAM,IAEV9zC,EAAI8zC,EAAIt7D,QAAQ,QAAS,KAErBqL,EAAMrL,QAAQqL,EAAOmc,EAEjC,CAUA,wBAAOwE,CAAkB3gB,EAAO8a,EAAU6b,EAAOpY,GAC7C,MAAM5I,EAAa4I,EAAOO,UAC1B,IAAIuxC,EAAc16C,EAAW4nB,KAAKoO,aAClCh2B,EAAW4nB,KAAKoO,aAAehV,EAC/B,IAAI92B,EAAO,KACPisB,EAAQ,KACRkB,EAAS,KAES,iBAAX,IACJhtB,QAAOH,QAASG,GAEnBgtB,EAAShtB,EAEb8rB,EAAQjsB,EACRmtB,EAAShtB,EAET,MAAM2b,EAAI4C,EACV,GAAI5I,EAAWqsB,SAASyD,4BAA6B,CACjDlnB,EAAO2gB,YAEP,IAAIX,EAAO,CACPzjB,SAAUnF,EAAWmF,SACrBqT,OAAQxS,EAAEwS,OACV9O,OAAQ1D,EAAE0D,OACV2Z,gBAAiBrd,EAAEqd,gBACnBziB,UAAWoF,EAAEpF,UACbuqB,WAAYnlB,EAAEmlB,WAAWnpC,MAAM,GAC/BR,KAAMwkB,EAAExkB,KACRynC,IAAKjjB,EAAEijB,IACP1F,MAAOvd,EAAEud,MACTxY,UAAW/E,EAAE+E,UAAU/oB,MAAM,GAC7B2jC,YAAa3f,EAAE2f,YACf3B,aAAche,EAAEge,aAChBwO,uBAAwBxsB,EAAEwsB,uBAC1B1L,uBAAwBle,EAAOke,wBAInC9gB,EAAEwsB,uBAAyB,KAC3BxsB,EAAEpF,UAAY,EACdoF,EAAEud,MAAQ,EACVvd,EAAEmlB,WAAW5qC,OAAS,EACtBqoB,EAAOmjB,YAAYvK,OACnB5Y,EAAOoe,aAAaxF,OACpB5Y,EAAOke,uBAAyB,KAChC9gB,EAAEimB,UAAU,sBACZjsB,EAAW4nB,KAAKtP,kBAChBtY,EAAWmF,SAAWA,EAEtB9a,EAAQ2V,EAAW9W,OAAOmuB,EAAQ,CAAEntB,KAAMisB,IAC1CnW,EAAW4nB,KAAKtP,kBAChBtY,EAAWmF,SAAWyjB,EAAKzjB,SAE3Ba,EAAEpF,UAAYgoB,EAAKhoB,UACnBgI,EAAOmjB,YAAYpK,UACnB/Y,EAAOoe,aAAarF,UACpB3b,EAAExkB,KAAOonC,EAAKpnC,KACdwkB,EAAEud,MAAQqF,EAAKrF,MAEfvd,EAAEwsB,uBAAyB5J,EAAK4J,uBAChCxsB,EAAEgmB,cAAc,CAAEvnC,MAAO,CAAE4+B,gBAAiBuF,EAAKvF,mBACjDuF,EAAKuC,WAAWpvC,SAAQolB,GAAK6E,EAAEmlB,WAAWzrC,KAAKyhB,KAC/CyH,EAAO8gB,WACP9gB,EAAOke,uBAAyB8B,EAAK9B,sBAEzC,MAGIz8B,EADkBuV,WAAWkT,WAAW,CAAE3N,SAAUtpB,EAAEspB,WAClCjc,OAAOmB,GAG/B,OADA2V,EAAW4nB,KAAKoO,aAAe0kB,EACxBrwD,CACX,CAWA,mBAAOoqC,CAAahf,EAAQuV,EAAMhK,EAAOzI,EAAa3P,GAClD,MAAM,SAAE9R,GAAa8R,GACf,gBAAEzB,GAAoB5C,EAAMG,QAClC,IAAI8M,EAAK,KACT,GAA4B,GAAxB/0B,MAAMuQ,QAAQg0B,GAAiB,CACjB,OAAVA,IACAA,EAAQ,IACZ,MAAMtZ,EAAU,GAChBA,EAAQhoB,KAAK,CAAC,EAAGshC,EAAMzgC,UACvBygC,EAAQ,CAACA,IACHtZ,QAAUA,CACpB,CAEA,GADA8J,EAAKrK,EAAgBI,gBAAgByZ,EAAOvL,EAAOvrB,MAC/CsnB,EAEA,OADSA,EAAG9I,OAAO5R,EAAUk0B,GAAM,EAAOzS,EAAa3P,EAG/D,CAQA,qBAAOqrB,CAAezyC,EAAMmwC,EAAU/oB,GAClC,MAAM,WAAEyY,GAAe9c,EAAMG,QAC7B,IAAI8B,EAAImrB,EAAS7iC,WACjB0X,EAAIA,EAAE4D,UAAU,EAAG5D,EAAEwtC,YAAY,KAAO,GAAGhyD,MAAM,GAAI,GACrDwkB,EAAI6a,EAAWs1B,aAAanwC,GAC5B,IACI0a,EADM,IAAI9iC,OAAOooB,GACNjf,KAAK/F,GAIpB,OAHI0/B,IACAA,EAAKhX,OAASgX,EAAK,GAAG3gC,QAEnB2gC,CACX,CAEA,2BAAOra,CAAqBb,GACxB,MAAO,CAACI,EAAGR,KACP,MAAM+0C,EAAc/0C,EAAOqqC,sBAAwB1rC,EAAMG,QAAQD,YACjE,IAAI5oB,EAAI,CAAC,EACT,IAAK,IAAIoJ,KAAKmhB,EAAG,CACb,IAAII,EAAI,IAAIm0C,EAAY30C,GACxBU,EAAWC,UAAUf,EAAQY,EAAGJ,EAAEnhB,IAClCpJ,EAAEoJ,GAAKuhB,EACPZ,EAAOqxB,WAAWzwB,EACtB,CACA,OAAO3qB,CAAC,CAEhB,CAQA,sBAAO63C,CAAgBvuB,EAAU+C,EAAK0yC,GAClC,OAAQA,GACJ,IAAK,OACD,OAAOz1C,EAASnjB,MAAMkmB,EAAM,GAChC,IAAK,SACD,MACJ,IAAK,MACD,OAAO/C,EAASnjB,MAAM,GAC1B,IAAK,UACD,IAAImD,EAAIggB,EAASnjB,MAAM,GAEvB,cADQmD,EAAE+iB,GACH/iB,EAEf,MAAO,EACX,EAKJ5J,EAAQgpB,MAAQA,EAGhB,MAAM,iBAAE8gB,GAAqB,EAAQ,G,8BC1oCrCzoC,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IAEpD,MAAMmV,EAAS,EAAQ,OACjB,eAAEgV,GAAmB,EAAQ,MAC7B/S,EAAW,CACb,uBAAwBvI,UACpB,MAAM,SAAEsE,GAAagC,EAAOlI,OAAOujD,iBACnC,IAAKr9C,EACD,OAEJ,IAAI,OAACyF,GAAUzF,EAASs9C,IACxB,GAAc,QAAV73C,EACA,OAML,GAAY,GAHEzD,EAAO6B,UAAUrc,MAAM,CAACke,SAAS,OAAQ1F,GAIrD,MAAM,IAAI7P,MAAM,wCAKjB,MAAMoB,EAAMyO,EAAS+C,UAEfw6C,EAAOvmC,EAAeC,OAAO1lB,GAEnCoR,QAAQC,IAAI,yBACZZ,EAAOw7C,UAAUC,iBAAiB,CAC9B,SAAW,OACX,QAAUF,IACXrjD,MAAMyJ,IACL3B,EAAOlI,OAAO4jD,iBAAiB/5C,EAAE,GACnC,GAIV5lB,EAAQkmB,SAAWA,C,iBCvCnB,MAAM,WAAE7B,GAAe,EAAQ,KAGzB8N,EAAQ,CACV1J,KAAM,CAMF,cAAAD,CAAehV,GA6GX,IAAIosD,EAAcv7C,EAAWkT,WA5GZ,CACb8N,UAAW,eACXsU,WAAY,CACR,mBAAoB,CAChB,MAAS,OACT,YAAe,IACf,YAAe,IACf,QAAW,MAEf,gBAAiB,CACb,MAAS,8BACT,IAAO,cACP,QAAW,YAEf,gBAAiB,CACb,MAAS,SACT,IAAO,YACP,QAAW,QACX,SAAY,CACR,CACI,QAAW,qBACZ,CACC,MAAS,iBAEb,CACI,MAAS,UACT,YAAe,IAEnB,CACI,MAAS,OACT,IAAO,OACP,YAAe,MAI3B,aAAc,CACV,MAAS,MACT,IAAO,YACP,QAAW,aACX,SAAY,CACR,CACI,QAAW,oBAIvB,0BAA2B,CACvB,SAAY,CACR,CACI,QAAW,kBAEf,CACI,QAAW,sBAEf,CACI,QAAW,iBAIvB,2BAA4B,CACxB,SAAY,CAAC,CACT,QAAW,kBAEf,CACI,QAAW,iBAGnB,uBAAwB,CACpBptC,MAAO,QACPtJ,IAAK,WACL0mB,QAAS,iBACTC,SAAU,CACN,CACIrd,MAAO,MACPtJ,IAAK,MACL0L,KAAM,+BACNib,SAAU,CACN,CACI,QAAW,iCAOnCA,SAAU,CACN,CACIrd,MAAO,SACPtJ,IAAK,WACL0L,KAAM,YACNgb,QAAS,kBACTC,SAAU,CACN,CACIrd,MAAO,MACPtJ,IAAK,MACL0L,KAAM,+BACNib,SAAU,CACN,CACI,QAAW,iCAM/B,CACImzC,QAAS,4BAKrB,MAAM8C,EAAa,CAAC,EACdC,EAAY,CAAC,EAkEnB,OA7DAF,EAAYrkD,SAAW,CAInB+gB,GAAI,KACJujC,aACAC,YAIA3lC,MAAO,EAMP,YAAA2C,CAAa5C,EAAQ7M,GAAQ,gBAAE0P,EAAe,QAAEpT,EAAO,MAAE7a,EAAK,OAAE6f,EAAM,aAAE7H,IACpE,MAAM,MAAEO,GAAUgG,EAGZ8E,EAAQ,EAAElH,EAAGR,KACR,CACH,MAASA,EAAEo1C,WACX,KAAQp1C,EAAEq1C,WACZ70C,IAJQ,CAKX5oB,KAAK83B,MAAO93B,MAEf,OAAQsnB,GACJ,IAAK,WACDtnB,KAAKi6B,GAAKxtB,EAAMA,MAAMmoB,OACtB,MACJ,IAAK,QACD,MAAM,GAAEqF,GAAOj6B,KAEf,GADAA,KAAKi6B,GAAK,KACS,QAAdj6B,KAAK83B,QAAsB,MAAMhnB,KAAKmpB,GACvC,MAEJnK,EAAMmK,GAAMxtB,EAAMA,MAAMmoB,OACxB,MACJ,SACS8F,GA3CV,cAAc5pB,KA2CiCwW,KACtCtnB,KAAK83B,MAAQ,GAI7B,EACA,cAAAF,CAAeC,EAAQ7M,GAAQ,gBAAE0P,IAC7B,MAAM,QAAEpT,GAAYuQ,EACpB,IAAK6C,GAAmB,cAAc5pB,KAAKwW,GAAU,CACjD,IAAI7f,EAAI6f,EAAQkF,UAAU,EAAGlF,EAAQ3kB,OAAS,IAC9C3C,KAAK83B,MAAQrwB,CACjB,CAEJ,EAEA4lB,YAAW,CAAC5gB,KAAUiE,IACXjE,GAID8wD,GAAajyD,OAAO6F,GAC3B,CACHkV,UAAWm3C,EACXl3C,SAAUm3C,EAElB,IAIR//D,EAAOC,QAAU,IACVmyB,E,8BCnMP9wB,OAAOD,eAAepB,EAAS,aAA/B,CAA8C8O,OAAM,IACpD,MAAM,MAAEsV,GAAU,EAAQ,MAC1BpkB,EAAQokB,MAAQA,EAChBpkB,EAAQ+/D,Y,iCCFR,MAAM,WAAE17C,GAAe,EAAQ,MAEzB27C,EAAW,CAChB,UAAa,UACb,aAAgB,UAChB,KAAQ,OACR,WAAc,UACd,MAAS,UACT,MAAS,UACT,OAAU,UACV,MAAS,OACT,eAAkB,UAClB,KAAQ,OACR,WAAc,UACd,MAAS,UACT,UAAa,UACb,UAAa,UACb,WAAc,UACd,UAAa,UACb,MAAS,UACT,eAAkB,UAClB,SAAY,UACZ,QAAW,UACX,KAAQ,OACR,SAAY,UACZ,SAAY,UACZ,cAAiB,UACjB,SAAY,UACZ,UAAa,UACb,SAAY,UACZ,UAAa,UACb,YAAe,UACf,eAAkB,UAClB,WAAc,UACd,WAAc,OACd,QAAW,UACX,WAAc,UACd,aAAgB,UAChB,cAAiB,UACjB,cAAiB,UACjB,cAAiB,UACjB,cAAiB,UACjB,WAAc,UACd,SAAY,UACZ,YAAe,UACf,QAAW,UACX,QAAW,UACX,WAAc,UACd,UAAa,UACb,YAAe,UACf,YAAe,UACf,QAAW,OACX,UAAa,UACb,WAAc,UACd,KAAQ,UACR,UAAa,UACb,KAAQ,UACR,MAAS,UACT,YAAe,UACf,KAAQ,UACR,SAAY,UACZ,QAAW,UACX,WAAc,UACd,UAAa,UACb,OAAU,UACV,MAAS,UACT,MAAS,UACT,SAAY,UACZ,cAAiB,UACjB,UAAa,UACb,aAAgB,UAChB,UAAa,UACb,WAAc,UACd,UAAa,UACb,qBAAwB,UACxB,UAAa,UACb,WAAc,UACd,UAAa,UACb,UAAa,UACb,YAAe,UACf,cAAiB,UACjB,aAAgB,UAChB,eAAkB,UAClB,eAAkB,UAClB,eAAkB,UAClB,YAAe,UACf,KAAQ,OACR,UAAa,OACb,MAAS,UACT,QAAW,OACX,OAAU,UACV,iBAAoB,OACpB,WAAc,OACd,aAAgB,UAChB,aAAgB,UAChB,eAAkB,UAClB,gBAAmB,UACnB,kBAAqB,UACrB,gBAAmB,UACnB,gBAAmB,UACnB,aAAgB,UAChB,UAAa,UACb,UAAa,UACb,SAAY,UACZ,YAAe,UACf,KAAQ,UACR,QAAW,UACX,MAAS,UACT,UAAa,UACb,OAAU,UACV,UAAa,UACb,OAAU,UACV,cAAiB,UACjB,UAAa,UACb,cAAiB,UACjB,cAAiB,UACjB,WAAc,UACd,UAAa,UACb,KAAQ,UACR,KAAQ,UACR,KAAQ,UACR,WAAc,UACd,OAAU,UACV,IAAO,OACP,UAAa,UACb,UAAa,UACb,YAAe,UACf,OAAU,UACV,WAAc,UACd,SAAY,UACZ,SAAY,UACZ,OAAU,UACV,OAAU,UACV,QAAW,UACX,UAAa,UACb,UAAa,UACb,UAAa,UACb,KAAQ,UACR,YAAe,UACf,UAAa,UACb,IAAO,UACP,KAAQ,UACR,QAAW,UACX,OAAU,UACV,YAAe,cACf,UAAa,UACb,OAAU,UACV,MAAS,UACT,MAAS,OACT,WAAc,UACd,OAAU,OACV,YAAe,QAEVC,EAAsB,CAAEzwD,IAE7B,IAAI0d,EAAK,CAAC,EACV,IAAK,IAAIxjB,KAAK8F,EAEb0d,EADQ1d,EAAE9F,IACFA,EAET,OAAOwjB,CACP,EAR2B,CAQzB8yC,GAoDH,SAASE,EAAcC,EAAKt6C,EAAE,KAC7B,OAAOtkB,KAAK6+D,MAAMD,EAAKt6C,GAAKA,CAC7B,CAGA,MAAMzB,EACL,+BAAOoC,CAAyB7X,EAAMsV,GACrC,MAAMQ,EAAaJ,EAAWM,KAAKhW,GACnC,IAAK8V,EACJ,MAAM,IAAIrS,MAAM,sBAEjB,MAAO,CACN,qBAAAqU,CAAsBxE,EAAUnW,GAC/B,MAAMiZ,EAAQ9C,EAAS+C,UAEjB0B,EAAgBtC,EAAMuC,cAAclC,EAAYM,GAChD6B,EAAU,GAChB,GAAIF,EACH,IACCA,EAAclmB,SAAQkJ,IACrB,IAAIwB,EAAI+W,EAAS4E,WAA4B,EAAjBnd,EAAEod,cAC1B3b,EAAI8W,EAAS4E,WAAWnd,EAAEod,aAAepd,EAAEoF,MAAM9J,QACrD,MAAMigB,EAAS,IAAIhB,EAAOiB,MAAMha,EAAGC,GAC7B4b,EAAS3C,EAAM4C,SAAmB,YAAVtd,EAAE4R,KAAqB8I,EAAM6C,aAAavd,EAAEoF,OAASpF,EAAEoF,MAAOmV,GACtFiD,EAAU,IAAIjD,EAAOkD,iBAAiBlC,EAAQ8B,GACpDH,EAAQziB,KAAK+iB,EAAQ,GAEvB,CAAE,MAAOE,GACRxC,QAAQyC,MAAM,SAAUD,EACzB,CAED,OAAOR,CACR,EAEF,CACA,8BAAOY,CAAwB7T,EAAIsQ,GAClC,MAAO,CAQN,yBAAAsD,CAA0Btf,EAAOoQ,EAASvM,GAEzC,MAAMwwB,EAAK,GACL6jC,EAAK,CAAEE,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAG32D,EAAG,EAAGE,EAAG,EAAGC,EAAG,EAAGy2D,EAAG,EAAG56C,EAAG,GACpDgV,EAAQ,CAAEjsB,KAAM,GAAI8xD,SAAU,MAepC,MAtGH,EAACx4D,EAAO+rB,KAEP,IAAI5N,EA2BN,SAAoBne,GACnB,IAAIswD,EAAoB,GAAftwD,EAAMy4D,MAAa72D,UAKb+iB,EAL6BrrB,KAAK6+D,MAAoB,IAAdn4D,EAAMy4D,OAMtDn/D,KAAKC,IANiE,IAMxDD,KAAKD,IAAI,EAAGsrB,MANkDrZ,SAAS,IAAIsrD,SAAS,EAAG,KAAO,GAKpH,IAAgBjyC,EAJf,MAAO,KAAmB,IAAZ3kB,EAAMud,KAAajS,SAAS,IAAIsrD,SAAS,EAAG,MAC1C,IAAd52D,EAAM04D,OAAeptD,SAAS,IAAIsrD,SAAS,EAAG,MACjC,IAAb52D,EAAM24D,MAAcrtD,SAAS,IAAIsrD,SAAS,EAAG,KAAOtG,CACvD,CAhCasI,CAAW54D,GAAOC,cACzB8rB,IACHA,EAAIysC,SAAWr6C,GAEhB,MAAM06C,EAAQ,GACd,GAjB+BL,EAiBHr6C,EAAKyI,UAAU,GAhBrC,8BAA8B1b,KAAKstD,GAgBO,CAC/C,IAAIM,EAAQ,IAAM36C,EAAKyI,UAAU,EAAG,GACnCzI,EAAKyI,UAAU,EAAG,GAClBzI,EAAKyI,UAAU,EAAG,GACnBiyC,EAAM38D,KAAK48D,EAAM74D,cAClB,CAtB8B,IAACu4D,EAwB/B,IADAK,EAAM38D,KAAKiiB,GACJ06C,EAAM97D,OAAS,GAErB,GADAohB,EAAO06C,EAAMhoD,QACTsN,KAAQ65C,EAIX,OAHIjsC,IACHA,EAAIrlB,KAAOsxD,EAAoB75C,KAEzB,EAGT,OAAO,CAAK,EAiEK46C,CAAc/4D,EAAO2yB,IAEnC0B,EAAGn4B,KAAK,IAAI8f,EAAOg9C,kBAAkBrmC,EAAMjsB,OAE5C2tB,EAAGn4B,KAAK,IAAI8f,EAAOg9C,kBAAkBrmC,EAAM6lC,WAC3CN,EAAGE,EAAiB,IAAZp4D,EAAMud,IACd26C,EAAGG,EAAmB,IAAdr4D,EAAM04D,MACdR,EAAGI,EAAkB,IAAbt4D,EAAM24D,KACdT,EAAGK,EAAmB,IAAdv4D,EAAMy4D,MACdP,EAAGv6C,EAAI3d,EAAMy4D,MACM,GAAfz4D,EAAMy4D,OACTpkC,EAAGn4B,KAAK,IAAI8f,EAAOg9C,kBAAkB,OAAOd,EAAGE,MAAMF,EAAGG,MAAMH,EAAGI,OAClEjkC,EAAGn4B,KAAK,IAAI8f,EAAOg9C,kBAAkB,QAAQd,EAAGE,MAAMF,EAAGG,MAAMH,EAAGI,MAAMJ,EAAGv6C,OAC3E0W,EAAGn4B,KAAK,IAAI8f,EAAOg9C,kBAAkB,OAAOf,EAAcj4D,EAAMud,SAAS06C,EAAcj4D,EAAM04D,WAAWT,EAAcj4D,EAAM24D,UAAUV,EAAcj4D,EAAMy4D,eACnJpkC,CACR,EAEF,CACA,mBAAOrV,CAAahf,GACnB,OAAO+3D,EAAS/3D,IAAU,MAC3B,CAOA,eAAO+e,CAASy5C,EAAUx8C,GACzB,IAAIi9C,EAAO,EAAGC,EAAS,EAAGC,EAAQ,EAC9BC,EAAS,EACb,MAAMhrC,EAAKoqC,EAAS5xC,UAAU,GACxBs7B,EAAQsW,EAASz7D,OAAS,EAChC,OAAQmlD,GACP,KAAK,EACL,KAAK,EACJ+W,EAAOr3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAG5qB,OAAO,GAAI,IAAM,IACpDk9D,EAASt3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAG5qB,OAAO,GAAI,IAAM,IACtDm9D,EAAQv3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAG5qB,OAAO,GAAI,IAAM,IACxC,GAATkmD,IACHkX,EAAUx3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAG5qB,OAAO,GAAI,IAAM,KAExD,MACD,KAAK,EACJi9D,EAAOr3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAI,IAAM,IAC1CsyC,EAASt3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAI,IAAM,IAC5CuyC,EAAQv3D,SAASwsB,EAAGxH,UAAU,EAAG,GAAI,IAAM,IAG7C,OAAO,IAAI5K,EAAOq9C,MAAMJ,EAAMC,EAAQC,EAAOC,EAE9C,CAQA,oBAAO16C,CAAciH,EAAWpa,GAC/B,MAAM+tD,EAAe,GACf5nC,EAAY,CAQjB,YAAAmD,CAAa5C,EAAQ7M,EAAQ0P,GAAkB,GAC9C,GAAIA,EACH,OAED,MAAM,QAAEpT,EAAO,MAAE7a,EAAK,OAAE6f,EAAM,aAAE7H,GAAiBzC,EAAW+1B,qBAAqBlgB,EAAQ7M,IACnF,MAAEhG,GAAUgG,EAClB,OAAQ1D,GACP,IAAK,WACL,IAAK,WACJ,MAAMwU,EAAO,CAAE,KAAQxU,EAAS,MAAS7a,EAAM8G,OAAQkR,eAAc6H,UACrE4yC,EAAap9D,KAAKg6B,GAClB9W,GAASzC,QAAQC,IAAIsZ,GAGxB,GAID,OAFAvQ,EAAUrS,SAAWoe,EACrB/L,EAAUjgB,OAAO6F,GACV+tD,CACR,EAGDvhE,EAAQokB,MAAQA,C,iBCjWhB/iB,OAAOD,eAAepB,EAAS,aAA/B,CAA+C8O,OAAO,IAEtD,MAAM,yBAAE41B,GAA6B,EAAQ,MACvC88B,EAAS,EAAQ,OAGjB,SAAEv4C,EAAQ,YAAEC,EAAW,MAAE8V,GAAUwiC,EAAOx4C,MAAMG,QAehDs4C,EAAkB,CACpB,QAAU,UACV,gBAAgB,QA+BdC,EAAgB,CAClBrmB,iBAhBJ,cAA2BpyB,EACvB04C,UACA,QAAAxJ,CAASvyC,GACLuhB,MAAMgxB,SAASvyC,IACVA,EAAE+7C,WAAat/D,KAAKs/D,YACrB/7C,EAAE+7C,UAAYt/D,KAAKs/D,UAE3B,GAUAjN,qBARJ,cAA2BxrC,EACvBy4C,UACA,WAAAlqD,CAAYgT,GACR0c,MAAM1c,EACV,GAKAmtC,yBAzBJ,cAA4ClzB,EACxCi9B,UACAh4C,QACA,QAAAi4C,GACI,OAXUj4C,EAWMtnB,KAAKsnB,WAVV83C,EACJA,EAAgB93C,GAEpBA,EAAQuL,cAJnB,IAAkBvL,CAYd,IAqKJ3pB,EAAQ0hE,cAAgBA,EACxB1hE,EAAQ6hE,SAnMR,SAAkBpuD,EAAQquD,GACtB,IACIC,EAAS,yEADGD,EAAiB,IAAI98D,OAC6D,MAC9Fg9D,EAAa,EACjBvuD,EAAOwuD,iBAAiB,YAAYzhE,SAAQkJ,IACxC,IAAI4B,EAAI2W,SAASigD,cAAc,OAC/B52D,EAAE62D,UAAYH,EAAa,EAC3B12D,EAAEpL,MAAQ6hE,EACVr4D,EAAE04D,aAAa92D,EAAG5B,EAAE24D,YACpBL,GAAY,GAEpB,EAyLAhiE,EAAQsiE,sBA3IR,SAA+BrmC,GAa3B,OAZAA,EAAKsmC,cAAgB,EAErBtmC,EAAKumC,eAAiB,CAClB,QAAU,EACV,SAAW,EACX,KAAO,EACP,OAAS,EACT,SAAW,EACX,gBAAgB,EAChB,OAAS,EACT,OAAS,GAEN,WACH,IAIIC,EAAS,CACTx6B,UAAS,EAAC,SAACC,KACA,GAEXC,WAAU,IACC,GAEX,cAAAkb,EAAe,KAACllB,EAAI,OAAEjG,EAAM,KAAEluB,EAAI,YAAEulC,IACN,GAAtBvlC,EAAKitB,OAAOjyB,QACRuqC,EAAYlG,SAAuC,GAA3BkG,EAAYxiB,OAAO/nB,QAGnDkzB,GACJ,EACA,WAAAxI,CAAY9C,EAAGQ,EAAQzD,EAAS6D,EAAQnG,EAAO6S,GAE3C,GADA7S,GAAS2X,EAAMna,IAAI,cAAe,CAAC/V,MAAM8d,EAAGjD,UAASyD,OAAQA,EAAO3mB,MAAM,KAC5D,GAAVmmB,EAAE5nB,OACF,MAAO,GAEX,IAAIkvB,EAAK9G,EAAOtU,QACZxN,EAAI,KACJo3D,EAAU,GACVC,EAAO,CAAC,EAsBZ,OArBIh5C,IACAg5C,EAAKh5C,GAAW,EAChBsS,EAAKumC,eAAe74C,GAAW,GAE/BuQ,GAAQynC,WACRznC,EAAOynC,UAAU58D,MAAM,KAAKvE,SAAQolB,IACb,GAAjBA,EAAEqR,OAAOjyB,SACX29D,EAAK/8C,GAAG,EACFA,KAAKqW,EAAKumC,iBACZvmC,EAAKumC,eAAe58C,GAAK,GAAC,IAGlC,YAAYzS,KAAK+gB,KACjBtH,EAAIA,EAAEnpB,QAAQ,IAAK,QAAQA,QAAQ,IAAK,QACxCk/D,EAAQ,EAAE,EACVA,EAAa,OAAE,GAEf,mBAAmBxvD,KAAK+gB,KACxBtH,EAAI,0FAA6FA,EAAE,mCAAoCA,GAE3I81C,EAAUrhE,OAAO8S,KAAKwuD,GAAM1hE,KAAK,KACb,GAAhByhE,EAAQ19D,OACD4nB,EAEiB,oBAAd,UACVthB,EAAI2W,SAASigD,cAAc,QAC3B52D,EAAEq2D,UAAYe,EACdp3D,EAAE62D,UAAYv1C,EAEPthB,EAAEs3D,YAEDF,EAAQ19D,OAAO,IACf09D,EAAU,WAAYA,EAAQ,KAEzB,QAAQA,EAAQ,IAAI91C,EAAE,UAG3C,EACA,OAAA+8B,GACI/kC,QAAQC,IAAI,eAChB,EACA,iBAAA2b,EAAkB,OAACrS,IAEfA,EAAOhqB,KAAK,GAChB,EACA,WAAA06C,EAAY,OAAC1wB,EAAM,SAAE+Z,EAAQ,QAAEH,IAC3B,MAAMnsB,EAAI,GAWV,OATAuS,EAAO3tB,SAASyqB,IACZA,EAAElmB,MAAM,MAAMvE,SAAQm9C,IAElBA,EAAK,qBAAuBA,EAC5BA,GAAK,SACL/hC,EAAEzX,KAAKw5C,GACP1hB,EAAKsmC,eAAe,GACtB,IAEC3mD,EAAE3a,KAAKinC,GAAUzE,SAC5B,EACA,MAAAtV,EAAO,OAAE8O,EAAM,OAAE9O,EAAM,SAAE+Z,EAAQ,MAAExH,EAAK,KAAEiQ,IACtC,IAAI/0B,EAAI,GAIR,OAFIA,EAAKuS,EAAOltB,KAAKinC,GAEdtsB,CACX,EAKA,KAAA0W,EAAM,OAAEnE,EAAM,OAAE8O,EAAM,MAAE+K,EAAK,QAAED,EAAO,gBAAED,IAa1B,CAAC7K,GACTz8B,SAZmB,SAASy8B,GACP,GAAfA,EAAOj4B,SAGPgjC,EAAQ,IACR/K,EAAS,SAAY,SAASh5B,OAAO,GAAIA,OAAO+jC,GAAS,UAAY/K,GAIzE9O,EAAOhqB,KAAK84B,GAChB,GAGJ,EACA,aAAA4K,CAAcjiB,GAEd,GAKJ,OAHAvkB,OAAOD,eAAe66B,EAAM,aAAc,CAACjtB,IAAG,IACnC6zD,WAEJJ,CACX,CACJ,C,wBC1MA1iE,EAAOC,QAAU8iE,QAAQ,S,mrgJCCrBC,EAA2B,CAAC,EAGhC,SAASt5C,EAAoBu5C,GAE5B,IAAIC,EAAeF,EAAyBC,GAC5C,QAAqBn1D,IAAjBo1D,EACH,OAAOA,EAAajjE,QAGrB,IAAID,EAASgjE,EAAyBC,GAAY,CAGjDhjE,QAAS,CAAC,GAOX,OAHAkjE,EAAoBF,GAAUjjE,EAAQA,EAAOC,QAASypB,GAG/C1pB,EAAOC,OACf,CCtBAypB,EAAoB5N,EAAI,CAAC7T,EAAKkoC,IAAU7uC,OAAOF,UAAUuN,eAAevL,KAAK6E,EAAKkoC,GCGlF,IAAIizB,EAAsB15C,EAAoB,M","sources":["webpack://balafon-formatters/./node_modules/cli-color/art.js","webpack://balafon-formatters/./node_modules/cli-color/bare.js","webpack://balafon-formatters/./node_modules/cli-color/beep.js","webpack://balafon-formatters/./node_modules/cli-color/columns.js","webpack://balafon-formatters/./node_modules/cli-color/erase.js","webpack://balafon-formatters/./node_modules/cli-color/get-stripped-length.js","webpack://balafon-formatters/./node_modules/cli-color/index.js","webpack://balafon-formatters/./node_modules/cli-color/lib/sgr.js","webpack://balafon-formatters/./node_modules/cli-color/lib/supports-color.js","webpack://balafon-formatters/./node_modules/cli-color/lib/xterm-colors.js","webpack://balafon-formatters/./node_modules/cli-color/lib/xterm-match.js","webpack://balafon-formatters/./node_modules/cli-color/move.js","webpack://balafon-formatters/./node_modules/cli-color/regex-ansi.js","webpack://balafon-formatters/./node_modules/cli-color/reset.js","webpack://balafon-formatters/./node_modules/cli-color/slice.js","webpack://balafon-formatters/./node_modules/cli-color/strip.js","webpack://balafon-formatters/./node_modules/cli-color/throbber.js","webpack://balafon-formatters/./node_modules/cli-color/window-size.js","webpack://balafon-formatters/./node_modules/d/auto-bind.js","webpack://balafon-formatters/./node_modules/d/index.js","webpack://balafon-formatters/./node_modules/d/lazy.js","webpack://balafon-formatters/./node_modules/es5-ext/array/\u0000#/clear.js","webpack://balafon-formatters/./node_modules/es5-ext/array/\u0000#/e-index-of.js","webpack://balafon-formatters/./node_modules/es5-ext/array/\u0000#/for-each-right.js","webpack://balafon-formatters/./node_modules/es5-ext/array/\u0000#/uniq.js","webpack://balafon-formatters/./node_modules/es5-ext/array/from/index.js","webpack://balafon-formatters/./node_modules/es5-ext/array/from/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/array/from/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/array/generate.js","webpack://balafon-formatters/./node_modules/es5-ext/array/to-array.js","webpack://balafon-formatters/./node_modules/es5-ext/error/custom.js","webpack://balafon-formatters/./node_modules/es5-ext/function/\u0000#/compose.js","webpack://balafon-formatters/./node_modules/es5-ext/function/_define-length.js","webpack://balafon-formatters/./node_modules/es5-ext/function/is-arguments.js","webpack://balafon-formatters/./node_modules/es5-ext/function/is-function.js","webpack://balafon-formatters/./node_modules/es5-ext/function/noop.js","webpack://balafon-formatters/./node_modules/es5-ext/iterable/is.js","webpack://balafon-formatters/./node_modules/es5-ext/iterable/validate-object.js","webpack://balafon-formatters/./node_modules/es5-ext/math/sign/index.js","webpack://balafon-formatters/./node_modules/es5-ext/math/sign/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/math/sign/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/math/trunc/index.js","webpack://balafon-formatters/./node_modules/es5-ext/math/trunc/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/math/trunc/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/number/is-nan/index.js","webpack://balafon-formatters/./node_modules/es5-ext/number/is-nan/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/number/is-nan/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/number/to-integer.js","webpack://balafon-formatters/./node_modules/es5-ext/number/to-pos-integer.js","webpack://balafon-formatters/./node_modules/es5-ext/object/_iterate.js","webpack://balafon-formatters/./node_modules/es5-ext/object/assign/index.js","webpack://balafon-formatters/./node_modules/es5-ext/object/assign/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/object/assign/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/object/copy.js","webpack://balafon-formatters/./node_modules/es5-ext/object/create.js","webpack://balafon-formatters/./node_modules/es5-ext/object/first-key.js","webpack://balafon-formatters/./node_modules/es5-ext/object/for-each.js","webpack://balafon-formatters/./node_modules/es5-ext/object/is-array-like.js","webpack://balafon-formatters/./node_modules/es5-ext/object/is-callable.js","webpack://balafon-formatters/./node_modules/es5-ext/object/is-object.js","webpack://balafon-formatters/./node_modules/es5-ext/object/is-value.js","webpack://balafon-formatters/./node_modules/es5-ext/object/keys/index.js","webpack://balafon-formatters/./node_modules/es5-ext/object/keys/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/object/keys/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/object/map.js","webpack://balafon-formatters/./node_modules/es5-ext/object/mixin.js","webpack://balafon-formatters/./node_modules/es5-ext/object/normalize-options.js","webpack://balafon-formatters/./node_modules/es5-ext/object/primitive-set.js","webpack://balafon-formatters/./node_modules/es5-ext/object/set-prototype-of/index.js","webpack://balafon-formatters/./node_modules/es5-ext/object/set-prototype-of/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/object/set-prototype-of/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/object/valid-callable.js","webpack://balafon-formatters/./node_modules/es5-ext/object/valid-object.js","webpack://balafon-formatters/./node_modules/es5-ext/object/valid-value.js","webpack://balafon-formatters/./node_modules/es5-ext/object/validate-stringifiable-value.js","webpack://balafon-formatters/./node_modules/es5-ext/object/validate-stringifiable.js","webpack://balafon-formatters/./node_modules/es5-ext/safe-to-string.js","webpack://balafon-formatters/./node_modules/es5-ext/string/\u0000#/contains/index.js","webpack://balafon-formatters/./node_modules/es5-ext/string/\u0000#/contains/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/string/\u0000#/contains/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/string/\u0000#/repeat/index.js","webpack://balafon-formatters/./node_modules/es5-ext/string/\u0000#/repeat/is-implemented.js","webpack://balafon-formatters/./node_modules/es5-ext/string/\u0000#/repeat/shim.js","webpack://balafon-formatters/./node_modules/es5-ext/string/is-string.js","webpack://balafon-formatters/./node_modules/es5-ext/to-short-string-representation.js","webpack://balafon-formatters/./node_modules/es6-iterator/array.js","webpack://balafon-formatters/./node_modules/es6-iterator/for-of.js","webpack://balafon-formatters/./node_modules/es6-iterator/get.js","webpack://balafon-formatters/./node_modules/es6-iterator/index.js","webpack://balafon-formatters/./node_modules/es6-iterator/is-iterable.js","webpack://balafon-formatters/./node_modules/es6-iterator/string.js","webpack://balafon-formatters/./node_modules/es6-iterator/valid-iterable.js","webpack://balafon-formatters/./node_modules/es6-symbol/index.js","webpack://balafon-formatters/./node_modules/es6-symbol/is-implemented.js","webpack://balafon-formatters/./node_modules/es6-symbol/is-symbol.js","webpack://balafon-formatters/./node_modules/es6-symbol/lib/private/generate-name.js","webpack://balafon-formatters/./node_modules/es6-symbol/lib/private/setup/standard-symbols.js","webpack://balafon-formatters/./node_modules/es6-symbol/lib/private/setup/symbol-registry.js","webpack://balafon-formatters/./node_modules/es6-symbol/polyfill.js","webpack://balafon-formatters/./node_modules/es6-symbol/validate-symbol.js","webpack://balafon-formatters/./node_modules/event-emitter/index.js","webpack://balafon-formatters/./node_modules/ext/global-this/implementation.js","webpack://balafon-formatters/./node_modules/ext/global-this/index.js","webpack://balafon-formatters/./node_modules/ext/global-this/is-implemented.js","webpack://balafon-formatters/./node_modules/is-promise/index.js","webpack://balafon-formatters/./node_modules/lru-queue/index.js","webpack://balafon-formatters/./node_modules/memoizee/ext/async.js","webpack://balafon-formatters/./node_modules/memoizee/ext/dispose.js","webpack://balafon-formatters/./node_modules/memoizee/ext/max-age.js","webpack://balafon-formatters/./node_modules/memoizee/ext/max.js","webpack://balafon-formatters/./node_modules/memoizee/ext/promise.js","webpack://balafon-formatters/./node_modules/memoizee/ext/ref-counter.js","webpack://balafon-formatters/./node_modules/memoizee/index.js","webpack://balafon-formatters/./node_modules/memoizee/lib/configure-map.js","webpack://balafon-formatters/./node_modules/memoizee/lib/methods.js","webpack://balafon-formatters/./node_modules/memoizee/lib/resolve-length.js","webpack://balafon-formatters/./node_modules/memoizee/lib/resolve-normalize.js","webpack://balafon-formatters/./node_modules/memoizee/lib/resolve-resolve.js","webpack://balafon-formatters/./node_modules/memoizee/methods.js","webpack://balafon-formatters/./node_modules/memoizee/normalizers/get-1.js","webpack://balafon-formatters/./node_modules/memoizee/normalizers/get-fixed.js","webpack://balafon-formatters/./node_modules/memoizee/normalizers/get-primitive-fixed.js","webpack://balafon-formatters/./node_modules/memoizee/normalizers/get.js","webpack://balafon-formatters/./node_modules/memoizee/normalizers/primitive.js","webpack://balafon-formatters/./node_modules/memoizee/plain.js","webpack://balafon-formatters/./node_modules/next-tick/index.js","webpack://balafon-formatters/./node_modules/timers-ext/max-timeout.js","webpack://balafon-formatters/./node_modules/timers-ext/valid-timeout.js","webpack://balafon-formatters/./node_modules/type/function/is.js","webpack://balafon-formatters/./node_modules/type/lib/resolve-error-message.js","webpack://balafon-formatters/./node_modules/type/lib/resolve-exception.js","webpack://balafon-formatters/./node_modules/type/lib/safe-to-string.js","webpack://balafon-formatters/./node_modules/type/lib/to-short-string.js","webpack://balafon-formatters/./node_modules/type/object/is.js","webpack://balafon-formatters/./node_modules/type/plain-function/ensure.js","webpack://balafon-formatters/./node_modules/type/plain-function/is.js","webpack://balafon-formatters/./node_modules/type/prototype/is.js","webpack://balafon-formatters/./node_modules/type/string/coerce.js","webpack://balafon-formatters/./node_modules/type/value/ensure.js","webpack://balafon-formatters/./node_modules/type/value/is.js","webpack://balafon-formatters/./src/extension.js","webpack://balafon-formatters/./src/formatter.js","webpack://balafon-formatters/./src/formatters/ sync ^\\.\\/.*\\.btm\\-syntax\\.json$","webpack://balafon-formatters/./src/lib/BlockInfo.js","webpack://balafon-formatters/./src/lib/CaptureInfo.js","webpack://balafon-formatters/./src/lib/CaptureRenderer.js","webpack://balafon-formatters/./src/lib/Css/CssAtLayerDefinition.js","webpack://balafon-formatters/./src/lib/Css/CssAtRuleProperty.js","webpack://balafon-formatters/./src/lib/Css/CssCounterStyle.js","webpack://balafon-formatters/./src/lib/Css/CssFontFaceStyle.js","webpack://balafon-formatters/./src/lib/Css/CssImports.js","webpack://balafon-formatters/./src/lib/Css/CssLayerStyle.js","webpack://balafon-formatters/./src/lib/Css/CssProperties.js","webpack://balafon-formatters/./src/lib/Css/CssStyle.js","webpack://balafon-formatters/./src/lib/Css/CssStyleDefinitions.js","webpack://balafon-formatters/./src/lib/Css/CssStyleRenderer.js","webpack://balafon-formatters/./src/lib/Css/CssTransformer.js","webpack://balafon-formatters/./src/lib/Debug.js","webpack://balafon-formatters/./src/lib/EndMissingEngine/bhtml.js","webpack://balafon-formatters/./src/lib/EndMissingEngine/engines.js","webpack://balafon-formatters/./src/lib/FormatterBuffer.js","webpack://balafon-formatters/./src/lib/FormatterBufferUtils.js","webpack://balafon-formatters/./src/lib/FormatterCloseParentInfo.js","webpack://balafon-formatters/./src/lib/FormatterDebugger.js","webpack://balafon-formatters/./src/lib/FormatterEndMissingEngine.js","webpack://balafon-formatters/./src/lib/FormatterEndMissingExpression.js","webpack://balafon-formatters/./src/lib/FormatterErrors.js","webpack://balafon-formatters/./src/lib/FormatterLineMatcher.js","webpack://balafon-formatters/./src/lib/FormatterLineSegment.js","webpack://balafon-formatters/./src/lib/FormatterLintError.js","webpack://balafon-formatters/./src/lib/FormatterListener.js","webpack://balafon-formatters/./src/lib/FormatterMarkerInfo.js","webpack://balafon-formatters/./src/lib/FormatterMatchTreatment.js","webpack://balafon-formatters/./src/lib/FormatterOptions.js","webpack://balafon-formatters/./src/lib/FormatterPatternException.js","webpack://balafon-formatters/./src/lib/FormatterSegmentInfo.js","webpack://balafon-formatters/./src/lib/FormatterSegmentJoin.js","webpack://balafon-formatters/./src/lib/FormatterSetting.js","webpack://balafon-formatters/./src/lib/FormatterStreamBuffer.js","webpack://balafon-formatters/./src/lib/FormatterSyntaxException.js","webpack://balafon-formatters/./src/lib/FormatterToken.js","webpack://balafon-formatters/./src/lib/Formatters.js","webpack://balafon-formatters/./src/lib/FormattingCodeStyles.js","webpack://balafon-formatters/./src/lib/Formattings/FormattingBase.js","webpack://balafon-formatters/./src/lib/Formattings/FormattingMode.js","webpack://balafon-formatters/./src/lib/Formattings/KAndRFormatting.js","webpack://balafon-formatters/./src/lib/JSonParser.js","webpack://balafon-formatters/./src/lib/NativeRegExp.js","webpack://balafon-formatters/./src/lib/PatterMatchErrorInfo.js","webpack://balafon-formatters/./src/lib/PatternFormattingOptions.js","webpack://balafon-formatters/./src/lib/PatternMatchInfo.js","webpack://balafon-formatters/./src/lib/Patterns.js","webpack://balafon-formatters/./src/lib/RefPatterns.js","webpack://balafon-formatters/./src/lib/RegexEngine.js","webpack://balafon-formatters/./src/lib/RegexUtils.js","webpack://balafon-formatters/./src/lib/ReplaceWithCondition.js","webpack://balafon-formatters/./src/lib/TransformEngine.js","webpack://balafon-formatters/./src/lib/Utils.js","webpack://balafon-formatters/./src/vscode/command.js","webpack://balafon-formatters/./src/vscode/completion.js","webpack://balafon-formatters/./src/vscode/index.js","webpack://balafon-formatters/./src/vscode/utils.js","webpack://balafon-formatters/./src/web/Utils.js","webpack://balafon-formatters/external commonjs \"vscode\"","webpack://balafon-formatters/webpack/bootstrap","webpack://balafon-formatters/webpack/runtime/hasOwnProperty shorthand","webpack://balafon-formatters/webpack/startup"],"sourcesContent":["\"use strict\";\n\nvar object        = require(\"es5-ext/object/valid-object\")\n  , stringifiable = require(\"es5-ext/object/validate-stringifiable-value\")\n  , forOf         = require(\"es6-iterator/for-of\");\n\nmodule.exports = function (text, style) {\n\tvar result = \"\";\n\ttext = stringifiable(text);\n\tobject(style);\n\tforOf(text, function (char) { result += style[char] || char; });\n\treturn result;\n};\n","\"use strict\";\n\nvar d              = require(\"d\")\n  , assign         = require(\"es5-ext/object/assign\")\n  , forEach        = require(\"es5-ext/object/for-each\")\n  , map            = require(\"es5-ext/object/map\")\n  , primitiveSet   = require(\"es5-ext/object/primitive-set\")\n  , setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , memoize        = require(\"memoizee\")\n  , memoizeMethods = require(\"memoizee/methods\")\n  , sgr            = require(\"./lib/sgr\")\n  , supportsColor  = require(\"./lib/supports-color\");\n\nvar mods           = sgr.mods\n  , join           = Array.prototype.join\n  , defineProperty = Object.defineProperty\n  , max            = Math.max\n  , min            = Math.min\n  , variantModes   = primitiveSet(\"_fg\", \"_bg\")\n  , xtermMatch     = process.platform === \"win32\" ? require(\"./lib/xterm-match\") : null;\n\nvar getFn;\n\n// Some use cli-color as: console.log(clc.red('Error!'));\n// Which is inefficient as on each call it configures new clc object\n// with memoization we reuse once created object\nvar memoized = memoize(function (scope, mod) {\n\treturn defineProperty(getFn(), \"_cliColorData\", d(assign({}, scope._cliColorData, mod)));\n});\n\nvar proto = Object.create(\n\tFunction.prototype,\n\tassign(\n\t\tmap(mods, function (mod) {\n\t\t\treturn d.gs(function () { return memoized(this, mod); });\n\t\t}),\n\t\tmemoizeMethods({\n\t\t\t// xterm (255) color\n\t\t\txterm: d(function (code) {\n\t\t\t\tcode = isNaN(code) ? 255 : min(max(code, 0), 255);\n\t\t\t\treturn defineProperty(\n\t\t\t\t\tgetFn(), \"_cliColorData\",\n\t\t\t\t\td(\n\t\t\t\t\t\tassign({}, this._cliColorData, {\n\t\t\t\t\t\t\t_fg: [xtermMatch ? xtermMatch[code] : \"38;5;\" + code, 39]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}),\n\t\t\tbgXterm: d(function (code) {\n\t\t\t\tcode = isNaN(code) ? 255 : min(max(code, 0), 255);\n\t\t\t\treturn defineProperty(\n\t\t\t\t\tgetFn(), \"_cliColorData\",\n\t\t\t\t\td(\n\t\t\t\t\t\tassign({}, this._cliColorData, {\n\t\t\t\t\t\t\t_bg: [xtermMatch ? xtermMatch[code] + 10 : \"48;5;\" + code, 49]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t})\n\t\t})\n\t)\n);\n\nvar getEndRe = memoize(function (code) { return new RegExp(\"\\x1b\\\\[\" + code + \"m\", \"g\"); }, {\n\tprimitive: true\n});\n\ngetFn = function () {\n\treturn setPrototypeOf(\n\t\tfunction self(/* …msg*/) {\n\t\t\tvar start = \"\"\n\t\t\t  , end = \"\"\n\t\t\t  , msg = join.call(arguments, \" \")\n\t\t\t  , conf = self._cliColorData\n\t\t\t  , hasAnsi = sgr.hasCSI(msg);\n\t\t\tforEach(\n\t\t\t\tconf,\n\t\t\t\tfunction (mod, key) {\n\t\t\t\t\tend = sgr(mod[1]) + end;\n\t\t\t\t\tstart += sgr(mod[0]);\n\t\t\t\t\tif (hasAnsi) {\n\t\t\t\t\t\tmsg = msg.replace(getEndRe(mod[1]), variantModes[key] ? sgr(mod[0]) : \"\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tif (!supportsColor.isColorSupported()) return msg;\n\t\t\treturn start + msg + end;\n\t\t},\n\t\tproto\n\t);\n};\n\nmodule.exports = Object.defineProperties(getFn(), {\n\txtermSupported: d(!xtermMatch),\n\t_cliColorData: d(\"\", {})\n});\n","\"use strict\";\n\nmodule.exports = \"\\x07\";\n","\"use strict\";\n\nvar generate          = require(\"es5-ext/array/generate\")\n  , from              = require(\"es5-ext/array/from\")\n  , iterable          = require(\"es5-ext/iterable/validate-object\")\n  , isValue           = require(\"es5-ext/object/is-value\")\n  , stringifiable     = require(\"es5-ext/object/validate-stringifiable\")\n  , repeat            = require(\"es5-ext/string/#/repeat\")\n  , getStrippedLength = require(\"./get-stripped-length\");\n\nvar push = Array.prototype.push;\n\nmodule.exports = function (inputRows /*, options*/) {\n\tvar options = Object(arguments[1])\n\t  , colsMeta = []\n\t  , colsOptions = options.columns || []\n\t  , rows = [];\n\n\tfrom(iterable(inputRows), function (row) {\n\t\tvar rowRows = [[]];\n\t\tfrom(iterable(row), function (cellStr, columnIndex) {\n\t\t\tvar cellRows = stringifiable(cellStr).split(\"\\n\");\n\t\t\twhile (cellRows.length > rowRows.length) rowRows.push(generate(columnIndex, \"\"));\n\t\t\tcellRows.forEach(function (cellRow, rowRowIndex) {\n\t\t\t\trowRows[rowRowIndex][columnIndex] = cellRow;\n\t\t\t});\n\t\t});\n\t\tpush.apply(rows, rowRows);\n\t});\n\n\treturn (\n\t\trows\n\t\t\t.map(function (row) {\n\t\t\t\treturn from(iterable(row), function (str, index) {\n\t\t\t\t\tvar col = colsMeta[index], strLength;\n\t\t\t\t\tif (!col) col = colsMeta[index] = { width: 0 };\n\t\t\t\t\tstr = stringifiable(str);\n\t\t\t\t\tstrLength = getStrippedLength(str);\n\t\t\t\t\tif (strLength > col.width) col.width = strLength;\n\t\t\t\t\treturn { str: str, length: strLength };\n\t\t\t\t});\n\t\t\t})\n\t\t\t.map(function (row) {\n\t\t\t\treturn row\n\t\t\t\t\t.map(function (item, index) {\n\t\t\t\t\t\tvar pad, align = \"left\", colOptions = colsOptions && colsOptions[index];\n\t\t\t\t\t\talign = colOptions && colOptions.align === \"right\" ? \"right\" : \"left\";\n\t\t\t\t\t\tpad = repeat.call(\" \", colsMeta[index].width - item.length);\n\t\t\t\t\t\tif (align === \"left\") return item.str + pad;\n\t\t\t\t\t\treturn pad + item.str;\n\t\t\t\t\t})\n\t\t\t\t\t.join(isValue(options.sep) ? options.sep : \" | \");\n\t\t\t})\n\t\t\t.join(\"\\n\") + \"\\n\"\n\t);\n};\n","\"use strict\";\n\nmodule.exports = {\n\tscreen: \"\\x1b[2J\",\n\tscreenLeft: \"\\x1b[1J\",\n\tscreenRight: \"\\x1b[J\",\n\tline: \"\\x1b[2K\",\n\tlineLeft: \"\\x1b[1K\",\n\tlineRight: \"\\x1b[K\"\n};\n","\"use strict\";\n\n/*\n * get actual length of ANSI-formatted string\n */\n\nvar strip = require(\"./strip\");\n\nmodule.exports = function (str) { return strip(str).length; };\n","\"use strict\";\n\nvar d = require(\"d\");\n\nmodule.exports = Object.defineProperties(require(\"./bare\"), {\n\twindowSize: d(require(\"./window-size\")),\n\terase: d(require(\"./erase\")),\n\tmove: d(require(\"./move\")),\n\tbeep: d(require(\"./beep\")),\n\tcolumns: d(require(\"./columns\")),\n\tstrip: d(require(\"./strip\")),\n\tgetStrippedLength: d(require(\"./get-stripped-length\")),\n\tslice: d(require(\"./slice\")),\n\tthrobber: d(require(\"./throbber\")),\n\treset: d(require(\"./reset\")),\n\tart: d(require(\"./art\"))\n});\n","\"use strict\";\n\n/* CSI - control sequence introducer */\n/* SGR - set graphic rendition */\n\nvar assign       = require(\"es5-ext/object/assign\")\n  , includes     = require(\"es5-ext/string/#/contains\")\n  , forOwn       = require(\"es5-ext/object/for-each\")\n  , onlyKey      = require(\"es5-ext/object/first-key\")\n  , forEachRight = require(\"es5-ext/array/#/for-each-right\")\n  , uniq         = require(\"es5-ext/array/#/uniq.js\");\n\nvar CSI = \"\\x1b[\";\n\nvar sgr = function (code) { return CSI + code + \"m\"; };\n\nsgr.CSI = CSI;\n\nvar mods = assign(\n\t{\n\t\t// Style\n\t\tbold: { _bold: [1, 22] },\n\t\titalic: { _italic: [3, 23] },\n\t\tunderline: { _underline: [4, 24] },\n\t\tblink: { _blink: [5, 25] },\n\t\tinverse: { _inverse: [7, 27] },\n\t\tstrike: { _strike: [9, 29] }\n\n\t\t// Color\n\t},\n\t[\"black\", \"red\", \"green\", \"yellow\", \"blue\", \"magenta\", \"cyan\", \"white\"].reduce(function (\n\t\tobj,\n\t\tcolor,\n\t\tindex\n\t) {\n\t\t// foreground\n\t\tobj[color] = { _fg: [30 + index, 39] };\n\t\tobj[color + \"Bright\"] = { _fg: [90 + index, 39] };\n\n\t\t// background\n\t\tobj[\"bg\" + color[0].toUpperCase() + color.slice(1)] = { _bg: [40 + index, 49] };\n\t\tobj[\"bg\" + color[0].toUpperCase() + color.slice(1) + \"Bright\"] = { _bg: [100 + index, 49] };\n\n\t\treturn obj;\n\t}, {})\n);\n\nsgr.mods = mods;\n\nsgr.openers = {};\nsgr.closers = {};\n\nforOwn(mods, function (mod) {\n\tvar modPair = mod[onlyKey(mod)];\n\n\tsgr.openers[modPair[0]] = modPair;\n\tsgr.closers[modPair[1]] = modPair;\n});\n\nsgr.openStyle = function (openedMods, code) { openedMods.push(sgr.openers[code]); };\n\nsgr.closeStyle = function (openedMods, code) {\n\tforEachRight.call(openedMods, function (modPair, index) {\n\t\tif (modPair[1] === code) {\n\t\t\topenedMods.splice(index, 1);\n\t\t}\n\t});\n};\n\n/* prepend openers */\nsgr.prepend = function (currentMods) {\n\treturn currentMods.map(function (modPair) { return sgr(modPair[0]); });\n};\n\n/* complete non-closed openers with corresponding closers */\nsgr.complete = function (openedMods, closerCodes) {\n\tcloserCodes.forEach(function (code) { sgr.closeStyle(openedMods, code); });\n\n\t// mods must be closed from the last opened to first opened\n\topenedMods = openedMods.reverse();\n\n\topenedMods = openedMods.map(function (modPair) { return modPair[1]; });\n\n\t// one closer can close many openers (31, 32 -> 39)\n\topenedMods = uniq.call(openedMods);\n\n\treturn openedMods.map(sgr);\n};\n\nvar hasCSI = function (str) { return includes.call(str, CSI); };\n\nsgr.hasCSI = hasCSI;\n\nvar extractCode = function (csi) {\n\tvar code = csi.slice(2, -1);\n\tcode = Number(code);\n\treturn code;\n};\n\nsgr.extractCode = extractCode;\n\nmodule.exports = sgr;\n","\"use strict\";\n\n// store whether supports-color mode is enabled or not.\nvar state = null;\n\n// force supports-color mode\nvar enableColor = function () { state = true; };\n\n// disable supports-color mode\nvar disableColor = function () { state = false; };\n\n// use the NO_COLOR environment variable (default)\nvar autoDetectSupport = function () { state = null; };\n\n// determine whether supports-color mode is enabled.\nvar isColorSupported = function () { return state === null ? !process.env.NO_COLOR : state; };\n\nmodule.exports = {\n\tenableColor: enableColor,\n\tdisableColor: disableColor,\n\tautoDetectSupport: autoDetectSupport,\n\tisColorSupported: isColorSupported\n};\n","\"use strict\";\n\nmodule.exports = [\n\t\"000000\", \"800000\", \"008000\", \"808000\", \"000080\", \"800080\", \"008080\", \"c0c0c0\", \"808080\",\n\t\"ff0000\", \"00ff00\", \"ffff00\", \"0000ff\", \"ff00ff\", \"00ffff\", \"ffffff\", \"000000\", \"00005f\",\n\t\"000087\", \"0000af\", \"0000d7\", \"0000ff\", \"005f00\", \"005f5f\", \"005f87\", \"005faf\", \"005fd7\",\n\t\"005fff\", \"008700\", \"00875f\", \"008787\", \"0087af\", \"0087d7\", \"0087ff\", \"00af00\", \"00af5f\",\n\t\"00af87\", \"00afaf\", \"00afd7\", \"00afff\", \"00d700\", \"00d75f\", \"00d787\", \"00d7af\", \"00d7d7\",\n\t\"00d7ff\", \"00ff00\", \"00ff5f\", \"00ff87\", \"00ffaf\", \"00ffd7\", \"00ffff\", \"5f0000\", \"5f005f\",\n\t\"5f0087\", \"5f00af\", \"5f00d7\", \"5f00ff\", \"5f5f00\", \"5f5f5f\", \"5f5f87\", \"5f5faf\", \"5f5fd7\",\n\t\"5f5fff\", \"5f8700\", \"5f875f\", \"5f8787\", \"5f87af\", \"5f87d7\", \"5f87ff\", \"5faf00\", \"5faf5f\",\n\t\"5faf87\", \"5fafaf\", \"5fafd7\", \"5fafff\", \"5fd700\", \"5fd75f\", \"5fd787\", \"5fd7af\", \"5fd7d7\",\n\t\"5fd7ff\", \"5fff00\", \"5fff5f\", \"5fff87\", \"5fffaf\", \"5fffd7\", \"5fffff\", \"870000\", \"87005f\",\n\t\"870087\", \"8700af\", \"8700d7\", \"8700ff\", \"875f00\", \"875f5f\", \"875f87\", \"875faf\", \"875fd7\",\n\t\"875fff\", \"878700\", \"87875f\", \"878787\", \"8787af\", \"8787d7\", \"8787ff\", \"87af00\", \"87af5f\",\n\t\"87af87\", \"87afaf\", \"87afd7\", \"87afff\", \"87d700\", \"87d75f\", \"87d787\", \"87d7af\", \"87d7d7\",\n\t\"87d7ff\", \"87ff00\", \"87ff5f\", \"87ff87\", \"87ffaf\", \"87ffd7\", \"87ffff\", \"af0000\", \"af005f\",\n\t\"af0087\", \"af00af\", \"af00d7\", \"af00ff\", \"af5f00\", \"af5f5f\", \"af5f87\", \"af5faf\", \"af5fd7\",\n\t\"af5fff\", \"af8700\", \"af875f\", \"af8787\", \"af87af\", \"af87d7\", \"af87ff\", \"afaf00\", \"afaf5f\",\n\t\"afaf87\", \"afafaf\", \"afafd7\", \"afafff\", \"afd700\", \"afd75f\", \"afd787\", \"afd7af\", \"afd7d7\",\n\t\"afd7ff\", \"afff00\", \"afff5f\", \"afff87\", \"afffaf\", \"afffd7\", \"afffff\", \"d70000\", \"d7005f\",\n\t\"d70087\", \"d700af\", \"d700d7\", \"d700ff\", \"d75f00\", \"d75f5f\", \"d75f87\", \"d75faf\", \"d75fd7\",\n\t\"d75fff\", \"d78700\", \"d7875f\", \"d78787\", \"d787af\", \"d787d7\", \"d787ff\", \"d7af00\", \"d7af5f\",\n\t\"d7af87\", \"d7afaf\", \"d7afd7\", \"d7afff\", \"d7d700\", \"d7d75f\", \"d7d787\", \"d7d7af\", \"d7d7d7\",\n\t\"d7d7ff\", \"d7ff00\", \"d7ff5f\", \"d7ff87\", \"d7ffaf\", \"d7ffd7\", \"d7ffff\", \"ff0000\", \"ff005f\",\n\t\"ff0087\", \"ff00af\", \"ff00d7\", \"ff00ff\", \"ff5f00\", \"ff5f5f\", \"ff5f87\", \"ff5faf\", \"ff5fd7\",\n\t\"ff5fff\", \"ff8700\", \"ff875f\", \"ff8787\", \"ff87af\", \"ff87d7\", \"ff87ff\", \"ffaf00\", \"ffaf5f\",\n\t\"ffaf87\", \"ffafaf\", \"ffafd7\", \"ffafff\", \"ffd700\", \"ffd75f\", \"ffd787\", \"ffd7af\", \"ffd7d7\",\n\t\"ffd7ff\", \"ffff00\", \"ffff5f\", \"ffff87\", \"ffffaf\", \"ffffd7\", \"ffffff\", \"080808\", \"121212\",\n\t\"1c1c1c\", \"262626\", \"303030\", \"3a3a3a\", \"444444\", \"4e4e4e\", \"585858\", \"626262\", \"6c6c6c\",\n\t\"767676\", \"808080\", \"8a8a8a\", \"949494\", \"9e9e9e\", \"a8a8a8\", \"b2b2b2\", \"bcbcbc\", \"c6c6c6\",\n\t\"d0d0d0\", \"dadada\", \"e4e4e4\", \"eeeeee\"\n];\n","\"use strict\";\n\nvar push = Array.prototype.push\n  , reduce = Array.prototype.reduce\n  , abs = Math.abs\n  , colors\n  , match\n  , result\n  , i;\n\ncolors = require(\"./xterm-colors\").map(function (color) {\n\treturn {\n\t\tr: parseInt(color.slice(0, 2), 16),\n\t\tg: parseInt(color.slice(2, 4), 16),\n\t\tb: parseInt(color.slice(4), 16)\n\t};\n});\n\nmatch = colors.slice(0, 16);\n\nmodule.exports = result = [];\n\ni = 0;\nwhile (i < 8) {\n\tresult.push(30 + i++);\n}\ni = 0;\nwhile (i < 8) {\n\tresult.push(90 + i++);\n}\npush.apply(\n\tresult,\n\tcolors.slice(16).map(function (data) {\n\t\tvar index, diff = Infinity;\n\t\tmatch.every(function (innerMatch, currentIndex) {\n\t\t\tvar ndiff = reduce.call(\n\t\t\t\t\"rgb\",\n\t\t\t\tfunction (currentDiff, channel) {\n\t\t\t\t\tcurrentDiff += abs(innerMatch[channel] - data[channel]);\n\t\t\t\t\treturn currentDiff;\n\t\t\t\t},\n\t\t\t\t0\n\t\t\t);\n\t\t\tif (ndiff < diff) {\n\t\t\t\tindex = currentIndex;\n\t\t\t\tdiff = ndiff;\n\t\t\t}\n\t\t\treturn ndiff;\n\t\t});\n\t\treturn result[index];\n\t})\n);\n","\"use strict\";\n\nvar d     = require(\"d\")\n  , trunc = require(\"es5-ext/math/trunc\");\n\nvar up, down, right, left, abs = Math.abs, floor = Math.floor, max = Math.max;\n\nvar getMove = function (control) {\n\treturn function (num) {\n\t\tnum = isNaN(num) ? 0 : max(floor(num), 0);\n\t\treturn num ? \"\\x1b[\" + num + control : \"\";\n\t};\n};\n\nmodule.exports = Object.defineProperties(\n\tfunction (x, y) {\n\t\tx = isNaN(x) ? 0 : floor(x);\n\t\ty = isNaN(y) ? 0 : floor(y);\n\t\treturn (x > 0 ? right(x) : left(-x)) + (y > 0 ? down(y) : up(-y));\n\t},\n\t{\n\t\tup: d((up = getMove(\"A\"))),\n\t\tdown: d((down = getMove(\"B\"))),\n\t\tright: d((right = getMove(\"C\"))),\n\t\tleft: d((left = getMove(\"D\"))),\n\t\tto: d(function (x, y) {\n\t\t\tx = isNaN(x) ? 1 : max(floor(x), 0) + 1;\n\t\t\ty = isNaN(y) ? 1 : max(floor(y), 0) + 1;\n\t\t\treturn \"\\x1b[\" + y + \";\" + x + \"H\";\n\t\t}),\n\t\tlines: d(function (n) {\n\t\t\tvar dir;\n\t\t\tn = trunc(n) || 0;\n\t\t\tdir = n >= 0 ? \"B\" : \"A\";\n\t\t\tn = floor(abs(n));\n\t\t\treturn \"\\x1b[\" + n + dir + \"\\x1b[1G\";\n\t\t}),\n\t\ttop: d(\"\\x1b[5000F\"),\n\t\tbottom: d(\"\\x1b[5000B\"),\n\t\tlineBegin: d(\"\\x1b[5000D\"),\n\t\tlineEnd: d(\"\\x1b[5000C\")\n\t}\n);\n","\"use strict\";\n\nmodule.exports = function () {\n\t// Borrowed from ansi-regex package\n\t// https://github.com/chalk/ansi-regex/blob/a28b8e7ee67aa9996ba44bf123f0436eea62d285/index.js\n\n\treturn new RegExp(\n\t\t\"[\\\\u001B\\\\u009B][[\\\\]()#;?]\" +\n\t\t\t\"*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]\" +\n\t\t\t\"+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\" +\n\t\t\t\"|\" +\n\t\t\t\"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\n\t\t\"g\"\n\t);\n};\n","\"use strict\";\n\nmodule.exports = \"\\x1b[2J\\x1b[0;0H\";\n","/* eslint max-lines: \"off\" */\n\n\"use strict\";\n\nvar reAnsi        = require(\"./regex-ansi\")\n  , stringifiable = require(\"es5-ext/object/validate-stringifiable-value\")\n  , length        = require(\"./get-stripped-length\")\n  , sgr           = require(\"./lib/sgr\")\n  , max           = Math.max;\n\nvar Token = function (token) { this.token = token; };\n\nvar tokenize = function (str) {\n\tvar match = reAnsi().exec(str);\n\n\tif (!match) {\n\t\treturn [str];\n\t}\n\n\tvar index = match.index, head, prehead, tail;\n\n\tif (index === 0) {\n\t\thead = match[0];\n\t\ttail = str.slice(head.length);\n\n\t\treturn [new Token(head)].concat(tokenize(tail));\n\t}\n\n\tprehead = str.slice(0, index);\n\thead = match[0];\n\ttail = str.slice(index + head.length);\n\n\treturn [prehead, new Token(head)].concat(tokenize(tail));\n};\n\nvar isChunkInSlice = function (chunk, index, begin, end) {\n\tvar endIndex = chunk.length + index;\n\n\tif (begin > endIndex) return false;\n\tif (end < index) return false;\n\treturn true;\n};\n\n// eslint-disable-next-line max-lines-per-function\nvar sliceSeq = function (seq, begin, end) {\n\tvar sliced = seq.reduce(\n\t\tfunction (state, chunk) {\n\t\t\tvar index = state.index;\n\n\t\t\tif (chunk instanceof Token) {\n\t\t\t\tvar code = sgr.extractCode(chunk.token);\n\n\t\t\t\tif (index <= begin) {\n\t\t\t\t\tif (code in sgr.openers) {\n\t\t\t\t\t\tsgr.openStyle(state.preOpeners, code);\n\t\t\t\t\t}\n\t\t\t\t\tif (code in sgr.closers) {\n\t\t\t\t\t\tsgr.closeStyle(state.preOpeners, code);\n\t\t\t\t\t}\n\t\t\t\t} else if (index < end) {\n\t\t\t\t\tif (code in sgr.openers) {\n\t\t\t\t\t\tsgr.openStyle(state.inOpeners, code);\n\t\t\t\t\t\tstate.seq.push(chunk);\n\t\t\t\t\t} else if (code in sgr.closers) {\n\t\t\t\t\t\tstate.inClosers.push(code);\n\t\t\t\t\t\tstate.seq.push(chunk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar nextChunk = \"\";\n\n\t\t\t\tif (isChunkInSlice(chunk, index, begin, end)) {\n\t\t\t\t\tvar relBegin = Math.max(begin - index, 0)\n\t\t\t\t\t  , relEnd = Math.min(end - index, chunk.length);\n\n\t\t\t\t\tnextChunk = chunk.slice(relBegin, relEnd);\n\t\t\t\t}\n\n\t\t\t\tstate.seq.push(nextChunk);\n\t\t\t\tstate.index = index + chunk.length;\n\t\t\t}\n\n\t\t\treturn state;\n\t\t},\n\t\t{\n\t\t\tindex: 0,\n\t\t\tseq: [],\n\n\t\t\t// preOpeners -> [ mod ]\n\t\t\t// preOpeners must be prepended to the slice if they wasn't closed til the end of it\n\t\t\t// preOpeners must be closed if they wasn't closed til the end of the slice\n\t\t\tpreOpeners: [],\n\n\t\t\t// inOpeners  -> [ mod ]\n\t\t\t// inOpeners already in the slice and must not be prepended to the slice\n\t\t\t// inOpeners must be closed if they wasn't closed til the end of the slice\n\t\t\tinOpeners: [], // opener CSI inside slice\n\n\t\t\t// inClosers -> [ code ]\n\t\t\t// closer CSIs for determining which pre/in-Openers must be closed\n\t\t\tinClosers: []\n\t\t}\n\t);\n\n\tsliced.seq = [].concat(\n\t\tsgr.prepend(sliced.preOpeners), sliced.seq,\n\t\tsgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)\n\t);\n\n\treturn sliced.seq;\n};\n\nmodule.exports = function (str /*, begin, end*/) {\n\tvar seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;\n\n\tstr = stringifiable(str);\n\tlen = length(str);\n\n\tif (isNaN(begin)) {\n\t\tbegin = 0;\n\t}\n\tif (isNaN(end)) {\n\t\tend = len;\n\t}\n\tif (begin < 0) {\n\t\tbegin = max(len + begin, 0);\n\t}\n\tif (end < 0) {\n\t\tend = max(len + end, 0);\n\t}\n\n\tseq = tokenize(str);\n\tseq = sliceSeq(seq, begin, end);\n\treturn seq\n\t\t.map(function (chunk) {\n\t\t\tif (chunk instanceof Token) {\n\t\t\t\treturn chunk.token;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t})\n\t\t.join(\"\");\n};\n","// Strip ANSI formatting from string\n\n\"use strict\";\n\nvar stringifiable = require(\"es5-ext/object/validate-stringifiable\")\n  , r             = require(\"./regex-ansi\")();\n\nmodule.exports = function (str) { return stringifiable(str).replace(r, \"\"); };\n","\"use strict\";\n\nvar compose      = require(\"es5-ext/function/#/compose\")\n  , callable     = require(\"es5-ext/object/valid-callable\")\n  , d            = require(\"d\")\n  , validTimeout = require(\"timers-ext/valid-timeout\");\n\nvar chars = \"-\\\\|/\", l = chars.length, ThrobberIterator;\n\nThrobberIterator = function () {\n\t// no setup needed\n};\nObject.defineProperties(ThrobberIterator.prototype, {\n\tindex: d(-1),\n\trunning: d(false),\n\tnext: d(function () {\n\t\tvar str = this.running ? \"\\u0008\" : \"\";\n\t\tif (!this.running) this.running = true;\n\t\treturn str + chars[(this.index = (this.index + 1) % l)];\n\t}),\n\treset: d(function () {\n\t\tif (!this.running) return \"\";\n\t\tthis.index = -1;\n\t\tthis.running = false;\n\t\treturn \"\\u0008\";\n\t})\n});\n\nmodule.exports = exports = function (write, interval /*, format*/) {\n\tvar format = arguments[2], token, iterator = new ThrobberIterator();\n\tcallable(write);\n\tinterval = validTimeout(interval);\n\tif (format !== undefined) write = compose.call(write, callable(format));\n\treturn {\n\t\tstart: function () {\n\t\t\tif (token) return;\n\t\t\ttoken = setInterval(function () { write(iterator.next()); }, interval);\n\t\t},\n\t\trestart: function () {\n\t\t\tthis.stop();\n\t\t\tthis.start();\n\t\t},\n\t\tstop: function () {\n\t\t\tif (!token) return;\n\t\t\tclearInterval(token);\n\t\t\ttoken = null;\n\t\t\twrite(iterator.reset());\n\t\t}\n\t};\n};\n\nObject.defineProperty(exports, \"Iterator\", d(ThrobberIterator));\n","\"use strict\";\n\nvar d = require(\"d\");\n\nObject.defineProperties(exports, {\n\twidth: d.gs(\"ce\", function () { return process.stdout.columns || 0; }),\n\theight: d.gs(\"ce\", function () { return process.stdout.rows || 0; })\n});\n","\"use strict\";\n\nvar isValue             = require(\"type/value/is\")\n  , ensureValue         = require(\"type/value/ensure\")\n  , ensurePlainFunction = require(\"type/plain-function/ensure\")\n  , copy                = require(\"es5-ext/object/copy\")\n  , normalizeOptions    = require(\"es5-ext/object/normalize-options\")\n  , map                 = require(\"es5-ext/object/map\");\n\nvar bind = Function.prototype.bind\n  , defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, options) {\n\tvar value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, options*/) {\n\tvar options = normalizeOptions(arguments[1]);\n\tif (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);\n\treturn map(props, function (desc, name) { return define(name, desc, options); });\n};\n","\"use strict\";\n\nvar isValue         = require(\"type/value/is\")\n  , isPlainFunction = require(\"type/plain-function/is\")\n  , assign          = require(\"es5-ext/object/assign\")\n  , normalizeOpts   = require(\"es5-ext/object/normalize-options\")\n  , contains        = require(\"es5-ext/string/#/contains\");\n\nvar d = (module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif (arguments.length < 2 || typeof dscr !== \"string\") {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t\tw = contains.call(dscr, \"w\");\n\t} else {\n\t\tc = w = true;\n\t\te = false;\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n});\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== \"string\") {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (!isValue(get)) {\n\t\tget = undefined;\n\t} else if (!isPlainFunction(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (!isValue(set)) {\n\t\tset = undefined;\n\t} else if (!isPlainFunction(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t} else {\n\t\tc = true;\n\t\te = false;\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n","\"use strict\";\n\nvar isPlainFunction = require(\"type/plain-function/is\")\n  , ensureValue     = require(\"type/value/ensure\")\n  , isValue         = require(\"type/value/is\")\n  , map             = require(\"es5-ext/object/map\")\n  , contains        = require(\"es5-ext/string/#/contains\");\n\nvar call = Function.prototype.call\n  , defineProperty = Object.defineProperty\n  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor\n  , getPrototypeOf = Object.getPrototypeOf\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , cacheDesc = { configurable: false, enumerable: false, writable: false, value: null }\n  , define;\n\ndefine = function (name, options) {\n\tvar value, dgs, cacheName, desc, writable = false, resolvable, flat;\n\toptions = Object(ensureValue(options));\n\tcacheName = options.cacheName;\n\tflat = options.flat;\n\tif (!isValue(cacheName)) cacheName = name;\n\tdelete options.cacheName;\n\tvalue = options.value;\n\tresolvable = isPlainFunction(value);\n\tdelete options.value;\n\tdgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };\n\tif (name !== cacheName) {\n\t\tdgs.get = function () {\n\t\t\tif (hasOwnProperty.call(this, cacheName)) return this[cacheName];\n\t\t\tcacheDesc.value = resolvable ? call.call(value, this, options) : value;\n\t\t\tcacheDesc.writable = writable;\n\t\t\tdefineProperty(this, cacheName, cacheDesc);\n\t\t\tcacheDesc.value = null;\n\t\t\tif (desc) defineProperty(this, name, desc);\n\t\t\treturn this[cacheName];\n\t\t};\n\t} else if (!flat) {\n\t\tdgs.get = function self() {\n\t\t\tvar ownDesc;\n\t\t\tif (hasOwnProperty.call(this, name)) {\n\t\t\t\townDesc = getOwnPropertyDescriptor(this, name);\n\t\t\t\t// It happens in Safari, that getter is still called after property\n\t\t\t\t// was defined with a value, following workarounds that\n\t\t\t\t// While in IE11 it may happen that here ownDesc is undefined (go figure)\n\t\t\t\tif (ownDesc) {\n\t\t\t\t\tif (ownDesc.hasOwnProperty(\"value\")) return ownDesc.value;\n\t\t\t\t\tif (typeof ownDesc.get === \"function\" && ownDesc.get !== self) {\n\t\t\t\t\t\treturn ownDesc.get.call(this);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdesc.value = resolvable ? call.call(value, this, options) : value;\n\t\t\tdefineProperty(this, name, desc);\n\t\t\tdesc.value = null;\n\t\t\treturn this[name];\n\t\t};\n\t} else {\n\t\tdgs.get = function self() {\n\t\t\tvar base = this, ownDesc;\n\t\t\tif (hasOwnProperty.call(this, name)) {\n\t\t\t\t// It happens in Safari, that getter is still called after property\n\t\t\t\t// was defined with a value, following workarounds that\n\t\t\t\townDesc = getOwnPropertyDescriptor(this, name);\n\t\t\t\tif (ownDesc.hasOwnProperty(\"value\")) return ownDesc.value;\n\t\t\t\tif (typeof ownDesc.get === \"function\" && ownDesc.get !== self) {\n\t\t\t\t\treturn ownDesc.get.call(this);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!hasOwnProperty.call(base, name)) base = getPrototypeOf(base);\n\t\t\tdesc.value = resolvable ? call.call(value, base, options) : value;\n\t\t\tdefineProperty(base, name, desc);\n\t\t\tdesc.value = null;\n\t\t\treturn base[name];\n\t\t};\n\t}\n\tdgs.set = function (value) {\n\t\tif (hasOwnProperty.call(this, name)) {\n\t\t\tthrow new TypeError(\"Cannot assign to lazy defined '\" + name + \"' property of \" + this);\n\t\t}\n\t\tdgs.get.call(this);\n\t\tthis[cacheName] = value;\n\t};\n\tif (options.desc) {\n\t\tdesc = {\n\t\t\tconfigurable: contains.call(options.desc, \"c\"),\n\t\t\tenumerable: contains.call(options.desc, \"e\")\n\t\t};\n\t\tif (cacheName === name) {\n\t\t\tdesc.writable = contains.call(options.desc, \"w\");\n\t\t\tdesc.value = null;\n\t\t} else {\n\t\t\twritable = contains.call(options.desc, \"w\");\n\t\t\tdesc.get = dgs.get;\n\t\t\tdesc.set = dgs.set;\n\t\t}\n\t\tdelete options.desc;\n\t} else if (cacheName === name) {\n\t\tdesc = {\n\t\t\tconfigurable: Boolean(options.configurable),\n\t\t\tenumerable: Boolean(options.enumerable),\n\t\t\twritable: Boolean(options.writable),\n\t\t\tvalue: null\n\t\t};\n\t}\n\tdelete options.configurable;\n\tdelete options.enumerable;\n\tdelete options.writable;\n\treturn dgs;\n};\n\nmodule.exports = function (props) {\n\treturn map(props, function (desc, name) { return define(name, desc); });\n};\n","// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n\"use strict\";\n\nvar value = require(\"../../object/valid-value\");\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n","\"use strict\";\n\nvar numberIsNaN       = require(\"../../number/is-nan\")\n  , toPosInt          = require(\"../../number/to-pos-integer\")\n  , value             = require(\"../../object/valid-value\")\n  , indexOf           = Array.prototype.indexOf\n  , objHasOwnProperty = Object.prototype.hasOwnProperty\n  , abs               = Math.abs\n  , floor             = Math.floor;\n\nmodule.exports = function (searchElement /*, fromIndex*/) {\n\tvar i, length, fromIndex, val;\n\tif (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n\tlength = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < length; ++i) {\n\t\tif (objHasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (numberIsNaN(val)) return i; // Jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n","\"use strict\";\n\nvar toPosInt          = require(\"../../number/to-pos-integer\")\n  , callable          = require(\"../../object/valid-callable\")\n  , value             = require(\"../../object/valid-value\")\n  , objHasOwnProperty = Object.prototype.hasOwnProperty\n  , call              = Function.prototype.call;\n\nmodule.exports = function (cb /*, thisArg*/) {\n\tvar i, self, thisArg;\n\n\tself = Object(value(this));\n\tcallable(cb);\n\tthisArg = arguments[1];\n\n\tfor (i = toPosInt(self.length) - 1; i >= 0; --i) {\n\t\tif (objHasOwnProperty.call(self, i)) call.call(cb, thisArg, self[i], i, self);\n\t}\n};\n","\"use strict\";\n\nvar indexOf = require(\"./e-index-of\")\n  , filter  = Array.prototype.filter\n  , isFirst;\n\nisFirst = function (value, index) { return indexOf.call(this, value) === index; };\n\nmodule.exports = function () { return filter.call(this, isFirst, this); };\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Array.from : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar from = Array.from, arr, result;\n\tif (typeof from !== \"function\") return false;\n\tarr = [\"raz\", \"dwa\"];\n\tresult = from(arr);\n\treturn Boolean(result && result !== arr && result[1] === \"dwa\");\n};\n","\"use strict\";\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArguments    = require(\"../../function/is-arguments\")\n  , isFunction     = require(\"../../function/is-function\")\n  , toPosInt       = require(\"../../number/to-pos-integer\")\n  , callable       = require(\"../../object/valid-callable\")\n  , validValue     = require(\"../../object/valid-value\")\n  , isValue        = require(\"../../object/is-value\")\n  , isString       = require(\"../../string/is-string\")\n  , isArray        = Array.isArray\n  , call           = Function.prototype.call\n  , desc           = { configurable: true, enumerable: true, writable: true, value: null }\n  , defineProperty = Object.defineProperty;\n\n// eslint-disable-next-line complexity, max-lines-per-function\nmodule.exports = function (arrayLike /*, mapFn, thisArg*/) {\n\tvar mapFn = arguments[1]\n\t  , thisArg = arguments[2]\n\t  , Context\n\t  , i\n\t  , j\n\t  , arr\n\t  , length\n\t  , code\n\t  , iterator\n\t  , result\n\t  , getIterator\n\t  , value;\n\n\tarrayLike = Object(validValue(arrayLike));\n\n\tif (isValue(mapFn)) callable(mapFn);\n\tif (!this || this === Array || !isFunction(this)) {\n\t\t// Result: Plain array\n\t\tif (!mapFn) {\n\t\t\tif (isArguments(arrayLike)) {\n\t\t\t\t// Source: Arguments\n\t\t\t\tlength = arrayLike.length;\n\t\t\t\tif (length !== 1) return Array.apply(null, arrayLike);\n\t\t\t\tarr = new Array(1);\n\t\t\t\tarr[0] = arrayLike[0];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (isArray(arrayLike)) {\n\t\t\t\t// Source: Array\n\t\t\t\tarr = new Array((length = arrayLike.length));\n\t\t\t\tfor (i = 0; i < length; ++i) arr[i] = arrayLike[i];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t}\n\t\tarr = [];\n\t} else {\n\t\t// Result: Non plain array\n\t\tContext = this;\n\t}\n\n\tif (!isArray(arrayLike)) {\n\t\tif ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n\t\t\t// Source: Iterator\n\t\t\titerator = callable(getIterator).call(arrayLike);\n\t\t\tif (Context) arr = new Context();\n\t\t\tresult = iterator.next();\n\t\t\ti = 0;\n\t\t\twhile (!result.done) {\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[i] = value;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tlength = i;\n\t\t} else if (isString(arrayLike)) {\n\t\t\t// Source: String\n\t\t\tlength = arrayLike.length;\n\t\t\tif (Context) arr = new Context();\n\t\t\tfor (i = 0, j = 0; i < length; ++i) {\n\t\t\t\tvalue = arrayLike[i];\n\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\tcode = value.charCodeAt(0);\n\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n\t\t\t\t}\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, j, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[j] = value;\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlength = j;\n\t\t}\n\t}\n\tif (length === undefined) {\n\t\t// Source: array or array-like\n\t\tlength = toPosInt(arrayLike.length);\n\t\tif (Context) arr = new Context(length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n\t\t\tif (Context) {\n\t\t\t\tdesc.value = value;\n\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t} else {\n\t\t\t\tarr[i] = value;\n\t\t\t}\n\t\t}\n\t}\n\tif (Context) {\n\t\tdesc.value = null;\n\t\tarr.length = length;\n\t}\n\treturn arr;\n};\n","\"use strict\";\n\nvar toPosInt = require(\"../number/to-pos-integer\")\n  , value    = require(\"../object/valid-value\")\n  , slice    = Array.prototype.slice;\n\nmodule.exports = function (length /*, …fill*/) {\n\tvar arr, currentLength;\n\tlength = toPosInt(value(length));\n\tif (length === 0) return [];\n\n\tarr = arguments.length < 2 ? [undefined] : slice.call(arguments, 1, 1 + length);\n\n\twhile ((currentLength = arr.length) < length) {\n\t\tarr = arr.concat(arr.slice(0, length - currentLength));\n\t}\n\treturn arr;\n};\n","\"use strict\";\n\nvar from    = require(\"./from\")\n  , isArray = Array.isArray;\n\nmodule.exports = function (arrayLike) { return isArray(arrayLike) ? arrayLike : from(arrayLike); };\n","\"use strict\";\n\nvar assign            = require(\"../object/assign\")\n  , isObject          = require(\"../object/is-object\")\n  , isValue           = require(\"../object/is-value\")\n  , captureStackTrace = Error.captureStackTrace;\n\nmodule.exports = function (message /*, code, ext*/) {\n\tvar err = new Error(message), code = arguments[1], ext = arguments[2];\n\tif (!isValue(ext)) {\n\t\tif (isObject(code)) {\n\t\t\text = code;\n\t\t\tcode = null;\n\t\t}\n\t}\n\tif (isValue(ext)) assign(err, ext);\n\tif (isValue(code)) err.code = code;\n\tif (captureStackTrace) captureStackTrace(err, module.exports);\n\treturn err;\n};\n","\"use strict\";\n\nvar isValue  = require(\"../../object/is-value\")\n  , callable = require(\"../../object/valid-callable\")\n  , aFrom    = require(\"../../array/from\");\n\nvar apply = Function.prototype.apply\n  , call = Function.prototype.call\n  , callFn = function (arg, fn) { return call.call(fn, this, arg); };\n\nmodule.exports = function (fnIgnored /*, …fnn*/) {\n\tvar fns, first;\n\tvar args = aFrom(arguments);\n\tfns = isValue(this) ? [this].concat(args) : args;\n\tfns.forEach(callable);\n\tfns = fns.reverse();\n\tfirst = fns[0];\n\tfns = fns.slice(1);\n\treturn function (argIgnored) { return fns.reduce(callFn, apply.call(first, this, arguments)); };\n};\n","\"use strict\";\n\nvar toPosInt = require(\"../number/to-pos-integer\");\n\nvar test = function (arg1, arg2) { return arg2; };\n\nvar desc, defineProperty, generate, mixin;\n\ntry {\n\tObject.defineProperty(test, \"length\", {\n\t\tconfigurable: true,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tvalue: 1\n\t});\n}\ncatch (ignore) {}\n\nif (test.length === 1) {\n\t// ES6\n\tdesc = { configurable: true, writable: false, enumerable: false };\n\tdefineProperty = Object.defineProperty;\n\tmodule.exports = function (fn, length) {\n\t\tlength = toPosInt(length);\n\t\tif (fn.length === length) return fn;\n\t\tdesc.value = length;\n\t\treturn defineProperty(fn, \"length\", desc);\n\t};\n} else {\n\tmixin = require(\"../object/mixin\");\n\tgenerate = (function () {\n\t\tvar cache = [];\n\t\treturn function (length) {\n\t\t\tvar args, i = 0;\n\t\t\tif (cache[length]) return cache[length];\n\t\t\targs = [];\n\t\t\twhile (length--) args.push(\"a\" + (++i).toString(36));\n\t\t\t// eslint-disable-next-line no-new-func\n\t\t\treturn new Function(\n\t\t\t\t\"fn\",\n\t\t\t\t\"return function (\" + args.join(\", \") + \") { return fn.apply(this, arguments); };\"\n\t\t\t);\n\t\t};\n\t})();\n\tmodule.exports = function (src, length) {\n\t\tvar target;\n\t\tlength = toPosInt(length);\n\t\tif (src.length === length) return src;\n\t\ttarget = generate(length)(src);\n\t\ttry { mixin(target, src); }\n\t\tcatch (ignore) {}\n\t\treturn target;\n\t};\n}\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , id = objToString.call((function () { return arguments; })());\n\nmodule.exports = function (value) { return objToString.call(value) === id; };\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);\n\nmodule.exports = function (value) {\n\treturn typeof value === \"function\" && isFunctionStringTag(objToString.call(value));\n};\n","\"use strict\";\n\n// eslint-disable-next-line no-empty-function\nmodule.exports = function () {};\n","\"use strict\";\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isValue        = require(\"../object/is-value\")\n  , isArrayLike    = require(\"../object/is-array-like\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\tif (typeof value[iteratorSymbol] === \"function\") return true;\n\treturn isArrayLike(value);\n};\n","\"use strict\";\n\nvar isObject = require(\"../object/is-object\")\n  , is       = require(\"./is\");\n\nmodule.exports = function (value) {\n\tif (is(value) && isObject(value)) return value;\n\tthrow new TypeError(value + \" is not an iterable or array-like object\");\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Math.sign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== \"function\") return false;\n\treturn sign(10) === 1 && sign(-20) === -1;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || value === 0) return value;\n\treturn value > 0 ? 1 : -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Math.trunc : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar trunc = Math.trunc;\n\tif (typeof trunc !== \"function\") return false;\n\treturn trunc(13.67) === 13 && trunc(-13.67) === -13;\n};\n","\"use strict\";\n\nvar floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return NaN;\n\tvalue = Number(value);\n\tif (value === 0) return value;\n\tif (value === Infinity) return Infinity;\n\tif (value === -Infinity) return -Infinity;\n\tif (value > 0) return floor(value);\n\treturn -floor(-value);\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Number.isNaN : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar numberIsNaN = Number.isNaN;\n\tif (typeof numberIsNaN !== \"function\") return false;\n\treturn !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\t// eslint-disable-next-line no-self-compare\n\treturn value !== value;\n};\n","\"use strict\";\n\nvar sign  = require(\"../math/sign\")\n  , abs   = Math.abs\n  , floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif (value === 0 || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n","\"use strict\";\n\nvar toInteger = require(\"./to-integer\")\n  , max       = Math.max;\n\nmodule.exports = function (value) { return max(0, toInteger(value)); };\n","// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n\"use strict\";\n\nvar callable                = require(\"./valid-callable\")\n  , value                   = require(\"./valid-value\")\n  , bind                    = Function.prototype.bind\n  , call                    = Function.prototype.call\n  , keys                    = Object.keys\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb /*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== \"function\") method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.assign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n};\n","\"use strict\";\n\nvar keys  = require(\"../keys\")\n  , value = require(\"../valid-value\")\n  , max   = Math.max;\n\nmodule.exports = function (dest, src /*, …srcn*/) {\n\tvar error, i, length = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n","\"use strict\";\n\nvar aFrom  = require(\"../array/from\")\n  , assign = require(\"./assign\")\n  , value  = require(\"./valid-value\");\n\nmodule.exports = function (obj /*, propertyNames, options*/) {\n\tvar copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);\n\tif (copy !== obj && !propertyNames) return copy;\n\tvar result = {};\n\tif (propertyNames) {\n\t\taFrom(propertyNames, function (propertyName) {\n\t\t\tif (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n\t\t});\n\t} else {\n\t\tassign(result, obj);\n\t}\n\treturn result;\n};\n","// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n\"use strict\";\n\nvar create = Object.create, shim;\n\nif (!require(\"./set-prototype-of/is-implemented\")()) {\n\tshim = require(\"./set-prototype-of/shim\");\n}\n\nmodule.exports = (function () {\n\tvar nullObject, polyProps, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tpolyProps = {};\n\tdesc = { configurable: false, enumerable: false, writable: true, value: undefined };\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === \"__proto__\") {\n\t\t\tpolyProps[name] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: undefined\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tpolyProps[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, polyProps);\n\n\tObject.defineProperty(shim, \"nullPolyfill\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: nullObject\n\t});\n\n\treturn function (prototype, props) {\n\t\treturn create(prototype === null ? nullObject : prototype, props);\n\t};\n})();\n","\"use strict\";\n\nvar value                   = require(\"./valid-value\")\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (obj) {\n\tvar i;\n\tvalue(obj);\n\tfor (i in obj) {\n\t\tif (objPropertyIsEnumerable.call(obj, i)) return i;\n\t}\n\treturn null;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./_iterate\")(\"forEach\");\n","\"use strict\";\n\nvar isFunction = require(\"../function/is-function\")\n  , isObject   = require(\"./is-object\")\n  , isValue    = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\treturn (\n\t\t(isValue(value) &&\n\t\t\ttypeof value.length === \"number\" &&\n\t\t\t// Just checking ((typeof x === 'object') && (typeof x !== 'function'))\n\t\t\t// won't work right for some cases, e.g.:\n\t\t\t// type of instance of NodeList in Safari is a 'function'\n\t\t\t((isObject(value) && !isFunction(value)) || typeof value === \"string\")) ||\n\t\tfalse\n\t);\n};\n","// Deprecated\n\n\"use strict\";\n\nmodule.exports = function (obj) { return typeof obj === \"function\"; };\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar map = { function: true, object: true };\n\nmodule.exports = function (value) { return (isValue(value) && map[typeof value]) || false; };\n","\"use strict\";\n\nvar _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\nmodule.exports = function (val) { return val !== _undefined && val !== null; };\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue = require(\"../is-value\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };\n","\"use strict\";\n\nvar callable = require(\"./valid-callable\")\n  , forEach  = require(\"./for-each\")\n  , call     = Function.prototype.call;\n\nmodule.exports = function (obj, cb /*, thisArg*/) {\n\tvar result = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, targetObj, index) {\n\t\tresult[key] = call.call(cb, thisArg, value, key, targetObj, index);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar value                    = require(\"./valid-value\")\n  , defineProperty           = Object.defineProperty\n  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor\n  , getOwnPropertyNames      = Object.getOwnPropertyNames\n  , getOwnPropertySymbols    = Object.getOwnPropertySymbols;\n\nmodule.exports = function (target, source) {\n\tvar error, sourceObject = Object(value(source));\n\ttarget = Object(value(target));\n\tgetOwnPropertyNames(sourceObject).forEach(function (name) {\n\t\ttry {\n\t\t\tdefineProperty(target, name, getOwnPropertyDescriptor(source, name));\n\t\t} catch (e) { error = e; }\n\t});\n\tif (typeof getOwnPropertySymbols === \"function\") {\n\t\tgetOwnPropertySymbols(sourceObject).forEach(function (symbol) {\n\t\t\ttry {\n\t\t\t\tdefineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));\n\t\t\t} catch (e) { error = e; }\n\t\t});\n\t}\n\tif (error !== undefined) throw error;\n\treturn target;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1 /*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (arg /*, …args*/) {\n\tvar set = create(null);\n\tforEach.call(arguments, function (name) { set[name] = true; });\n\treturn set;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.setPrototypeOf : require(\"./shim\");\n","\"use strict\";\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};\n\nmodule.exports = function (/* CustomCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== \"function\") return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n};\n","/* eslint no-proto: \"off\" */\n\n// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n\"use strict\";\n\nvar isObject         = require(\"../is-object\")\n  , value            = require(\"../valid-value\")\n  , objIsPrototypeOf = Object.prototype.isPrototypeOf\n  , defineProperty   = Object.defineProperty\n  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif (prototype === null || isObject(prototype)) return obj;\n\tthrow new TypeError(\"Prototype must be null or an object\");\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self(obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, \"level\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: status.level\n\t});\n})(\n\t(function () {\n\t\tvar tmpObj1 = Object.create(null)\n\t\t  , tmpObj2 = {}\n\t\t  , set\n\t\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n\t\tif (desc) {\n\t\t\ttry {\n\t\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\t\tset.call(tmpObj1, tmpObj2);\n\t\t\t} catch (ignore) {}\n\t\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n\t\t}\n\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n\t\ttmpObj1 = {};\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n\t\treturn false;\n\t})()\n);\n\nrequire(\"../create\");\n","\"use strict\";\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n","\"use strict\";\n\nvar isObject = require(\"./is-object\");\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) throw new TypeError(value + \" is not an Object\");\n\treturn value;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n","\"use strict\";\n\nvar ensureValue   = require(\"./valid-value\")\n  , stringifiable = require(\"./validate-stringifiable\");\n\nmodule.exports = function (value) { return stringifiable(ensureValue(value)); };\n","\"use strict\";\n\nvar isCallable = require(\"./is-callable\");\n\nmodule.exports = function (stringifiable) {\n\ttry {\n\t\tif (stringifiable && isCallable(stringifiable.toString)) return stringifiable.toString();\n\t\treturn String(stringifiable);\n\t} catch (e) {\n\t\tthrow new TypeError(\"Passed argument cannot be stringifed\");\n\t}\n};\n","\"use strict\";\n\nvar isCallable = require(\"./object/is-callable\");\n\nmodule.exports = function (value) {\n\ttry {\n\t\tif (value && isCallable(value.toString)) return value.toString();\n\t\treturn String(value);\n\t} catch (e) {\n\t\treturn \"<Non-coercible to string value>\";\n\t}\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? String.prototype.contains : require(\"./shim\");\n","\"use strict\";\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n};\n","\"use strict\";\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString /*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? String.prototype.repeat : require(\"./shim\");\n","\"use strict\";\n\nvar str = \"foo\";\n\nmodule.exports = function () {\n\tif (typeof str.repeat !== \"function\") return false;\n\treturn str.repeat(2) === \"foofoo\";\n};\n","// Thanks\n// @rauchma http://www.2ality.com/2014/01/efficient-string-repeat.html\n// @mathiasbynens https://github.com/mathiasbynens/String.prototype.repeat/blob/4a4b567def/repeat.js\n\n\"use strict\";\n\nvar value     = require(\"../../../object/valid-value\")\n  , toInteger = require(\"../../../number/to-integer\");\n\nmodule.exports = function (count) {\n\tvar str = String(value(this)), result;\n\tcount = toInteger(count);\n\tif (count < 0) throw new RangeError(\"Count must be >= 0\");\n\tif (!isFinite(count)) throw new RangeError(\"Count must be < ∞\");\n\n\tresult = \"\";\n\twhile (count) {\n\t\tif (count % 2) result += str;\n\t\tif (count > 1) str += str;\n\t\t// eslint-disable-next-line no-bitwise\n\t\tcount >>= 1;\n\t}\n\treturn result;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString, id = objToString.call(\"\");\n\nmodule.exports = function (value) {\n\treturn (\n\t\ttypeof value === \"string\" ||\n\t\t(value &&\n\t\t\ttypeof value === \"object\" &&\n\t\t\t(value instanceof String || objToString.call(value) === id)) ||\n\t\tfalse\n\t);\n};\n","\"use strict\";\n\nvar safeToString = require(\"./safe-to-string\");\n\nvar reNewLine = /[\\n\\r\\u2028\\u2029]/g;\n\nmodule.exports = function (value) {\n\tvar string = safeToString(value);\n\t// Trim if too long\n\tif (string.length > 100) string = string.slice(0, 99) + \"…\";\n\t// Replace eventual new lines\n\tstring = string.replace(reNewLine, function (char) {\n\t\treturn JSON.stringify(char).slice(1, -1);\n\t});\n\treturn string;\n};\n","\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , contains       = require(\"es5-ext/string/#/contains\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tIterator.call(this, arr);\n\tif (!kind) kind = \"value\";\n\telse if (contains.call(kind, \"key+value\")) kind = \"key+value\";\n\telse if (contains.call(kind, \"key\")) kind = \"key\";\n\telse kind = \"value\";\n\tdefineProperty(this, \"__kind__\", d(\"\", kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete ArrayIterator.prototype.constructor;\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === \"value\") return this.__list__[i];\n\t\tif (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n\t\treturn i;\n\t})\n});\ndefineProperty(ArrayIterator.prototype, Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , callable    = require(\"es5-ext/object/valid-callable\")\n  , isString    = require(\"es5-ext/string/is-string\")\n  , get         = require(\"./get\");\n\nvar isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb /*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = \"array\";\n\telse if (isString(iterable)) mode = \"string\";\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () {\n\t\tbroken = true;\n\t};\n\tif (mode === \"array\") {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\treturn broken;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === \"string\") {\n\t\tlength = iterable.length;\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif (i + 1 < length) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n","\"use strict\";\n\nvar isArguments    = require(\"es5-ext/function/is-arguments\")\n  , isString       = require(\"es5-ext/string/is-string\")\n  , ArrayIterator  = require(\"./array\")\n  , StringIterator = require(\"./string\")\n  , iterable       = require(\"./valid-iterable\")\n  , iteratorSymbol = require(\"es6-symbol\").iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n","\"use strict\";\n\nvar clear    = require(\"es5-ext/array/#/clear\")\n  , assign   = require(\"es5-ext/object/assign\")\n  , callable = require(\"es5-ext/object/valid-callable\")\n  , value    = require(\"es5-ext/object/valid-value\")\n  , d        = require(\"d\")\n  , autoBind = require(\"d/auto-bind\")\n  , Symbol   = require(\"es6-symbol\");\n\nvar defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tdefineProperties(this, {\n\t\t__list__: d(\"w\", value(list)),\n\t\t__context__: d(\"w\", context),\n\t\t__nextIndex__: d(\"w\", 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on(\"_add\", this._onAdd);\n\tcontext.on(\"_delete\", this._onDelete);\n\tcontext.on(\"_clear\", this._onClear);\n};\n\n// Internal %IteratorPrototype% doesn't expose its constructor\ndelete Iterator.prototype.constructor;\n\ndefineProperties(\n\tIterator.prototype,\n\tassign(\n\t\t{\n\t\t\t_next: d(function () {\n\t\t\t\tvar i;\n\t\t\t\tif (!this.__list__) return undefined;\n\t\t\t\tif (this.__redo__) {\n\t\t\t\t\ti = this.__redo__.shift();\n\t\t\t\t\tif (i !== undefined) return i;\n\t\t\t\t}\n\t\t\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\t\t\tthis._unBind();\n\t\t\t\treturn undefined;\n\t\t\t}),\n\t\t\tnext: d(function () {\n\t\t\t\treturn this._createResult(this._next());\n\t\t\t}),\n\t\t\t_createResult: d(function (i) {\n\t\t\t\tif (i === undefined) return { done: true, value: undefined };\n\t\t\t\treturn { done: false, value: this._resolve(i) };\n\t\t\t}),\n\t\t\t_resolve: d(function (i) {\n\t\t\t\treturn this.__list__[i];\n\t\t\t}),\n\t\t\t_unBind: d(function () {\n\t\t\t\tthis.__list__ = null;\n\t\t\t\tdelete this.__redo__;\n\t\t\t\tif (!this.__context__) return;\n\t\t\t\tthis.__context__.off(\"_add\", this._onAdd);\n\t\t\t\tthis.__context__.off(\"_delete\", this._onDelete);\n\t\t\t\tthis.__context__.off(\"_clear\", this._onClear);\n\t\t\t\tthis.__context__ = null;\n\t\t\t}),\n\t\t\ttoString: d(function () {\n\t\t\t\treturn \"[object \" + (this[Symbol.toStringTag] || \"Object\") + \"]\";\n\t\t\t})\n\t\t},\n\t\tautoBind({\n\t\t\t_onAdd: d(function (index) {\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t++this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) {\n\t\t\t\t\tdefineProperty(this, \"__redo__\", d(\"c\", [index]));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t\t\t}, this);\n\t\t\t\tthis.__redo__.push(index);\n\t\t\t}),\n\t\t\t_onDelete: d(function (index) {\n\t\t\t\tvar i;\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t--this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) return;\n\t\t\t\ti = this.__redo__.indexOf(index);\n\t\t\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\t\t\tthis.__redo__.forEach(function (redo, j) {\n\t\t\t\t\tif (redo > index) this.__redo__[j] = --redo;\n\t\t\t\t}, this);\n\t\t\t}),\n\t\t\t_onClear: d(function () {\n\t\t\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\t\t\tthis.__nextIndex__ = 0;\n\t\t\t})\n\t\t})\n\t)\n);\n\ndefineProperty(\n\tIterator.prototype,\n\tSymbol.iterator,\n\td(function () {\n\t\treturn this;\n\t})\n);\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , isValue     = require(\"es5-ext/object/is-value\")\n  , isString    = require(\"es5-ext/string/is-string\");\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArray        = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn typeof value[iteratorSymbol] === \"function\";\n};\n","// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, \"__length__\", d(\"\", str.length));\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete StringIterator.prototype.constructor;\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\t_next: d(function () {\n\t\tif (!this.__list__) return undefined;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t\treturn undefined;\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t})\n});\ndefineProperty(StringIterator.prototype, Symbol.toStringTag, d(\"c\", \"String Iterator\"));\n","\"use strict\";\n\nvar isIterable = require(\"./is-iterable\");\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? require(\"ext/global-this\").Symbol\n\t: require(\"./polyfill\");\n","\"use strict\";\n\nvar global     = require(\"ext/global-this\")\n  , validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar Symbol = global.Symbol;\n\tvar symbol;\n\tif (typeof Symbol !== \"function\") return false;\n\tsymbol = Symbol(\"test symbol\");\n\ttry { String(symbol); }\n\tcatch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tif (!value) return false;\n\tif (typeof value === \"symbol\") return true;\n\tif (!value.constructor) return false;\n\tif (value.constructor.name !== \"Symbol\") return false;\n\treturn value[value.constructor.toStringTag] === \"Symbol\";\n};\n","\"use strict\";\n\nvar d = require(\"d\");\n\nvar create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;\n\nvar created = create(null);\nmodule.exports = function (desc) {\n\tvar postfix = 0, name, ie11BugWorkaround;\n\twhile (created[desc + (postfix || \"\")]) ++postfix;\n\tdesc += postfix || \"\";\n\tcreated[desc] = true;\n\tname = \"@@\" + desc;\n\tdefineProperty(\n\t\tobjPrototype, name,\n\t\td.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t})\n\t);\n\treturn name;\n};\n","\"use strict\";\n\nvar d            = require(\"d\")\n  , NativeSymbol = require(\"ext/global-this\").Symbol;\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\t// To ensure proper interoperability with other native functions (e.g. Array.from)\n\t\t// fallback to eventual native implementation of given symbol\n\t\thasInstance: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill(\"hasInstance\")\n\t\t),\n\t\tisConcatSpreadable: d(\n\t\t\t\"\",\n\t\t\t(NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\t\t\tSymbolPolyfill(\"isConcatSpreadable\")\n\t\t),\n\t\titerator: d(\"\", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill(\"iterator\")),\n\t\tmatch: d(\"\", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill(\"match\")),\n\t\treplace: d(\"\", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill(\"replace\")),\n\t\tsearch: d(\"\", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill(\"search\")),\n\t\tspecies: d(\"\", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill(\"species\")),\n\t\tsplit: d(\"\", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill(\"split\")),\n\t\ttoPrimitive: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill(\"toPrimitive\")\n\t\t),\n\t\ttoStringTag: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill(\"toStringTag\")\n\t\t),\n\t\tunscopables: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill(\"unscopables\")\n\t\t)\n\t});\n};\n","\"use strict\";\n\nvar d              = require(\"d\")\n  , validateSymbol = require(\"../../../validate-symbol\");\n\nvar registry = Object.create(null);\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\tfor: d(function (key) {\n\t\t\tif (registry[key]) return registry[key];\n\t\t\treturn (registry[key] = SymbolPolyfill(String(key)));\n\t\t}),\n\t\tkeyFor: d(function (symbol) {\n\t\t\tvar key;\n\t\t\tvalidateSymbol(symbol);\n\t\t\tfor (key in registry) {\n\t\t\t\tif (registry[key] === symbol) return key;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t})\n\t});\n};\n","// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n\"use strict\";\n\nvar d                    = require(\"d\")\n  , validateSymbol       = require(\"./validate-symbol\")\n  , NativeSymbol         = require(\"ext/global-this\").Symbol\n  , generateName         = require(\"./lib/private/generate-name\")\n  , setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\")\n  , setupSymbolRegistry  = require(\"./lib/private/setup/symbol-registry\");\n\nvar create = Object.create\n  , defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty;\n\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\n\nif (typeof NativeSymbol === \"function\") {\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n} else {\n\tNativeSymbol = null;\n}\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = description === undefined ? \"\" : String(description);\n\treturn defineProperties(symbol, {\n\t\t__description__: d(\"\", description),\n\t\t__name__: d(\"\", generateName(description))\n\t});\n};\n\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill);\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d(\"\", function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return \"Symbol (\" + validateSymbol(this).__description__ + \")\"; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(\n\tSymbolPolyfill.prototype, SymbolPolyfill.toPrimitive,\n\td(\"\", function () {\n\t\tvar symbol = validateSymbol(this);\n\t\tif (typeof symbol === \"symbol\") return symbol;\n\t\treturn symbol.toString();\n\t})\n);\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])\n);\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])\n);\n","\"use strict\";\n\nvar isSymbol = require(\"./is-symbol\");\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ is resolved with global context, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? globalThis : require(\"./implementation\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tif (typeof globalThis !== \"object\") return false;\n\tif (!globalThis) return false;\n\treturn globalThis.Array === Array;\n};\n","module.exports = isPromise;\nmodule.exports.default = isPromise;\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n","'use strict';\n\nvar toPosInt = require('es5-ext/number/to-pos-integer')\n\n  , create = Object.create, hasOwnProperty = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (limit) {\n\tvar size = 0, base = 1, queue = create(null), map = create(null), index = 0, del;\n\tlimit = toPosInt(limit);\n\treturn {\n\t\thit: function (id) {\n\t\t\tvar oldIndex = map[id], nuIndex = ++index;\n\t\t\tqueue[nuIndex] = id;\n\t\t\tmap[id] = nuIndex;\n\t\t\tif (!oldIndex) {\n\t\t\t\t++size;\n\t\t\t\tif (size <= limit) return;\n\t\t\t\tid = queue[base];\n\t\t\t\tdel(id);\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tdelete queue[oldIndex];\n\t\t\tif (base !== oldIndex) return;\n\t\t\twhile (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip\n\t\t},\n\t\tdelete: del = function (id) {\n\t\t\tvar oldIndex = map[id];\n\t\t\tif (!oldIndex) return;\n\t\t\tdelete queue[oldIndex];\n\t\t\tdelete map[id];\n\t\t\t--size;\n\t\t\tif (base !== oldIndex) return;\n\t\t\tif (!size) {\n\t\t\t\tindex = 0;\n\t\t\t\tbase = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip\n\t\t},\n\t\tclear: function () {\n\t\t\tsize = 0;\n\t\t\tbase = 1;\n\t\t\tqueue = create(null);\n\t\t\tmap = create(null);\n\t\t\tindex = 0;\n\t\t}\n\t};\n};\n","/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n\n// Support for asynchronous functions\n\n\"use strict\";\n\nvar aFrom        = require(\"es5-ext/array/from\")\n  , objectMap    = require(\"es5-ext/object/map\")\n  , mixin        = require(\"es5-ext/object/mixin\")\n  , defineLength = require(\"es5-ext/function/_define-length\")\n  , nextTick     = require(\"next-tick\");\n\nvar slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;\n\nrequire(\"../lib/registered-extensions\").async = function (tbi, conf) {\n\tvar waiting = create(null)\n\t  , cache = create(null)\n\t  , base = conf.memoized\n\t  , original = conf.original\n\t  , currentCallback\n\t  , currentContext\n\t  , currentArgs;\n\n\t// Initial\n\tconf.memoized = defineLength(function (arg) {\n\t\tvar args = arguments, last = args[args.length - 1];\n\t\tif (typeof last === \"function\") {\n\t\t\tcurrentCallback = last;\n\t\t\targs = slice.call(args, 0, -1);\n\t\t}\n\t\treturn base.apply(currentContext = this, currentArgs = args);\n\t}, base);\n\ttry { mixin(conf.memoized, base); }\n\tcatch (ignore) {}\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id) {\n\t\tvar cb, context, args;\n\t\tif (!currentCallback) return;\n\n\t\t// Unresolved\n\t\tif (waiting[id]) {\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback];\n\t\t\telse waiting[id].push(currentCallback);\n\t\t\tcurrentCallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Resolved, assure next tick invocation\n\t\tcb = currentCallback;\n\t\tcontext = currentContext;\n\t\targs = currentArgs;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\tnextTick(function () {\n\t\t\tvar data;\n\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\tdata = cache[id];\n\t\t\t\tconf.emit(\"getasync\", id, args, context);\n\t\t\t\tapply.call(cb, data.context, data.args);\n\t\t\t} else {\n\t\t\t\t// Purged in a meantime, we shouldn't rely on cached value, recall\n\t\t\t\tcurrentCallback = cb;\n\t\t\t\tcurrentContext = context;\n\t\t\t\tcurrentArgs = args;\n\t\t\t\tbase.apply(context, args);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Not from cache\n\tconf.original = function () {\n\t\tvar args, cb, origCb, result;\n\t\tif (!currentCallback) return apply.call(original, this, arguments);\n\t\targs = aFrom(arguments);\n\t\tcb = function self(err) {\n\t\t\tvar cb, args, id = self.id;\n\t\t\tif (id == null) {\n\t\t\t\t// Shouldn't happen, means async callback was called sync way\n\t\t\t\tnextTick(apply.bind(self, this, arguments));\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tdelete self.id;\n\t\t\tcb = waiting[id];\n\t\t\tdelete waiting[id];\n\t\t\tif (!cb) {\n\t\t\t\t// Already processed,\n\t\t\t\t// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\targs = aFrom(arguments);\n\t\t\tif (conf.has(id)) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconf.delete(id);\n\t\t\t\t} else {\n\t\t\t\t\tcache[id] = { context: this, args: args };\n\t\t\t\t\tconf.emit(\"setasync\", id, typeof cb === \"function\" ? 1 : cb.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof cb === \"function\") {\n\t\t\t\tresult = apply.call(cb, this, args);\n\t\t\t} else {\n\t\t\t\tcb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\torigCb = currentCallback;\n\t\tcurrentCallback = currentContext = currentArgs = null;\n\t\targs.push(cb);\n\t\tresult = apply.call(original, this, args);\n\t\tcb.cb = origCb;\n\t\tcurrentCallback = cb;\n\t\treturn result;\n\t};\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id) {\n\t\tif (!currentCallback) {\n\t\t\tconf.delete(id);\n\t\t\treturn;\n\t\t}\n\t\tif (waiting[id]) {\n\t\t\t// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)\n\t\t\tif (typeof waiting[id] === \"function\") waiting[id] = [waiting[id], currentCallback.cb];\n\t\t\telse waiting[id].push(currentCallback.cb);\n\t\t} else {\n\t\t\twaiting[id] = currentCallback.cb;\n\t\t}\n\t\tdelete currentCallback.cb;\n\t\tcurrentCallback.id = id;\n\t\tcurrentCallback = null;\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tvar result;\n\t\t// If false, we don't have value yet, so we assume that intention is not\n\t\t// to memoize this call. After value is obtained we don't cache it but\n\t\t// gracefully pass to callback\n\t\tif (hasOwnProperty.call(waiting, id)) return;\n\t\tif (!cache[id]) return;\n\t\tresult = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, slice.call(result.args, 1));\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\tconf.emit(\n\t\t\t\"clearasync\", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })\n\t\t);\n\t});\n};\n","// Call dispose callback on each cache purge\n\n\"use strict\";\n\nvar callable   = require(\"es5-ext/object/valid-callable\")\n  , forEach    = require(\"es5-ext/object/for-each\")\n  , extensions = require(\"../lib/registered-extensions\")\n\n  , apply = Function.prototype.apply;\n\nextensions.dispose = function (dispose, conf, options) {\n\tvar del;\n\tcallable(dispose);\n\tif ((options.async && extensions.async) || (options.promise && extensions.promise)) {\n\t\tconf.on(\"deleteasync\", del = function (id, resultArray) {\n\t\t\tapply.call(dispose, null, resultArray);\n\t\t});\n\t\tconf.on(\"clearasync\", function (cache) {\n\t\t\tforEach(cache, function (result, id) {\n del(id, result);\n});\n\t\t});\n\t\treturn;\n\t}\n\tconf.on(\"delete\", del = function (id, result) {\n dispose(result);\n});\n\tconf.on(\"clear\", function (cache) {\n\t\tforEach(cache, function (result, id) {\n del(id, result);\n});\n\t});\n};\n","/* eslint consistent-this: 0 */\n\n// Timeout cached values\n\n\"use strict\";\n\nvar aFrom      = require(\"es5-ext/array/from\")\n  , forEach    = require(\"es5-ext/object/for-each\")\n  , nextTick   = require(\"next-tick\")\n  , isPromise  = require(\"is-promise\")\n  , timeout    = require(\"timers-ext/valid-timeout\")\n  , extensions = require(\"../lib/registered-extensions\");\n\nvar noop = Function.prototype, max = Math.max, min = Math.min, create = Object.create;\n\nextensions.maxAge = function (maxAge, conf, options) {\n\tvar timeouts, postfix, preFetchAge, preFetchTimeouts;\n\n\tmaxAge = timeout(maxAge);\n\tif (!maxAge) return;\n\n\ttimeouts = create(null);\n\tpostfix =\n\t\t(options.async && extensions.async) || (options.promise && extensions.promise)\n\t\t\t? \"async\"\n\t\t\t: \"\";\n\tconf.on(\"set\" + postfix, function (id) {\n\t\ttimeouts[id] = setTimeout(function () { conf.delete(id); }, maxAge);\n\t\tif (typeof timeouts[id].unref === \"function\") timeouts[id].unref();\n\t\tif (!preFetchTimeouts) return;\n\t\tif (preFetchTimeouts[id]) {\n\t\t\tif (preFetchTimeouts[id] !== \"nextTick\") clearTimeout(preFetchTimeouts[id]);\n\t\t}\n\t\tpreFetchTimeouts[id] = setTimeout(function () {\n\t\t\tdelete preFetchTimeouts[id];\n\t\t}, preFetchAge);\n\t\tif (typeof preFetchTimeouts[id].unref === \"function\") preFetchTimeouts[id].unref();\n\t});\n\tconf.on(\"delete\" + postfix, function (id) {\n\t\tclearTimeout(timeouts[id]);\n\t\tdelete timeouts[id];\n\t\tif (!preFetchTimeouts) return;\n\t\tif (preFetchTimeouts[id] !== \"nextTick\") clearTimeout(preFetchTimeouts[id]);\n\t\tdelete preFetchTimeouts[id];\n\t});\n\n\tif (options.preFetch) {\n\t\tif (options.preFetch === true || isNaN(options.preFetch)) {\n\t\t\tpreFetchAge = 0.333;\n\t\t} else {\n\t\t\tpreFetchAge = max(min(Number(options.preFetch), 1), 0);\n\t\t}\n\t\tif (preFetchAge) {\n\t\t\tpreFetchTimeouts = {};\n\t\t\tpreFetchAge = (1 - preFetchAge) * maxAge;\n\t\t\tconf.on(\"get\" + postfix, function (id, args, context) {\n\t\t\t\tif (!preFetchTimeouts[id]) {\n\t\t\t\t\tpreFetchTimeouts[id] = \"nextTick\";\n\t\t\t\t\tnextTick(function () {\n\t\t\t\t\t\tvar result;\n\t\t\t\t\t\tif (preFetchTimeouts[id] !== \"nextTick\") return;\n\t\t\t\t\t\tdelete preFetchTimeouts[id];\n\t\t\t\t\t\tconf.delete(id);\n\t\t\t\t\t\tif (options.async) {\n\t\t\t\t\t\t\targs = aFrom(args);\n\t\t\t\t\t\t\targs.push(noop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = conf.memoized.apply(context, args);\n\t\t\t\t\t\tif (options.promise) {\n\t\t\t\t\t\t\t// Supress eventual error warnings\n\t\t\t\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\t\t\t\tif (typeof result.done === \"function\") result.done(noop, noop);\n\t\t\t\t\t\t\t\telse result.then(noop, noop);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tconf.on(\"clear\" + postfix, function () {\n\t\tforEach(timeouts, function (id) { clearTimeout(id); });\n\t\ttimeouts = {};\n\t\tif (preFetchTimeouts) {\n\t\t\tforEach(preFetchTimeouts, function (id) { if (id !== \"nextTick\") clearTimeout(id); });\n\t\t\tpreFetchTimeouts = {};\n\t\t}\n\t});\n};\n","// Limit cache size, LRU (least recently used) algorithm.\n\n\"use strict\";\n\nvar toPosInteger = require(\"es5-ext/number/to-pos-integer\")\n  , lruQueue     = require(\"lru-queue\")\n  , extensions   = require(\"../lib/registered-extensions\");\n\nextensions.max = function (max, conf, options) {\n\tvar postfix, queue, hit;\n\n\tmax = toPosInteger(max);\n\tif (!max) return;\n\n\tqueue = lruQueue(max);\n\tpostfix = (options.async && extensions.async) || (options.promise && extensions.promise)\n\t\t? \"async\" : \"\";\n\n\tconf.on(\"set\" + postfix, hit = function (id) {\n\t\tid = queue.hit(id);\n\t\tif (id === undefined) return;\n\t\tconf.delete(id);\n\t});\n\tconf.on(\"get\" + postfix, hit);\n\tconf.on(\"delete\" + postfix, queue.delete);\n\tconf.on(\"clear\" + postfix, queue.clear);\n};\n","/* eslint max-statements: 0 */\n\n// Support for functions returning promise\n\n\"use strict\";\n\nvar objectMap     = require(\"es5-ext/object/map\")\n  , primitiveSet  = require(\"es5-ext/object/primitive-set\")\n  , ensureString  = require(\"es5-ext/object/validate-stringifiable-value\")\n  , toShortString = require(\"es5-ext/to-short-string-representation\")\n  , isPromise     = require(\"is-promise\")\n  , nextTick      = require(\"next-tick\");\n\nvar create = Object.create\n  , supportedModes = primitiveSet(\"then\", \"then:finally\", \"done\", \"done:finally\");\n\nrequire(\"../lib/registered-extensions\").promise = function (mode, conf) {\n\tvar waiting = create(null), cache = create(null), promises = create(null);\n\n\tif (mode === true) {\n\t\tmode = null;\n\t} else {\n\t\tmode = ensureString(mode);\n\t\tif (!supportedModes[mode]) {\n\t\t\tthrow new TypeError(\"'\" + toShortString(mode) + \"' is not valid promise mode\");\n\t\t}\n\t}\n\n\t// After not from cache call\n\tconf.on(\"set\", function (id, ignore, promise) {\n\t\tvar isFailed = false;\n\n\t\tif (!isPromise(promise)) {\n\t\t\t// Non promise result\n\t\t\tcache[id] = promise;\n\t\t\tconf.emit(\"setasync\", id, 1);\n\t\t\treturn;\n\t\t}\n\t\twaiting[id] = 1;\n\t\tpromises[id] = promise;\n\t\tvar onSuccess = function (result) {\n\t\t\tvar count = waiting[id];\n\t\t\tif (isFailed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Detected unordered then|done & finally resolution, which \" +\n\t\t\t\t\t\t\"in turn makes proper detection of success/failure impossible (when in \" +\n\t\t\t\t\t\t\"'done:finally' mode)\\n\" +\n\t\t\t\t\t\t\"Consider to rely on 'then' or 'done' mode instead.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!count) return; // Deleted from cache before resolved\n\t\t\tdelete waiting[id];\n\t\t\tcache[id] = result;\n\t\t\tconf.emit(\"setasync\", id, count);\n\t\t};\n\t\tvar onFailure = function () {\n\t\t\tisFailed = true;\n\t\t\tif (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)\n\t\t\tdelete waiting[id];\n\t\t\tdelete promises[id];\n\t\t\tconf.delete(id);\n\t\t};\n\n\t\tvar resolvedMode = mode;\n\t\tif (!resolvedMode) resolvedMode = \"then\";\n\n\t\tif (resolvedMode === \"then\") {\n\t\t\tvar nextTickFailure = function () { nextTick(onFailure); };\n\t\t\t// Eventual finally needs to be attached to non rejected promise\n\t\t\t// (so we not force propagation of unhandled rejection)\n\t\t\tpromise = promise.then(function (result) {\n\t\t\t\tnextTick(onSuccess.bind(this, result));\n\t\t\t}, nextTickFailure);\n\t\t\t// If `finally` is a function we attach to it to remove cancelled promises.\n\t\t\tif (typeof promise.finally === \"function\") {\n\t\t\t\tpromise.finally(nextTickFailure);\n\t\t\t}\n\t\t} else if (resolvedMode === \"done\") {\n\t\t\t// Not recommended, as it may mute any eventual \"Unhandled error\" events\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess, onFailure);\n\t\t} else if (resolvedMode === \"done:finally\") {\n\t\t\t// The only mode with no side effects assuming library does not throw unconditionally\n\t\t\t// for rejected promises.\n\t\t\tif (typeof promise.done !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'done' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (typeof promise.finally !== \"function\") {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Memoizee error: Retrieved promise does not implement 'finally' \" +\n\t\t\t\t\t\t\"in 'done:finally' mode\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tpromise.done(onSuccess);\n\t\t\tpromise.finally(onFailure);\n\t\t}\n\t});\n\n\t// From cache (sync)\n\tconf.on(\"get\", function (id, args, context) {\n\t\tvar promise;\n\t\tif (waiting[id]) {\n\t\t\t++waiting[id]; // Still waiting\n\t\t\treturn;\n\t\t}\n\t\tpromise = promises[id];\n\t\tvar emit = function () { conf.emit(\"getasync\", id, args, context); };\n\t\tif (isPromise(promise)) {\n\t\t\tif (typeof promise.done === \"function\") promise.done(emit);\n\t\t\telse {\n\t\t\t\tpromise.then(function () { nextTick(emit); });\n\t\t\t}\n\t\t} else {\n\t\t\temit();\n\t\t}\n\t});\n\n\t// On delete\n\tconf.on(\"delete\", function (id) {\n\t\tdelete promises[id];\n\t\tif (waiting[id]) {\n\t\t\tdelete waiting[id];\n\t\t\treturn; // Not yet resolved\n\t\t}\n\t\tif (!hasOwnProperty.call(cache, id)) return;\n\t\tvar result = cache[id];\n\t\tdelete cache[id];\n\t\tconf.emit(\"deleteasync\", id, [result]);\n\t});\n\n\t// On clear\n\tconf.on(\"clear\", function () {\n\t\tvar oldCache = cache;\n\t\tcache = create(null);\n\t\twaiting = create(null);\n\t\tpromises = create(null);\n\t\tconf.emit(\"clearasync\", objectMap(oldCache, function (data) { return [data]; }));\n\t});\n};\n","// Reference counter, useful for garbage collector like functionality\n\n\"use strict\";\n\nvar d          = require(\"d\")\n  , extensions = require(\"../lib/registered-extensions\")\n\n  , create = Object.create, defineProperties = Object.defineProperties;\n\nextensions.refCounter = function (ignore, conf, options) {\n\tvar cache, postfix;\n\n\tcache = create(null);\n\tpostfix = (options.async && extensions.async) || (options.promise && extensions.promise)\n\t\t? \"async\" : \"\";\n\n\tconf.on(\"set\" + postfix, function (id, length) {\n cache[id] = length || 1;\n});\n\tconf.on(\"get\" + postfix, function (id) {\n ++cache[id];\n});\n\tconf.on(\"delete\" + postfix, function (id) {\n delete cache[id];\n});\n\tconf.on(\"clear\" + postfix, function () {\n cache = {};\n});\n\n\tdefineProperties(conf.memoized, {\n\t\tdeleteRef: d(function () {\n\t\t\tvar id = conf.get(arguments);\n\t\t\tif (id === null) return null;\n\t\t\tif (!cache[id]) return null;\n\t\t\tif (!--cache[id]) {\n\t\t\t\tconf.delete(id);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}),\n\t\tgetRefCount: d(function () {\n\t\t\tvar id = conf.get(arguments);\n\t\t\tif (id === null) return 0;\n\t\t\tif (!cache[id]) return 0;\n\t\t\treturn cache[id];\n\t\t})\n\t});\n};\n","\"use strict\";\n\nvar normalizeOpts = require(\"es5-ext/object/normalize-options\")\n  , resolveLength = require(\"./lib/resolve-length\")\n  , plain         = require(\"./plain\");\n\nmodule.exports = function (fn/*, options*/) {\n\tvar options = normalizeOpts(arguments[1]), length;\n\n\tif (!options.normalizer) {\n\t\tlength = options.length = resolveLength(options.length, fn.length, options.async);\n\t\tif (length !== 0) {\n\t\t\tif (options.primitive) {\n\t\t\t\tif (length === false) {\n\t\t\t\t\toptions.normalizer = require(\"./normalizers/primitive\");\n\t\t\t\t} else if (length > 1) {\n\t\t\t\t\toptions.normalizer = require(\"./normalizers/get-primitive-fixed\")(length);\n\t\t\t\t}\n\t\t\t} else if (length === false) options.normalizer = require(\"./normalizers/get\")();\n\t\t\t\telse if (length === 1) options.normalizer = require(\"./normalizers/get-1\")();\n\t\t\t\telse options.normalizer = require(\"./normalizers/get-fixed\")(length);\n\t\t}\n\t}\n\n\t// Assure extensions\n\tif (options.async) require(\"./ext/async\");\n\tif (options.promise) require(\"./ext/promise\");\n\tif (options.dispose) require(\"./ext/dispose\");\n\tif (options.maxAge) require(\"./ext/max-age\");\n\tif (options.max) require(\"./ext/max\");\n\tif (options.refCounter) require(\"./ext/ref-counter\");\n\n\treturn plain(fn, options);\n};\n","/* eslint no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */\n\n\"use strict\";\n\nvar customError      = require(\"es5-ext/error/custom\")\n  , defineLength     = require(\"es5-ext/function/_define-length\")\n  , d                = require(\"d\")\n  , ee               = require(\"event-emitter\").methods\n  , resolveResolve   = require(\"./resolve-resolve\")\n  , resolveNormalize = require(\"./resolve-normalize\");\n\nvar apply = Function.prototype.apply\n  , call = Function.prototype.call\n  , create = Object.create\n  , defineProperties = Object.defineProperties\n  , on = ee.on\n  , emit = ee.emit;\n\nmodule.exports = function (original, length, options) {\n\tvar cache = create(null)\n\t  , conf\n\t  , memLength\n\t  , get\n\t  , set\n\t  , del\n\t  , clear\n\t  , extDel\n\t  , extGet\n\t  , extHas\n\t  , normalizer\n\t  , getListeners\n\t  , setListeners\n\t  , deleteListeners\n\t  , memoized\n\t  , resolve;\n\tif (length !== false) memLength = length;\n\telse if (isNaN(original.length)) memLength = 1;\n\telse memLength = original.length;\n\n\tif (options.normalizer) {\n\t\tnormalizer = resolveNormalize(options.normalizer);\n\t\tget = normalizer.get;\n\t\tset = normalizer.set;\n\t\tdel = normalizer.delete;\n\t\tclear = normalizer.clear;\n\t}\n\tif (options.resolvers != null) resolve = resolveResolve(options.resolvers);\n\n\tif (get) {\n\t\tmemoized = defineLength(function (arg) {\n\t\t\tvar id, result, args = arguments;\n\t\t\tif (resolve) args = resolve(args);\n\t\t\tid = get(args);\n\t\t\tif (id !== null) {\n\t\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\t\tif (getListeners) conf.emit(\"get\", id, args, this);\n\t\t\t\t\treturn cache[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (args.length === 1) result = call.call(original, this, args[0]);\n\t\t\telse result = apply.call(original, this, args);\n\t\t\tif (id === null) {\n\t\t\t\tid = get(args);\n\t\t\t\tif (id !== null) throw customError(\"Circular invocation\", \"CIRCULAR_INVOCATION\");\n\t\t\t\tid = set(args);\n\t\t\t} else if (hasOwnProperty.call(cache, id)) {\n\t\t\t\tthrow customError(\"Circular invocation\", \"CIRCULAR_INVOCATION\");\n\t\t\t}\n\t\t\tcache[id] = result;\n\t\t\tif (setListeners) conf.emit(\"set\", id, null, result);\n\t\t\treturn result;\n\t\t}, memLength);\n\t} else if (length === 0) {\n\t\tmemoized = function () {\n\t\t\tvar result;\n\t\t\tif (hasOwnProperty.call(cache, \"data\")) {\n\t\t\t\tif (getListeners) conf.emit(\"get\", \"data\", arguments, this);\n\t\t\t\treturn cache.data;\n\t\t\t}\n\t\t\tif (arguments.length) result = apply.call(original, this, arguments);\n\t\t\telse result = call.call(original, this);\n\t\t\tif (hasOwnProperty.call(cache, \"data\")) {\n\t\t\t\tthrow customError(\"Circular invocation\", \"CIRCULAR_INVOCATION\");\n\t\t\t}\n\t\t\tcache.data = result;\n\t\t\tif (setListeners) conf.emit(\"set\", \"data\", null, result);\n\t\t\treturn result;\n\t\t};\n\t} else {\n\t\tmemoized = function (arg) {\n\t\t\tvar result, args = arguments, id;\n\t\t\tif (resolve) args = resolve(arguments);\n\t\t\tid = String(args[0]);\n\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\tif (getListeners) conf.emit(\"get\", id, args, this);\n\t\t\t\treturn cache[id];\n\t\t\t}\n\t\t\tif (args.length === 1) result = call.call(original, this, args[0]);\n\t\t\telse result = apply.call(original, this, args);\n\t\t\tif (hasOwnProperty.call(cache, id)) {\n\t\t\t\tthrow customError(\"Circular invocation\", \"CIRCULAR_INVOCATION\");\n\t\t\t}\n\t\t\tcache[id] = result;\n\t\t\tif (setListeners) conf.emit(\"set\", id, null, result);\n\t\t\treturn result;\n\t\t};\n\t}\n\tconf = {\n\t\toriginal: original,\n\t\tmemoized: memoized,\n\t\tprofileName: options.profileName,\n\t\tget: function (args) {\n\t\t\tif (resolve) args = resolve(args);\n\t\t\tif (get) return get(args);\n\t\t\treturn String(args[0]);\n\t\t},\n\t\thas: function (id) { return hasOwnProperty.call(cache, id); },\n\t\tdelete: function (id) {\n\t\t\tvar result;\n\t\t\tif (!hasOwnProperty.call(cache, id)) return;\n\t\t\tif (del) del(id);\n\t\t\tresult = cache[id];\n\t\t\tdelete cache[id];\n\t\t\tif (deleteListeners) conf.emit(\"delete\", id, result);\n\t\t},\n\t\tclear: function () {\n\t\t\tvar oldCache = cache;\n\t\t\tif (clear) clear();\n\t\t\tcache = create(null);\n\t\t\tconf.emit(\"clear\", oldCache);\n\t\t},\n\t\ton: function (type, listener) {\n\t\t\tif (type === \"get\") getListeners = true;\n\t\t\telse if (type === \"set\") setListeners = true;\n\t\t\telse if (type === \"delete\") deleteListeners = true;\n\t\t\treturn on.call(this, type, listener);\n\t\t},\n\t\temit: emit,\n\t\tupdateEnv: function () { original = conf.original; }\n\t};\n\tif (get) {\n\t\textDel = defineLength(function (arg) {\n\t\t\tvar id, args = arguments;\n\t\t\tif (resolve) args = resolve(args);\n\t\t\tid = get(args);\n\t\t\tif (id === null) return;\n\t\t\tconf.delete(id);\n\t\t}, memLength);\n\t} else if (length === 0) {\n\t\textDel = function () { return conf.delete(\"data\"); };\n\t} else {\n\t\textDel = function (arg) {\n\t\t\tif (resolve) arg = resolve(arguments)[0];\n\t\t\treturn conf.delete(arg);\n\t\t};\n\t}\n\textGet = defineLength(function () {\n\t\tvar id, args = arguments;\n\t\tif (length === 0) return cache.data;\n\t\tif (resolve) args = resolve(args);\n\t\tif (get) id = get(args);\n\t\telse id = String(args[0]);\n\t\treturn cache[id];\n\t});\n\textHas = defineLength(function () {\n\t\tvar id, args = arguments;\n\t\tif (length === 0) return conf.has(\"data\");\n\t\tif (resolve) args = resolve(args);\n\t\tif (get) id = get(args);\n\t\telse id = String(args[0]);\n\t\tif (id === null) return false;\n\t\treturn conf.has(id);\n\t});\n\tdefineProperties(memoized, {\n\t\t__memoized__: d(true),\n\t\tdelete: d(extDel),\n\t\tclear: d(conf.clear),\n\t\t_get: d(extGet),\n\t\t_has: d(extHas)\n\t});\n\treturn conf;\n};\n","\"use strict\";\n\nvar forEach       = require(\"es5-ext/object/for-each\")\n  , normalizeOpts = require(\"es5-ext/object/normalize-options\")\n  , callable      = require(\"es5-ext/object/valid-callable\")\n  , lazy          = require(\"d/lazy\")\n  , resolveLength = require(\"./resolve-length\")\n  , extensions    = require(\"./registered-extensions\");\n\nmodule.exports = function (memoize) {\n\treturn function (props) {\n\t\tforEach(props, function (desc) {\n\t\t\tvar fn = callable(desc.value), length;\n\t\t\tdesc.value = function (options) {\n\t\t\t\tif (options.getNormalizer) {\n\t\t\t\t\toptions = normalizeOpts(options);\n\t\t\t\t\tif (length === undefined) {\n\t\t\t\t\t\tlength = resolveLength(\n\t\t\t\t\t\t\toptions.length,\n\t\t\t\t\t\t\tfn.length,\n\t\t\t\t\t\t\toptions.async && extensions.async\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\toptions.normalizer = options.getNormalizer(length);\n\t\t\t\t\tdelete options.getNormalizer;\n\t\t\t\t}\n\t\t\t\treturn memoize(fn.bind(this), options);\n\t\t\t};\n\t\t});\n\t\treturn lazy(props);\n\t};\n};\n","\"use strict\";\n\nvar toPosInt = require(\"es5-ext/number/to-pos-integer\");\n\nmodule.exports = function (optsLength, fnLength, isAsync) {\n\tvar length;\n\tif (isNaN(optsLength)) {\n\t\tlength = fnLength;\n\t\tif (!(length >= 0)) return 1;\n\t\tif (isAsync && length) return length - 1;\n\t\treturn length;\n\t}\n\tif (optsLength === false) return false;\n\treturn toPosInt(optsLength);\n};\n","\"use strict\";\n\nvar callable = require(\"es5-ext/object/valid-callable\");\n\nmodule.exports = function (userNormalizer) {\n\tvar normalizer;\n\tif (typeof userNormalizer === \"function\") return { set: userNormalizer, get: userNormalizer };\n\tnormalizer = { get: callable(userNormalizer.get) };\n\tif (userNormalizer.set !== undefined) {\n\t\tnormalizer.set = callable(userNormalizer.set);\n\t\tif (userNormalizer.delete) normalizer.delete = callable(userNormalizer.delete);\n\t\tif (userNormalizer.clear) normalizer.clear = callable(userNormalizer.clear);\n\t\treturn normalizer;\n\t}\n\tnormalizer.set = normalizer.get;\n\treturn normalizer;\n};\n","\"use strict\";\n\nvar toArray  = require(\"es5-ext/array/to-array\")\n  , isValue  = require(\"es5-ext/object/is-value\")\n  , callable = require(\"es5-ext/object/valid-callable\");\n\nvar slice = Array.prototype.slice, resolveArgs;\n\nresolveArgs = function (args) {\n\treturn this.map(function (resolve, i) {\n\t\treturn resolve ? resolve(args[i]) : args[i];\n\t}).concat(slice.call(args, this.length));\n};\n\nmodule.exports = function (resolvers) {\n\tresolvers = toArray(resolvers);\n\tresolvers.forEach(function (resolve) {\n\t\tif (isValue(resolve)) callable(resolve);\n\t});\n\treturn resolveArgs.bind(resolvers);\n};\n","\"use strict\";\n\nmodule.exports = require(\"./lib/methods\")(require(\"./\"));\n","\"use strict\";\n\nvar indexOf = require(\"es5-ext/array/#/e-index-of\");\n\nmodule.exports = function () {\n\tvar lastId = 0, argsMap = [], cache = [];\n\treturn {\n\t\tget: function (args) {\n\t\t\tvar index = indexOf.call(argsMap, args[0]);\n\t\t\treturn index === -1 ? null : cache[index];\n\t\t},\n\t\tset: function (args) {\n\t\t\targsMap.push(args[0]);\n\t\t\tcache.push(++lastId);\n\t\t\treturn lastId;\n\t\t},\n\t\tdelete: function (id) {\n\t\t\tvar index = indexOf.call(cache, id);\n\t\t\tif (index !== -1) {\n\t\t\t\targsMap.splice(index, 1);\n\t\t\t\tcache.splice(index, 1);\n\t\t\t}\n\t\t},\n\t\tclear: function () {\n\t\t\targsMap = [];\n\t\t\tcache = [];\n\t\t}\n\t};\n};\n","\"use strict\";\n\nvar indexOf = require(\"es5-ext/array/#/e-index-of\")\n  , create  = Object.create;\n\nmodule.exports = function (length) {\n\tvar lastId = 0, map = [[], []], cache = create(null);\n\treturn {\n\t\tget: function (args) {\n\t\t\tvar index = 0, set = map, i;\n\t\t\twhile (index < length - 1) {\n\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\tif (i === -1) return null;\n\t\t\t\tset = set[1][i];\n\t\t\t\t++index;\n\t\t\t}\n\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\tif (i === -1) return null;\n\t\t\treturn set[1][i] || null;\n\t\t},\n\t\tset: function (args) {\n\t\t\tvar index = 0, set = map, i;\n\t\t\twhile (index < length - 1) {\n\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\tif (i === -1) {\n\t\t\t\t\ti = set[0].push(args[index]) - 1;\n\t\t\t\t\tset[1].push([[], []]);\n\t\t\t\t}\n\t\t\t\tset = set[1][i];\n\t\t\t\t++index;\n\t\t\t}\n\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\tif (i === -1) {\n\t\t\t\ti = set[0].push(args[index]) - 1;\n\t\t\t}\n\t\t\tset[1][i] = ++lastId;\n\t\t\tcache[lastId] = args;\n\t\t\treturn lastId;\n\t\t},\n\t\tdelete: function (id) {\n\t\t\tvar index = 0, set = map, i, path = [], args = cache[id];\n\t\t\twhile (index < length - 1) {\n\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\tif (i === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpath.push(set, i);\n\t\t\t\tset = set[1][i];\n\t\t\t\t++index;\n\t\t\t}\n\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\tif (i === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tid = set[1][i];\n\t\t\tset[0].splice(i, 1);\n\t\t\tset[1].splice(i, 1);\n\t\t\twhile (!set[0].length && path.length) {\n\t\t\t\ti = path.pop();\n\t\t\t\tset = path.pop();\n\t\t\t\tset[0].splice(i, 1);\n\t\t\t\tset[1].splice(i, 1);\n\t\t\t}\n\t\t\tdelete cache[id];\n\t\t},\n\t\tclear: function () {\n\t\t\tmap = [[], []];\n\t\t\tcache = create(null);\n\t\t}\n\t};\n};\n","\"use strict\";\n\nmodule.exports = function (length) {\n\tif (!length) {\n\t\treturn function () {\n\t\t\treturn \"\";\n\t\t};\n\t}\n\treturn function (args) {\n\t\tvar id = String(args[0]), i = 0, currentLength = length;\n\t\twhile (--currentLength) {\n\t\t\tid += \"\\u0001\" + args[++i];\n\t\t}\n\t\treturn id;\n\t};\n};\n","/* eslint max-statements: 0 */\n\n\"use strict\";\n\nvar indexOf = require(\"es5-ext/array/#/e-index-of\");\n\nvar create = Object.create;\n\nmodule.exports = function () {\n\tvar lastId = 0, map = [], cache = create(null);\n\treturn {\n\t\tget: function (args) {\n\t\t\tvar index = 0, set = map, i, length = args.length;\n\t\t\tif (length === 0) return set[length] || null;\n\t\t\tif ((set = set[length])) {\n\t\t\t\twhile (index < length - 1) {\n\t\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\t\tif (i === -1) return null;\n\t\t\t\t\tset = set[1][i];\n\t\t\t\t\t++index;\n\t\t\t\t}\n\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\tif (i === -1) return null;\n\t\t\t\treturn set[1][i] || null;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function (args) {\n\t\t\tvar index = 0, set = map, i, length = args.length;\n\t\t\tif (length === 0) {\n\t\t\t\tset[length] = ++lastId;\n\t\t\t} else {\n\t\t\t\tif (!set[length]) {\n\t\t\t\t\tset[length] = [[], []];\n\t\t\t\t}\n\t\t\t\tset = set[length];\n\t\t\t\twhile (index < length - 1) {\n\t\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\t\tif (i === -1) {\n\t\t\t\t\t\ti = set[0].push(args[index]) - 1;\n\t\t\t\t\t\tset[1].push([[], []]);\n\t\t\t\t\t}\n\t\t\t\t\tset = set[1][i];\n\t\t\t\t\t++index;\n\t\t\t\t}\n\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\tif (i === -1) {\n\t\t\t\t\ti = set[0].push(args[index]) - 1;\n\t\t\t\t}\n\t\t\t\tset[1][i] = ++lastId;\n\t\t\t}\n\t\t\tcache[lastId] = args;\n\t\t\treturn lastId;\n\t\t},\n\t\tdelete: function (id) {\n\t\t\tvar index = 0, set = map, i, args = cache[id], length = args.length, path = [];\n\t\t\tif (length === 0) {\n\t\t\t\tdelete set[length];\n\t\t\t} else if ((set = set[length])) {\n\t\t\t\twhile (index < length - 1) {\n\t\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\t\tif (i === -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpath.push(set, i);\n\t\t\t\t\tset = set[1][i];\n\t\t\t\t\t++index;\n\t\t\t\t}\n\t\t\t\ti = indexOf.call(set[0], args[index]);\n\t\t\t\tif (i === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tid = set[1][i];\n\t\t\t\tset[0].splice(i, 1);\n\t\t\t\tset[1].splice(i, 1);\n\t\t\t\twhile (!set[0].length && path.length) {\n\t\t\t\t\ti = path.pop();\n\t\t\t\t\tset = path.pop();\n\t\t\t\t\tset[0].splice(i, 1);\n\t\t\t\t\tset[1].splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete cache[id];\n\t\t},\n\t\tclear: function () {\n\t\t\tmap = [];\n\t\t\tcache = create(null);\n\t\t}\n\t};\n};\n","\"use strict\";\n\nmodule.exports = function (args) {\n\tvar id, i, length = args.length;\n\tif (!length) return \"\\u0002\";\n\tid = String(args[i = 0]);\n\twhile (--length) id += \"\\u0001\" + args[++i];\n\treturn id;\n};\n","\"use strict\";\n\nvar callable      = require(\"es5-ext/object/valid-callable\")\n  , forEach       = require(\"es5-ext/object/for-each\")\n  , extensions    = require(\"./lib/registered-extensions\")\n  , configure     = require(\"./lib/configure-map\")\n  , resolveLength = require(\"./lib/resolve-length\");\n\nmodule.exports = function self(fn /*, options */) {\n\tvar options, length, conf;\n\n\tcallable(fn);\n\toptions = Object(arguments[1]);\n\n\tif (options.async && options.promise) {\n\t\tthrow new Error(\"Options 'async' and 'promise' cannot be used together\");\n\t}\n\n\t// Do not memoize already memoized function\n\tif (hasOwnProperty.call(fn, \"__memoized__\") && !options.force) return fn;\n\n\t// Resolve length;\n\tlength = resolveLength(options.length, fn.length, options.async && extensions.async);\n\n\t// Configure cache map\n\tconf = configure(fn, length, options);\n\n\t// Bind eventual extensions\n\tforEach(extensions, function (extFn, name) {\n\t\tif (options[name]) extFn(options[name], conf, options);\n\t});\n\n\tif (self.__profiler__) self.__profiler__(conf);\n\n\tconf.updateEnv();\n\treturn conf.memoized;\n};\n","'use strict';\n\nvar ensureCallable = function (fn) {\n\tif (typeof fn !== 'function') throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n\nvar byObserver = function (Observer) {\n\tvar node = document.createTextNode(''), queue, currentQueue, i = 0;\n\tnew Observer(function () {\n\t\tvar callback;\n\t\tif (!queue) {\n\t\t\tif (!currentQueue) return;\n\t\t\tqueue = currentQueue;\n\t\t} else if (currentQueue) {\n\t\t\tqueue = currentQueue.concat(queue);\n\t\t}\n\t\tcurrentQueue = queue;\n\t\tqueue = null;\n\t\tif (typeof currentQueue === 'function') {\n\t\t\tcallback = currentQueue;\n\t\t\tcurrentQueue = null;\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\t\tnode.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash\n\t\twhile (currentQueue) {\n\t\t\tcallback = currentQueue.shift();\n\t\t\tif (!currentQueue.length) currentQueue = null;\n\t\t\tcallback();\n\t\t}\n\t}).observe(node, { characterData: true });\n\treturn function (fn) {\n\t\tensureCallable(fn);\n\t\tif (queue) {\n\t\t\tif (typeof queue === 'function') queue = [queue, fn];\n\t\t\telse queue.push(fn);\n\t\t\treturn;\n\t\t}\n\t\tqueue = fn;\n\t\tnode.data = (i = ++i % 2);\n\t};\n};\n\nmodule.exports = (function () {\n\t// Node.js\n\tif ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {\n\t\treturn process.nextTick;\n\t}\n\n\t// queueMicrotask\n\tif (typeof queueMicrotask === \"function\") {\n\t\treturn function (cb) { queueMicrotask(ensureCallable(cb)); };\n\t}\n\n\t// MutationObserver\n\tif ((typeof document === 'object') && document) {\n\t\tif (typeof MutationObserver === 'function') return byObserver(MutationObserver);\n\t\tif (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);\n\t}\n\n\t// W3C Draft\n\t// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html\n\tif (typeof setImmediate === 'function') {\n\t\treturn function (cb) { setImmediate(ensureCallable(cb)); };\n\t}\n\n\t// Wide available standard\n\tif ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {\n\t\treturn function (cb) { setTimeout(ensureCallable(cb), 0); };\n\t}\n\n\treturn null;\n}());\n","\"use strict\";\n\nmodule.exports = 2147483647;\n","\"use strict\";\n\nvar toPosInt   = require(\"es5-ext/number/to-pos-integer\")\n  , maxTimeout = require(\"./max-timeout\");\n\nmodule.exports = function (value) {\n\tvalue = toPosInt(value);\n\tif (value > maxTimeout) throw new TypeError(value + \" exceeds maximum possible timeout\");\n\treturn value;\n};\n","\"use strict\";\n\nvar isPrototype = require(\"../prototype/is\");\n\nmodule.exports = function (value) {\n\tif (typeof value !== \"function\") return false;\n\n\tif (!hasOwnProperty.call(value, \"length\")) return false;\n\n\ttry {\n\t\tif (typeof value.length !== \"number\") return false;\n\t\tif (typeof value.call !== \"function\") return false;\n\t\tif (typeof value.apply !== \"function\") return false;\n\t} catch (error) {\n\t\treturn false;\n\t}\n\n\treturn !isPrototype(value);\n};\n","\"use strict\";\n\nvar stringCoerce  = require(\"../string/coerce\")\n  , toShortString = require(\"./to-short-string\");\n\nmodule.exports = function (errorMessage, value, inputOptions) {\n\tif (inputOptions && inputOptions.errorMessage) {\n\t\terrorMessage = stringCoerce(inputOptions.errorMessage);\n\t}\n\n\tvar valueInsertIndex = errorMessage.indexOf(\"%v\");\n\tvar valueToken = valueInsertIndex > -1 ? toShortString(value) : null;\n\tif (inputOptions && inputOptions.name) {\n\t\tvar nameInsertIndex = errorMessage.indexOf(\"%n\");\n\t\tif (nameInsertIndex > -1) {\n\t\t\tif (valueInsertIndex > -1) {\n\t\t\t\tvar firstToken, secondToken, firstInsertIndex, secondInsertIndex;\n\t\t\t\tif (nameInsertIndex > valueInsertIndex) {\n\t\t\t\t\tfirstToken = valueToken;\n\t\t\t\t\tfirstInsertIndex = valueInsertIndex;\n\t\t\t\t\tsecondToken = inputOptions.name;\n\t\t\t\t\tsecondInsertIndex = nameInsertIndex;\n\t\t\t\t} else {\n\t\t\t\t\tfirstToken = inputOptions.name;\n\t\t\t\t\tfirstInsertIndex = nameInsertIndex;\n\t\t\t\t\tsecondToken = valueToken;\n\t\t\t\t\tsecondInsertIndex = valueInsertIndex;\n\t\t\t\t}\n\t\t\t\treturn (\n\t\t\t\t\terrorMessage.slice(0, firstInsertIndex) +\n\t\t\t\t\tfirstToken +\n\t\t\t\t\terrorMessage.slice(firstInsertIndex + 2, secondInsertIndex) +\n\t\t\t\t\tsecondToken +\n\t\t\t\t\terrorMessage.slice(secondInsertIndex + 2)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn (\n\t\t\t\terrorMessage.slice(0, nameInsertIndex) +\n\t\t\t\tinputOptions.name +\n\t\t\t\terrorMessage.slice(nameInsertIndex + 2)\n\t\t\t);\n\t\t}\n\t}\n\tif (valueInsertIndex > -1) {\n\t\treturn (\n\t\t\terrorMessage.slice(0, valueInsertIndex) +\n\t\t\tvalueToken +\n\t\t\terrorMessage.slice(valueInsertIndex + 2)\n\t\t);\n\t}\n\treturn errorMessage;\n};\n","\"use strict\";\n\nvar isValue             = require(\"../value/is\")\n  , resolveErrorMessage = require(\"./resolve-error-message\");\n\nmodule.exports = function (value, defaultMessage, inputOptions) {\n\tif (inputOptions && !isValue(value)) {\n\t\tif (\"default\" in inputOptions) return inputOptions[\"default\"];\n\t\tif (inputOptions.isOptional) return null;\n\t}\n\tvar ErrorConstructor = (inputOptions && inputOptions.Error) || TypeError;\n\tvar error = new ErrorConstructor(resolveErrorMessage(defaultMessage, value, inputOptions));\n\tif (inputOptions && inputOptions.errorCode) error.code = inputOptions.errorCode;\n\tthrow error;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\ttry {\n\t\treturn value.toString();\n\t} catch (error) {\n\t\ttry { return String(value); }\n\t\tcatch (error2) { return null; }\n\t}\n};\n","\"use strict\";\n\nvar safeToString = require(\"./safe-to-string\");\n\nvar reNewLine = /[\\n\\r\\u2028\\u2029]/g;\n\nmodule.exports = function (value) {\n\tvar string = safeToString(value);\n\tif (string === null) return \"<Non-coercible to string value>\";\n\t// Trim if too long\n\tif (string.length > 100) string = string.slice(0, 99) + \"…\";\n\t// Replace eventual new lines\n\tstring = string.replace(reNewLine, function (char) {\n\t\tswitch (char) {\n\t\t\tcase \"\\n\":\n\t\t\t\treturn \"\\\\n\";\n\t\t\tcase \"\\r\":\n\t\t\t\treturn \"\\\\r\";\n\t\t\tcase \"\\u2028\":\n\t\t\t\treturn \"\\\\u2028\";\n\t\t\tcase \"\\u2029\":\n\t\t\t\treturn \"\\\\u2029\";\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unexpected character\");\n\t\t}\n\t});\n\treturn string;\n};\n","\"use strict\";\n\nvar isValue = require(\"../value/is\");\n\n// prettier-ignore\nvar possibleTypes = { \"object\": true, \"function\": true, \"undefined\": true /* document.all */ };\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\treturn hasOwnProperty.call(possibleTypes, typeof value);\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\tvar options = arguments[1];\n\tvar errorMessage =\n\t\toptions && options.name\n\t\t\t? \"Expected a plain function for %n, received %v\"\n\t\t\t: \"%v is not a plain function\";\n\treturn resolveException(value, errorMessage, options);\n};\n","\"use strict\";\n\nvar isFunction = require(\"../function/is\");\n\nvar classRe = /^\\s*class[\\s{/}]/, functionToString = Function.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isFunction(value)) return false;\n\tif (classRe.test(functionToString.call(value))) return false;\n\treturn true;\n};\n","\"use strict\";\n\nvar isObject = require(\"../object/is\");\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) return false;\n\ttry {\n\t\tif (!value.constructor) return false;\n\t\treturn value.constructor.prototype === value;\n\t} catch (error) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue  = require(\"../value/is\")\n  , isObject = require(\"../object/is\");\n\nvar objectToString = Object.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return null;\n\tif (isObject(value)) {\n\t\t// Reject Object.prototype.toString coercion\n\t\tvar valueToString = value.toString;\n\t\tif (typeof valueToString !== \"function\") return null;\n\t\tif (valueToString === objectToString) return null;\n\t\t// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant\n\t\t// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case\n\t}\n\ttry {\n\t\treturn \"\" + value; // Ensure implicit coercion\n\t} catch (error) {\n\t\treturn null;\n\t}\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\tvar options = arguments[1];\n\tvar errorMessage =\n\t\toptions && options.name ? \"Expected a value for %n, received %v\" : \"Cannot use %v\";\n\treturn resolveException(value, errorMessage, options);\n};\n","\"use strict\";\n\n// ES3 safe\nvar _undefined = void 0;\n\nmodule.exports = function (value) { return value !== _undefined && value !== null; };\n","// author: C.A.D. BONDJE DOUE\n// file: extension.js\n// @date: 20240618 21:32:54\n// @desc: bformatter vscode extension\nObject.defineProperty(exports, '__ESModule', { value: true });\n\nconst vscode = require('vscode');\n\n// for release \nconst cli = require('cli-color');\nconst { TransformEngine } = require('./lib/TransformEngine');\nconst { utils } = require('./vscode');\nconst { Formatters } = require(\"./formatter\");\nconst completion = require(\"./vscode/completion\");\nconst Version = 'debug.0.0.1';\nclass VSCodeTransformEngine extends TransformEngine {\n\n}\n\n\nTransformEngine.Register('vscode', VSCodeTransformEngine);\nconst sm_FORMATTERS = {};\nlet _formatter = null;\nfunction GetFormatter(format) {\n    if (format in sm_FORMATTERS) {\n        return sm_FORMATTERS[format];\n    }\n    try {\n        _formatter = Formatters.Load(format);\n        if (!_formatter) {\n            throw new Error(\"formatter is missing[\" + format + \"]\");\n        }\n    } catch (e) {\n        console.log(\"error\", e);\n    }\n    sm_FORMATTERS[format] = _formatter;\n    return _formatter;\n}\n/**\n * \n * @param {*} document \n * @param {string|{name:string, prefix:string}} format \n * @returns \n */\nfunction formatAllDocument(document, format) {\n    const _text = document.getText();\n    const _range = new vscode.Range(\n        document.lineAt(0).range.start,\n        document.lineAt(document.lineCount - 1).range.end\n    );\n    const _formatter = GetFormatter(format);\n    if (_formatter) {\n        console.log(\"format :\", { format });\n        let _res = _formatter.format(_text.split(\"\\n\"));\n        if (_res) {\n            return vscode.TextEdit.replace(_range, _res);\n        }\n        console.log('missing format....', _formatter.error);\n    } else {\n        console.log(cli.red('missing formatter: ' + format));\n    }\n}\n/**\n * \n * @param {vscode.ExtensionContext} context \n */\nfunction activate(context) {\n    // + | register language formatters \n    console.log(\"activate bformatters\");\n    const languageFormatter = new Map();\n    [\"bcss\", \"bview\", \"phtml\", \"bjs\", \"pcss\", \"bhtml\", \"vbmacros\"].forEach((a) => {\n        ;\n        let p = vscode.languages.registerDocumentFormattingEditProvider(\n            a, {\n            provideDocumentFormattingEdits(document, options, token) {\n                return [formatAllDocument(document, a, options, token)];\n            }\n        }\n        );\n        context.subscriptions.push(p);\n        languageFormatter.set(a, p);\n    });\n    const { commands } = require('./vscode/command')\n    // + |\n    // + | register extension command\n    const _commands = {\n        ...commands\n    };\n\n\n    // + | subscribe command\n    for (let _key in _commands) {\n        let _fc = _commands[_key];\n        let c = vscode.commands.registerCommand(_key, _fc);\n        context.subscriptions.push(c);\n    }\n\n    // + | register color provider \n    const _clprofiles =\n    {\n        'bcss': {\n            ...utils.LoadProvideDocumentColor('bcss-provide-colors', vscode)\n        },\n        \"bcolor\": {\n            /**\n             * \n             * @param {vscode.TextDocument} document \n             * @param {vscode.CancellationToken} token \n             * @returns {vscode.ColorInformation[]}\n             */\n            provideDocumentColors(document, token) {\n                const _text = document.getText();\n                const _formatter = Formatters.Load('fbcolor');\n                const _colors_lists = utils.ExtractColors(_formatter, _text);\n                const _colors = [];\n                if (_colors_lists) {\n                    try {\n                        _colors_lists.forEach(i => {\n                            let x = document.positionAt(i.sourceOffset * 1.0);\n                            let y = document.positionAt(i.sourceOffset + i.value.length);\n                            const _range = new vscode.Range(x, y);\n                            const _color = utils.GetColor(i.type == 'webcolor' ? utils.ReverseColor(i.value) : i.value, vscode);\n                            const _clinfo = new vscode.ColorInformation(_range, _color);\n                            _colors.push(_clinfo);\n                        });\n                    } catch (ex) {\n                        console.debug(\"error \", ex);\n                    }\n                }\n                return _colors;\n            }\n        }\n    }\n        ;\n    for (let i in _clprofiles) {\n        const _provider = _clprofiles[i] || {};\n        if (!('provideColorPresentations' in _provider)) {\n            const { provideColorPresentations } = utils.GetProviderPresentation(i, vscode);\n            _provider.provideColorPresentations = provideColorPresentations;\n        }\n        const c = vscode.languages.registerColorProvider({ scheme: 'file', language: i },\n            _provider\n        );\n        context.subscriptions.push(c);\n    }\n\n\n\n    // register hightight definition \n    context.subscriptions.push(vscode.languages.registerCompletionItemProvider({\n        scheme: 'file',\n        language: 'bcss'\n    }, {\n        /**\n         * \n         * @param {*} document \n         * @param {*} position \n         * @param {*} token \n         * @param {{triggerCharacter:number, triggerKind:number}} context \n         * @returns \n         */\n        provideCompletionItems(document, position, token, context) {\n            const _provide_items = [];\n            // init media \n            '@balafon|@def|@xsm-screen|@sm-screen|@lg-screen|@xlg-screen|@xxlg-screen'.split('|').sort().forEach(o => {\n                const _item = new vscode.CompletionItem(o);\n                _item.commitCharacters = [\"\\t\"];\n                _item.documentation = new vscode.MarkdownString('define screen - type');\n                _item.insertText = o + \"{\\n}\";\n                _item.kind = vscode.CompletionItemKind.Module;\n                // _item.command = { command: 'editor.action.triggerSuggest', title: 'Re-trigger completions...' };\n                _provide_items.push(_item);\n            });\n            const properties = require('../src/lib/Css/CssProperties')\n            properties.sort().forEach(o => {\n                const _item = new vscode.CompletionItem(o);\n                _provide_items.push(_item);\n            });\n            const { GetProvideList } = completion.bcss;\n            const { colorList, rootList } = GetProvideList(document.getText());\n            const li = [colorList, rootList];\n            while (li.length > 0) {\n                const _m = li.shift()\n                // load color \n                for (let i in _m) {\n                    const _item = new vscode.CompletionItem(i);\n                    _item.insertText = 'var('+i+')';\n                    _item.kind = vscode.CompletionItemKind.Property;\n                    _provide_items.push(_item);\n                }\n            }\n\n            return _provide_items;\n        }\n\n    }, '.'));\n}\n/**\n * \n */\nfunction deactivate() {\n    // console.log(\"deactivated\");\n}\n\n// export extension method\nmodule.exports = {\n    activate,\n    deactivate\n}","\"use strict\";\nconst { Formatters, Utils, Patterns } = require(\"./lib/Formatters\");\nObject.defineProperty(exports, '__esModule', {value:true});\n\nexports.Formatters = Formatters; \nexports.Patterns = Patterns; \nexports.CaptureInfo = Utils.Classes.CaptureInfo; \nexports.Utils = Utils; \nexports.Version = process.env.VERSION || '1.0.0'; \nexports.Web = (()=>{\n    const Utils = require (\"./web/Utils\")\n    return {\n        Utils\n    };\n})();","var map = {\n\t\"./bcss-inline.markdown.btm-syntax.json\": 1044,\n\t\"./bcss-provide-colors.btm-syntax.json\": 1006,\n\t\"./bcss.btm-syntax.json\": 4191,\n\t\"./bcss.inline.btm-syntax.json\": 5202,\n\t\"./bhtml.btm-syntax.json\": 655,\n\t\"./bview.btm-syntax.json\": 103,\n\t\"./csharp.btm-syntax.json\": 9429,\n\t\"./css-transform.btm-syntax.json\": 8252,\n\t\"./demodata.btm-syntax.json\": 769,\n\t\"./fbcolor.btm-syntax.json\": 4143,\n\t\"./features.btm-syntax.json\": 8469,\n\t\"./format-only.btm-syntax.json\": 5866,\n\t\"./js.btm-syntax.json\": 4249,\n\t\"./markdown.btm-syntax.json\": 935,\n\t\"./pascal.btm-syntax.json\": 7224,\n\t\"./pcss.btm-syntax.json\": 493,\n\t\"./php.btm-syntax.json\": 5286,\n\t\"./python.btm-syntax.json\": 722,\n\t\"./vbmacros.btm-syntax.json\": 8779\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 3323;","\"use stricts;\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n\n/**\n * used to handle block definition\n */\nclass BlockInfo{\n    /**\n     * @var {?number | 'inline'}\n     */\n    mode;\n}\n\nexports.BlockInfo = BlockInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\nconst { Utils } = require(\"./Utils\");\nclass CaptureInfo{\n    /**\n     * string name of the capture info used in token\n     * @var {?string}\n     */\n    name;\n\n    /**\n     * id used to setup rendering definition\n     */\n    tokenID;\n    /**\n     * extra patterns definition \n     * @var {null|[{include:string}|{extends: string}|Pattern]}\n     */\n    patterns;\n\n    /**\n     * transformation to apply to this element before send it to patterns list in case this patterns is set\n     * @var {null|string|string[]|(v:string):string}\n     */\n    transform;\n    /**\n     * description of this \n     */\n    comment;\n    /**\n     * replace with \n     */\n    replaceWith;\n\n    /**\n     * transformat option \n     * @var {bool}\n     */\n    nextTrimWhiteSpace;\n\n    /**\n     * list of capture info \n     */\n    captures;\n\n    /**\n     * format object \n     * @var {*} \n     */\n    format;\n\n    /**\n     * throw error on capture detection\n     * @var {string|{message: string, match:regularExpression|string}}\n     */\n    throwError;\n\n    constructor(parent){ \n\n        Object.defineProperty(this, 'parent', {get(){return parent;}})\n    }\n\n    json_parse(parser, fieldname, data, refKey, refObj){\n        const q = this;\n        const { Patterns, RefPatterns } = Utils.Classes;\n        const patterns = Utils.ArrayPatternsFromParser(parser, Patterns, RefPatterns);\n        const transform = Utils.TransformPropertyCallback();\n        const _regex_parser = (s)=>{\n            return Utils.RegexParse(s, 'd'); \n        };\n        const captures = Utils.JSONInitCaptureField(q);\n        const parse = {\n            patterns(n,parser, refKey, refObj){\n                let d = patterns.apply(q, [n,parser, refKey, refObj]);\n                d.forEach((s)=>{\n                    // attach the pattern to the capture parent \n                    s.parent = q.parent;\n                });\n                return d;\n            }, // update with parent\n            begin: _regex_parser,\n            end: _regex_parser,\n            match: _regex_parser,\n            replaceWith: _regex_parser,\n            replaceWithCondition(n, parser){\n                let m = new ReplaceWithCondition; \n                JSonParser._LoadData(parser, m, n, refObj);  \n                return m;\n            },\n            transform,\n            captures,\n            matchTransform(){                \n                throw new Error('match transform not handled');\n            }\n        };\n        let fc = parse[fieldname];\n        if (fc){\n            return fc.apply(q, [data, parser, refKey, refObj]);\n        }\n        return data;\n    }\n}\n\nexports.CaptureInfo = CaptureInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { FormatterMatchTreatment } = require('./FormatterMatchTreatment');\nconst { FormatterOptions } = require('./FormatterOptions');\nconst { FormatterSyntaxException } = require('./FormatterSyntaxException');\nconst { Utils } = require('./Utils');\nclass CaptureRenderer{\n    matches;\n    roots;\n    subcaptures;\n    token;\n    /**\n     * null or capture renderer\n     * @param {*} matches \n     * @param {string} token base token name\n     * @returns {null|CaptureRenderer}\n     */\n    static CreateFromGroup(matches, token='constant'){\n        function get_matche_token_info(matches, token='constant'){\n            if (!matches){\n                throw new Error('matches missing')\n            } \n            let _t = matches[0]; \n            if (matches.length<1){\n                return {value:_t, token: token};\n            }\n            const {indices} = matches;\n            if (typeof(indices) == 'undefined'){\n                console.log(\"missing [d] flag\");\n                return null;\n            }\n            let _startIndex = indices[0][0];\n            let rootgroup = {};\n            let subcaptures = {};\n            let _troot = null;\n            let _offset = 0;\n            let _info = null;\n            let chain_root = function(_troot, i){\n                subcaptures[i] = _troot;\n                rootgroup[i] = _troot;\n            }\n            let begin_root = function(idx, v, range, i){\n                _offset = idx+v.length;\n                _troot = def_info(range, v, null, i); \n                chain_root(_troot, i);\n                _info = null;\n            }\n            let info_contains = function (s, d){\n                return ((s.start<=d.start)&&(s.end>=d.end));\n            }\n            let def_info = function(range, v, parent, id){\n                return {...range, value:v,id, get index(){ return this.start + matches.index; }, parent: parent, childs:[]};\n            }\n            let lp;\n            let range;\n         \n            for(let i = 1; i < matches.length; i++){\n                lp = indices[i];\n                if (typeof(lp)=='undefined'){\n                    subcaptures[i] = {value: undefined};\n                    continue;\n                }\n                let v = matches[i];\n                range = {start:lp[0] - _startIndex,end:lp[1] - _startIndex}; // range to litteral captured string\n                let idx = _t.indexOf(v, _offset); \n                if (_troot==null){ \n                    // first root \n                    begin_root(idx,v, range, i);\n            \n                }else{\n                    // check for group\n                    if((_troot.start == range.start) && (_troot.end==range.end))\n                    {\n                        // skip the same root capture property \n                        subcaptures[i] = _troot;\n                    } else {\n                        if ((_troot.start<= range.start) && (_troot.end>=range.end)){\n                            if (_info && info_contains(_info, range)){\n                                // create and info with\n                                let _minfo = def_info(range, v, _info, i);\n                                _info = _minfo;\n                            }else{\n                                _info = def_info(range, v, _troot, i); // {...range, value:v, get index(){ return this.start - matches.index; }, parent: _troot};\n                                _troot.childs.push(_info);\n                            }\n        \n                            subcaptures[i] = _info;\n                        }else{\n                            // begin a new root\n                            begin_root(idx,v, range, i);\n                        }\n                    }\n                }\n            }\n            // register to group top group\n            if (_t.length>0){\n                lp = indices[0];\n                range = {start:lp[0] - _startIndex,end:lp[1] - _startIndex};\n                chain_root (def_info(range, matches[0], null, 0), 0); \n            }\n            return {matches, roots: rootgroup, subcaptures: subcaptures};\n        }\n        const _info = get_matche_token_info(matches, token);\n        if(!_info){\n            return null;\n        }\n        const { roots , subcaptures } = _info;\n        let _o = new CaptureRenderer;\n        _o.roots = roots;\n        _o.matches = _info.matches;\n        _o.subcaptures = subcaptures;\n        _o.token = token;\n        return _o;\n    }\n    /**\n     * \n     * @param {*} listener \n     * @param {*} captures \n     * @param {false|(rf, cap, id, listener):string} end \n     * @param {*} tokens \n     * @param {*|{debug:bool}} option \n     * @param {*|{treat:bool}} params \n     * @returns \n     */\n    render(listener, captures, end, tokens, option, outdefine, treat=true){ \n        if (!captures){\n            throw new Error('missing captures info');\n        }\n        if (!outdefine){\n            throw new Error('missing outdefine info');\n        }\n        const self = this;\n        const { matches, roots } = self;\n        const { debug, engine} = option;\n        let _input = matches[0];// .input.substring(matches.index);\n        let _begin = 0;\n        let _output = ''; \n        let _formatter = option.formatter;\n        let treat_root = function (_input, root, listener, captures, tokens, refData){\n            // treat rf value\n            let rf = root.value;\n            let rd = rf;\n            let subchilds = [{root, output:[], treat:false, sub:false}];\n            let _end = false;\n            while(subchilds.length>0){\n                let q = subchilds.shift();\n                let {id}= q.root;\n                if (q.treat){\n                    continue;\n                }\n                _end = false;\n                if (!q.sub && q.root.childs.length>0){  \n                    const childrens = q.root.childs.slice(0);\n                    q.sub = true;\n                    subchilds.unshift(q);\n                    while(childrens.length>0){\n                        let croot = childrens.pop();\n                        subchilds.unshift({parent: q, treat:false, root: croot, sub:false});\n                    }\n                }else{\n                    rf = q.sub ? q.output : q.root.value;\n                    tokens = tokens ? tokens.slice(0) : [];// default constant \n                    let tokenID = null;\n                    let cap = null;\n                   \n                    if (Array.isArray(rf)){\n                        // + | transform reference to rf \n                        const nv = q.root.value;\n                        let offset = 0;\n                        let _out = '';\n                        let c = '';\n                        // + | glue value to for rendering\n                        rf.forEach(s=>{\n                            // c = treat_constant(nv.substring(offset, s.range[0]), listener);\n                            c = nv.substring(offset, s.range[0]);//, listener);\n                            let dt = c+s.rf;\n                            offset = s.range[0]+s.range[1];\n                            _out +=dt;\n                        });\n                        // _out+= treat_constant(nv.substring(offset), listener);\n                        _out+= nv.substring(offset);//, listener);\n                        rf = _out;\n                    }\n                    let _treat_pattern = false;\n                    const _op = FormatterMatchTreatment.Init(rf);\n                    if (id in captures){\n                        cap = captures[id];\n                        if (cap.throwError){\n                            //+ | use match to handle throw error\n                            let e_obj = CaptureRenderer.CheckError(cap.throwError, rf, option); \n                            if (e_obj){\n                                throw e_obj;\n                            }\n                        } \n                        if (cap.name){\n                            Utils.StoreTokens(cap.name, tokens);\n                        }\n                        if (cap.tokenID){\n                            tokenID = cap.tokenID;\n                        }\n                        // treat pattern or other stuff \n                        if (end){\n                            // special treatment for end captures\n                            rd = rf;\n                            rf = end(rf, cap, id, listener, {tokens, engine, debug, tokenID});\n                            _end = true; \n                        } else {\n                            // treat value. cap\n                            if(_formatter){\n                                rf = _formatter.treatMarkerValue(cap, rf, _op, option, self.matches);\n\n                            }else{\n                                if (cap.transform){\n                                    rf = Utils.StringValueTransform(rf, cap.transform); \n                                }  \n                            }  \n                            if (cap.patterns?.length>0){\n                                const _bckTokens = option.tokenList.slice(0);\n                                option.tokenList = tokens.slice(0, tokens.length-1);\n                                rf = Utils.TreatPatternValue(rf, cap.patterns, \n                                    self.matches, option);\n                                _treat_pattern = true;\n\n                                option.tokenList = _bckTokens;\n                            }\n                        }\n                    } \n                    if (listener && !_treat_pattern && listener.renderToken){\n                        \n                        rd = rf;\n                        rf = _end || !rf ? rf : rf.length>0? listener.renderToken(rf, tokens, tokenID, engine, debug, cap, option) : ''; \n                    }\n                    if (q.parent){\n                        // update parent value.\n                        let s =  q.root.start - q.parent.root.start;\n                        let e =  q.root.end - q.root.start;\n                        // + | transform to range - at [start_index, length] of nv to replace\n                        if (rf.length>0){\n                            q.parent.output.push({range:[s,e], rf, rd}); \n                        }\n                    }\n                    q.treat = true;\n                }\n            }\n            refData.data = rd;\n            return rf;\n        };\n        let treat_constant = function(c, listener){\n            if (treat && (c.length>0)){\n                if (listener){\n                    c = listener.renderToken(c, ['constant.definition'], 'constant', engine, debug, null, option);\n                }\n            }\n            return c;\n        }\n        let c = '';\n        let d = '';\n        let _keys = Object.keys(roots);\n        let _Capkeys = Object.keys(captures);\n        let _root_only = ( 0 in captures) && (_Capkeys.length==1);\n        let _ref_data = {data:null, input:_input, bufferSegment:[],dataSegment:[]};\n        for(let j in roots){ \n            if ( !_root_only && ((j==0)&&(_keys.length>1))){\n                continue;\n            }\n            let rt = roots[j];\n\n            c = _input.substring(_begin, rt.start);\n            if (c.length>0){\n                d += c; \n                _ref_data.dataSegment.push(c);\n                c = treat_constant(c, listener); \n                _output += c;   \n                _ref_data.bufferSegment.push(c);\n            }         \n            c = treat_root(_input, rt,listener,captures,tokens,_ref_data);\n            _output += c;\n            _begin = rt.end;\n            d+=_ref_data.data;\n            _ref_data.dataSegment.push(_ref_data.data);\n            _ref_data.bufferSegment.push(c);\n            if (_root_only)\n                break;\n        }\n        if (_begin < _input.length){\n            let l = _input.substring(_begin);\n            d+= l;\n            _ref_data.dataSegment.push(l);\n            c = treat_constant(l, listener); \n            _output += c;\n            _ref_data.bufferSegment.push(c);\n        } \n        if (outdefine){ \n            outdefine.bufferSegment = _ref_data.bufferSegment;\n            outdefine.dataSegment = _ref_data.dataSegment;\n        }\n        return _output;\n    }\n    /**\n     * \n     * @param {*} error \n     * @param {string} rf \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static CheckError(error, rf, option){\n        let e_obj = null;\n        let message = null , match = null;\n        let _error = true;\n        if (typeof(error) == 'object'){\n            ({message, match} = error);\n        } else{\n            message = error;\n        }\n        if (match){\n            const regex = typeof(match)=='string'? new RegExp(match) : match;\n            _error = regex.test(rf);\n        }  \n        if (_error){ \n            e_obj= new FormatterSyntaxException(message, option);\n        }\n        return e_obj;\n    }\n}\nexports.CaptureRenderer = CaptureRenderer;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/** \n */\nclass CssAtLayerDefinition {\n  list;\n  styles;  \n  constructor() {\n    this.list = [];\n    this.styles = {}; \n  }\n  toJSON() {\n    let l = {};\n    if (this.list.length > 0) {\n      l['list'] = this.list;\n    }\n    if (Object.keys(this.styles).length > 0) {\n      l['styles'] = this.styles;\n    }\n    \n    return l;\n  }\n}\nexports.CssAtLayerDefinition = CssAtLayerDefinition;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/** \n */\nclass CssAtRuleProperty {\n  syntax;\n  inherits;\n  get initialValue(){\n    return this['initial-value'];\n  }\n  set initialValue(v){\n    this['initial-value'] = v;\n  }\n  toJSON(){\n    let l = {...this};\n    l.inherits= typeof(l.inherits)=='boolean' ? l.inherits : l.inherits=='true';\n    return l;\n  }\n}\nexports.CssAtRuleProperty = CssAtRuleProperty;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass CssCounterStyle{\n    system;\n    symbols;\n    negative;\n    prefix;\n    suffix;\n    range;\n    pad;\n    fallback;\n    get speakAs(){\n        return this['speak-as'];\n    }\n    set speakAs(v){\n        this['speak-as'] = v;\n    }\n    get additiveSymbols(){\n        return this['additive-symbols'];\n    }\n    set additiveSymbols(v){\n        this['additive-symbols'] = v;\n    }\n}\n\nexports.CssCounterStyle = CssCounterStyle;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass CssFontFaceStyle {\n    get ascentOverride() { return this['ascent-override']; }\n    set ascentOverride(v) { this['ascent-override'] = v; }\n    get descentOverride() { return this['descent-override']; }\n    set descentOverride(v) { this['descent-override'] = v; }\n    get fontDisplay() { return this['font-display']; }\n    set fontDisplay(v) { this['font-display'] = v; }\n    get fontFamily() { return this['font-family']; }\n    set fontFamily(v) { this['font-family'] = v; }\n    get fontStretch() { return this['font-stretch']; }\n    set fontStretch(v) { this['font-stretch'] = v; }\n    get fontStyle() { return this['font-style']; }\n    set fontStyle(v) { this['font-style'] = v; }\n    get fontWeight() { return this['font-weight']; }\n    set fontWeight(v) { this['font-weight'] = v; }\n    get fontFeatureSettings() { return this['font-feature-settings']; }\n    set fontFeatureSettings(v) { this['font-feature-settings'] = v; }\n    get fontVariationSettings() { return this['font-variation-settings']; }\n    set fontVariationSettings(v) { this['font-variation-settings'] = v; }\n    get lineGapOverride() { return this['line-gap-override']; }\n    set lineGapOverride(v) { this['line-gap-override'] = v; }\n    get sizeAdjust() { return this['size-adjust']; }\n    set sizeAdjust(v) { this['size-adjust'] = v; }\n    src;\n    get unicodeRange() { return this['unicode-range']; }\n    set unicodeRange(v) { this['unicode-range'] = v; }\n}\n\nexports.CssFontFaceStyle = CssFontFaceStyle;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass CssImports{\n    constructor(){\n        this._list = [];\n    }\n    contains(url){\n        return false;\n    }\n    toJSON(){\n        return this._list;\n    }\n    toRender(){\n        return this._list;\n    }\n    /**\n     * \n     * @param {*} param0 \n     */\n    store({url, layer, supports, queries}){\n        this._list.push({url, layer, supports, queries});\n    }\n}\n\nexports.CssImports = CssImports;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\nconst { CssStyle } = require(\"./CssStyle\")\n/** \n */\nclass CssLayerStyle extends CssStyle{\n    get childs(){\n        const _key = '@childs'; \n        if (!(_key in this)){\n            this[_key] = {};\n        }\n        return this[_key];\n    }\n}\nexports.CssLayerStyle = CssLayerStyle;","const properties = \"zoom|z-index|y|x|writing-mode|word-wrap|word-spacing|word-break|will-change|width|widows|white-space-collapse|white-space|webkit-writing-mode|webkit-user-select|webkit-user-modify|webkit-user-drag|webkit-transition-timing-function|webkit-transition-property|webkit-transition-duration|webkit-transition-delay|webkit-transition|webkit-transform-style|webkit-transform-origin-z|webkit-transform-origin-y|webkit-transform-origin-x|webkit-transform-origin|webkit-transform|webkit-text-zoom|webkit-text-underline-position|webkit-text-stroke-width|webkit-text-stroke-color|webkit-text-stroke|webkit-text-size-adjust|webkit-text-security|webkit-text-orientation|webkit-text-fill-color|webkit-text-emphasis-style|webkit-text-emphasis-position|webkit-text-emphasis-color|webkit-text-emphasis|webkit-text-decorations-in-effect|webkit-text-decoration-style|webkit-text-decoration-skip|webkit-text-decoration-line|webkit-text-decoration-color|webkit-text-decoration|webkit-text-combine|webkit-tap-highlight-color|webkit-shape-outside|webkit-shape-margin|webkit-shape-image-threshold|webkit-ruby-position|webkit-rtl-ordering|webkit-print-color-adjust|webkit-perspective-origin-y|webkit-perspective-origin-x|webkit-perspective-origin|webkit-perspective|webkit-padding-start|webkit-padding-end|webkit-padding-before|webkit-padding-after|webkit-order|webkit-opacity|webkit-nbsp-mode|webkit-min-logical-width|webkit-min-logical-height|webkit-max-logical-width|webkit-max-logical-height|webkit-mask-source-type|webkit-mask-size|webkit-mask-repeat-y|webkit-mask-repeat-x|webkit-mask-repeat|webkit-mask-position-y|webkit-mask-position-x|webkit-mask-position|webkit-mask-origin|webkit-mask-image|webkit-mask-composite|webkit-mask-clip|webkit-mask-box-image-width|webkit-mask-box-image-source|webkit-mask-box-image-slice|webkit-mask-box-image-repeat|webkit-mask-box-image-outset|webkit-mask-box-image|webkit-mask|webkit-margin-start|webkit-margin-end|webkit-margin-before|webkit-margin-after|webkit-logical-width|webkit-logical-height|webkit-locale|webkit-line-snap|webkit-line-grid|webkit-line-clamp|webkit-line-break|webkit-line-box-contain|webkit-line-align|webkit-justify-items|webkit-justify-content|webkit-initial-letter|webkit-hyphens|webkit-hyphenate-limit-lines|webkit-hyphenate-limit-before|webkit-hyphenate-limit-after|webkit-hyphenate-character|webkit-font-smoothing|webkit-font-kerning|webkit-font-feature-settings|webkit-flex-wrap|webkit-flex-shrink|webkit-flex-grow|webkit-flex-flow|webkit-flex-direction|webkit-flex-basis|webkit-flex|webkit-filter|webkit-cursor-visibility|webkit-columns|webkit-column-width|webkit-column-span|webkit-column-rule-width|webkit-column-rule-style|webkit-column-rule-color|webkit-column-rule|webkit-column-progression|webkit-column-gap|webkit-column-fill|webkit-column-count|webkit-column-break-inside|webkit-column-break-before|webkit-column-break-after|webkit-column-axis|webkit-clip-path|webkit-box-sizing|webkit-box-shadow|webkit-box-reflect|webkit-box-pack|webkit-box-orient|webkit-box-ordinal-group|webkit-box-lines|webkit-box-flex-group|webkit-box-flex|webkit-box-direction|webkit-box-decoration-break|webkit-box-align|webkit-border-vertical-spacing|webkit-border-top-right-radius|webkit-border-top-left-radius|webkit-border-start-width|webkit-border-start-style|webkit-border-start-color|webkit-border-start|webkit-border-radius|webkit-border-image|webkit-border-horizontal-spacing|webkit-border-end-width|webkit-border-end-style|webkit-border-end-color|webkit-border-end|webkit-border-bottom-right-radius|webkit-border-bottom-left-radius|webkit-border-before-width|webkit-border-before-style|webkit-border-before-color|webkit-border-before|webkit-border-after-width|webkit-border-after-style|webkit-border-after-color|webkit-border-after|webkit-background-size|webkit-background-origin|webkit-background-clip|webkit-backface-visibility|webkit-backdrop-filter|webkit-appearance|webkit-app-region|webkit-animation-timing-function|webkit-animation-play-state|webkit-animation-name|webkit-animation-iteration-count|webkit-animation-fill-mode|webkit-animation-duration|webkit-animation-direction|webkit-animation-delay|webkit-animation|webkit-alt|webkit-align-self|webkit-align-items|webkit-align-content|visibility|view-transition-name|view-timeline-name|view-timeline-inset|view-timeline-axis|view-timeline|vertical-align|vector-effect|user-select|unicode-range|unicode-bidi|translate|transition-timing-function|transition-property|transition-duration|transition-delay|transition-behavior|transition|transform-style|transform-origin-z|transform-origin-y|transform-origin-x|transform-origin|transform-box|transform|touch-action|top|timeline-scope|text-wrap-style|text-wrap-mode|text-wrap|text-underline-position|text-underline-offset|text-transform|text-spacing-trim|text-size-adjust|text-shadow|text-rendering|text-overflow|text-orientation|text-justify|text-indent|text-emphasis-style|text-emphasis-position|text-emphasis-color|text-emphasis|text-decoration-thickness|text-decoration-style|text-decoration-skip-ink|text-decoration-skip|text-decoration-line|text-decoration-color|text-decoration|text-combine-upright|text-anchor|text-align-last|text-align|table-layout|tab-size|system|syntax|symbols|supported-color-schemes|suffix|stroke-width|stroke-opacity|stroke-miterlimit|stroke-linejoin|stroke-linecap|stroke-dashoffset|stroke-dasharray|stroke-color|stroke|stop-opacity|stop-color|src|speak-as|speak|size-adjust|size|shape-rendering|shape-outside|shape-margin|shape-image-threshold|scrollbar-width|scrollbar-gutter|scrollbar-color|scroll-timeline-name|scroll-timeline-axis|scroll-timeline|scroll-snap-type|scroll-snap-stop|scroll-snap-margin-top|scroll-snap-margin-right|scroll-snap-margin-left|scroll-snap-margin-bottom|scroll-snap-margin|scroll-snap-align|scroll-padding-top|scroll-padding-right|scroll-padding-left|scroll-padding-inline-start|scroll-padding-inline-end|scroll-padding-inline|scroll-padding-bottom|scroll-padding-block-start|scroll-padding-block-end|scroll-padding-block|scroll-padding|scroll-margin-top|scroll-margin-right|scroll-margin-left|scroll-margin-inline-start|scroll-margin-inline-end|scroll-margin-inline|scroll-margin-bottom|scroll-margin-block-start|scroll-margin-block-end|scroll-margin-block|scroll-margin|scroll-behavior|scale|ry|rx|ruby-position|ruby-align|row-gap|rotate|right|resize|range|r|quotes|print-color-adjust|prefix|position|pointer-events|place-self|place-items|place-content|perspective-origin-y|perspective-origin-x|perspective-origin|perspective|paint-order|page-orientation|page-break-inside|page-break-before|page-break-after|page|padding-top|padding-right|padding-left|padding-inline-start|padding-inline-end|padding-inline|padding-bottom|padding-block-start|padding-block-end|padding-block|padding|pad|overscroll-behavior-y|overscroll-behavior-x|overscroll-behavior-inline|overscroll-behavior-block|overscroll-behavior|override-colors|overlay|overflow-y|overflow-x|overflow-wrap|overflow-inline|overflow-clip-margin|overflow-block|overflow-anchor|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|order|opacity|offset-rotate|offset-position|offset-path|offset-distance|offset-anchor|offset|object-view-box|object-position|object-fit|negative|moz-window-dragging|moz-user-select|moz-user-modify|moz-user-input|moz-transition-timing-function|moz-transition-property|moz-transition-duration|moz-transition-delay|moz-transition|moz-transform-style|moz-transform-origin|moz-transform|moz-text-size-adjust|moz-tab-size|moz-perspective-origin|moz-perspective|moz-padding-start|moz-padding-end|moz-osx-font-smoothing|moz-orient|moz-margin-start|moz-margin-end|moz-hyphens|moz-force-broken-image-icon|moz-font-language-override|moz-font-feature-settings|moz-float-edge|moz-box-sizing|moz-box-pack|moz-box-orient|moz-box-ordinal-group|moz-box-flex|moz-box-direction|moz-box-align|moz-border-start-width|moz-border-start-style|moz-border-start-color|moz-border-start|moz-border-image|moz-border-end-width|moz-border-end-style|moz-border-end-color|moz-border-end|moz-backface-visibility|moz-appearance|moz-animation-timing-function|moz-animation-play-state|moz-animation-name|moz-animation-iteration-count|moz-animation-fill-mode|moz-animation-duration|moz-animation-direction|moz-animation-delay|moz-animation|mix-blend-mode|min-width|min-inline-size|min-height|min-block-size|max-width|max-inline-size|max-height|max-block-size|math-style|math-shift|math-depth|mask-type|mask-size|mask-repeat|mask-position-y|mask-position-x|mask-position|mask-origin|mask-mode|mask-image|mask-composite|mask-clip|mask-border-width|mask-border-source|mask-border-slice|mask-border-repeat|mask-border-outset|mask-border|mask|marker-start|marker-mid|marker-end|marker|margin-trim|margin-top|margin-right|margin-left|margin-inline-start|margin-inline-end|margin-inline|margin-bottom|margin-block-start|margin-block-end|margin-block|margin|list-style-type|list-style-position|list-style-image|list-style|line-height|line-gap-override|line-break|lighting-color|letter-spacing|left|kerning|justify-self|justify-items|justify-content|isolation|inset-inline-start|inset-inline-end|inset-inline|inset-block-start|inset-block-end|inset-block|inset|inline-size|initial-value|initial-letter|inherits|ime-mode|image-rendering|image-orientation|hyphens|hyphenate-limit-chars|hyphenate-character|height|hanging-punctuation|grid-template-rows|grid-template-columns|grid-template-areas|grid-template|grid-row-start|grid-row-gap|grid-row-end|grid-row|grid-gap|grid-column-start|grid-column-gap|grid-column-end|grid-column|grid-auto-rows|grid-auto-flow|grid-auto-columns|grid-area|grid|glyph-orientation-vertical|glyph-orientation-horizontal|gap|forced-color-adjust|font-weight|font-variation-settings|font-variant-position|font-variant-numeric|font-variant-ligatures|font-variant-east-asian|font-variant-caps|font-variant-alternates|font-variant|font-synthesis-weight|font-synthesis-style|font-synthesis-small-caps|font-synthesis-position|font-synthesis|font-style|font-stretch|font-size-adjust|font-size|font-palette|font-optical-sizing|font-language-override|font-kerning|font-feature-settings|font-family|font-display|font|flood-opacity|flood-color|float|flex-wrap|flex-shrink|flex-grow|flex-flow|flex-direction|flex-basis|flex|filter|fill-rule|fill-opacity|fill|field-sizing|fallback|epub-writing-mode|epub-word-break|epub-text-transform|epub-text-orientation|epub-text-emphasis-style|epub-text-emphasis-color|epub-text-emphasis|epub-text-combine|epub-hyphens|epub-caption-side|empty-cells|dominant-baseline|display|direction|descent-override|d|cy|cx|cursor|css-rules|css-float|counter-set|counter-reset|counter-increment|content-visibility|content|container-type|container-name|container|contain-intrinsic-width|contain-intrinsic-size|contain-intrinsic-inline-size|contain-intrinsic-height|contain-intrinsic-block-size|contain|columns|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|color-scheme|color-rendering|color-interpolation-filters|color-interpolation|color-adjust|color|clip-rule|clip-path|clip|clear|caret-color|caption-side|buffered-rendering|break-inside|break-before|break-after|box-sizing|box-shadow|box-decoration-break|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-start-start-radius|border-start-end-radius|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-left-width|border-left-style|border-left-color|border-left|border-inline-width|border-inline-style|border-inline-start-width|border-inline-start-style|border-inline-start-color|border-inline-start|border-inline-end-width|border-inline-end-style|border-inline-end-color|border-inline-end|border-inline-color|border-inline|border-image-width|border-image-source|border-image-slice|border-image-repeat|border-image-outset|border-image|border-end-start-radius|border-end-end-radius|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border-block-width|border-block-style|border-block-start-width|border-block-start-style|border-block-start-color|border-block-start|border-block-end-width|border-block-end-style|border-block-end-color|border-block-end|border-block-color|border-block|border|block-size|baseline-source|baseline-shift|base-palette|background-size|background-repeat-y|background-repeat-x|background-repeat|background-position-y|background-position-x|background-position|background-origin|background-image|background-color|background-clip|background-blend-mode|background-attachment|background|backface-visibility|backdrop-filter|aspect-ratio|ascent-override|apple-pay-button-type|apple-pay-button-style|appearance|app-region|animation-timing-function|animation-timeline|animation-range-start|animation-range-end|animation-range|animation-play-state|animation-name|animation-iteration-count|animation-fill-mode|animation-duration|animation-direction|animation-delay|animation-composition|animation|alt|all|alignment-baseline|align-self|align-items|align-content|additive-symbols|accent-colorzoom|z-index|y|x|writing-mode|word-wrap|word-spacing|word-break|will-change|width|widows|white-space-collapse|white-space|webkit-writing-mode|webkit-user-select|webkit-user-modify|webkit-user-drag|webkit-transition-timing-function|webkit-transition-property|webkit-transition-duration|webkit-transition-delay|webkit-transition|webkit-transform-style|webkit-transform-origin-z|webkit-transform-origin-y|webkit-transform-origin-x|webkit-transform-origin|webkit-transform|webkit-text-zoom|webkit-text-underline-position|webkit-text-stroke-width|webkit-text-stroke-color|webkit-text-stroke|webkit-text-size-adjust|webkit-text-security|webkit-text-orientation|webkit-text-fill-color|webkit-text-emphasis-style|webkit-text-emphasis-position|webkit-text-emphasis-color|webkit-text-emphasis|webkit-text-decorations-in-effect|webkit-text-decoration-style|webkit-text-decoration-skip|webkit-text-decoration-line|webkit-text-decoration-color|webkit-text-decoration|webkit-text-combine|webkit-tap-highlight-color|webkit-shape-outside|webkit-shape-margin|webkit-shape-image-threshold|webkit-ruby-position|webkit-rtl-ordering|webkit-print-color-adjust|webkit-perspective-origin-y|webkit-perspective-origin-x|webkit-perspective-origin|webkit-perspective|webkit-padding-start|webkit-padding-end|webkit-padding-before|webkit-padding-after|webkit-order|webkit-opacity|webkit-nbsp-mode|webkit-min-logical-width|webkit-min-logical-height|webkit-max-logical-width|webkit-max-logical-height|webkit-mask-source-type|webkit-mask-size|webkit-mask-repeat-y|webkit-mask-repeat-x|webkit-mask-repeat|webkit-mask-position-y|webkit-mask-position-x|webkit-mask-position|webkit-mask-origin|webkit-mask-image|webkit-mask-composite|webkit-mask-clip|webkit-mask-box-image-width|webkit-mask-box-image-source|webkit-mask-box-image-slice|webkit-mask-box-image-repeat|webkit-mask-box-image-outset|webkit-mask-box-image|webkit-mask|webkit-margin-start|webkit-margin-end|webkit-margin-before|webkit-margin-after|webkit-logical-width|webkit-logical-height|webkit-locale|webkit-line-snap|webkit-line-grid|webkit-line-clamp|webkit-line-break|webkit-line-box-contain|webkit-line-align|webkit-justify-items|webkit-justify-content|webkit-initial-letter|webkit-hyphens|webkit-hyphenate-limit-lines|webkit-hyphenate-limit-before|webkit-hyphenate-limit-after|webkit-hyphenate-character|webkit-font-smoothing|webkit-font-kerning|webkit-font-feature-settings|webkit-flex-wrap|webkit-flex-shrink|webkit-flex-grow|webkit-flex-flow|webkit-flex-direction|webkit-flex-basis|webkit-flex|webkit-filter|webkit-cursor-visibility|webkit-columns|webkit-column-width|webkit-column-span|webkit-column-rule-width|webkit-column-rule-style|webkit-column-rule-color|webkit-column-rule|webkit-column-progression|webkit-column-gap|webkit-column-fill|webkit-column-count|webkit-column-break-inside|webkit-column-break-before|webkit-column-break-after|webkit-column-axis|webkit-clip-path|webkit-box-sizing|webkit-box-shadow|webkit-box-reflect|webkit-box-pack|webkit-box-orient|webkit-box-ordinal-group|webkit-box-lines|webkit-box-flex-group|webkit-box-flex|webkit-box-direction|webkit-box-decoration-break|webkit-box-align|webkit-border-vertical-spacing|webkit-border-top-right-radius|webkit-border-top-left-radius|webkit-border-start-width|webkit-border-start-style|webkit-border-start-color|webkit-border-start|webkit-border-radius|webkit-border-image|webkit-border-horizontal-spacing|webkit-border-end-width|webkit-border-end-style|webkit-border-end-color|webkit-border-end|webkit-border-bottom-right-radius|webkit-border-bottom-left-radius|webkit-border-before-width|webkit-border-before-style|webkit-border-before-color|webkit-border-before|webkit-border-after-width|webkit-border-after-style|webkit-border-after-color|webkit-border-after|webkit-background-size|webkit-background-origin|webkit-background-clip|webkit-backface-visibility|webkit-backdrop-filter|webkit-appearance|webkit-app-region|webkit-animation-timing-function|webkit-animation-play-state|webkit-animation-name|webkit-animation-iteration-count|webkit-animation-fill-mode|webkit-animation-duration|webkit-animation-direction|webkit-animation-delay|webkit-animation|webkit-alt|webkit-align-self|webkit-align-items|webkit-align-content|visibility|view-transition-name|view-timeline-name|view-timeline-inset|view-timeline-axis|view-timeline|vertical-align|vector-effect|user-select|unicode-range|unicode-bidi|translate|transition-timing-function|transition-property|transition-duration|transition-delay|transition-behavior|transition|transform-style|transform-origin-z|transform-origin-y|transform-origin-x|transform-origin|transform-box|transform|touch-action|top|timeline-scope|text-wrap-style|text-wrap-mode|text-wrap|text-underline-position|text-underline-offset|text-transform|text-spacing-trim|text-size-adjust|text-shadow|text-rendering|text-overflow|text-orientation|text-justify|text-indent|text-emphasis-style|text-emphasis-position|text-emphasis-color|text-emphasis|text-decoration-thickness|text-decoration-style|text-decoration-skip-ink|text-decoration-skip|text-decoration-line|text-decoration-color|text-decoration|text-combine-upright|text-anchor|text-align-last|text-align|table-layout|tab-size|system|syntax|symbols|supported-color-schemes|suffix|stroke-width|stroke-opacity|stroke-miterlimit|stroke-linejoin|stroke-linecap|stroke-dashoffset|stroke-dasharray|stroke-color|stroke|stop-opacity|stop-color|src|speak-as|speak|size-adjust|size|shape-rendering|shape-outside|shape-margin|shape-image-threshold|scrollbar-width|scrollbar-gutter|scrollbar-color|scroll-timeline-name|scroll-timeline-axis|scroll-timeline|scroll-snap-type|scroll-snap-stop|scroll-snap-margin-top|scroll-snap-margin-right|scroll-snap-margin-left|scroll-snap-margin-bottom|scroll-snap-margin|scroll-snap-align|scroll-padding-top|scroll-padding-right|scroll-padding-left|scroll-padding-inline-start|scroll-padding-inline-end|scroll-padding-inline|scroll-padding-bottom|scroll-padding-block-start|scroll-padding-block-end|scroll-padding-block|scroll-padding|scroll-margin-top|scroll-margin-right|scroll-margin-left|scroll-margin-inline-start|scroll-margin-inline-end|scroll-margin-inline|scroll-margin-bottom|scroll-margin-block-start|scroll-margin-block-end|scroll-margin-block|scroll-margin|scroll-behavior|scale|ry|rx|ruby-position|ruby-align|row-gap|rotate|right|resize|range|r|quotes|print-color-adjust|prefix|position|pointer-events|place-self|place-items|place-content|perspective-origin-y|perspective-origin-x|perspective-origin|perspective|paint-order|page-orientation|page-break-inside|page-break-before|page-break-after|page|padding-top|padding-right|padding-left|padding-inline-start|padding-inline-end|padding-inline|padding-bottom|padding-block-start|padding-block-end|padding-block|padding|pad|overscroll-behavior-y|overscroll-behavior-x|overscroll-behavior-inline|overscroll-behavior-block|overscroll-behavior|override-colors|overlay|overflow-y|overflow-x|overflow-wrap|overflow-inline|overflow-clip-margin|overflow-block|overflow-anchor|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|order|opacity|offset-rotate|offset-position|offset-path|offset-distance|offset-anchor|offset|object-view-box|object-position|object-fit|negative|moz-window-dragging|moz-user-select|moz-user-modify|moz-user-input|moz-transition-timing-function|moz-transition-property|moz-transition-duration|moz-transition-delay|moz-transition|moz-transform-style|moz-transform-origin|moz-transform|moz-text-size-adjust|moz-tab-size|moz-perspective-origin|moz-perspective|moz-padding-start|moz-padding-end|moz-osx-font-smoothing|moz-orient|moz-margin-start|moz-margin-end|moz-hyphens|moz-force-broken-image-icon|moz-font-language-override|moz-font-feature-settings|moz-float-edge|moz-box-sizing|moz-box-pack|moz-box-orient|moz-box-ordinal-group|moz-box-flex|moz-box-direction|moz-box-align|moz-border-start-width|moz-border-start-style|moz-border-start-color|moz-border-start|moz-border-image|moz-border-end-width|moz-border-end-style|moz-border-end-color|moz-border-end|moz-backface-visibility|moz-appearance|moz-animation-timing-function|moz-animation-play-state|moz-animation-name|moz-animation-iteration-count|moz-animation-fill-mode|moz-animation-duration|moz-animation-direction|moz-animation-delay|moz-animation|mix-blend-mode|min-width|min-inline-size|min-height|min-block-size|max-width|max-inline-size|max-height|max-block-size|math-style|math-shift|math-depth|mask-type|mask-size|mask-repeat|mask-position-y|mask-position-x|mask-position|mask-origin|mask-mode|mask-image|mask-composite|mask-clip|mask-border-width|mask-border-source|mask-border-slice|mask-border-repeat|mask-border-outset|mask-border|mask|marker-start|marker-mid|marker-end|marker|margin-trim|margin-top|margin-right|margin-left|margin-inline-start|margin-inline-end|margin-inline|margin-bottom|margin-block-start|margin-block-end|margin-block|margin|list-style-type|list-style-position|list-style-image|list-style|line-height|line-gap-override|line-break|lighting-color|letter-spacing|left|kerning|justify-self|justify-items|justify-content|isolation|inset-inline-start|inset-inline-end|inset-inline|inset-block-start|inset-block-end|inset-block|inset|inline-size|initial-value|initial-letter|inherits|ime-mode|image-rendering|image-orientation|hyphens|hyphenate-limit-chars|hyphenate-character|height|hanging-punctuation|grid-template-rows|grid-template-columns|grid-template-areas|grid-template|grid-row-start|grid-row-gap|grid-row-end|grid-row|grid-gap|grid-column-start|grid-column-gap|grid-column-end|grid-column|grid-auto-rows|grid-auto-flow|grid-auto-columns|grid-area|grid|glyph-orientation-vertical|glyph-orientation-horizontal|gap|forced-color-adjust|font-weight|font-variation-settings|font-variant-position|font-variant-numeric|font-variant-ligatures|font-variant-east-asian|font-variant-caps|font-variant-alternates|font-variant|font-synthesis-weight|font-synthesis-style|font-synthesis-small-caps|font-synthesis-position|font-synthesis|font-style|font-stretch|font-size-adjust|font-size|font-palette|font-optical-sizing|font-language-override|font-kerning|font-feature-settings|font-family|font-display|font|flood-opacity|flood-color|float|flex-wrap|flex-shrink|flex-grow|flex-flow|flex-direction|flex-basis|flex|filter|fill-rule|fill-opacity|fill|field-sizing|fallback|epub-writing-mode|epub-word-break|epub-text-transform|epub-text-orientation|epub-text-emphasis-style|epub-text-emphasis-color|epub-text-emphasis|epub-text-combine|epub-hyphens|epub-caption-side|empty-cells|dominant-baseline|display|direction|descent-override|d|cy|cx|cursor|css-rules|css-float|counter-set|counter-reset|counter-increment|content-visibility|content|container-type|container-name|container|contain-intrinsic-width|contain-intrinsic-size|contain-intrinsic-inline-size|contain-intrinsic-height|contain-intrinsic-block-size|contain|columns|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|color-scheme|color-rendering|color-interpolation-filters|color-interpolation|color-adjust|color|clip-rule|clip-path|clip|clear|caret-color|caption-side|buffered-rendering|break-inside|break-before|break-after|box-sizing|box-shadow|box-decoration-break|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-start-start-radius|border-start-end-radius|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-left-width|border-left-style|border-left-color|border-left|border-inline-width|border-inline-style|border-inline-start-width|border-inline-start-style|border-inline-start-color|border-inline-start|border-inline-end-width|border-inline-end-style|border-inline-end-color|border-inline-end|border-inline-color|border-inline|border-image-width|border-image-source|border-image-slice|border-image-repeat|border-image-outset|border-image|border-end-start-radius|border-end-end-radius|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border-block-width|border-block-style|border-block-start-width|border-block-start-style|border-block-start-color|border-block-start|border-block-end-width|border-block-end-style|border-block-end-color|border-block-end|border-block-color|border-block|border|block-size|baseline-source|baseline-shift|base-palette|background-size|background-repeat-y|background-repeat-x|background-repeat|background-position-y|background-position-x|background-position|background-origin|background-image|background-color|background-clip|background-blend-mode|background-attachment|background|backface-visibility|backdrop-filter|aspect-ratio|ascent-override|apple-pay-button-type|apple-pay-button-style|appearance|app-region|animation-timing-function|animation-timeline|animation-range-start|animation-range-end|animation-range|animation-play-state|animation-name|animation-iteration-count|animation-fill-mode|animation-duration|animation-direction|animation-delay|animation-composition|animation|alt|all|alignment-baseline|align-self|align-items|align-content|additive-symbols|accent-color\".split('|').filter((v, i, arr)=>{\n    return arr.indexOf(v) == i;\n});\nmodule.exports = properties;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/** \n */\nclass CssStyle {\n   /**\n    * append style definition\n    * @param {*} css \n    * @param {*} def \n    */\n   static AppendDef(css, def){\n    for(let i in def){\n        css[i] = def[i];\n    }\n   }\n}\nexports.CssStyle = CssStyle;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { CssStyleRenderer } = require('./CssStyleRenderer');\n\n/**\n * class Used to store style definition\n */\nclass CssStyleDefinitions{\n    /**\n     * store charset\n     */\n    charset;\n    /**\n     * store frames list\n     */\n    frames;\n    /**\n     * store global style definition\n     */\n    styles;\n\n    /**\n     * retrieve color profiles\n     * @var {*}\n     */\n    colorProfile;\n    // medias;\n    imports;\n\n    /**\n     * retrieve container\n     * @var {*}\n     */\n    container;\n\n    /**\n     * get or set counter style\n     */\n    counterStyle;\n\n    /**\n     * get or set font faces\n     */\n    fontFace;\n\n    /**\n     * get or set font feature values\n     */\n    fontFeatureValues;\n    /**\n     * get or set font palette values\n     */\n    fontPaletteValues;\n    /**\n     * get or set layer definition\n     */\n    layer;\n    /**\n     * get or set namespace\n     */\n    namespace;\n    /**\n     * get or set page\n     */\n    page;\n    /**\n     * get or set property\n     */\n    property;\n    /**\n     * get or set scope\n     */\n    scope;\n    /**\n     * get or set startingStyle\n     */\n    startingStyle;\n    /**\n     * get or set supports\n     */\n    supports;\n\n\n\n\n\n\n    constructor(){\n        this.styles = {}; \n        var m_media = null;\n        Object.defineProperty(this, 'medias',{\n            get(){\n                if (!m_media){\n                    m_media = {};\n                }\n                return m_media;\n            }\n        })\n    }\n    /**\n     * export to json definition\n     * @returns \n     */\n    toJSON(){\n        let ref = {};\n        let { medias, styles } = this;\n        \n        for(let i in this){\n            if (/\\b(medias|styles)\\b/.test(i)) continue;\n            const lt = this[i];\n            if (lt){\n                ref[i] = lt;\n            }\n        }\n        if(styles && (Object.keys(styles).length>0)){\n            ref.styles = styles;\n        } \n        if(medias && (Object.keys(medias).length>0)){\n            // get only non null medias\n\n            ref.medias = medias;\n        }\n        return ref;\n    }\n    /**\n     * build css litteral\n     * @returns \n     */\n    css(){\n        function _glueStyle(m){\n            let p = [];\n            let sep = '';\n            for(let i in m){\n                let j = m[i];\n                if (j !== null){\n                    if (typeof(j)=='object'){\n                        j = \"'\"+j+\"'\";\n                    }\n                    p.push(i+\":\"+sep+j);\n                }\n            }\n            return p.join(\";\");\n        }\n        const sep = '';\n        const res = [];\n        if (this.charset){\n            res.push('@charset '+this.charset);\n        } \n        \n        const render = new CssStyleRenderer;   \n        let s = render.render(this);\n        if (s && s.length>0){\n            res.push(s);\n        } \n        if (this.frames){\n            for(let i in this.frames){\n                let s = \"@keyframes \"+i;\n                let def = this.frames[i];\n\n                s+=\"{\";\n                for(let j in def){\n                    s+=j+'{';\n                    s+= _glueStyle(def[j]);\n                    s+='}';\n                }\n                s+=\"}\";\n                res.push(s);\n            }\n        }\n\n        if (this.styles){\n            for (let i in this.styles){\n                let m = this.styles[i];\n                let l = _glueStyle(m);\n                if (l && (l.length>0))\n                res.push(i+\"{\"+ l +\"}\");\n            }\n        }\n        if (this.medias){\n            let s = render.renderMedias(this.medias);\n            if (s){\n            res.push(s);\n            }\n        } \n        return res.join(sep);\n    }\n    initMedia(){\n        this.medias = {};\n    }\n}\n\n\nexports.CssStyleDefinitions = CssStyleDefinitions;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst profileNames = {\n    \"colorProfile\": \"color-profile\",\n    \"counterStyles\": \"counter-styles\",\n    \"fontFace\": \"font-face\",\n    \"fontFeatureValues\": \"font-feature-values\",\n    \"startingStyle\": \"starting-style\",\n    \"fontPaletteValues\": \"font-palette-values\"\n}\nconst _multi_def = ['scope', 'layer', 'counter-styles', 'font-face', 'font-feature-values', 'font-palette-values', 'imports', 'namespace', 'pages','starting-style', 'supports','view-transition'];\n\nconst _get_directive = (n) => {\n    return profileNames[n] || n.replace(/[A-Z]/g, (o) => '-' + o.toLowerCase()).toLowerCase();\n};\n/**\n * \n * @param {*} m list\n * @param {*} filter use to filter property \n * @param {*} filter_sub use to filter object \n * @returns \n */\nconst _glueStyles = (m, filter, filter_sub) => {\n    let p = [];\n    let sep = '';\n    function _set_join(p) {\n        const m = p.join(';');\n        p.length = 0;\n        p.push(m);\n        return p;\n    }\n    for (let i in m) {\n        let f = m[i];\n        if (filter && filter(i)) {\n            continue;\n        }\n        if (typeof (f) == 'object') {\n            if (filter_sub) {\n                if (filter_sub(p, i, f)) {\n                    _set_join(p);\n                    continue;\n                }\n            }\n        }\n        p.push(i + \":\" + sep + m[i]);\n    }\n    _set_join(p);\n    return p[0];//.join(\";\");\n}\nclass CssStyleRenderer {\n    pretty = false;\n    minify = true;\n    renderMedias(medias) {\n        let s = [];\n        let _keys = Object.keys(medias);\n        if (_keys.length > 0)\n            _keys.forEach(s => {\n                let l = medias[s];\n                s.push('@media ' + s);\n                s.push('{');\n                s.push(_glueStyles(l));\n                s.push('}');\n\n            })\n\n        return s.join('');\n\n    }\n    /**\n     * object to render \n     * @param {*} obj \n     */\n    render(obj) {\n        const objKeys = Object.keys(obj);\n        let s = '';\n        objKeys.forEach(o => {\n            if (/\\b(charset|frames|medias|styles)\\b/.test(o)) {\n                return;\n            }\n            let _f = obj[o];\n            if (_f) {\n                let _k = _get_directive(o);\n\n                let _fc = this['_render_' + o.toLowerCase().replace('-', '_')];\n                if (typeof (_fc) == 'function') {\n                    if (_multi_def.indexOf(_k) == -1)\n                        s += '@' + _k + ' ';\n                    s += _fc.apply(this, [_f]);\n                } else {\n                    s += '/* missing rendering for [' + o + \"] */\";\n                }\n            }\n\n        });\n        return s;\n    }\n    /**\n     * render global rules\n     * @param {*} d \n     * @param {{pretty:boolean}} option \n     * @param {(s:string[], i:string, l:object, refObj:undefined|{space:boolean})=>boolean} filter filter callback \n     * @returns \n     */\n    static RenderRule(d, { pretty }, filter) {\n        const s = [];\n        let _n = false;\n        let _refObj = { space: _n };\n        let _filter_sub = filter ? (s, i, l) => {\n            return filter(s, i, l, _refObj);\n        } : null;\n        Object.keys(d).sort().forEach(i => {\n\n            let l = d[i];\n            _n = _refObj.space;\n            if (pretty && _n) {\n                s.push(' ');\n            }\n            s.push(i);\n            s.push('{');\n            s.push(_glueStyles(l, null, _filter_sub));\n            s.push('}');\n            _n = true;\n        });\n\n        return s.join('');\n    }\n    _render_colorprofile(d) {\n        const s = [];\n        for (let i in d) {\n            let l = d[i];\n            s.push(i);\n            s.push('{');\n            s.push(_glueStyles(l));\n            s.push('}');\n        }\n        return s.join('');\n    }\n    _render_container(d) {\n        const s = [];\n\n        for (let i in d) {\n            let l = d[i];\n            s.push(i);\n            s.push('{');\n            let j = l['$container'];\n            if (j) {\n                s.push(('@container ' + this._render_container(j)).replace(/^@container\\s+\\(/, '@container('));\n            }\n            s.push(_glueStyles(l, (o) => /\\$\\bcontainer\\b/.test(o)));\n            s.push('}');\n        }\n        return s.join('')\n    }\n    _render_property(d) {\n        return CssStyleRenderer.RenderRule(d, this);\n    }\n    _render_scope(d) {\n        let s = [];\n        for (let i in d) {\n            let l = d[i];\n            s.push('@scope ' + i);\n            s.push('{');\n            s.push(CssStyleRenderer.RenderRule(l, this));\n            s.push('}');\n        }\n        return s.join('');\n    }\n    _render_layer(d) {\n        const q = this;\n        const s = [];\n        if (d.list.length > 0) {\n            s.push('@layer ' + d.list.join(',') + ';');\n        }\n        function _render_layer(s, i, _f) {\n            let _n = i != '@global' ? ' ' + i : '';\n            s.push('@layer' + _n);\n            s.push('{');\n            s.push(_f);\n            s.push('}');\n        }\n        function _render_layer_child(s, i, l) {\n            let _op = { ...l };\n            let _f = _get_inner_layer(_op);\n            if (_f && (_f.length > 0)) {\n                _render_layer(s, i, _f);\n            }\n        }\n        function _get_inner_layer(_copy) {\n            const _childs = _copy['@childs'];\n            const s = [];\n            const _filter = (s, i, l, refObj) => {\n                if (i == '@childs') {\n                    const _s = [];\n                    for (let k in l) {\n                        _render_layer_child(_s, k, l[k]);\n                    }\n                    s.push(_s.join(''));\n                    refObj.space = true;\n                    return true;\n                }\n                return false;\n            };\n            if (_childs) {\n                for (let i in _childs) {\n                    let _op = { ..._childs[i] };\n                    let _f = _get_inner_layer(_op);\n                    if (_f && (_f.length > 0)) {\n                        _render_layer(s, i, _f);\n                    }\n                }\n            }\n\n            delete (_copy['@childs']);\n            s.push(CssStyleRenderer.RenderRule(_copy, q, _filter));\n            return s.join('');\n        }\n\n        for (let i in d.styles) {\n            let l = d.styles[i];\n            let _copy = { ...l };\n            let _f = _get_inner_layer(_copy, this);\n            if (_f && (_f.length > 0)) {\n                _render_layer(s, i, _f);\n            }\n        }\n\n        return s.join('');\n\n    }\n\n    _render_counterstyles(d) {\n        const s = [];\n        const sep = '';\n        for (let i in d) {\n            let l = d[i];\n            let m = { ...l };\n\n            s.push(\"@counter-styles \" + i);\n            s.push('{');\n            let cp = [];\n            for (let k in m) {\n                let _v = m[k];\n                if (_v) {\n                    _v = /^\\s+$/.test(_v) ? \"'\" + _v + \"'\" : _v;\n                    cp.push(k + \":\" + sep + _v)\n                }\n            }\n            s.push(cp.join(';'));\n            s.push('}');\n        }\n        return s.join('');\n    }\n    _render_fontface(d) {\n        const s = [];\n        d.forEach(i => {\n            let l = i;\n            s.push('@font-face{');\n            _render_in_def(s, l);\n            s.push('}');\n        });\n        return s.join('');\n    }\n    _render_fontfeaturevalues(d) {\n        const s = _render_def(\"@font-feature-values \", d, this);\n        return s;\n    }\n    _render_fontpalettevalues(d) {\n        const s = _render_def(\"@font-palette-values \", d, this);\n        return s;\n    }\n    _render_imports(d) {\n        const s = [];\n        d._list.forEach((a) => {\n            let cd = [];\n\n            if (a.url) {\n                cd.push(a.url);\n                ['layer', 'supports','queries'].forEach((i)=>{\n                    if (a[i])\n                    cd.push(a[i])\n                });\n            }\n            if (cd.length > 0) {\n                cd = cd.join(' ')+\";\";\n                s.push('@import ' + cd);\n            }\n        });\n\n        return s.length > 0 ? s.join('') : null;\n    }\n    _render_namespace(d){\n        const s =  [];\n        d.forEach((a)=>{\n            const d = [];\n            ['prefix','url'].forEach(i=>{\n                if (a[i]){\n                    d.push(a[i]);\n                }\n            });\n            if (d.length>0){\n                s.push('@namespace '+d.join(' ')+';');\n            }\n        });\n        return s.join('');\n    }\n    _render_pages(d){\n        const s = [];\n        let i = null;\n        for (i in d){\n            let m = '';\n            let l = d[i];\n            if (i !='$global'){\n                m += i;\n            }\n            let r = _glueStyles(d[i]);\n            if (r){\n                m += '{'+r+'}';\n            } \n            if (m){\n                s.push(\"@page \");\n                s.push(m);\n            } \n        }\n        return s.join('');\n    }\n    _render_startingstyle(d){\n        const s = [];\n        s.push(_render_def(\"@starting-style\", d, this));\n        return s.join('');\n    }\n    _render_supports(d){\n        const s = [];\n        // condition => setting\n        for(let i in d){\n            let m = [];\n            let l = d[i];\n            m.push('@supports');\n            if (i!='$global'){\n                let sep = /^[^a-z@]/.test(i) ? '': ' ';\n                m.push(sep+i);\n            }\n            m.push('{');\n            m.push(_render_def('', l, this).trim());\n            m.push('}');\n\n            s.push(m.join(''));\n        }\n\n        return s.join('');\n    }\n    _render_viewtransition(d){\n        const s = []; \n        const m = [];\n        m.push('{');\n        m.push(_glueStyles(d));\n        m.push('}');\n        s.push('@view-transition'+m.join('')); \n        return s.join('');\n    }\n}\n/**\n * render in def \n * @param {*} s \n * @param {*} m \n */\nfunction _render_in_def(s, m) {\n    let cp = [];\n    const sep = '';\n\n    for (let k in m) {\n        let _v = m[k];\n        if (_v) {\n            _v = /^\\s+$/.test(_v) || (typeof (_v) == 'object') ? \"'\" + _v + \"'\" : _v;\n            cp.push(k + \":\" + sep + _v)\n        }\n    }\n    s.push(cp.join(';'));\n}\n/**\n * render definition \n * @param {*} key \n * @param {*} d \n * @param {*} renderer \n * @returns \n */\nfunction _render_def(key, d, renderer) {\n    const s = [];\n    const sep = '';\n    for (let i in d) {\n        let l = d[i];\n        let m = { ...l };\n        s.push(key + ' ' + i);\n        s.push('{');\n        let cp = [];\n        for (let k in m) {\n            let _v = m[k];\n            if (_v) {\n                if (typeof (_v) == 'object') {\n                    let g = _glueStyles(_v);\n                    if (g && (g.length > 0))\n                        cp.push(k + \":\" + sep + g);\n                } else {\n                    _v = /^\\s+$/.test(_v) ? \"'\" + _v + \"'\" : _v;\n                    cp.push(k + \":\" + sep + _v);\n                }\n            }\n        }\n        s.push(cp.join(';'));\n        s.push('}');\n    }\n    return s.join('');\n}\n\nexports.CssStyleRenderer = CssStyleRenderer;\nexports.Utils = {\n    glueStyles: _glueStyles\n};","'use strict';\nObject.defineProperty(exports, '__ESModule', { value: true });\n\nconst { FormatterListener } = require('../FormatterListener');\nconst { Formatters } = require('../Formatters');\nconst { CssStyleDefinitions } = require('./CssStyleDefinitions');\nconst { CssStyle } = require('./CssStyle');\nconst { CssAtRuleProperty } = require('./CssAtRuleProperty');\nconst json_data = require(\"../../formatters/css-transform.btm-syntax.json\");\nconst { CssAtLayerDefinition } = require('./CssAtLayerDefinition');\nconst { CssLayerStyle } = require('./CssLayerStyle');\nconst { CssCounterStyle } = require('./CssCounterStyle');\nconst { CssFontFaceStyle } = require('./CssFontFaceStyle');\nconst { CssImports } = require('./CssImports');\n\nconst _formatter = Formatters.CreateFrom(json_data);\nconst _baseFormatterListener = new FormatterListener;\n\n/**\n * retrieve method suffix name\n * @param {string} n \n * @returns \n */\nfunction methodSuffixName(n) {\n    n = n.replace(/(-|_)[a-z]/g, (o) => o[1].toUpperCase()).replace(/(^-)|_/g, '');\n    n = n[0].toUpperCase() + n.substring(1);\n    return n;\n}\n\nfunction get_container_id(inf) {\n    const tab = [];\n    if (inf.name) {\n        tab.push(inf.name);\n    }\n    if (inf.condition) {\n        tab.push(inf.condition);\n    }\n    return tab.length > 0 ? tab.join(' ') : '$global';\n}\n\n/**\n * store style definition property\n */\nclass CssStyles {\n\n}\n\n/**\n * selector definition\n */\nclass SelectorDefinition {\n    value;\n    property;\n    key;\n    definitions;\n    mergeDefinitions;\n    /**\n     * storage of global propertiy to by pass listener \n     */\n    styleStore;\n    /**\n     * build style listener\n     * @param {*} listener \n     */\n    constructor(listener) {\n        if (!listener) {\n            throw new Error('invalid parameters');\n        }\n        this.value = this.property = this.key = '';\n        Object.defineProperty(this, \"listener\", { get() { return listener } });\n    }\n    /**\n     * init definition\n     * @param {*} def \n     */\n    initDefinition(def) {\n        const _init_style = () => new CssStyles();\n        if (def) {\n            const { key } = this;\n            this.definitions = ((key in def) ? def[key] : null) || _init_style();\n        } else {\n            this.definitions = this.getStylesDefinition(this.key) || _init_style();\n        }\n        this.store(def);\n    }\n    start() {\n        this.property = '';\n        this.key = '';\n        this.value = '';\n        this.definitions = null;\n    }\n    /**\n     * update property value\n     */\n    update() {\n        const { property, value, definitions } = this;\n        let c = '';\n        function litteralString(n) {\n            this.toJSON = () => {\n                return n;\n            }\n            this.toString = () => {\n                return n;\n            }\n        }\n        if (property && definitions) {\n            const _regex = /^('|\")(.*)\\1$/g;\n            const _is_litteral = _regex.test(value?.trim());\n\n            if (_is_litteral) {\n                c = new litteralString(value?.trim().replace(_regex, '$2'));\n\n            }\n            else {\n                c = (value.trim().length == 0) && (value.length > 0) ? value : value?.trim().replace(_regex, '$2');\n            }\n            definitions[property] = c;\n            this.value = '';\n        }\n    }\n    /**\n     * store key definition. div property \n     * @param {*} def \n     */\n    store(def) {\n        /** */\n        this.update();\n        const { listener, key, definitions, styleStore } = this;\n        if (key) {\n            if (def) {\n                def[key] = definitions;\n                this._loadSeparator(def, key, definitions);\n            } else {\n                const _def= styleStore || listener.styles;\n                _def[key] = definitions;\n                this._loadSeparator(listener.styles, key, definitions);\n            }\n        }\n    }\n    _loadSeparator(def, key, definitions) {\n        const _tab = key.split(',');\n        if (_tab.length > 1) {\n            this._mergeFromDefinition(def);\n            if (!(key in this.mergeDefinitions.keys) || (this.mergeDefinitions.keys[key].indexOf(def) == -1)) {\n                if (!(key in this.mergeDefinitions.keys)) {\n                    this.mergeDefinitions.keys[key] = [];\n                }\n                this.mergeDefinitions.keys[key].push(def);\n            }\n        }\n    }\n    _mergeDefinition(style, definitions) {\n        for (let key in definitions) {\n            style[key] = definitions[key];\n        }\n    }\n    _mergeDefinitionComplete() {\n        const { mergeDefinitions } = this;\n        if (!mergeDefinitions) return;\n        const list = Object.keys(mergeDefinitions.keys);\n        while (list.length > 0) {\n            let q = list.shift();\n            const _tab = q.split(/\\s*,\\s*/);\n            const _tdef = this.mergeDefinitions.keys[q];\n            while (_tdef.length > 0) {\n                const definitions = _tdef.shift()[q];\n\n\n                _tab.forEach(o => {\n                    o = o.trim();\n                    if (o in def) {\n                        this._mergeDefinition(def[o], definitions);\n                    } else {\n                        if (o in pdef) {\n                        }\n\n                    }\n                    //     pdef[o] = ;\n                    // }\n                });\n            }\n        }\n    }\n    complete() {\n        this._mergeDefinitionComplete();\n    }\n    _mergeFromDefinition(def) {\n        if (!this.mergeDefinitions) {\n            this.mergeDefinitions = [];\n            this.mergeDefinitions.styles = {};\n            this.mergeDefinitions.keys = {};\n\n        }\n        const { mergeDefinitions } = this;\n        let _index = this.mergeDefinitions.indexOf(def);\n        if (_index == -1) {\n            this.mergeDefinitions.push(def);\n            _index = this.mergeDefinitions.length - 1;\n            this.mergeDefinitions.styles[_index] = new CssStyles;\n        }\n        const pdef = this.mergeDefinitions.styles[_index];\n        return pdef;\n    }\n    getStylesDefinition(key) {\n        const { listener } = this;\n        return this._get_definition(key, listener.styles);\n    }\n    getMediasDefinition(rule) {\n        const { listener } = this;\n        return this._get_definition(rule, listener.medias);\n\n    }\n    _get_definition(key, tab) {\n        return (key in tab) ? tab[key] : null;\n    }\n}\nclass CssSelectorStyles {\n\n}\n\nfunction _initListener(_formatter, _selectorDefinition, callBacks) {\n    const { _updateMediaDefinition, _updatePropertyDefinition, _css_definition } = callBacks;\n\n    // + | retrieve key frames\n    const _get_frames = function () {\n        if (!_css_definition.frames) {\n            _css_definition.frames = {};\n        }\n        const _frame = _css_definition.frames;\n        return { frame: _frame };\n    };\n    // + | retrieve color profilie\n    const _get_color_profile = function () {\n        if (!_css_definition.colorProfile) {\n            _css_definition.colorProfile = {};\n        }\n        return _css_definition;\n    }\n    function _initDef(obj, key, data) {\n        if (!(key in obj)) {\n            obj[key] = data != undefined ? data : {};\n        }\n    }\n    const _listener = {\n        mode: null,\n        medias_definition: null,\n        media_states: null,\n        ref_mode: [],\n        _auto: false,\n        _frame_info: null,\n        renderToken(value, tokenList, tokenID, engine, option) {\n            return value;\n        },\n        onStartHandler(marker, option) {\n            // check on start - \n            const { tokenID } = marker;\n            console.log(\"************* start **************\", tokenID);\n            let _auto = false; // state auto mode\n            switch (tokenID) {\n                case \"css-media\":\n                    _updatePropertyDefinition();\n                    _updateMediaDefinition();\n                    this.mode = 'media';\n                    _selectorDefinition.start();\n                    _selectorDefinition.store();\n                    break;\n                case \"css-value\":\n                case \"css-selector\":\n                case \"css-property\":\n                    break;\n                default:\n                    if (tokenID && /^invalid./.test(tokenID)) {\n                        throw new Error(`invalid syntax.${tokenID}`);\n                    }\n                    if (tokenID && /^css-/.test(tokenID)) {\n                        const _mode = tokenID.toLowerCase().replace(/-/g, '_').substring(4);\n                        // save old mode\n                        if (this.mode)\n                            this.ref_mode.push([this.mode, this._auto]);\n                        this.mode = _mode;\n                        _auto = true;\n\n                        const _mfc = this['_onStart' + methodSuffixName(_mode)];\n                        if (_mfc) {\n                            _mfc.apply(this);\n                        }\n                    }\n                    this._auto = _auto;\n                    break;\n            }\n        },\n        _handleColorprofile(data, marker, tokenID, tokenList, _handle) {\n            _handle.handle = true;\n            const { colorProfile } = _get_color_profile();\n            switch (tokenID) {\n                case 'css-profile-name':\n                    const _n = data.source;\n                    //_initDef(colorProfile, _n); \n                    this._initSelectorDefinition(_n, colorProfile);\n                    break;\n                case 'css-colorProfile':\n                    // on end clear keys\n                    //const def = _selectorDefinition.definitions;\n                    this._resetSelectorDefinition();\n                    break;\n                default:\n                    _handle.handle = false;\n                    break;\n            }\n        },\n        _handleKeyframes(data, marker, tokenID, tokenList, _handle) {\n            // console.log(\"==================> handle key frames: \"+tokenID);\n            const { frame } = _get_frames();\n            _handle.handle = true;\n            switch (tokenID) {\n                case 'css-keyname':\n                    const _n = data.source;\n                    const ref = _n in frame ? frame[_n] : {};\n                    frame[_n] = ref;\n                    this._frame_info = { key: _n, object: ref };\n                    break;\n                case 'css-keyentry':\n                    this._handleKeyentry(data);\n                    break;\n                default:\n                    _handle.handle = false;\n                    break;\n            }\n        },\n        _handleKeyentry(data) {\n            const { frame } = _get_frames();\n            const _name = this._frame_info.key;\n            const key = data.source;\n            const def = frame[_name];\n            this._initSelectorDefinition(key, def);\n        },\n        _handleMedia(data, marker, tokenID, tokenList, _handle) {\n\n            // console.log(\"on media ::::: \", tokenID);\n            let _condition = null;\n\n            switch (tokenID) {\n                case 'css-media-condition':\n\n                    // retrieve media definitions to merge keys\n                    _condition = data.value;\n                    if (!this.media_states) {\n                        this.media_states = { condition: _condition }\n                    } else {\n                        this.media_states.condition += _condition;\n                    }\n\n\n                    _handle.handle = true;\n                    break;\n                case 'css-media':\n                    // close media definition \n                    _updateMediaDefinition();\n                    this.medias_definition = null;\n                    this.mode = null;\n                    _handle.handle = true;\n\n                    break;\n                case 'css-selector':\n                    _handle.handle = true;\n                    _updatePropertyDefinition();\n                    _condition = this.media_states.condition?.trim();\n                    const _src = _css_definition.medias[_condition];\n                    this.medias_definition = {\n                        'condition': _condition,\n                        'styles': _src || new CssSelectorStyles()\n                    };\n                    this.media_states = null;\n                    _selectorDefinition.key = data.value?.trim();\n                    _selectorDefinition.property = '';\n                    _selectorDefinition.value = '';\n                    _selectorDefinition.initDefinition(this.medias_definition.styles);\n\n                    break;\n            }\n        },\n        _resetSelectorDefinition() {\n            _selectorDefinition.key = null;\n            _selectorDefinition.property = '';\n            _selectorDefinition.value = '';\n            _selectorDefinition.definitions = null;\n        },\n        /**\n         * initialize selector definition\n         * @param {*} key \n         * @param {*} def \n         */\n        _initSelectorDefinition(key, def) {\n            this._resetSelectorDefinition();\n            _selectorDefinition.key = key;\n            _selectorDefinition.initDefinition(def);\n        },\n        _handleCharset_value(data, marker, tokenID, tokenList, _handle) {\n            // console.log('charset value', data)\n            _css_definition.charset = data.value.slice(1, -1);\n        },\n        _onStartContainer() {\n            const { objDef } = this;\n            if (objDef) {\n                // check is nested container - if $global not a named container\n                if (objDef.type != 'container') {\n                    throw new Error('container not allowed in ' + objDef.type);\n                }\n            }\n            const inf = (() => {\n                let _ref = { type: 'container', name: '', list: null, condition: null, parent: null, childs: [], def: null };\n                this._resetSelectorDefinition();\n                _selectorDefinition.initDefinition(null);\n                _ref.def = _selectorDefinition.definitions;\n                return this.objDef = _ref;\n            })();\n            if (objDef) {\n                this.objDef.parent = objDef;\n            }\n            return { inf };\n        },\n        _onStartAtRuleProperty() {\n            this._resetSelectorDefinition();\n            _selectorDefinition.definitions = new CssAtRuleProperty;\n            this.objDef = { type: 'property', name: '', def: _selectorDefinition.definitions };\n            if (!_css_definition.property) {\n                _css_definition.property = {};\n            }\n        },\n        _handleAtRuleProperty(data, marker, tokenID, tokenList, _handle) {\n            _handle.handle = true;\n            switch (tokenID) {\n                case 'css-property-name':\n                    this.objDef.name = data.source;\n                    break;\n                case 'css-at-rule-property':\n                    _css_definition.property[this.objDef.name] = this.objDef.def;\n                    this.objDef = null;\n                    _selectorDefinition.definitions = null;\n                    break;\n                default:\n                    _handle.handle = false;\n                    break;\n            }\n        },\n        _onStartScope() {\n            this._resetSelectorDefinition();\n            this.objDef = { type: 'scope', condition: null, selector: null };\n            if (!_css_definition.scope) {\n                _css_definition.scope = {};\n            }\n            _selectorDefinition.definitions = null;\n\n        },\n        _closeAutoHandle() {\n            _selectorDefinition.definitions = null;\n            this.objDef = null;\n            this._auto = true;\n        },\n        _handleScope(data, marker, tokenID, tokenList, _handle) {\n            let _h = true;\n            let _obj = this.objDef;\n            let _value = data.value;\n            function get_scope_id(obj) {\n                let r = [];\n                if (obj.condition) {\n                    r.push(obj.condition);\n                }\n                return r.length > 0 ? r.join(' ') : '$global';\n            }\n            let _id = '';\n            switch (tokenID) {\n                case 'scope-condition':\n                    if (_obj.condition) {\n                        _obj.condition += _value;\n                    } else\n                        _obj.condition = _value;\n                    break;\n                case 'css-scope':\n                    // - close and auto\n                    this._closeAutoHandle();\n                    _h = false;\n                    break;\n                case 'css-selector':\n                    _id = get_scope_id(_obj);\n                    if (!_css_definition.scope[_id]) {\n                        _css_definition.scope[_id] = {};\n                    }\n                    let _def = _css_definition.scope[_id] ? _css_definition.scope[_id][_value] : null;\n                    if (!_def) {\n                        _def = new CssStyle;\n                        _css_definition.scope[_id][_value] = _def;\n                    }\n                    _selectorDefinition.definitions = _def;\n                    _obj.selector = _value;\n                    break;\n                default:\n                    _h = false;\n                    break;\n            }\n            _handle.handle = _h;\n        },\n        /**\n         * pop auto mode\n         * @param {*} tokenID \n         * @returns \n         */\n        _popMode(tokenID, force = false) {\n            if ((force || this._auto) && /^css-/.test(tokenID)) {\n                const g = this.ref_mode.pop();\n                if (g) {\n                    this.mode = g[0];\n                    this._auto = g[1];\n                } else {\n                    this.mode = undefined;\n                    this._auto = false;\n                }\n                return true;\n            }\n        },\n        _handleLayer(data, marker, tokenID, tokenList, _handle) {\n            let _h = true;\n            let _v = data.value;\n            const _obj = this.objDef;\n            function _store_style(_obj, def, key) {\n                if (_obj.store) {\n                    return;\n                }\n                const _key = key || _selectorDefinition.key;\n                const _id = _obj.names.join(', ') || '@global';\n\n                if (!(def instanceof CssLayerStyle) && _key && _obj.def) {\n                    _obj.def[_key] = def;\n                    def = _obj.def;\n                    _css_definition.layer.styles[_id] = def;\n                }\n                else {\n                    if (!_css_definition.layer.styles[_id]) {\n                        _css_definition.layer.styles[_id] = {};\n                    }\n                    if (_key !== null) {\n                        _css_definition.layer.styles[_id][_key] = def;\n                    } else {\n                        _css_definition.layer.styles[_id] = def;\n                    }\n                }\n                _obj.store = true;\n            }\n\n            switch (tokenID) {\n                case 'layer-name':\n                    _obj.names.push(_v);\n                    break;\n                case 'end.instruction':\n                    if (_css_definition.layer.list.length > 0) {\n                        throw new Error(\"already declared a list layer tree\");\n                    }\n                    if (_obj.parent) {\n                        throw new Error(\"layer declaration not allowed in parent layer\");\n                    }\n                    _css_definition.layer.list.push(..._obj.names);\n                    this._closeAutoHandle();\n                    this._popMode();\n                    _h = false;\n                    break;\n                case 'css-selector':\n                    _selectorDefinition.key = _v;\n                    _selectorDefinition.definitions = new CssStyle;\n                    break;\n                case 'css-layer':\n                    let _p = _obj?.parent;\n                    if (!_p) {\n\n                        // store childs\n                        _store_style(_obj, _selectorDefinition.definitions)\n                        this._closeAutoHandle();\n                        _h = false;\n                    }\n                    this.objDef = _p;\n                    _selectorDefinition.definitions = _p?.def;\n                    _selectorDefinition.key = null;\n                    break;\n                // case 'css-selector':\n                //     break;\n                case 'selector-block':\n                    let _id = null;\n                    let def = _selectorDefinition.definitions;\n                    let _key = _selectorDefinition.key;\n                    if (_obj.parent) {\n                        _id = _obj.names.join(', ');\n                        const _pdef = _obj.parent.def;\n                        if (!_pdef.childs[_id]) {\n                            _pdef.childs[_id] = {};\n                        }\n                        _pdef.childs[_id][_key] = def;\n                        def = _pdef;\n                    } else {\n                        _store_style(_obj, def);\n                        // _obj.def = def;\n                        def = _obj.def;\n                    }\n                    _selectorDefinition.definitions = def;\n                    _selectorDefinition.key = null;\n\n                    break;\n                default:\n                    _h = false;\n                    break;\n            }\n            _handle.handle = _h;\n        },\n        _onStartLayer() {\n            const _obj = this.objDef;\n            let _parent = null;\n\n            if (_obj) {\n                if (_obj.type != 'layer') {\n                    throw new Error('layer not allowed in ' + _obj.type);\n                }\n                _parent = _obj;\n                if (!_parent.def) {\n                    _parent.def = new CssLayerStyle;\n                }\n                //  _def = _selectorDefinition.definitions;\n            }\n\n            let _ndef = _parent?.def;//  || new CssLayerStyle;\n            this.objDef = { type: 'layer', names: [], parent: _parent, def: _ndef, store: false };\n            if (!_css_definition.layer) {\n                // + | create layer definitions\n                _css_definition.layer = new CssAtLayerDefinition;\n            }\n            _selectorDefinition.definitions = _ndef;\n        },\n        _handleContainer(data, marker, tokenID, tokenList, _handle) {\n            const inf = this.objDef; //._onStartContainer();\n            let _value = data.source;\n            // console.log(\"init container....:\" + tokenID);\n            _handle.handle = true;\n            switch (tokenID) {\n                case 'container-condition':\n                    let _op = /\\s*,\\s*/g.test(_value)\n                    _value = _op ? _value.replace(/\\s*,\\s*/g, ',') : _value;\n                    if (inf.condition) {\n                        inf.condition += (_op ? '' : ' ') + _value;\n                    } else {\n                        if (/^\\s*\\b(and|or)\\b/.test(_value)) {\n                            throw new Error('start with boolean operator not allowed');\n                        }\n                        inf.condition = _value;\n                    }\n                    break;\n                case 'container-name':\n                    inf.name = _value;\n                    inf.list = _value.replace(/\\s*,\\s*/, ',').split(',');\n                    break;\n                case 'css-container':\n                    // + | end css container \n                    const def = _selectorDefinition.definitions;\n                    if (def) {\n                        const _container_name = get_container_id(inf);\n                        if (!_css_definition.container) {\n                            _css_definition.container = {};\n                        }\n                        if (inf.parent) {\n                            inf.childs.push(def);\n                            if (!('$container' in inf.parent.def)) {\n                                inf.parent.def[\"$container\"] = {};\n                            }\n                            let _p = inf.parent.def[\"$container\"][_container_name];\n                            if (_p) {\n                                CssStyle.AppendDef(_p, def);\n                            } else\n                                inf.parent.def[\"$container\"][_container_name] = def;\n                        } else {\n                            let _p = _css_definition.container[_container_name];\n                            if (_p) {\n                                CssStyle.AppendDef(_p, def);\n                            } else {\n                                _css_definition.container[_container_name] = def;\n                            }\n                        }\n\n                    }\n                    this._resetSelectorDefinition();\n                    if (inf.parent) {\n                        this.objDef = inf.parent;\n                        _selectorDefinition.definitions = inf.parent.def;\n                    } else {\n                        // reset contener reference\n                        this.objDef = null;\n                    }\n                    break;\n                default:\n                    _handle.handle = false;\n                    break;\n            }\n        },\n        onEndHandler(marker, option, isSubFormatting = false) {\n            if (isSubFormatting) {\n                return;\n            }\n            let tokenList = option.tokenChains;\n            let tokenID = marker.tokenID;\n            // for matchType = 0\n            const _value = marker.value || (() => ({ value: option.buffer, source: option.data }))();\n            const { mode } = this;\n            const { debug } = option;\n\n            debug && console.log(\"************* end **************\", tokenID, _value.source);\n\n\n            if (mode) {\n                const _mfc = this['_handle' + methodSuffixName(mode)];\n                if (_mfc) {\n                    const _handle = { handle: false };\n                    _mfc.apply(this, [_value, marker, tokenID, tokenList, _handle]);\n                    if (_handle.handle) {\n                        return;\n                    }\n                }\n                // if auto register\n                if (this._popMode(tokenID)) {\n                    return;\n                }\n            }\n\n            switch (tokenID) {\n                case 'css-value':\n                    _selectorDefinition.value += _value.value;\n                    break;\n                case 'css-property':\n                    _updatePropertyDefinition();\n                    _selectorDefinition.property = _value.value?.trim();\n                    _selectorDefinition.value = '';\n                    break;\n                case 'css-selector':\n                    _updatePropertyDefinition();\n                    _selectorDefinition.key = _value.value?.trim();\n                    _selectorDefinition.property = '';\n                    _selectorDefinition.value = '';\n                    _selectorDefinition.initDefinition();\n                    break;\n                case 'value-definition':\n                    // end value definition \n                    _updatePropertyDefinition();\n                    _selectorDefinition.property = '';\n                    _selectorDefinition.value = '';\n                    break;\n                case 'selector-block':\n                    _updatePropertyDefinition();\n                    _selectorDefinition.key = '';\n                    _selectorDefinition.property = '';\n                    _selectorDefinition.value = '';\n                    break;\n            }\n            //console.log(\"|*********** end handling *************|\" + marker, marker.value, _value, { tokenList, tokenID })\n        },\n        store(){\n            _baseFormatterListener.store.apply(_baseFormatterListener, arguments);\n        },\n        // counter-style\n        _onStartCounterStyle() {\n            this._resetSelectorDefinition();\n        },\n        _handleCounterStyle(data, marker, tokenID, tokenList, _handle) {\n\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                switch (tokenID) {\n                    case 'counter-style-name':\n                        _selectorDefinition.key = _v;\n                        _selectorDefinition.definitions = new CssCounterStyle;\n                        break;\n                    case 'css-counter-style':\n                        const _key = _selectorDefinition.key;\n                        if (!_css_definition.counterStyles) {\n                            _css_definition.counterStyles = {};\n                        }\n                        _css_definition.counterStyles[_key] = _selectorDefinition.definitions;\n                        this._resetSelectorDefinition();\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n\n        // font-face\n        _onStartFontFace() {\n            this._resetSelectorDefinition();\n            _selectorDefinition.definitions = new CssFontFaceStyle;\n        },\n        _handleFontFace(data, marker, tokenID, tokenList, _handle) {\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                switch (tokenID) {\n                    case 'css-font-face':\n                        if (!_css_definition.fontFace) {\n                            _css_definition.fontFace = []\n                        }\n                        _css_definition.fontFace.push(_selectorDefinition.definitions);\n                        this._resetSelectorDefinition();\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n        // font-feature-values\n        _onStartFontFeatureValues() {\n            this._resetSelectorDefinition();\n            this.objDef = { type: 'font-feature-values', key: null, ident: null, names: [] }\n        },\n        _handleFontFeatureValues(data, marker, tokenID, tokenList, _handle) {\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                let _obj = this.objDef;\n                switch (tokenID) {\n                    case 'ftv-name':\n                        if (!_css_definition.fontFeatureValues) {\n                            _css_definition.fontFeatureValues = {};\n                        }\n                        _obj.names.push(_v);\n                        break;\n                    case 'ftv-type':\n                        this.objDef.key = _v;\n                        const _id = _obj.names.join(' ');\n                        const _ref = _css_definition.fontFeatureValues;\n                        this._resetSelectorDefinition();\n                        if (!_ref[_id]) {\n                            _ref[_id] = {};\n                        }\n                        _ndef = _ref[_id][_v] || (() => {\n                            const c = new CssStyle;\n                            _ref[_id][_v] = c;\n                            return c;\n                        });\n                        _selectorDefinition.definitions = _ndef;\n                        break;\n                    case 'ftv-ident':\n                        this.objDef.ident = _v;\n                        break;\n                    case 'css-font-feature-values':\n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n        // font-feature-values\n        _onStartFontPaletteValues() {\n            this._resetSelectorDefinition();\n            this.objDef = { type: 'font-palette-values', key: null, ident: null, names: [] }\n        },\n        _handleFontPaletteValues(data, marker, tokenID, tokenList, _handle) {\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                let _obj = this.objDef;\n                switch (tokenID) {\n                    case 'ftp-name':\n                        if (!_css_definition.fontPaletteValues) {\n                            _css_definition.fontPaletteValues = {};\n                        }\n                        _obj.names.push(_v);\n                        const _id = _obj.names.join(' ');\n                        let _ndef = _css_definition.fontPaletteValues[_id] || (() => {\n                            let c = new CssStyle;\n                            _css_definition.fontPaletteValues[_id] = c;\n                            return c;\n                        })();\n                        _selectorDefinition.definitions = _ndef;\n\n                        break;\n                    case 'css-font-palette-values':\n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n\n        // imports\n        _onStartImport() {\n            this._resetSelectorDefinition();\n            this.objDef = {\n                type: 'imports', key: null, ident: null, names: [],\n                url: null, layer: null, supports: null, queries: null\n            }\n        },\n        _handleImport(data, marker, tokenID, tokenList, _handle) {\n            const q = this;\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                let _obj = q.objDef;\n                if (!_css_definition.imports) {\n                    _css_definition.imports = new CssImports;\n                }\n                switch (tokenID) {\n                    case 'url':\n                        _obj.url = _v;\n                        break;\n                    case 'media-queries':\n                        _obj.queries = _v;\n                        break;\n                    case 'method-call':\n                        if (/^layer/.test(_v)) {\n                            _obj.layer = _v;\n                        }\n                        if (/^supports/.test(_v)) {\n                            _obj.supports = _v;\n                        }\n                        break;\n                    case 'css-import':\n                        _css_definition.imports.store(_obj);\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n        // namespace\n        _onStartNamespace() {\n            this._resetSelectorDefinition();\n            this.objDef = {\n                type: 'namespace', prefix: null, url: null\n            }\n        },\n        _handleNamespace(data, marker, tokenID, tokenList, _handle) {\n            const q = this;\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                let _obj = q.objDef;\n                if (!_css_definition.namespace) {\n                    _css_definition.namespace = []\n                }\n                switch (tokenID) {\n                    case 'ns-prefix':\n                        _obj.prefix = _v;\n                        break;\n                    case 'url':\n                        _obj.url = _v;\n                        break;\n                    case 'css-namespace':\n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        const { prefix, url } = _obj;\n                        _css_definition.namespace.push({ prefix, url })\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n\n        // page\n        _onStartPage() {\n            this._resetSelectorDefinition();\n            this.objDef = {\n                type: 'page', selector: [],\n                def: new CssStyle\n            };\n            _selectorDefinition.definitions = this.objDef.def;\n            if (!_css_definition.pages) {\n                _css_definition.pages = {};\n            }\n        },\n        _handlePage(data, marker, tokenID, tokenList, _handle) {\n            const q = this;\n            _handle.handle = (() => {\n                let _h = true;\n                let _v = data.value;\n                let _obj = q.objDef;\n                switch (tokenID) {\n                    case 'page-selector':\n                        _obj.selector.push(_v);\n                        break;\n                    case 'url':\n                        _obj.url = _v;\n                        break;\n                    case 'css-page':\n                        const _def = _obj.def;\n                        const _id = (_obj.selector.length > 0 ? _obj.selector.join(', ') : null) || '$global';\n                        let _inf = _css_definition.pages[_id];\n                        if (_inf) {\n                            CssStyle.AppendDef(_inf, _def);\n                        } else {\n                            _css_definition.pages[_id] = _def;\n                        }\n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n\n        // starting-style\n        _onStartStartingStyle() {\n            this._resetSelectorDefinition();\n            this.objDef = {\n                type: 'starting-style',\n                current: _selectorDefinition.listener.styles\n            };\n            _selectorDefinition.definitions = new CssStyle;\n            if (!_css_definition.startingStyle) {\n                _css_definition.startingStyle = {};\n            }\n            _selectorDefinition.styleStore = _css_definition.startingStyle;\n             \n        },\n        _handleStartingStyle(data, marker, tokenID, tokenList, _handle) {\n            const q = this;\n            _handle.handle = (() => {\n                let _h = true; \n                let _obj = q.objDef;\n                switch (tokenID) {\n                    case 'css-starting-style':\n                        // const _gdef = _selectorDefinition.definitions;\n                        // const _def = _obj.def;\n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        _selectorDefinition.styleStore = _obj.current;\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n\n         // supports\n         _onStartSupports() {\n            this._resetSelectorDefinition();\n            this.objDef = {\n                type: 'supports', \n                key : '$global',\n                storage: null\n            };\n            _selectorDefinition.definitions = new CssStyle;\n            if (!_css_definition.supports) {\n                _css_definition.supports = {};\n            }\n            this.objDef.storage = _css_definition.supports[this.objDef.key] || {};\n            _selectorDefinition.styleStore = this.objDef.storage;\n            _selectorDefinition.key = this.objDef.key;\n             \n        },\n        _handleSupports(data, marker, tokenID, tokenList, _handle) {\n            const q = this;\n            _handle.handle = (() => {\n                let _h = true; \n                let _obj = q.objDef;\n                let _v = data.value;\n                let _g = null;\n                switch (tokenID) {\n                    case 'support-condition':\n                        _obj.key = _v;\n                        _g = _css_definition.supports[_v];\n                        if (_g){\n                            this.objDef.storage = _g;\n                            _selectorDefinition.styleStore = this.objDef.storage;\n                             \n                        } else{\n                            _g = {};\n                            this.objDef.storage = _g;\n                            _selectorDefinition.styleStore = this.objDef.storage;\n                            _css_definition.supports[_v] = _g;\n                        }\n                        break;\n                    case 'css-supports':\n                        // const _gdef = _selectorDefinition.definitions;\n                        // const _def = _obj.def;\n                        let _key = _obj.key;\n                        if (_key=='$global'){\n                            _css_definition.supports[_key] = _obj.storage; // selectorDefinition.definitions;\n                        } \n\n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        _selectorDefinition.styleStore = _obj.current;\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n\n        _onStartViewTransition() {\n            this._resetSelectorDefinition();\n            this.objDef = {\n                type: 'view-transition',  \n                storage: null\n            };\n            // + | direct style properties definition \n            _selectorDefinition.definitions = new CssStyle;\n            if (!_css_definition.viewTransition) {\n                _css_definition.viewTransition = _selectorDefinition.definitions ;\n            }\n             \n        },\n        _handleViewTransition(data, marker, tokenID, tokenList, _handle) {\n            const q = this;\n            _handle.handle = (() => {\n                let _h = true; \n                let _obj = q.objDef; \n                switch (tokenID) { \n                    case 'css-view-transition':  \n                        this._resetSelectorDefinition();\n                        this.objDef = null;\n                        _selectorDefinition.styleStore = _obj.current;\n                        break;\n                    default:\n                        _h = false;\n                        break;\n                }\n                return _h\n            })();\n        },\n    };\n    _formatter.listener = _listener;\n\n}\n\n\n\n/**\n * @typedef {undefined|boolean|string|string[]} IDebugFeatures \n */\n\nclass CssTransformer {\n\n    /**\n     * \n     * @param {*} src \n     * @param {undefined|{debug:undefined|IDebugFeatures|bool, complete:undefined|(d:string)=>void, output: undefined|(css:CssStyleDefinitions)=>void} option \n     * @returns {string}\n     */\n    static ToJSON(src, option) {\n        const _css_definition = new CssStyleDefinitions();\n        const _selectorDefinition = new SelectorDefinition(_css_definition);\n\n\n        function _updatePropertyDefinition() {\n            _selectorDefinition.update();\n        }\n        function _updateMediaDefinition() {\n            // console.log(\"update media definition : \");\n            if (_listener.medias_definition) {\n                if (!_css_definition.medias) {\n                    _css_definition.initMedia();\n                }\n                _css_definition.medias[_listener.medias_definition.condition] =\n                    _listener.medias_definition.styles;\n            }\n        }\n        let _debug = false;\n\n        if (option) {\n            (() => {\n                const { debug } = option;\n                _debug = debug;\n            })();\n        }\n        _formatter.debug = _debug;\n        _initListener(_formatter, _selectorDefinition, {\n            _updatePropertyDefinition,\n            _updateMediaDefinition, _css_definition\n        });\n        const _listener = _formatter.listener;\n        const _format = _formatter.format(src, {\n            complete() {\n                _selectorDefinition.store();\n                _selectorDefinition.complete();\n            }\n        }\n        );\n        if (typeof (option?.format) == 'function') {\n            option.format(_format);\n        }\n        if (typeof (option?.output) == 'function') {\n            option.output(_css_definition);\n        }\n        return JSON.stringify(_css_definition, null, 4);\n    }\n}\nexports.CssTransformer = CssTransformer","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst LOG_NAME = '[igk-formatters]'\nclass Debug{\n    static LogLevel = 3;\n    static #Enabled = false;\n    \n    static get IsEnabled(){\n        return Debug.#Enabled;\n    }\n    static log(msg, level){\n        if (level){\n            if (level < Debug.LogLevel){\n                return;\n            }\n        }\n        if (typeof(msg)=='object'){\n            msg = JSON.stringify(msg, (k, v)=>{\n                if (k.length==0){\n                    return v;\n                }\n                if (typeof(v)=='object'){\n                    return {};//'[object]';\n                }\n                if (typeof(v)=='array'){\n                    return [];//'[array]';\n                }\n                return v;\n            });\n        }\n        let args = [];\n        if (arguments){\n            for(let i = 1; i < arguments.length; i++){\n                args.push(arguments[i]);\n            }\n        }\n        console.log(`${LOG_NAME} - ${msg}`, ...args);\n    }\n    /**\n     * enable debug globally\n     * @param {?bool} enable \n     */\n    static Enable(enable){\n        Debug.#Enabled = enable;\n    }\n}\n\nexports.Debug = Debug;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterOptions } = require(\"../FormatterOptions\");\nconst { Utils } = require(\"../Utils\");\n\nconst auto_closed = 'link|img|input';\nclass bhtml {\n    isAutoCloseTag(target, value) {\n        return auto_closed.split('|').indexOf(target) != -1;\n    }\n    /**\n     * auto close tagreturn buffer content\n     * @param {string} target - tag name \n     * @param {*} value - data baleur\n     * @param {*} marker - source marker\n     * @param {FormatterOptions} option - formatting option\n     * @returns {string}\n     */\n    autoCloseTagValue(target, value, marker, option, captures) {\n        let _value = value;\n        let _lastData = _value.dataSegment.pop();\n        let _lastBuffer = _value.bufferSegment.pop();\n        let _load_data = (_cp) => {\n            _value.dataSegment.push(_cp.data);\n            _value.bufferSegment.push(_cp.buffer);\n        };\n\n        let _captures = captures || marker.endCaptures || marker.captures; //[]; //marker.endMissingCaptures || marker.endCaptures || marker.captures;\n        let _is_closed = />\\s*$/.test(_lastData) || /^>/.test(_lastData);\n        let _close_tag = \"</\" + target + \">\";\n        let _is_auto_closed = this.isAutoCloseTag(target, value);\n        if (_is_auto_closed) {\n            _close_tag = \"/>\";\n        }\n        _load_data({ buffer: _lastBuffer, data: _lastData });\n        if (_lastData != _close_tag) { \n            let _p = Utils.CreateEndMatch(_close_tag); \n            let tp = option.treatEndCaptures(marker, _p, _captures);\n            //let cp = Utils.RenderToBuffer(_close_tag, marker, _captures, option);\n            // _load_data({ buffer: _lastBuffer, data: _lastData });\n            if (!_is_closed) {\n                if (!_is_auto_closed) {\n                    const _tdp = Utils.RenderToBuffer('>', marker, _captures, option);\n                    _load_data(_tdp);\n                }\n            }\n            if ((marker.childs.length > 0) && this._isChildBlock(marker.childs)) {\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.appendExtraOutput();\n                let refData = {};\n                const _rbuffer = option.flush(true, refData);\n                option.restoreSavedBuffer();\n                _load_data({ buffer: _rbuffer, data: refData.data });\n            } else {\n                _load_data({ buffer: tp, data: _close_tag });\n            }\n        }\n        return value.bufferSegment.join('');\n    }\n    _isChildBlock(childs) {\n        const { Formatters } = Utils.Classes;\n        return Formatters.IsChildBlock(childs);\n    }\n}\n\nexports.bhtml = bhtml;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { bhtml }  = require(\"./bhtml\")\n\nconst engines = {\n    bhtml\n}\n \nexports.engines = engines","\"use strict\";\n\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nlet Joiner = null;\n/**\n * @import (./IBufferData)\n */\n\n/**\n * class that help to manibule buffer by segment\n * @property {string[]} output \n * @property {string[]} dataOutput \n * @property {string[]} bufferSegments \n * @property {string[]} dataSegments \n */\nclass FormatterBuffer {\n    static DEBUG = false;\n    /**\n     * set the formatter buffer identification \n     */\n    id;\n    constructor() {\n        var m_output = [];\n        var m_bufferSegments = [];\n        var m_dataSegments = [];\n        var m_dataOutput = [];\n        \n        m_bufferSegments.marked = FormatterBuffer.InitMarkedSegment();\n        /*\n        arry of buffer segment\n         */\n        Object.defineProperty(this, 'bufferSegments', { get() { return m_bufferSegments; } });\n        Object.defineProperty(this, 'dataSegments', { get() { return m_dataSegments; } });\n        Object.defineProperty(this, 'output', { get() { return m_output; } });\n        Object.defineProperty(this, 'dataOutput', { get() { return m_dataOutput; } });\n        Object.defineProperty(this, 'length', { get() { return m_bufferSegments.length; } });\n\n    }\n    get isEmpty() {\n        return this.bufferSegments.length == 0;\n    }\n\n    static InitBufferMarkedSegment(bufferSegment){ \n        if (bufferSegment && !('marked' in bufferSegment)){\n            bufferSegment.marked = FormatterBuffer.InitMarkedSegment();\n        } \n    }\n\n    static CopyMarkedSegment(bufferSegment){\n        return bufferSegment.marked ? ((a)=>{\n            let marked = a.slice(0);\n            if('op' in a)\n                marked.op = JSON.parse(JSON.stringify(a.op));\n            else \n                marked.op = FormatterBuffer.InitOpMarkedSegment();\n            return marked;\n        })(bufferSegment.marked) : \n            FormatterBuffer.InitMarkedSegment(); \n    }\n\n    /**\n     * prepend value on segments\n     * @param {string|{buffer:string, data:string}} value \n     */\n    prepend(value){\n        let buffer = null;\n        let data = null;\n        if (typeof(value)=='object'){\n            ({buffer, data}= value);\n            if (!buffer || !data){\n                throw new Error('invalid data');\n            }\n        } else {\n            if (typeof(value)=='string'){\n            buffer = data = value;\n            }\n            else \n                throw new Error('not a string data'); \n        } \n        this.bufferSegments.unshift(buffer);\n        this.dataSegments.unshift(data); \n    }\n    /**\n     * get the buffer offset content\n     * @param {number} offset \n     * @param {string} join \n     * @returns {string}\n     */\n    getContent(offset, join = '') {\n        return this.bufferSegments.slice(offset).join(join || '');\n    }\n    /**\n     * get data segment offset\n     * @param {*} offset \n     * @param {*} join \n     * @returns \n     */\n    getData(offset, join = '') {\n        return this.dataSegments.slice(offset).join(join || '');\n    }\n    /**\n     * get buffer segment\n     * @var {string}\n     */\n    get buffer() {\n        return this.bufferSegments.join('');\n    }\n    /**\n     * retrieve data\n     * @var {string}\n     */\n    get data() {\n        return this.dataSegments.join('');\n    }\n    /**\n     * join the buffer segments\n     * @param {null|string} join \n     * @returns string\n     */\n    join(join) {\n\n        return this.bufferSegments.join(join || '');\n    }\n    /**\n     * join segment \n     */\n    joinSegments(join = '') {\n        const { bufferSegments, dataSegments } = this;\n        return FormatterBuffer.JoinSegments(bufferSegments, dataSegments); \n     }\n    /**\n     * copy join segment\n     * @param {*} bufferSegments \n     * @param {*} dataSegments \n     * @param {string} join \n     * @returns \n     */\n    static JoinSegments(bufferSegments, dataSegments, join = '') {\n        let ch = null;\n        let _bufferS = [];\n        let _dataS = [];\n        if (bufferSegments.marked) {\n            const q = bufferSegments.marked;\n            q.sort();\n            const _OP = q.op || {};\n            let _call = (tab, q, marked) => {\n                let c = 0;\n                let t = [];\n                const _bufferS = [];\n                const _marked = FormatterBuffer.InitMarkedSegment();\n                tab.forEach(a => {\n                    if ((q.length > 0) && (q[0] == c)) {\n                        if (t.length > 0) {\n                            _bufferS.push(t.join(join));\n                            t.length = 0;\n                        }\n                        _bufferS.push(a);\n                        q.shift();\n                        let _idx = _bufferS.length - 1;\n                        if (c in _OP) {\n                            // + | update marker optionration  \n                            Utils.UpdateSegmentMarkerOperation(_marked, _idx, _OP[c]);\n                        }\n                        _marked.push(_idx);\n                    } else {\n                        t.push(a);\n                    }\n                    c++;\n                });\n                if (t.length > 0) {\n                    _bufferS.push(t.join(join));\n                    t.length = 0;\n                }\n                if (marked) {\n                    _bufferS.marked = _marked;\n                }\n                return _bufferS;\n            };\n\n            _bufferS = _call(bufferSegments, q.slice(0), true);\n            _dataS = _call(dataSegments, q.slice(0));\n\n        } else {\n            _bufferS.push(bufferSegments.join(join));\n            _dataS.push(dataSegments.join(join));\n        }\n        return { bufferSegment: _bufferS, dataSegment: _dataS };\n    }\n    /**\n     * init marked segment\n     * @returns \n     */\n    static InitMarkedSegment(){\n        const _g = []; \n        FormatterBuffer.InitOpMarkedSegment(_g);\n        return _g;\n    }\n    static InitOpMarkedSegment(d){\n        d.op = {};\n    }\n    /**\n     * append value to buffer segment\n     * @param {string|{buffer:string, data: string, marked: boolean|{}}} v \n     */\n    appendToBuffer(v) {\n        if (typeof (v) == 'string') {\n            this.bufferSegments.push(v);\n            this.appendToData(v);\n        } else {\n            const { buffer, data, marked, dataSegments, bufferSegments } = v;\n            if (dataSegments && bufferSegments) {\n                this._joinWith({ bufferSegment: bufferSegments, dataSegment: dataSegments });\n            }\n            else //if (buffer && data)\n                {\n                this.bufferSegments.push(buffer);\n                this.appendToData(data);\n                if (marked) {\n                    if (!('marked' in this.bufferSegments)) {\n                        this.bufferSegments.marked = FormatterBuffer.InitMarkedSegment();\n                    }\n                    const _idx = this.bufferSegments.length - 1;\n                    this.bufferSegments.marked.push(_idx);\n                    if (typeof (marked) == 'object') {\n                        if (!('op' in this.bufferSegments.marked)){\n                            FormatterBuffer.InitOpMarkedSegment(this.bufferSegments.marked);\n                        }\n                        Utils.UpdateSegmentMarkerOperation( this.bufferSegments.marked, _idx, marked);\n                     \n                    }\n                }\n            }\n        }\n    }\n    /**\n     * push data segment\n     * @param {*} v \n     */\n    appendToData(v) {\n        this.dataSegments.push(v);\n    }\n    /**\n     * store to buffer\n     * @param {string|{_buffer:string, _data:{bufferSegment:[*], dataSegment:[*]}}} buffer \n     * @param {*} param1 \n     */\n    storeToBuffer(buffer, { lastDefineStates }) {\n        if (typeof (buffer) == 'string') {\n            if (lastDefineStates && (buffer == lastDefineStates.bufferSegment.join(''))) {\n                this.appendToBuffer({ buffer, data: lastDefineStates.dataSegment.join('') });\n            }\n            else {\n                // + | just store to buffer \n                this.appendToBuffer(buffer);\n            }\n        } else {\n            const { _buffer, _data } = buffer;\n            if (!_data?.bufferSegment){\n                // + | missing buffer segment\n                this.appendToBuffer(_buffer);\n                return;\n                // throw new Error('missing buffer segment');\n            }\n            let rs = _data.bufferSegment.join('');\n            if (_buffer != rs) {\n                // TODO : update list of item to join operation and trim line\n                this.appendToBuffer({ buffer:_buffer, data: '-nop-'}); // lastDefineStates.dataSegment.join('') });\n                return;\n                throw new Error('invalid buffer mismatch segments');\n            }\n            this._joinWith(_data);\n\n        }\n    }\n    static ClearSegments({dataSegment, bufferSegment}){\n        dataSegment.length = 0;\n        bufferSegment.length = 0;\n        if ('marked' in bufferSegment){ \n            bufferSegment.marked.length = 0;\n            FormatterBuffer.InitOpMarkedSegment(bufferSegment.marked);\n        }\n    }\n    /**\n     * reduce buffer segment index\n     * @param {number} count \n     * @param {*} bufferSegment \n     */\n    static ReduceBufferSegmentIndex(count, bufferSegment){\n          // + | reduce index \n          const TS = [];\n          bufferSegment.marked?.forEach(v=>{\n              const _op = bufferSegment.marked.op[v];\n              const _new_idx = v-count;\n              if (_op){\n                  delete(bufferSegment.marked.op[v]); \n                  Utils.UpdateSegmentMarkerOperation(bufferSegment.marked, _new_idx,_op);  \n              }\n              TS.push(_new_idx);  \n          }); \n          bufferSegment.marked.length = 0;\n          bufferSegment.marked.push(...TS);\n    }\n    /**\n     * join with segment\n     * @param {{bufferSegment:[*], dataSegment:[*]}} param0 \n     */\n    _joinWith({ bufferSegment, dataSegment }) {\n        const { FormatterSegmentJoin} = Utils.Classes;\n\n        let join = Joiner || (() => { Joiner = new FormatterSegmentJoin(); return Joiner })();\n        join.bufferSegment = bufferSegment;\n        join.dataSegment = dataSegment;\n        join.updateData({ bufferSegment: this.bufferSegments, dataSegment: this.dataSegments });\n    }\n    /**\n     * clear segments\n     */\n    clear() {\n        const { bufferSegments, dataSegments } = this;\n        bufferSegments.length = 0;\n        dataSegments.length = 0;\n        bufferSegments.marked = [];\n    }\n    /**\n     * clear outputs\n     */\n    clearOutput() {\n        this.output.length = 0;\n        this.dataOutput.length = 0;\n    }\n    /**\n     * clear all \n     */\n    clearAll() {\n        this.clear();\n        this.clearOutput();\n    }\n    /**\n     * trim end data\n     */\n    trimEnd() {\n        const { bufferSegments, dataSegments } = this;\n        let q = null;\n        [bufferSegments, dataSegments].forEach(segment => {\n            while (segment.length > 0) {\n                q = segment.pop();\n                q = q.trimEnd();\n                if (q.length > 0) {\n                    segment.push(q);\n                    break;\n                }\n            }\n        });\n    }\n    trimStart() {\n        const { bufferSegments, dataSegments } = this;\n        let q = null;\n        [bufferSegments, dataSegments].forEach(segment => {\n            while (segment.length > 0) {\n                q = segment.unshift();\n                q = q.trimEnd();\n                if (q.length > 0) {\n                    segment.push(q);\n                    break;\n                }\n            }\n        });\n    }\n    trim() {\n        this.trimStart();\n        this.trimEnd();\n    }\n    /**\n     * last segment value\n     * @returns {null|string}\n     */\n    lastSegment() {\n        const { bufferSegments } = this;\n        if (bufferSegments.length > 0) {\n            return bufferSegments[bufferSegments.length - 1];\n        }\n        return null;\n    }\n    lastDataSegment() {\n        const { dataSegments } = this;\n        if (dataSegments.length > 0) {\n            return dataSegments[dataSegments.length - 1];\n        }\n        return null;\n    }\n    /**\n     * retrieve last segment info\n     */\n    lastSegmentInfo(){\n        const { bufferSegments } = this;\n        if (bufferSegments.length > 0) {\n            const idx = bufferSegments.length - 1;\n            const _buffer =  bufferSegments[idx];\n            const op = FormatterBuffer.GetBufferMarkedOperation(bufferSegments, idx); \n            return new FormatterSegmentInfo(_buffer, op);\n        }\n        return null;\n    }\n    /**\n     * get buffer sement\n     * @param {*} bufferSegments \n     * @param {*} idx \n     */\n    static GetBufferMarkedOperation(bufferSegments, idx){\n        let op = null;\n        const { marked } = bufferSegments;\n        if (marked){\n            let _op  = marked.op;\n            if (idx in bufferSegments.marked){\n                let l = bufferSegments.marked[idx];\n\n                if (op && (l in _op)){\n                    op =op[l];\n                }\n            }\n        }\n        return op;\n    }\n    /**\n     * replace last segment with new value\n     * @param {*} newValue \n     */\n    replaceLastSegment(newValue) {\n        const { bufferSegments } = this;\n        bufferSegments.pop();\n        bufferSegments.push(newValue);\n    }\n\n    /**\n     * \n     * @param {{ bufferSegment:[], dataSegment:[] }} bufferData \n     * @param {*|'*'|'trimmed'|(a)=>boolean} op \n     * @returns \n     */\n    static TreatMarkedSegments(bufferData, op = '*') {\n        const { bufferSegment, dataSegment } = bufferData;\n        const q = bufferSegment.slice(0);\n        let _idx = -1;\n        switch (op) {\n            case '*': {\n                // remove all marked segments\n                while (bufferSegment.marked.length > 0) {\n                    _idx = bufferSegment.marked.shift();\n                    delete (q[_idx]);\n                    delete (dataSegment[_idx]);\n                }\n            }\n                break;\n            case 'trimmed':\n\n                Utils.TrimBufferSegment(bufferSegment, dataSegment);\n                Utils.ReorderBufferSegment(bufferSegment);\n                let elt = dataSegment.filter(o => o!== undefined);\n                dataSegment.length = 0;\n                dataSegment.push(...elt);\n                return dataSegment;\n                // const _tlist = bufferSegment.marked.slice(0);\n                // let _count = 0;\n                // let _dir = 0;\n\n\n\n                // while (_tlist.length > 0) {\n                //     _idx = _dir == 0 ? _tlist.shift() : _tlist.pop();\n                //     let _top = bufferSegment.marked.op[_idx] || null;\n                //     let _trim = _dir == 0 ? _idx == _count : false;\n                //     if (_top && _trim && _top.trimmed) {\n                //         //let _ts = q[_idx];\n                //         delete (q[_idx]);\n                //         delete (dataSegment[_idx]);\n                //         delete (bufferSegment.marked.op[_idx]);\n                //         delete (bufferSegment.marked[_count])\n                //     }\n                //     if (_dir==1){\n                //         if (!_trim){\n                //             break;\n                //         }\n                //     } else {\n                //         if (!_trim){\n                //             _dir = 1;\n                //         }\n                //     }\n                //     _count++;\n                // }\n                // const _marked = bufferSegment.marked.filter(o => o);\n                // bufferSegment.marked.length = 0;\n                // bufferSegment.marked.push(..._marked);\n                break;\n            default:\n                if (typeof (op) == 'function') {\n                    while (bufferSegment.marked.length > 0) {\n                        _idx = bufferSegment.marked.shift();\n                        s = q[_idx];\n                        if (op(s)) {\n                            delete (q[_idx]);\n                            delete (dataSegment[_idx]);\n                        }\n                    }\n\n                }\n        }\n\n        let elt = dataSegment.filter(o => o);\n        dataSegment.length = 0;\n        dataSegment.push(...elt);\n\n        bufferSegment.length = 0;\n        elt = q.filter(o => o);\n        bufferSegment.push(...elt);\n        return bufferData;\n    }\n}\n\nconst { FormatterSegmentInfo } = require(\"./FormatterSegmentInfo\");\nconst { FormatterSegmentJoin } = require(\"./FormatterSegmentJoin\");\nconst { Utils } = require(\"./Utils\");\n\nexports.FormatterBuffer = FormatterBuffer;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\nclass FormatterBufferUtils{\n\n    /**\n     * just treat formatter value\n     * @param formatter \n     * @param value \n     * @param marker \n     * @param option \n     * @return {{buffer:string, data:string}}\n     */\n    static TreatValue(formatter, value, marker, option){\n        option.saveBuffer();\n        option.appendToBuffer(value, marker);\n        let _value = option.buffer;\n        let _data = option.data;\n        option.restoreSavedBuffer();\n\n        return {buffer:_value, data:_data};\n    }\n}\n\nexports.FormatterBufferUtils = FormatterBufferUtils;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\nclass FormatterCloseParentInfo{\n    /**\n     * value used to close \n     * @var {string}\n     */\n    value;\n    /**\n     * extra type to attach to parent\n     * @var {?string}\n     */\n    type;\n\n    /**\n     * define name of this close parent info\n     * @var {?string}\n     */\n    name;\n}\n\nexports.FormatterCloseParentInfo = FormatterCloseParentInfo;","\"use strict\";\n\nconst { FormatterBuffer } = require(\"./FormatterBuffer\");\n\nObject.defineProperty(exports, \"__ESModule\", { value: true });\n\nclass FormatterDebugger {\n    constructor(all) {\n        const q = this;\n        this.feature = (name) => {\n            if (all) {\n                return true;\n            }\n            if (name in q) {\n                return q[name];\n            }\n            return false;\n        }\n    }\n    static DebugAll() {\n        return DEBUG_ALL;\n    }\n    static Load(data) {\n        let c = new FormatterDebugger;\n        let top_keys = {};\n        Object.keys(data).forEach((i) => {\n            let r = data[i];\n            let tp = ((i)=>{i = i.split('.'); i.pop(); return i.join('.'); })(i);\n            if (tp.length>0){\n                top_keys[tp] = 1;\n            }\n\n            Object.defineProperty(c, i, {\n                get: function () {\n                    if (typeof (r) == \"function\") {\n                        return r();\n                    }\n                    return r;\n                }\n            });\n        });\n        for(let i in top_keys){\n            if (i in c )\n                continue;\n            Object.defineProperty(c, i, { value: true}); \n        }\n        return c;\n    }\n\n}\n\nconst DEBUG_ALL = new FormatterDebugger(true);\n\n\nexports.FormatterDebugger = FormatterDebugger;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { engines }  = require(\"../lib/EndMissingEngine/engines\")\nconst { bhtml } = engines;\nconst ENGINES = {\n    'source.bhtml': bhtml\n}\nconst REF = {};\nclass FormatterEndMissingEngine{\n    static Get(scopeName){\n        if (!(scopeName in REF)){\n            const  d  = ENGINES[scopeName]\n            REF[scopeName] = new d();\n        }\n        return REF[scopeName];\n    }\n}\n\nexports.FormatterEndMissingEngine = FormatterEndMissingEngine;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass FormatterEndMissingExpression{\n    #expression;\n    #captures;\n\n    constructor(expression,captures){\n        this.#expression = expression;\n        this.#captures = captures;\n    }\n    get expression(){\n        return this.#expression;\n    }\n    get captures(){\n        return this.#captures;\n    }\n    /**\n     * \n     * @param {*} group \n     */\n    load(group, transform, engine, value, marker, option, captures){\n        let _e = this.expression;\n        let _ret = null;\n        let _p = transform(new RegExp(_e), group); \n        let _captures = captures ||  this.captures;\n        let _args = [engine, value, marker, option, _captures];\n        let _cp = (new Function('engine', \"return \"+_p)).apply(null, _args);\n        if (Array.isArray(_cp)){\n            _p = _cp.shift();\n            _args.shift();\n            _args.unshift(..._cp);\n            _args.unshift(engine);\n            _ret = _p.call(..._args);\n            \n        }else{\n            _args = [engine, value, marker, option, captures];\n            let _fc = new Function('engine','value', 'marker', 'option', 'return (()=>'+_p+')();');\n            _ret = _fc.call(null, _args);\n        }\n        return _ret;\n    }\n}\nexports.FormatterEndMissingExpression = FormatterEndMissingExpression;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst Errors = {\n     101: 'not in capture.' ,\n     102: 'not define.' ,\n     103: 'invalid syntax.' ,\n};\nexports.FormatterErrors = Errors;","\"use strict\";\nObject.defineProperty(exports, '__ESModule', { value: true });\n\nconst { Debug } = require('./Debug');\nconst { RegexUtils } = require('./RegexUtils')\n/**\n * use to operate on line matching \n */\nclass FormatterLineMatcher {\n    /**\n     * start line flag\n     * @var {?boolean} \n     */\n    #m_startLine;\n\n    /**\n     * flag: middle pos when ending - must consider hown element\n     */\n    #m_middelPos;\n    /**\n     * source line\n     * @type {?string}\n     */\n    #m_soureLine;\n    /**\n     * current line\n     * @type {?string}\n     */\n    #m_line;\n    /**\n     * current offset \n    * @type {?number}\n     */\n    #m_offset;\n    /**\n     * expected next position\n     * @type {?number}\n     */\n    #m_nextPosition;\n\n\n    /**\n     * \n     */\n    constructor() {\n        const MATCHER_STATES = [];\n\n        this.save = function (new_value) {\n            const { sourceLine, line, offset, position } = this;\n            MATCHER_STATES.push({ sourceLine, line, offset, position });\n            if (typeof (new_value) == 'string') {\n                this.sourceLine = new_value;\n            }\n        }\n        this.restore = () => {\n            const def = MATCHER_STATES.pop();\n            if (def) {\n                const { sourceLine, line, offset, position } = def;\n                this.sourceLine = sourceLine;\n                this.#m_line = line;\n                this.#m_offset = offset;\n                this.#m_nextPosition = position;\n            }\n        }\n    }\n\n    /**\n     * get the start line flag\n     */\n    get startLine() {\n        return this.#m_startLine;\n    }\n    /**\n     * set the start line flag\n     */\n    set startLine(v) {\n        this.#m_startLine = v;\n    }\n\n    /**\n     * define source line\n     * @param {?string} v \n     */\n    set sourceLine(v) {\n        if (v == undefined) throw new Error('value not allowed');\n        // + | setup source file\n        this.#m_soureLine = v;\n        this.#m_line = v;\n        this.#m_offset = 0;\n        this.#m_nextPosition = 0;\n    }\n    get sourceLine() {\n        return this.#m_soureLine;\n    }\n    get line() {\n        return this.#m_line;\n    }\n    set line(v) {\n        this.#m_line = v;\n    }\n    get subLine() {\n        return this.#m_soureLine.substring(this.#m_offset);\n    }\n    get nextLine() {\n        return this.#m_soureLine.substring(this.#m_nextPosition);\n    }\n    /**\n     * get current offset\n     */\n    get offset() {\n        return this.#m_offset;\n    }\n    get position() {\n        return this.#m_nextPosition;\n    }\n    set offset(v) {\n        this.#m_offset = v;\n    }\n    /**\n     * chang the position\n     */\n    set position(v) {\n        const _np = this.#m_nextPosition;\n        if (v != _np) {\n            if (v < _np) {\n                throw new Error('next position not allowed ' + v + ' < ' + _np);\n            }\n            this.#m_offset = this.#m_nextPosition;\n            this.#m_nextPosition = v;\n        }\n    }\n    reset() {\n        this.#m_offset = 0;\n        this.#m_nextPosition = 0;\n    }\n    /**\n  * set position and offset \n  * @param {number} position \n  * @param {undefined|number} offset \n  */\n    setPosition(position, offset) {\n        if (offset) {\n            if (offset > position) {\n                throw new Error(\"offset must not be greater than position\");\n            }\n        } else {\n            offset = position;\n        }\n        this.#m_offset = offset;\n        this.#m_nextPosition = position;\n    }\n    /**\n     * and and return regex result\n     * @param {*} regex \n     * @returns {null|IRegexResult} regex result\n     */\n    check(regex, option) {\n        const _has_movement = RegexUtils.HasBackyardMovementCapture(regex);\n        const _has_startLine = RegexUtils.CheckRequestStartLine(regex);\n        const { subLine, nextLine, sourceLine, position, startLine, offset } = this;\n        const { debug } = option || { debug: false };\n        let _p = null;\n        if (_has_startLine) {\n            if (startLine && (position == 0)) {\n                _p = regex.exec(sourceLine);\n                if (_p) {\n                    _p.move = false;\n                    return _p;\n                }\n            }\n            if (!startLine) {\n                debug && Debug.log('--::: skip: not on start line :::--')\n                return _p;\n            }\n        }\n        if (_has_movement) {\n            _p = regex.exec(subLine);\n            if (_p) {\n                _p.move = true;\n                _p.index += offset;\n                let _idx = _p.index;\n                let cp = null;\n                let _mark = false;\n                while (_idx < position) {\n                    _mark = true;\n                    _idx++;\n                    let new_s = sourceLine.substring(_idx);\n                    cp = regex.exec(new_s);\n                    if (cp) {\n                        _idx += cp.index;\n                        cp.index = _idx;\n                        cp.input = sourceLine;\n                        cp.move = true;\n                    } else {\n                        break;\n                    }\n                }\n                if (_mark) {\n                    if (!cp) {\n                        _p = null;\n                    } else {\n                        _p = cp;\n                    }\n                }\n                if (_p) {\n                    _p.index += -position;\n                }\n            }\n        } else if (!_p) {\n            _p = regex.exec(nextLine);\n        }\n        if (_p) {\n            _p.index += position;\n            _p.input = sourceLine;\n            if (_p.index < position) {\n                _p = null;\n            }\n        }\n        return _p;\n    }\n}\n\nexports.FormatterLineMatcher = FormatterLineMatcher;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * formatter line segment\n */\nclass FormatterLineSegment extends Array {\n    constructor(){\n        super();\n        let m_states = [];\n\n        this.save = ()=>{\n            m_states.push(this.slice(0));\n            this.clear();\n        };\n        this.restore=()=>{\n            let mps = m_states.pop();\n            if (mps){\n                this.clear();\n                super.push(...mps);\n            }\n        };\n    }\n    store(segment, option) {\n        if (!option.isCapturing) {\n            super.push(segment);\n        }\n    }\n    push(segment, option) {\n        if (!option) {\n            throw new Error('require option');\n        }\n        if (!option.isCapturing) {\n            super.push(segment);\n        }\n    }\n    unshift(segment, option) {\n        if (!option) {\n            throw new Error('require option');\n        }\n        if (!option.isCapturing) {\n            super.unshift(segment);\n        }\n    }\n    clear() {\n        this.length = 0;\n    }\n}\n\n\nexports.FormatterLineSegment = FormatterLineSegment;\n","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass FormatterLintError{\n    message;\n    code;\n    constructor(){\n        \n    }\n}\n\nexports.FormatterLintError = FormatterLintError;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\nconst { Debug } = require(\"./Debug\");\nconst { Patterns } = require(\"./Patterns\");\nconst { Utils } = require(\"./Utils\");\n\n/**\n * @type IFormatterListener\n * @method renderToken - render token\n * @method store - store to buffer\n * @method onEndHandler - marker end with content value\n */\n\n\n/**\n * formatter listener\n * @extends IFormatterListener\n */\nclass FormatterListener {  \n\n    constructor() {\n        var m_lastToken;\n        /**\n         * get last evaluated marker\n         */\n        Object.defineProperty(this, 'lastMarker', { get() { return m_lastToken } }); \n        this.setLastMarker = function (token) {\n            m_lastToken = token;\n        };\n    }\n    /**\n     * append new line to buffer\n     * @param {string} line_feed \n     * @param {FormatterBuffer} buffer \n     */\n    appendLine(line_feed, buffer, option){\n        option.saveBuffer();\n        option.appendExtraOutput();\n        const _cbuffer = option.flush(true);\n        option.restoreSavedBuffer();\n        buffer.appendToBuffer(_cbuffer);\n    }\n    /**\n     * call to add a new block\n     * @var {{formatterBuffer: FormatterBuffer, tabStop:string, depth:number}} param\n     */\n    startNewBlock({formatterBuffer, tabStop, depth}){ \n        // override to mark start new block\n    } \n    /**\n     * override en output\n     * @param {*} param0 \n     */\n    endOutput({lineFeed}){\n\n    }\n    /**\n     * override end content\n     */\n    endContent(){\n\n    }\n    /**\n     * treat current buffer and store it to option \n     * buffer to ouput . \n     */\n    store({buffer, data, output, dataOutput, depth, tabStop, startBlock}) { \n        let s = buffer;\n        let d = depth; \n        if (s.length > 0){\n            if (startBlock){\n                output.unshift('');\n                dataOutput.unshift('');\n            }\n            let _tab = d > 0 ? tabStop.repeat(d) : '';\n            output.push(_tab + s);\n            dataOutput.push(_tab+data);\n        } \n    }\n    /**\n     * use this to join everything that as represent in buffer with the lineFeed data\n     * @param {bool} clear \n     * @param {{output:string[], lineFeed:string}} param1 \n     * @returns {string}\n     */\n    output({output, lineFeed}) { \n        let _s = output.join(lineFeed); \n        return _s;\n    }  \n    /**\n     * transform value depending on token definition \n     * @param {string} value \n     * @param {null|string|string[]} tokens \n     * @param {null|string} tokenID \n     * @param {null|FormatterEngine} engine \n     * @param {?bool} debug \n     * @param {*} marker parent marker  \n     * @returns {string}\n     */\n    renderToken(value, tokens, tokenID, engine, debug, marker, option){\n        const { FormatterToken } = Utils.Classes;\n        const rt = new FormatterToken();\n        rt.tokens = tokens;\n        rt.tokenID = tokenID;\n        rt.value =  value;\n        option.lastToken = rt;\n        debug?.feature(\"render-token\") && Debug.log(\"render token\", JSON.parse(JSON.stringify(rt)));\n        if (engine){\n            return engine.renderToken(value, tokens, tokenID, marker);\n        } \n        return value;\n    } \n}\n\nexports.FormatterListener = FormatterListener;","\"use strict\"; \nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { Debug } = require('./Debug');\nconst { FormatterBuffer } = require('./FormatterBuffer');\n\n/**\n * formatter marker info setting\n * @property {number} currentMode\n */\nclass FormatterMarkerInfo{\n    /**\n     * buffering buffer start\n     */\n    start = false;\n    /**\n     * backup state\n     */\n    state;\n    /**\n     * flag: indicate newly start block\n     * @var {bool}\n     */\n    startBlock;\n\n    oldBlockStart;\n    blockStarted;\n    useEntry = true;\n    \n   \n\n    /**\n     * use to capture entry \n     * @var {?string}\n     */\n    captureEntry;\n\n    /**\n     * store context join with\n     */\n    joinWith;\n\n    /**\n     * data stored\n     */\n    prependExtra;\n\n    storePrependExtra(data){\n        if (!this.prependExtra && data){\n            if (!Array.isArray(this.prependExtra)){\n                this.prependExtra = [this.prependExtra]\n            }\n            this.prependExtra.push(data);\n            return;\n        }\n        this.prependExtra = data;\n    }\n\n    toString(){\n        return 'FormatterMarkerInfo#'+this.marker.toString();\n    }\n\n    /**\n     * update marker info\n     * @param {*} data \n     */\n    updateDataSegments(data){\n        const {bufferSegment, dataSegment} = data;\n        const _data = this.data;\n        const ic = _data.bufferSegment.length;\n        _data.bufferSegment.push(...bufferSegment);\n        _data.dataSegment.push(...dataSegment);\n\n        const _marked = bufferSegment.marked?.slice(0);\n        if (_marked){\n            for(let c = 0; c <  _marked.length; c++){\n                let _new_id =    _marked[c] + ic;\n                _marked[c] += ic;\n                if (c in bufferSegment.marked.op){\n                    let _op = bufferSegment.marked.op[c];\n                    delete(bufferSegment.marked.op[c]); \n                    Utils.UpdateSegmentMarkerOperation(bufferSegment.marked, _new_id, _op);  \n                }\n            }\n            if ( !_data.bufferSegment.marked )\n                _data.bufferSegment.marked  = [];\n            _data.bufferSegment.marked.push( ..._marked);\n            _data.bufferSegment.marked.op = { ... _data.bufferSegment.marked.op, ... bufferSegment.marked.op };\n        }\n\n    }\n    /**\n     * create a formatter marker info \n     * @param {*} formatter \n     * @param {*} _marker \n     * @param {*} entry \n     * @param {*} _endRegex \n     * @param {*} option \n     */\n    constructor(formatter, _marker, entry, _endRegex, option){  \n        this.startBlock = _marker.isBlock ? 1 : 0;\n        this.oldBlockStart = _marker.isBlock;\n        this.blockStarted = false;\n        let m_currentMode = _marker.mode;\n        \n\n        Object.defineProperty(this, 'formatter', {get(){return formatter;}}); \n        Object.defineProperty(this, 'marker', {get(){return _marker;}});\n        Object.defineProperty(this, 'endRegex', {get(){return _endRegex;}});\n        Object.defineProperty(this, 'currentMode', {get(){return m_currentMode;},\n        set(v){\n            if (v==2){\n                if (this.marker.name == 'meta.function.sub-definition.vbmacros'){\n                    console.log(\"changin mode ....\");\n                }\n            }\n            m_currentMode = v;\n        }});\n\n\n\n        \n    \n        (function (entry, _marker_info) {\n            var _content = entry;\n            var _isNew  = true;\n            // + | static storage - presentation value \n            var _data = null;\n\n            //_marker_info.updateStore\n\n            if (option?.lastDefineStates?.bufferSegment.join('')==entry){\n                const { dataSegment, bufferSegment } = option.lastDefineStates;\n                _data = { dataSegment: dataSegment.slice(0), bufferSegment : bufferSegment.slice(0) };\n                // + | copy marked segment  \n                _data.bufferSegment.marked = FormatterBuffer.CopyMarkedSegment(bufferSegment);\n            }else{\n                let e = [];\n                let d = [];\n                if (entry.length>0){\n                    e.push(entry);\n                    d.push(entry);\n                }\n                _data = {dataSegment: e, bufferSegment:d}\n            }\n            if (!('marked' in _data.bufferSegment))\n                 _data.bufferSegment.marked = FormatterBuffer.InitMarkedSegment();\n\n\n\n            _marker_info.set = function(){\n                _isNew = false;\n            };\n            /**\n             * get stored data segment\n             */\n            Object.defineProperty(_marker_info, 'data', {get(){\n                return _data;\n            }});\n            /**\n             * is new marker info \n             */\n            Object.defineProperty(_marker_info, 'isNew', {get(){\n                return _isNew;\n            }});\n            Object.defineProperty(_marker_info, 'entryBuffer', {\n                get() {\n                    return entry;\n                }\n            });\n            Object.defineProperty(_marker_info, 'content', {\n                get() {\n                    return _content;\n                },\n                set(v) {\n                    \n                    if (v != _content) {\n                        option.debug?.feature(\"store-content\") && (()=>{\n                            Debug.log(\"---::store content ::---\\n[value::'\" + v+\"']\"); \n                            console.log({newValue: v, oldValue:_content});\n                        })();\n                        _content = v;\n                    } \n                }\n            });\n            Object.defineProperty(_marker_info, 'childs', {\n                get() {\n                    return _marker_info.marker.childs;\n                }\n            });\n        })(entry, this); \n    } \n    /**\n     * save state \n     * @param {*} option mode definition \n     * @param {number} mode formatting mode\n     */\n    saveState(option, mode){\n        // + | save buffer state \n        this.state = {\n            buffer: option.formatterBuffer.buffer, // store old buffer\n            output: option.output,\n            formatterBuffer: option.formatterBuffer,\n            get currentBufferContent(){\n                return this.formatterBuffer.buffer;\n            },\n            get mode(){\n                return mode;\n            }\n        }; \n    }\n\n}\n\nexports.FormatterMarkerInfo = FormatterMarkerInfo;","\"use strict\";\nObject.defineProperty(exports, 'enModule', { value: true });\n\n\nclass FormatterMatchTreatment{\n    static Init(source){\n        const _op = [];\n        let _data = undefined;\n        _op.treatment = new FormatterMatchTreatment;\n        Object.defineProperty(_op, 'treated', { get(){\n            return (_op.indexOf('replaceWith')!=-1);\n        } });\n        Object.defineProperty(_op, 'source', { get(){\n            return source;\n        } });\n        Object.defineProperty(_op, 'data', { get(){\n            return _data;\n        }, set(v) {\n            _data = v;\n        } });\n        return _op;\n    }\n}\n\nexports.FormatterMatchTreatment = FormatterMatchTreatment;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\nconst { Utils } = require(\"./Utils\");\nconst { Debug } = require(\"./Debug\");\nconst { FormatterBuffer } = require(\"./FormatterBuffer\");\nconst { FormatterLineMatcher } = require(\"./FormatterLineMatcher\");\nconst { FormatterLineSegment } = require(\"./FormatterLineSegment\");\nconst { FormatterListener } = require(\"./FormatterListener\");\n\n/**\n * @typedef IFormatSourceOption\n * @type\n * @property {?string} name\n * @property {?string} constantName\n * @property {?number} depth\n */\n\n/**\n * @typedef IFormatterOptions\n * @funcion newBuffer \n * @property {string} line current line definition\n * @property { boolean } isEOL detect that is end off line; \n */\n\n/**\n * class used to expose formatter option \n * @type IFormatterOptions\n * @property {FormatterLineMatcher} lineMatcher \n * @function joinBuffer\n */\nclass FormatterOptions {\n    // private \n    #m_lineSegments;\n\n    // sourceLine;\n    // line;\n\n    /**\n     * position on operate line \n     */\n    // pos = 0;\n    /**\n     * current line cursor\n     */\n    lineCount = 0;\n\n    /**\n     * line offset\n     */\n    lineOffset = 0;\n    \n    continue = false;\n    lineJoin = false;\n    skipTreatEnd = false;\n    skipTreatWhile = false;\n    markerDepth = 0; // store handleMarker stack\n    loopInfo;\n\n    /**\n     * get or set last marker depth\n     * @var {*}\n     */\n    lastMarker;\n\n    /**\n     * format source option\n     * @var {undefined|IFormatSourceOption}\n     */\n    sourceOption;\n    /**\n     * join with flag string\n     * @var {?string}\n     */\n    joinWith;\n    /**\n     * flag to call on end of file\n     */\n    EOF = false;\n    /**\n     * flag to set on en of line\n     */\n    EOL = false;\n\n    TOEND = false;\n    /**\n     * store global output result \n     */\n    // output = [];   // output result global output result \n    tokenList = [];// store entry token list\n    /**\n     * line feed flag in order to store on next root operation\n     * @var {?boolean} \n     */\n    lineFeedFlag = false;\n    state = ''; // current state mode \n    range = {\n        start: 0, // start position\n        end: 0    // number end position range\n    };\n    /**\n     * get or set the current stream option\n     */\n    stream;\n    /**\n     * store chain of new created OldBuffers\n     */\n    newOldBuffers = [];\n\n    /**\n     * activate the hold buffer list \n     */\n    holdBufferState = false;\n    /**\n     * flag for glue value : used to skip entry data for match.\n     */\n    glueValue = null;\n\n    /**\n     * flag formatter skip start empty line flag\n     */\n    skipEmptyMatchValue = false; \n\n    /**\n     * flag to skip update start line logic\n     */\n    skipUpdateStartLine = false;\n\n    /**\n     * on stream buffer handler skip marker flag\n     */\n    skipMarkerFlag = false;\n\n    /**\n     * next mode\n     * @var {number}\n     */\n    nextMode = 1;\n\n    /**\n     * last rendered token \n     */\n    lastToken;\n\n    /**\n     * last segment\n     */\n    lastSegment;\n\n    /**\n     * flag to store last define\n     */\n    lastDefineStates;\n\n    /**\n     * flag: use to indicate the line is starting\n     * @var {boolean}\n     */\n    startLine; \n\n    /**\n     * flag : skip end of line\n     */\n    skipEndOfLine;\n\n    /**\n     * flag: start line reading \n     */\n    get startReading(){\n        return this.formatter?.startReading;\n    }\n\n    /**\n     * flag: newly block start\n     * @var {null|undefined|bolean}\n     */\n    startBlock;\n\n    /**\n     * transform marker style\n     * @var {*}\n     */\n    matchTransformFlag; \n \n    /**\n     * get or set last marker Pattern - to skip for next get global pattern loop. skip only one\n     */\n    lastEmptyMarkerPattern;\n\n    /**\n     * flag: value used to glue with next trimmed line;\n     * @var {undefined|string}\n     */\n    nextGlueValue; \n\n \n    get lineSegments(){\n        return this.#m_lineSegments;\n    }\n\n    /**\n     * \n     * @param {*} marker \n     * @returns \n     */\n    pushConditionalContainer(marker){\n        const { conditionalContainer } = this;\n        if (marker.isBlockConditionalContainer){\n            conditionalContainer.push({marker, start:true});\n            return true;\n        }\n        return false;\n    }\n    popConditionalContainer(){\n        const { conditionalContainer } = this;\n        return conditionalContainer.pop();\n    }\n\n    /**\n     * @var {boolean}\n     */\n    isConditionalBlockStart(){\n        const { conditionalContainer } =  this;\n        if (conditionalContainer.length>0){\n            let i = conditionalContainer[conditionalContainer.length-1];\n            return i.start;\n        }\n        return false;\n    }\n\n    /**\n     * top conditional block container\n     * @returns \n     */\n    topConditionalBlockContainer(){\n        const { conditionalContainer } =  this;\n        if (conditionalContainer.length>0){\n            return conditionalContainer[conditionalContainer.length-1];\n        }  \n        return null;\n    }\n \n    /**\n     * .ctr\n     * @param {*} _formatter \n     * @param {*} _formatterBuffer \n     * @param {*} _listener \n     * @param {*} m_constants_def \n     * @param {*} _rg \n     */\n    constructor(_formatter, _formatterBuffer, _listener, m_constants_def, _rg) {\n        const { debug } = _formatter;\n        const c_lineMatcher = new FormatterLineMatcher(this);\n        const c_conditionalContainer = [];\n        // initialize conditional field\n        let { lineFeed, tabStop } = {lineFeed:_rg?.lineFeed || _formatter.info.lineFeed || \"\\n\", \n            tabStop: _rg?.tabStop || _formatter.info.tabStop || \"\\t\"};\n        this.#m_lineSegments = new FormatterLineSegment;\n        let m_isCapturing = false;\n\n        \n        let m_depth = _rg?.depth || 0;\n        let _blockStarted = false;\n        const _bufferState = [];\n        const _markerInfo = [];\n        const _states = [];\n        const { CaptureRenderer, FormatterBuffer, Debug } = Utils.Classes;\n        let m_appendToBufferListener = null;\n        let _outputBufferInfo = {\n            line: 0,\n            start: 0,\n            end: 0,\n            /**\n             * update number information\n             * @param {number} lineCount number info\n             */\n            updateLine(lineCount) {\n                this.line = lineCount;\n                this.start = this.end = 0;\n            },\n            /**\n             * update range\n             * @param {number} start \n             * @param {undefined|number} end \n             */\n            updateRange(start, end) {\n                this.start = start;\n                this.end = typeof (end) == 'undefined' ? start : end;\n            }\n        }\n        const option = this;\n        let m_saveCount = 0;\n        let m_formatterListener = null;\n        // inject setting property\n        for (let i in _rg) {\n            if (['depth', 'line', 'tabStop', 'lineFeed'].indexOf(i) != -1) {\n                continue;\n            }\n            Object.defineProperty(this, i, {\n                get() {\n                    return _rg[i];\n                }\n            });\n        }\n        this.resetRange = function () {\n            this.storeRange(0, 0);\n        }\n        this.storeRange = function (start, end) {\n            this.range.start = start;\n            this.range.end = typeof (end) == 'undefined' ? start : end;\n        }\n        this.isRootFormatterBuffer = function (formatter_buffer) {\n            return formatter_buffer === _formatterBuffer;\n        }\n        Object.defineProperty(option, 'isCurrentFormatterBufferIsRootBuffer', {\n            get() {\n                return this.isRootFormatterBuffer(this.formatterBuffer);\n            }\n        });\n        \n\n        Object.defineProperty(option, 'conditionalContainer', {get(){return c_conditionalContainer; }});\n        Object.defineProperty(option, 'lineMatcher', {get(){return c_lineMatcher; }});\n        Object.defineProperty(option, 'sourceLine', {get(){return c_lineMatcher.sourceLine; }});\n        Object.defineProperty(option, 'line', {get(){\n            return c_lineMatcher.line; \n        }, set(v){ c_lineMatcher.line = v;}});        \n        Object.defineProperty(option, '_saveCount', { get: function () { return m_saveCount; } })\n        Object.defineProperty(option, 'streamBuffer', { get: function () { return this.stream?.buffer; } })\n        Object.defineProperty(option, 'listener', { get: function () { return _listener; } })\n        Object.defineProperty(option, 'formatter', { get: function () { return _formatter; } })\n        Object.defineProperty(option, 'formatterBuffer', { get: function () { return _formatterBuffer; } })\n        Object.defineProperty(option, 'blockStarted', {\n            get: function () { return _blockStarted; }, set(v) {\n                _blockStarted = v;\n            }\n        });\n        Object.defineProperty(option, 'isEOL', { \n            get(){\n                return this.pos >= this.length;\n            }\n        } );\n        Object.defineProperty(option, 'isCapturing', {\n            get: function () { return m_isCapturing; }\n        });\n\n        Object.defineProperty(option, 'buffer', { get: function () { return _formatterBuffer.buffer; } })\n        Object.defineProperty(option, 'data', { get: function () { return _formatterBuffer.data; } })\n        Object.defineProperty(option, 'outputBufferInfo', { get() { return _outputBufferInfo; } })\n        Object.defineProperty(option, 'tokenChains', {\n            get() {\n                const _tokens = _formatter.getTokens();\n                let r = _tokens;\n                if (this.tokenList?.length > 0) {\n                    r = this.tokenList.concat(_tokens);\n                }\n                return r;\n            }\n        });\n        Object.defineProperty(option, 'length', { get: function () { return this.line.length; } })\n        Object.defineProperty(option, 'debug', { get: function () { return debug; } })\n        Object.defineProperty(option, 'markerInfo', { get: function () { return _markerInfo; } })\n        Object.defineProperty(option, 'constants', { get: function () { return m_constants_def; } })\n        Object.defineProperty(option, 'pos', {\n            get: function () { \n                return c_lineMatcher.position; \n            }, \n            set(v){\n                c_lineMatcher.position = v;\n            }\n        });\n        /**\n         * debug offset \n         */\n        Object.defineProperty(option, 'offset', {\n            get: function () { \n                return c_lineMatcher.offset; \n            }\n        });\n        /**\n         * append to buffer listener callback\n         * @var {null|(value:string)} \n         */\n        Object.defineProperty(option, 'appendToBufferListener', {\n            get: function () { return m_appendToBufferListener; }, set(v) {\n                m_appendToBufferListener = v;\n            }\n        });\n        Object.defineProperty(option, 'output', {\n            get: function () { return _formatterBuffer.output; },\n        });\n        Object.defineProperty(option, 'dataOutput', {\n            get: function () { return _formatterBuffer.dataOutput; },\n        });\n        Object.defineProperty(option, 'depth', {\n            get() { return m_depth; },\n            /**\n             * set the depth\n             * @param {number} v depth \n             */\n            set(v) {\n                m_depth = v;\n            }\n        });\n        option.getLineRangeContent = function () {\n            const q = this;\n            return q.line.substring(q.range.start, q.range.end);\n        };\n        option.unshiftMarker = (o) => { \n            _markerInfo.unshift(o);\n        };\n        option.shiftMarker = () => { \n            return _markerInfo.shift();\n        };\n        option.empty = empty;\n\n        Object.defineProperty(option, 'lineFeed', {get(){\n            return lineFeed;\n        }});\n\n        function empty(l) {\n            return (!l && l.length == 0)\n        }\n        function is_emptyObj(q) {\n            return Object.keys(q).length == 0\n        }\n        /**\n         * push object state\n         */\n        function pushState() {\n            let _keys = Object.keys(option);\n            let _state = {};\n            _keys.forEach(i => {\n                let t = typeof (option[i]);\n                if (/function|object/.test(t))\n                    return;\n                let _i = Object.getOwnPropertyDescriptor(option, i);\n                if (!_i || (_i.get && _i.set)) {\n                    _state[i] = option[i];\n                }\n            })\n            _states.unshift({ ..._state });\n        }\n        /**\n         * pop object state\n         */\n        function popState() {\n            let s = _states.shift();\n            if (s) {\n                for (let i in s) {\n                    option[i] = s[i];\n                }\n            }\n        }\n\n        option.pushState = pushState;\n        option.popState = popState;\n        /**\n         * treat how to update the current buffer before add it to listener\n         * @param {string} s \n         * @param {*} value \n         * @param {*} _marker \n         * @returns new buffer value\n         */\n        option.updateBufferValue = function (s, value, _marker) {\n            // allow listener to treate buffer value\n            // + | tranform before update \n            if (empty(value)) {\n                return s;\n            }\n            const { listener } = this;\n            if (listener?.joinBuffer) {\n                return listener.joinBuffer(s, value, _marker);\n            }\n            return this.joinBuffer(s, value);\n        };\n\n        /**\n         * \n         * @param {*} buffer \n         * @param {*} value \n         * @returns \n         */\n        option.joinBuffer = function (buffer, value) {\n            const { lineJoin, noSpaceJoin } = this;\n            let s = buffer;\n            if (lineJoin) {\n                let join = ' ';\n                if (noSpaceJoin) {\n                    join = '';\n                }\n                s = [s.trimEnd(), value.trimStart()].join(join);\n                this.lineJoin = false;\n            } else {\n                s += value;\n            }\n            return s;\n        }\n        function _shiftMarkerInfo(marker, tokenChains) {\n            if (_formatter.isSpecialMarker(marker)) {\n                if ((typeof (marker.shiftIdConstant) == 'function') && marker.shiftIdConstant())\n                    tokenChains.shift();\n            }\n        }\n        function getTokenID(marker) {\n            while (marker) {\n                if (marker.tokenID) {\n                    return marker.tokenID;\n                }\n                if (marker.fromGroup) {\n                    if (marker.fromGroup.tokenID) {\n                        return marker.fromGroup.tokenID;\n                    }\n                }\n\n                marker = marker.parent;\n            }\n            return null;\n        }\n     \n        /**\n         * append to buffer\n         * @param {string|{buffer:string, data:string}} value \n         * @param {PatternMatchInfo} _marker \n         * @param {?boolean} treat render token with listener  \n         * @param {*} _marker \n         */\n        option.appendToBuffer = function (value, _marker, treat = true, raise=true) {\n            \n            if (!value){\n                // buffer is undefined or null\n                return;\n            }\n            \n            const { debug, formatterBuffer } = this;\n            debug?.feature('append-to-buffer') && (()=>{\n                Debug.log(\"[append to buffer] - \");\n                console.log(value);\n            });\n            let _buffer = value;\n            let _storeBuffer = (value, data, _marker, treat)=>{\n                let _buffer = value;        \n                let _data = data;        \n                if (m_appendToBufferListener) {\n                    value = m_appendToBufferListener(value, _marker, treat, this);\n                }\n                else {\n                    if (treat){\n                        _buffer = this.treatValueBeforeStoreToBuffer(_marker, _buffer);\n                    } \n                    const marked = _marker.markedInfo();\n                    formatterBuffer.appendToBuffer({\n                        buffer: _buffer, data: _data, marked});\n                }\n            };\n            let _def_value = null;\n\n            if (typeof(value) == 'object' ){\n                // passing object \n                // encapsulate buffer but not data\n                _storeBuffer(value.buffer, value.data, _marker, false); \n                _buffer = option.buffer;\n                _def_value = {source: value.data, value: value.buffer};\n            }\n            else if (value.length > 0) {\n                if (m_appendToBufferListener) {\n                    value = m_appendToBufferListener(value, _marker, treat, this);\n                }\n                else {\n                    if (treat){\n                        _buffer = this.treatValueBeforeStoreToBuffer(_marker, _buffer);\n                    } \n                    // TODO: update marker info\n                    const marked =  _marker.markedInfo();\n\n                    formatterBuffer.appendToBuffer({\n                        buffer: _buffer, data: value, marked});\n                }\n            }\n            _marker.value = _def_value || { source: value, value: _buffer };\n            if (raise)\n                _formatter.onAppendToBuffer(_marker, _buffer, option);\n            if (_buffer?.trim().length>0){\n                option.glueValue = null;\n            }\n        };\n\n        option.useGlue = (_marker, _cm_value)=>{\n             // + | update or reset glue value\n             if (_marker.isGlueValue && _cm_value) {\n                option.glueValue = _cm_value;\n            } else {\n                option.glueValue = null;\n            }\n        };\n        option.treatValueBeforeStoreToBuffer = function (_marker, _buffer){\n            const { listener, tokenChains, engine } = this;\n            if (listener?.renderToken) {\n                _shiftMarkerInfo(_marker.marker, tokenChains);\n                // + | shift to token marker info \n                (()=>{\n                    // + | add extra to to token chains\n                    _marker.name && !_marker.isShiftenName && tokenChains.unshift(_marker.name);\n                    \n                })()\n                const tokenID = getTokenID(_marker);\n                _buffer = listener.renderToken(_buffer, tokenChains, tokenID, engine, debug, _marker, option);\n            }\n            return _buffer;\n        }\n        /**\n         * treat begin captures\n         * @param {*} _marker \n         * @param {*} matches \n         * @returns \n         */\n        option.treatBeginCaptures = function (patternInfo, _captures, _outdefine) {\n            const { marker, group } = patternInfo; \n            // + | do capture treatment \n            let _cap = _captures || Utils.BeginCaptures(marker);\n            if (is_emptyObj(_cap)) {\n                return;\n            } \n            let _s = null;  \n            // + | use capture to treat and pattern to continue reading\n            // + | clone and reset indices before generate  \n            _s = CaptureRenderer.CreateFromGroup(group, marker.name);\n            if (_s) {\n                _outdefine =_outdefine || {};\n                let _g = _renderCaptures( ()=>{\n                    return  _s.render(this.listener, _cap, false, this.tokenChains, this, _outdefine);\n                });\n                patternInfo.startOutput = _g;\n                this.lastDefineStates = _outdefine;\n                return _g;\n            }\n            return null;\n        };\n        option.treatEndCaptures = function (markerInfo, endMatch, captures, _outdefine) {\n            let _cap = captures || { ...markerInfo.captures, ...markerInfo.endCaptures };\n            if (is_emptyObj(_cap)) {\n                if (endMatch[0].length>0)\n                    return option.treatValueBeforeStoreToBuffer(markerInfo, endMatch[0]);\n                return;\n            }\n            const { marker } = markerInfo;\n            const { debug } = this;\n            const q = this;\n            const fc_handle_end = function (value, cap, id, listener, option) {\n                const { tokens, engine, debug, tokenID } = option;\n                if (cap.patterns) {\n                    value = Utils.TreatPatternValue(value, cap.patterns, markerInfo.group, q);\n                } else {\n                    // treat buffer marker \n                    const op = [];\n                    value = _formatter.treatMarkerValue(cap, value, op);\n                    value = listener.renderToken(value, tokens, tokenID, engine, debug, cap,q);\n                }\n                return value;\n\n            };\n            debug?.feature('treat-capture') && Debug.log('--:::TreatEndCapture:::--' + marker);\n            let def = endMatch;\n            let _s = CaptureRenderer.CreateFromGroup(def, marker.name);\n            if (_s) { \n                _outdefine = _outdefine || {};\n                let _g = _renderCaptures(()=>{\n                    let _g = _s.render(this.listener, _cap, fc_handle_end, this.tokenChains,\n                        q, _outdefine\n                    );\n                    return _g;\n                }); \n                markerInfo.endOutput = _g;\n                this.lastDefineStates = _outdefine;\n                debug?.feature('treat-capture') && (()=>{\n                    Debug.log('--::: end captures result :::--');\n                    console.log({endOuput:_g});\n                })();\n                return _g;\n            }\n            return null; \n        }\n\n        /**\n         * \n         */\n        function _renderCaptures(callback){\n            let q = option;\n            let _bck = q.skipEmptyMatchValue;\n            q.skipEmptyMatchValue = false;\n            m_isCapturing= true;\n            let _g = callback();\n            m_isCapturing = false;\n            q.skipEmptyMatchValue = _bck;\n            return _g;\n        }\n      \n    \n\n        /**\n         * deprecated use only renderer to treat value \n         * @param {*} _cap \n         * @param {*} _marker \n         * @param {*} endMatch \n         * @deprecated\n         * @returns \n         */\n        option.treatCaptures = function (_cap, _marker, endMatch) {\n            // let transformed = _marker.endRegex(_marker.group); \n            // use replaceWith to change the value at specied capture \n            let list = [];\n            list.markers = {};\n            let prop = null;\n            for (let i in _cap) {\n                list.push(i);\n                let d = _cap[i];\n                if (!(i in endMatch)) {\n                    _formatter.pushError(101);\n                    continue;\n                }\n                let value = endMatch[i];\n\n\n                if (d.transform) {\n                    value = Utils.StringValueTransform(value, d.transform);\n                }\n                if (d.name) {\n                    prop = new NameOnlyConstantPattern();\n                    prop.name = d.name;\n                    list.markers[i] = {\n                        marker: prop,\n                        value: value\n                    };\n                }\n                endMatch[i] = value;\n            }\n            return list;\n        }\n\n        /**\n         * move to this location\n         * @param {number} newPosition \n         */\n        option.moveTo = function (newPosition, newOffset) { \n            if (newOffset){\n                this.lineMatcher.setPosition(newPosition, newOffset)\n            } else {\n                this.pos = newPosition;\n            }\n        }\n        /**\n         * restore buffer \n         * @param {*} param0 \n         */\n        option.restoreBuffer = function ({ state }) {\n            _formatterBuffer = state.formatterBuffer;\n        };\n        option.newBuffer = function (id) {\n            _formatterBuffer = new FormatterBuffer;\n            _formatterBuffer.id = id;\n        };\n        /**\n         * save buffer\n         */\n        option.saveBuffer = function () {\n            m_saveCount++;\n            _bufferState.push({\n                output: this.output,\n                formatterBuffer: this.formatterBuffer\n            });\n            this.newBuffer('_save_buffer_');\n        };\n\n        /**\n         * restore saved buffer\n         */\n        option.restoreSavedBuffer = function () {\n            let buffer = _bufferState.pop();\n            if (buffer) {\n                this.restoreBuffer({ state: buffer });\n                m_saveCount--;\n            }\n        };\n\n        /**\n         * store definition\n         * @param {*} startBlock \n         */\n        option.store =\n            /**\n             * store and clear formatter buffer  \n             * @param {bool} startBlock \n             */\n            function (startBlock = false){\n                const _ctx = this;\n                const { buffer, data, output, dataOutput, depth, formatterBuffer, listener } = _ctx;\n                const _args = { buffer, output,data, dataOutput, depth, tabStop, formatterBuffer, _ctx, startBlock };\n                if (listener?.store) {\n                    listener.store.apply(null, [_args]);\n                } else {\n                    if (!m_formatterListener){\n                        m_formatterListener = new FormatterListener;\n                    }\n                    m_formatterListener.store(_args);\n                }\n                _formatterBuffer.clear();\n            };\n\n        option.flush =\n           /**\n           * flush with what is in the buffer - and clear buffer \n           * @param {bool} clear clear buffer list \n           * @param {{dataOutput:string, buffers: { bufferSegments: [*], dataSegments: [*]} }} refdata reference data return on buffer clear \n           * @returns \n           */\n            function (clear, refdata) {\n                const _ctx = this;\n                const { buffer, output, listener, dataOutput, formatterBuffer} = _ctx;\n                let l = '';\n                let data = null;\n                if (listener?.output) {\n                    l = listener.output.apply(null, [{ buffer, output, dataOutput, lineFeed, _ctx }]);\n                } else {\n                    l = output.join(lineFeed);\n                }\n                data = dataOutput.join(lineFeed);\n                //+| clear output and buffer \n                if (clear) {\n                    if (refdata){\n                        refdata.dataOutput = data;\n                        refdata.buffers = formatterBuffer.joinSegments();\n                    }\n                    formatterBuffer.clearAll();\n                    output.length = 0;\n                }\n                return l;\n            }\n        option.appendLine = \n            /**\n             * \n             * @returns \n             */\n            function () {\n            const { listener } = this; \n            const { lineFeed } = _formatter.settings;\n            if (listener?.appendLine) {\n                return listener.appendLine(lineFeed,\n                    this.formatterBuffer, this, {\n                    store: () => {\n                        this.store();\n                    }\n                });\n            } else {\n                return _formatter.appendToBuffer(lineFeed, this);\n            }\n        };\n    }\n\n    /**\n     * \n     * @param {PatternMatchInfo} sourcePattern \n     * @param {string} buffer \n     * @returns {_gbuffer:string, _cpos:number}\n     */\n    treatAndFormat(sourcePattern, buffer){\n        let _cpos = buffer.length;\n        const _s = sourcePattern.streamFormatter;\n        if (_s){\n            if (typeof(_s)=='function'){\n                buffer = formatter(buffer);\n            } else if ((typeof(_s) == 'object') && _s.format){\n                buffer = _s.format(buffer);\n            } \n            // update the new line\n            this.line = buffer + option.line.substring(_cpos);\n        }\n        return {_gbuffer: buffer, _cpos: buffer.length};\n    }\n    /**\n     * start loop detected \n     */\n    loopStart(){\n        if (this.loopInfo == null){\n            // + | init loop start\n            this.loopInfo = {\n                position: 0,\n                matcher: null,\n                count: 0\n            };\n        } else {\n            // + | reset loop start\n            this.loopInfo.position = 0;\n            this.loopInfo.matcher= null;\n            this.loopInfo.count = 0;\n        }\n    }\n    get sourceOffset(){\n        return this.lineOffset + this.offset;\n    }\n    /**\n     * reset flags definition\n     */\n    reset(){\n        this.lineJoin = \n        this.skipEmptyMatchValue = \n        this.holdBufferState = \n        this.EOF=\n        this.EOL=\n        this.startLine=\n        this.lineFeedFlag =\n        this.skipTreatEnd = \n        this.skipTreatWhile = \n        false;\n        this.lineCount = 0;\n        this.markerDepth = 0;\n        this.nextMode = 1;\n        // reset glue flags\n        this.joinWith = null;\n        this.lastDefineStates = null;\n        this.transformMarker = null;\n        this.lineSegments.clear();\n        this._resetFlags();\n    }\n    cleanNewOldBuffers() {\n        const option = this;\n        if (this.holdBufferState && option.newOldBuffers.length > 0) {\n            // On this Process handling clean all new Buffers\n            let count = option.newOldBuffers.length;\n            while (count > 0) {\n                let tq = option.shiftMarker();\n                let q = option.newOldBuffers.pop();\n                if (tq !== q) {\n                    throw new Error('invalid configuration');\n                }\n                count--;\n                let bf = option.buffer;\n                option.restoreBuffer(q);\n                if (bf.length > 0) {\n                    option.appendToBuffer(bf);\n                }\n            }\n        }\n    }\n    _resetFlags(){\n        this.glueValue = null;\n        this.lastEmptyMarkerPattern = null;\n        this.skipEndOfLine = false;\n    }\n    /**\n     * set source line \n     * @param {*} v \n     * @param {undefined|number} position \n     * @param {undefined|number} offset \n     */\n    setSourceLine(v, position, offset){\n        this.lineMatcher.sourceLine = v;\n        if ((position != undefined) && (position>=0)){\n            this.setPosition(position, offset);\n        }\n    }\n\n    /**\n     * set position and offset \n     * @param {number} position \n     * @param {undefined|number} offset \n     */\n    setPosition(position, offset){ \n        this.lineMatcher.setPosition(position, offset);\n    }\n    /**\n     * \n     * @param {*} _marker \n     * @param {*} _old \n     */\n\n    onBeginEndFound(_marker, _old){\n        this._resetFlags();\n        this.cleanNewOldBuffers();\n        // set the nextGlueValue to use.\n        if (_marker.nextGlueValue){\n            this.nextGlueValue = _marker.nextGlueValue;\n        }\n        if (_marker.isBlockConditionalContainer){\n            if (this.topConditionalBlockContainer()==_marker){\n\n                this.popConditionalContainer();\n            }\n        }\n    }\n    onBeginWhileFound(){\n\n    }\n\n    /**\n     * shift and restore from\n     * @param {*} from \n     * @param {*} throwError \n     * @returns \n     */\n    shiftAndRestoreFrom(from, throwError){\n        const option = this;\n        let _old = option.shiftFromMarkerInfo(from, throwError);\n        if (_old) {\n            // unshif and restore buffer \n            let _rbuffer = option.buffer;\n            let _rdata = option.data;\n            option.restoreBuffer(_old);\n            if (_rbuffer) {\n                option.formatterBuffer.appendToBuffer(\n                    {\n                    source:_rbuffer, data: _rdata});\n            }\n        }\n        return _old;\n    }\n    /**\n     * get if reading is in real start line\n     * @var {boolean}\n     */\n    get startLineReading(){\n        return this.startLine && (this.line == this.sourceLine);\n    }\n    /**\n     * return shift markerInfo from list\n     * @param {PatternMatchInfo} marker \n     * @param {bool} throwError \n     * @returns \n     */\n    shiftFromMarkerInfo(marker, throwError = true) {\n        if (this.markerInfo.length > 0) {\n            if (this.markerInfo[0].marker === marker) {\n                return this.markerInfo.shift();\n            }\n            if (throwError) {\n                throw new Error('missing markerInfo [shift Marker Info] ');\n            }\n        }\n        return null;\n    }\n    storeAndUpdateBuffer() {\n        this.store();\n        let _buffer = this.flush(true);\n        if (_buffer.length > 0) {\n            this.formatterBuffer.appendToBuffer(_buffer);\n        }\n    }\n    getBufferContent(clear, refData){\n        const option = this;\n        let _buffer = option.buffer;\n        let _cm = option.flush(true, refData);\n        if (clear){\n            option.formatterBuffer.clear();\n        }\n        return _cm+_buffer;\n    }\n    peekFirstMarkerInfo() {\n        if (this.markerInfo.length > 0) {\n            return this.markerInfo[0];\n        }\n        return null;\n    }\n    /**\n     * store current buffer to output\n     * @param {*} useDepth \n     * @param {*} blockStarted \n     */\n    storeToOutput({ buffer = null, useDepth = false, blockStarted = false, clear = false }) {\n        buffer = buffer || this.buffer;\n        if (buffer && (buffer.length > 0)) {\n            if (useDepth)\n                this.store(blockStarted);\n            else {\n                let l = this.buffer;\n                if (l.length) {\n                    this.output.push(l);\n                }\n            }\n        }\n        if (clear) {\n            this.formatterBuffer.clear();\n        }\n    }\n    /**\n     * get marker info\n     */\n    get peekMarkerInfo(){\n        return this.markerInfo.length>0? this.markerInfo[0] : null;\n    }\n\n    appendExtraOutput() {\n        this.debug?.feature('append-extra-prefix-line') && Debug.log('---:append extra output:---');\n        const { listener, output , dataOutput} = this;\n        FormatterOptions.AppendExtraLiveOutput({ listener, output, dataOutput });\n    }\n    /**\n     * flush and get data\n     * @param {*} clear \n     * @returns {{buffer:string, data: string}}\n     */\n    flushAndData(clear){\n        const _refData = {};\n        const _buffer = this.flush(clear, _refData);\n        return {buffer: _buffer, data: _refData.dataOutput };\n    }\n    static AppendExtraLiveOutput({ listener, output, dataOutput }) {\n        if (listener?.appendExtraOutput) {\n            listener.appendExtraOutput({ output: output });\n        } else{\n            output.push('');\n            dataOutput.push('');\n        }\n    }\n    get bufferSegmentState(){\n        const { formatterBuffer } = this;\n        return {\n            bufferSegment : formatterBuffer.bufferSegment,\n            dataSegment : FormatterBuffer.dataSegment\n        };\n    }\n    /**\n     * get buffer states\n     */\n    get bufferState(){\n        return {\n            buffer: this.buffer,\n            data : this.data,\n            output:  this.output.slice(0),\n            dataOutput:  this.dataOutput.slice(0),\n            bufferSegments : this.formatterBuffer.bufferSegments,\n            dataSegments : this.formatterBuffer.dataSegments,\n        };\n    }\n\n    constantPattern(){\n        let _c =  this.sourceOption?.constantName || this.sourceOption?.name;\n        if (_c){\n\n            let _g = this.constants.refConstantClass;\n\n            return new _g(_c); \n        }\n        return this.constants.GlobalConstant; \n    }\n}\n\n\n\nexports.FormatterOptions = FormatterOptions;","\"use strict\";\nObject.defineProperty(exports, 'enModule', { value: true });\n\n\n\nclass FormatterPatternException extends Error{\n    constructor(msg, pattern, match, line){\n        if (line){\n            msg += ' At '+line;\n        }\n        super(msg);\n        Object.defineProperty(this, 'pattern', {get(){return pattern}});\n        Object.defineProperty(this, 'match', {get(){return match}});\n    }\n}\n\n\nexports.FormatterPatternException = FormatterPatternException;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n\n/**\n * formatter buffer setting\n */\nclass FormatterSegmentInfo{\n    #m_buffer;\n    #m_op;\n\n    constructor(buffer, op){\n        this.#m_buffer = buffer;\n        this.#m_op = op;\n    }\n    toString(){\n        return this.#m_buffer;\n    }\n    get buffer(){\n        return this.#m_buffer;\n    }\n    get isMarked(){\n        return this.#m_op != null;\n    }\n    get info(){\n        if (this.isMarked){\n            return this.#m_op;\n        }\n        return null;\n    }\n}\n\n\nexports.FormatterSegmentInfo = FormatterSegmentInfo;","\"use strict\";\n\nconst { Utils } = require(\"./Utils\");\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\n\nclass FormatterSegmentJoin{\n    /**\n     * \n     */\n    dataSegment;\n    /**\n     * \n     */\n    bufferSegment;\n\n    constructor(){\n    }\n\n    /**\n     * update segment data\n     * @param {*} segments \n     * @param {*} param1 \n     */\n    static UpdateSegmentData(segments,{dataSegment, bufferSegment}){\n        let joiner = new FormatterSegmentJoin();\n        joiner.dataSegment = dataSegment;\n        joiner.bufferSegment = bufferSegment;\n        joiner.updateData(segments);\n    }\n    /**\n     * \n     * @param {{bufferSegment:[], dataSegment:[]}} segments segment list to update\n     */\n    updateData(segments){\n        const {dataSegment, bufferSegment} = this;\n        const _length = segments.bufferSegment.length;\n        segments.bufferSegment.push(...bufferSegment);\n        segments.dataSegment.push(...dataSegment);\n        const { marked }  = bufferSegment;\n        const { FormatterBuffer } = Utils.Classes;\n\n        if (marked){\n            if(!('op' in marked)){\n                FormatterBuffer.InitOpMarkedSegment(marked);\n            }\n            // + | -------------------------\n            // + | - to - \n            // + | -------------------------            \n            if (!('marked' in segments.bufferSegment)){ \n                segments.bufferSegment.marked = FormatterBuffer.InitMarkedSegment();\n            }\n            let _i = 0;\n            let _d = segments.bufferSegment.marked;\n            marked.forEach(element => {\n                const _idx = element + _length;\n                if (!('op' in _d)){\n                    FormatterBuffer.InitOpMarkedSegment(_d);\n                }\n                _d.push(_idx);\n                let _ts = element in marked.op? marked.op[element] : null;\n                Utils.UpdateSegmentMarkerOperation(_d, _idx, _ts);  \n                _i++;\n            });\n        }\n    }\n   \n}\n \n\nexports.FormatterSegmentJoin =FormatterSegmentJoin","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', { value: true });\nconst { FormattingCodeStyles } = require('./FormattingCodeStyles');\nconst { FormattingBase } = require('./Formattings/FormattingBase');\nconst { TransformEngine } = require('./TransformEngine');\n\nclass FormatterSetting {\n    tabStop = \"\\t\";\n    lineFeed = \"\\n\";\n    blockOnSingleLine = true;\n    noSpaceJoin = false;\n    codingStyle = FormattingCodeStyles.K_R;\n    /**\n     * use source indent\n     * @var {boolean} \n     */\n    useIndent = false;\n    depth = 0;\n    line = 0;\n    /**\n     * depending on lanuage instruction separator can be a value \n     */\n    instructionSeparator = ';';\n    /**\n     * by default use the current  formatter instance\n     */\n    useCurrentFormatterInstance = true;\n\n    /**\n     * setup engine used to transform tokenID or captured expression - setting\n     * @var {?TransformEngine}\n     */\n    transformEngine\n\n\n    /**\n     * support end match logic technique\n     * @var {'before'|'after'} \n     */\n    endMatchLogic = 'before';\n\n    /**\n     * \n     * @param {*} parser\n     * @param {*} fieldname\n     * @param {*} data \n     * @param {*} refKey \n     * @param {*} refObj \n     */\n    json_parse(parser, fieldname, data, refKey, refObj) {\n        switch (fieldname) {\n            case 'codingStyle':\n                if (FormattingCodeStyles.Support(data)) {\n                    return data;\n                }\n                throw new Error(fieldname + ' not supported');\n            case 'transformEngine': \n                let engine = null;\n                if (data instanceof TransformEngine){\n                    engine = data;\n                }\n                if (typeof(data) == 'string'){\n                    engine = TransformEngine.CreateEngine(data);\n                } else {\n                    const {id, engine} = data;\n                    // init transform engine \n                    engine = TransformEngine.CreateEngine(data);\n                } \n                return engine;\n        }\n        return data;\n    }\n    /**\n     * get code style formattings\n     * @returns \n     */\n    getCodingStyleFormatting() {\n        return FormattingBase.Factory(this.codingStyle);\n    }\n    /**\n     * \n     * @param {*} ch \n     * @returns \n     */\n    isInstructionSeperator(ch) {\n        let g = this.instructionSeparator;\n        if (typeof (g) == 'string') {\n            g = g.split('|');\n        }\n        return g.indexOf(ch) != -1;\n\n    }\n}\nexports.FormatterSetting = FormatterSetting;","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterBuffer } = require('./FormatterBuffer');\nconst { SpecialMeaningPatternBase, Patterns } = require('./Formatters');\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\nconst { Utils } = require(\"./Utils\");\nconst { FormattingMode } = require(\"./Formattings/FormattingMode\");\nconst { Debug } = require(\"./Debug\");\n\nconst FORMATTER_ID = '_formatter_buffer_';\n/**\n * use to read stream buffer\n */\nclass FormatterStreamBuffer extends SpecialMeaningPatternBase {\n    name = 'system.formatter.stream.buffer';\n    formatterBuffer;\n    from;\n    initialMode = 1;\n    startPosition;\n    started = false;\n    closed = false;\n    marked = false;\n    endFoundListener;\n    /**\n  * backup source marker info\n  */\n    sourceMarkerInfo;\n    /**\n     * backup stream token list\n     */\n    sourceTokenList;\n\n\n\n    get matchType() {\n        return 4;\n    }\n    constructor() {\n        super();\n        this.formatterBuffer = new FormatterBuffer;\n        this.formatterBuffer.id = FORMATTER_ID;\n        let m_saved = { saved: false, started: false };\n        const self = this;\n\n        this.appendToBuffer = function (v, def) {\n            if (def) {\n                const {_marker, formatting} = def;\n                if (_marker && formatting && (_marker.mode != 1) ){\n                    let _buffer = this.formatterBuffer.buffer;\n                    v = formatting.joinStreamBuffer(_marker.mode, _buffer, v);\n                    this.formatterBuffer.clear();\n                }\n            }\n            this.formatterBuffer.appendToBuffer(v);\n            return v;\n        }\n        this.clear = function () {\n            this.formatterBuffer.clear();\n        }\n        Object.defineProperty(this, 'saved', { get() { return m_saved; } });\n        Object.defineProperty(this, 'buffer', { get() { return this.formatterBuffer.buffer; } });\n        Object.defineProperty(this, 'begin', { get() { return this.from?.begin; } });\n        Object.defineProperty(this, 'end', { get() { return this.from?.end; } });\n        Object.defineProperty(this, 'comment', { get() { return this.from?.comment; } });\n        Object.defineProperty(this, 'index', { get() { return this.from?.index; } });\n        Object.defineProperty(this, 'patterns', {\n            get() {\n                return this.from?.patterns;\n            },\n            set(v) {\n                throw new Error('failed to set patterns not allowed');\n            }\n        });\n\n        // Object.defineProperty(this, 'comment', {get:function(){\n        //     return \"Hello\";\n        // }});\n        const q = this;\n        Object.keys(FormatterStreamBuffer.prototype).forEach(a => {\n            if (/(from)/.test(a))\n                return;\n            Object.defineProperty(q, a, {\n                get: function () {\n                    // console.log(\"this from \", q.from?.marker.comment);\n                    return q.from ? q.from[i] : undefined;\n                }\n            });\n        });\n\n    }\n    get newLineContinueState() {\n        return false;\n    }\n    get throwErrorOnEndSyntax() {\n        return true;\n    }\n    get isEndCaptureOnly() {\n        return this.from.isEndCaptureOnly;\n    }\n    get isWhileCaptureOnly() {\n        return this.from.isWhileCaptureOnly;\n    }\n    get isBeginCaptureOnly() {\n        return this.from.isBeginCaptureOnly;\n    }\n    get patterns() {\n        return this.from?.patterns;\n    }\n    get indexOf() {\n        return this.from?.indexOf;\n    }\n    get endRegex() {\n        return this.from?.endRegex;\n    }\n\n    get marker() {\n        return this.from?.marker;\n    }\n\n    // class on end of file \n    stopAndExitStream(patternInfo, option, _bck, _restoreState, _old) {\n        const { from, parent } = this;\n        const { formatter, markerInfo } = option;\n\n        const _line = this.buffer;\n        let ret = null;\n        let bck = { line: option.line, pos: option.pos };\n        _restoreState(option, _bck);\n        formatter._onEndHandler(from, option);\n\n        if (bck.line.length == 0) {\n            option.formatterBuffer.appendToBuffer(_line);\n            this.clear();\n            return null;\n        }\n\n\n        option.setSourceLine(_line,0);\n\n        if (parent != null) {\n            throw new Error(\"not implement exit parent.\");\n        } else {\n            ret = this.moveToNextPattern(patternInfo, option, _old, from);\n        }\n        option.line = bck.line;\n        option.pos = bck.pos;\n        if (_old?.marker != from)\n        option.shiftAndRestoreFrom(from);\n        return ret;\n    }\n    /**\n     * \n     * @returns \n     */\n    handleMarkerListener(option) {\n        const q = this;\n        let _restored = false;\n        let _topStreamRemoved = false;\n        function _restoreSavedBuffer(option) {\n            let _nbuffer = option.buffer;\n            if (!_restored && (_nbuffer.length > 0)) {\n                q.appendToBuffer(_nbuffer);\n                //option.formatterBuffer.clear();\n            }\n        }\n        function _restoreState(option, _bck) {\n            if (_restored) {\n                return;\n            }\n            _restoreSavedBuffer(option);\n            option.appendToBufferListener = _bck.option.listener;\n            _restored = true;\n        };\n        function _restoreBackupState(parent) {\n            /**\n             * restore backup state mode \n             */\n            parent.mode = _bck.parentMode;\n        }\n        const _bck = q.saved;\n        if (!q.started) {\n            // save backup mode \n            q.started = true;\n            const { parent } = q.from;\n            if (parent) {\n                _bck.parent = parent;\n                //backup parent definition \n                _bck.parentMode = parent.mode;\n            }\n        } else {\n            if (_bck.parent) {\n                _bck.parent.mode = FormattingMode.FM_APPEND;\n            }\n        }\n\n        return function (markerInfo, option) {\n            // + | -----------------------------------------\n            // + | handle streaming buffer\n            option.stream = q;\n            const { debug } = option;\n            const _formatter = this;\n            let _next_position = option.pos;\n            let _buffer = q.buffer;\n            const { from } = q;\n            const _line = option.line.substring(option.pos);\n            let _p, _matcher;\n            const _markerInfo = option.markerInfo;\n            debug && Debug.log(\"::- HANDLE STREAMING -::\");\n            try {\n                if (!_bck.started) {\n                    // + | ------------------------------------------------------------------------\n                    // + |  move cursor in order to detect only children with pattern because buffered stream have no capture defined\n                    // + | \n\n                    _bck.started = true;\n                    //option.pos++;\n                }\n                ({ _p, _matcher } = _formatter.detectPatternInfo(_line, markerInfo, option, markerInfo));\n            } catch (e) {\n                // invalid stream tag selection \n                const cp = _markerInfo.shift();\n                if (_bck.saved) {\n                    _restoreState(option, _bck);\n                }\n                option.line = q.buffer + option.line.substring(option.pos);\n                throw e;\n            }\n            // + | REMOVE TOP STREAM MARKER \n            let _old = option.shiftAndRestoreFrom(markerInfo, false);\n            if (_old) {\n                _topStreamRemoved = true;\n            }\n            // + | here must get the definition for the parent - to update if required\n            _old = (_markerInfo.length > 0) ? option.shiftFromMarkerInfo(from, false) : null;\n            if (!_bck.saved) {\n                _bck.option = {\n                    listener: option.appendToBufferListener\n                };\n                // + | Set add to buffer listener : data\n                option.appendToBufferListener = (v, _marker, treat, option) => {\n                    let _buffer = option.buffer;\n                    const { formatting } = option.formatter;\n                    const _def = {_marker, formatting} ;\n                    if (treat && !q.from.formatter){\n                        v = option.treatValueBeforeStoreToBuffer(_marker, v);\n                    }\n\n\n                    if (_buffer.length > 0) {\n                        if (_buffer != option.glueValue){\n                        q.appendToBuffer(_buffer, _def);\n                        option.formatterBuffer.clear();\n                        }\n                    }\n                    if (v.length > 0)\n                        q.appendToBuffer(v, _def);\n                    return v;\n                };\n                _bck.saved = true;\n            }\n\n            option.storeRange(option.pos);\n            let r = null;\n            const endFound = FormatterStreamBuffer.HandleStreamEndFound(q, markerInfo, _bck, _formatter, _restoreState, _restoreBackupState);\n            q.endFoundListener = (_buffer, _line, patternInfo, _p, option, _old) => {\n                const g = endFound(_buffer, _line, patternInfo, _p, option, _old);\n                _restoreSavedBuffer(option);\n                return g;\n            };\n\n            if (option.EOF && (_p == null) && (_matcher == null)) {\n                return q.stopAndExitStream(markerInfo, option, _bck, _restoreState, _old);\n            }\n            if (option.TOEND) {\n                //return q.stopAndExitStream(markerInfo, option, _bck, _restoreState, _old);\n\n                let _ret = endFound.apply(option.formatter, [_buffer, _line, markerInfo, _p, option, _old]);\n\n                return _ret;\n            }\n\n\n            try {\n                if ((_old == null) && (_buffer.length > 0)) {\n                    // + | just start stream buffer \n                    _buffer = '';\n                }\n                if (!q.marked) {\n                    const _stream_old = _formatter._updateMarkerOldContentOrSwapBuffer(markerInfo, null, '', null, option);\n                    q.marked = true;\n                    _stream_old.endFound = endFound;\n                }\n\n                r = _formatter.handleMatchLogic({\n                    _p,\n                    _old,\n                    _matcher,\n                    _line,\n                    patternInfo: from,\n                    option: option,\n                    _buffer,\n                    endFound,\n                    handleConstant(patternInfo, _line, option) {\n                        if (_line.trim().length > 0) {\n                            option.appendToBuffer(_line, patternInfo);\n                        }\n                        option.pos += _line.length;\n                        if (_old) {\n                            option.unshiftMarker(_old);\n                            return _old.marker;\n                        }\n                        return markerInfo;// q.from;\n                    }\n                });\n\n                if (q.closed && q.marked) {\n                    option.shiftAndRestoreFrom(markerInfo, false);\n                }\n\n            } catch (e) {\n                // update buffer \n                console.log(\"End buffer..... \", e);\n                _restoreSavedBuffer(option);\n                _formatter.skipFormat();\n                return null;\n            }\n            _restoreSavedBuffer(option);\n            option.stream = null;\n            if (r && !(r instanceof PatternMatchInfo)) {\n                throw new Error(\"pattern not valid\");\n            }\n            if (!q.closed) {\n                if (r === q.from) {\n                    return markerInfo;\n                }\n            }\n\n            return r;\n        };\n    }\n\n    /**\n     * \n     * @param {*} patternInfo \n     * @param {*} option \n     * @param {*} _old \n     * @param {*} markerInfo \n     * @param {*} next_position \n     * @param {*} length \n     * @param {*} _tline \n     * @returns \n     */\n    moveToNextPattern(patternInfo, option, _old, markerInfo, next_position, length, _tline) {\n        const { parent, hostPatterns, streamAction, indexOf } = patternInfo;\n        const { lineMatcher } = option;\n        lineMatcher.reset();\n        lineMatcher.sourceLine = _tline || '';\n\n        option.storeRange(option.pos);\n        let _patterns = hostPatterns ?\n            Utils.GetPatternsList(hostPatterns, indexOf, streamAction) : [];\n\n        if (_patterns.length > 0) {\n            // + | handle matcher to line\n            let g = Utils.GetPatternMatcherInfoFromLine(option.line, _patterns, option, parent);\n            if (_old) {\n                if (_old?.marker == markerInfo) {\n                    option.restoreBuffer(_old);\n                }\n            }\n            if (g) {\n                // + | exit from - top pattern Info \n                _old = //option.shiftFromMarkerInfo(patternInfo);\n                    option.shiftAndRestoreFrom(patternInfo, false);\n                return g;\n            }\n            // skip to next position \n            if (parent === null) {\n                // + | ------------------------------------------------------------\n                // + | skip and continue\n                let _rindex = next_position - length;\n                let _append = option.line.substring(0, _rindex);\n                option.appendToBuffer(_append, option.constants.StreamLineConstant);\n                option.line = option.line.substring(_rindex);\n                option.pos = 0;\n                return null;\n            }\n\n        }\n        if (parent === null) {\n            // + | just append to buffer              \n            option.appendToBuffer(option.line, option.constants.StreamLineConstant);\n            option.pos = option.length;\n            return null;\n        }\n        return parent;\n    }\n    /**\n     * get marker end buffers \n     * @param {*} q \n     * @param {*} markerInfo \n     * @param {*} _bck \n     * @param {*} _formatter \n     * @param {*} _restoreState \n     * @param {*} _restoreBackupState \n     * @returns \n     */\n    static HandleStreamEndFound(q, markerInfo, _bck, _formatter, _restoreState, _restoreBackupState) {\n        return (_buffer, _line, patternInfo, _p, option, _old) => {\n            const { parent } = patternInfo;\n            const { formatter } = option;\n            const { endRegex } = markerInfo;\n            q.closed = true;\n            // + backup line \n            let _cpos = option.pos;\n\n            let _cbuffer = q.buffer;\n            let _nextCapture = null;\n            let _next_position = 0;\n            option.lineMatcher.reset()\n            //option.pos = 0;\n            _nextCapture = Utils.GetNextCapture(_line, endRegex, option);\n            option.storeRange(option.pos);\n            _next_position = _nextCapture.index + _nextCapture.offset;\n            if (!_nextCapture) {\n                throw new Error('missing capture');\n            }\n            const _end = _nextCapture[0];\n            const _sline = _line.substring(0, _nextCapture.index);\n            _line = _line.substring(_nextCapture.index + _end.length);\n            const _gline = _cbuffer + _sline + _end;\n            const _tline = FormatterStreamBuffer.GetBufferedLine(formatter,\n                _gline, option, patternInfo);\n            option.line = _tline + _line;\n            _restoreState(option, _bck);\n\n            // + | move buffer to parrent \n            _buffer = option.getBufferContent(true);\n            _old && option.restoreBuffer(_old);\n            if (_buffer.length > 0)\n                option.formatterBuffer.appendToBuffer(_buffer);\n            // + | unset marker option \n            formatter._onEndHandler(patternInfo, option);\n            if (parent) {\n                // + | end handler before handle parent\n                _restoreBackupState(parent);\n                const _idx = patternInfo.indexOf;\n                if (_idx === -1) {\n                    throw new Error('missing component. use index not valid');\n                }\n                // + | depend on streamAction passing to content to next|parent \n                // + | next: mean to child process\n                // + | parent: to parent buffer \n\n                // restart on parent by removing to handle logic\n                // let _patterns = Utils.GetPatternsList(patternInfo.hostPatterns, _idx, streamAction);\n                // if (streamAction == 'parent') {\n                //     return parent;\n                // }\n                // let g = Utils.GetPatternMatcherInfoFromLine(option.line, _patterns, option, parent);\n                // if (g) { // continue to cp\n                //     let cp = _formatter._handleMarker(g, option); \n                //     return cp;\n                // }\n                // move cursor \n                _cpos = _tline.length - _next_position;\n                let _gbuffer = _tline.substring(0, _cpos);\n                ({ _gbuffer, _cpos } = option.treatAndFormat(q, _gbuffer));\n                // update stored definition and move cursor to next\n                option.pos = _cpos;\n                option.storeRange(option.pos);\n                option.appendToBuffer(_gbuffer, option.constants.StreamBufferConstant);\n\n                // passing children to parent\n                if (parent && (patternInfo.childs.length > 0)) {\n                    patternInfo.childs.forEach(a => parent.childs.push(a));\n                }\n                return parent;\n            }\n            // + | put this line to buffer and skip   \n            return q.moveToNextPattern(patternInfo, option, _old, markerInfo,\n                _next_position,\n                _end.length, _tline);\n        }\n    }\n    /**\n     * \n     * @param {*} formatter \n     * @param {*} _src_line \n     * @param {*} option \n     * @param {*} patternInfo \n     * @returns \n     */\n    static GetBufferedLine(formatter, _src_line, option, patternInfo) {\n        const op = [];\n        const _group = [_src_line];\n        let _line = formatter.treatMarkerValue(patternInfo, _src_line, op, option, _group);\n        const _captures = patternInfo.streamCaptures || patternInfo.captures;\n        if (_captures) {\n            _line = Utils.TreatCapture(patternInfo, _captures, _line, [], option);\n        }\n        return _line;\n    }\n\n    /**\n     * \n     * @param {*} option \n     */\n    start(option) {\n        this.initialMode = option.nextMode;\n    }\n}\n\nexports.FormatterStreamBuffer = FormatterStreamBuffer;\n","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {value:true});\n\nclass FormatterSyntaxException extends Error{\n    At;\n\n    constructor(message, {lineCount}){\n        super(message);\n        this.At = lineCount;\n    }\n}\nexports.FormatterSyntaxException = FormatterSyntaxException;","\"use strict\";\nObject.defineProperty(exports, '__ESModule', {value: true});\n\nclass FormatterToken{\n    tokens;\n    tokenID;\n    value;\n    /**\n     * @var {boolan}\n     */\n    isRendered;\n};\nexports.FormatterToken = FormatterToken;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { NativeRegExp } = require('./NativeRegExp');\nconst { FormatterCloseParentInfo } = require('./FormatterCloseParentInfo');\nconst { Utils } = require(\"./Utils\");\nconst { Patterns } = require(\"./Patterns\");\nconst { RefPatterns } = require(\"./RefPatterns\");\nconst { JSonParser } = require(\"./JSonParser\");\nconst { Debug } = require(\"./Debug\");\nconst { FormatterListener } = require(\"./FormatterListener\");\nconst { FormatterSetting } = require(\"./FormatterSetting\");\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\nconst { CaptureInfo } = require(\"./CaptureInfo\");\nconst { CaptureRenderer } = require(\"./CaptureRenderer\");\nconst { FormatterBuffer } = require(\"./FormatterBuffer\");\nconst { FormatterOptions } = require(\"./FormatterOptions\");\nconst { FormattingCodeStyles } = require(\"./FormattingCodeStyles\");\nconst { HandleFormatting, FormattingMode, formattingSetupPatternForBuffer } = require(\"./Formattings/FormattingMode\");\nconst { FormatterMarkerInfo } = require(\"./FormatterMarkerInfo\");\nconst { RegexUtils } = require(\"./RegexUtils\");\nconst { BlockInfo } = require(\"./BlockInfo\");\nconst { FormatterPatternException } = require(\"./FormatterPatternException\");\nconst { FormatterToken } = require(\"./FormatterToken\");\nconst { FormatterDebugger } = require(\"./FormatterDebugger\");\nconst { FormatterEndMissingExpression } = require(\"./FormatterEndMissingExpression\");\nconst { FormatterEndMissingEngine } = require(\"./FormatterEndMissingEngine\");\nconst { FormatterSegmentJoin } = require(\"./FormatterSegmentJoin\");\nconst { FormatterErrors } = require(\"./FormatterErrors\");\n\n\n/**\n * @type IFormatterListener\n * @function renderToken\n * @params (value:string, tokenList:string, tokenId:string[]);\n */\n\n\n// + | --------------------------------------------------------\n// + | export pattern match information \n// + | --------------------------------------------------------\nUtils.Classes = {\n    RefPatterns,\n    Patterns, // replacement \n    PatternMatchInfo, // \n    CaptureInfo, // replacement\n    CaptureRenderer,\n    FormatterBuffer,\n    FormatterOptions,\n    FormattingCodeStyles,\n    Debug,\n    RegexUtils,\n    BlockInfo,\n    FormatterPatternException,\n    FormatterCloseParentInfo,\n    FormatterToken,\n    FormatterDebugger,\n    FormatterEndMissingExpression,\n    FormatterSegmentJoin\n};\n\nlet sm_globalEngine;\n/**\n * @var engine formatter\n */\nlet sm_engine_formatter;\n/**\n * formatters entry point\n */\nclass Formatters {\n    /**\n     * store object reference of lint errors\n     * @type {any}\n     */\n    lintErrors;\n    /**\n     * array of patterns to inject\n     */\n    patterns;\n    /**\n     * repository to inject\n     */\n    repository;\n    /**\n     * @type {?string}\n     */\n    scopeName;\n\n    /**\n     * selector definition to implements\n     * @type {?string}\n     * \"L:source.language\"\n     */\n    injectionSelector;\n    /**\n    * @type {?boolean}\n    */\n    debug; // allow debug\n    /**\n     * use to configure general setting\n     * @type {{}| undefined | null}\n     */\n    settings;\n\n    /**\n     * comment description \n     * @type {string}\n     */\n    comment;\n\n    /**\n     * array to declare used token id.\n     * @type {?string[]}\n     */\n    tokens;\n\n    foldingStartMarker;\n\n    foldingStopMarker;\n\n    fileTypes;\n\n    /**\n     * @type {string?}\n     */\n    uuid;\n\n    /**\n     * @type {string?}\n     */\n    firstLineMatch;\n\n    /**\n     * @type {?string}\n     */\n    data;\n\n    /**\n     * @type {?string}\n     */\n    buffer;\n\n\n    /**\n     * get engine formatter\n     * @var {null|{resolve(name:string):PatterMatchErrorInfo}}\n     */\n    static get EngineFormatter() {\n        return sm_engine_formatter;\n    }\n    /**\n     * set the engine formatter\n     */\n    static set EngineFormatter(value) {\n        sm_engine_formatter = value;\n    }\n\n    /**\n     * set global engine\n     */\n    static get GlobalEngine() {\n        return sm_globalEngine;\n    }\n    /**\n     * set global engine\n     */\n    static set GlobalEngine(v) {\n        sm_globalEngine = v;\n    }\n    static EndListenerArguments(marker, option){\n        return {\n            tokenID: marker.tokenID,\n            tokenList: option.tokenChains,\n            offset: option.offset,\n            sourceOffset: option.sourceOffset,\n            value: marker.value || (() => ({ value: option.buffer, source: option.data }))()\n        };\n    }\n    /**\n     * @type {IFormattersListener | undefined }\n     */\n    listener;\n\n    /**\n     * object setting definition \n     * @type {null| {}} \n     */\n    objClass;\n\n    /**\n     * info definition \n     * @type {null|{isSubFormatting:number, captureGroup:[]}}\n     */\n    info;\n\n    /**\n     * .ctr\n     */\n    constructor() {\n        /**\n         * @var {null|IFormatterListener}\n         */\n        let m_listener;\n        let m_objClass;\n        let m_info = {\n            isSubFormatting: 0,\n            captureGroup: null\n        };\n        this.debug = false;\n        this.patterns = [];\n        this.repository = {};\n\n        /**\n         * get or set the listener info\n         * @type {*}\n         */\n        Object.defineProperty(this, 'listener', { get() { return m_listener; }, set(value) { m_listener = value } })\n        /**\n             * get format info : use to update some current state\n             */\n        Object.defineProperty(this, 'info', { get() { return m_info; } })\n        Object.defineProperty(this, 'objClass', { get() { return m_objClass; } })\n\n\n        this.pushError = (e) => {\n            this.m_errors.push(\n                FormatterErrors[e]\n            );\n        }\n        this._storeObjClass = function (s) {\n            m_objClass = s;\n            delete this._storeObjClass;//  = null;\n        };\n\n\n    }\n\n    skipFormat() {\n\n        if (!('skip_r' in this)) {\n            const q = this;\n            (function () {\n                let _skip = true;\n                Object.defineProperty(q, 'skip_r', {\n                    get() {\n                        return _skip;\n                    },\n                    set(v) {\n                        _skip = v;\n                    }\n                });\n            })();\n        }\n\n    }\n    // + | ------------------------------------------------------------------------\n    // + | raise event \n    // + | \n    onAppendToBuffer(_marker, _buffer, option) {\n        this.formatting?.onAppendToBuffer(this, _marker, _buffer, option);\n        // + | ---------------------------------------------------------------------\n        // + | reset flag every time something append to buffer - update line segment\n        // + |\n        option.startLine = false;\n        option.lineFeedFlag = false;\n        option.blockStart = false;\n        option.matchTransform = null;\n        option.lastSegment = option.formatterBuffer.lastSegmentInfo();\n\n        option.lineSegments.push(option.lastSegment, option);\n    }\n    /**\n     * get the line feed\n     */\n    get lineFeed() {\n        return this.m_option.lineFeed;\n    }\n    /**\n     * set the line feed\n     */\n    set lineFeed(value) {\n        this.m_option = value;\n    }\n    json_keys() {\n        const n = 'repository';\n        let tab = Object.keys(this);\n        let idx = tab.indexOf(n);\n        delete (tab[idx]);\n        tab.unshift(n);\n        return tab;\n    }\n    /**\n     * validate current field name\n     * @param {*} field_name \n     * @param {*} d \n     * @returns bool\n     */\n    json_validate(field_name, d, throw_on_error) {\n        const validator = {\n            patterns(d) {\n                return Array.isArray(d);\n            },\n            repository(d) {\n                return typeof (d) == 'object';\n            },\n            debug(d) {\n                return typeof (d) == 'boolean' || /(yes|no|1|0)/.test(d);\n            },\n            settings(d) {\n                return (d == null) || typeof (d) == 'object';\n            },\n            scopeName(d) {\n                return (d == null) || typeof (d) == 'string';\n            }\n        };\n        let f = validator[field_name];\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * \n     * @param {*} parser \n     * @param {*} fieldname \n     * @param {*} data \n     * @param {*} refKey \n     * @returns \n     */\n    json_parse(parser, fieldname, data, refKey) {\n        const _pattern_class = parser.patternClassName || Patterns;\n        const patterns = Utils.ArrayPatternsFromParser(parser, Patterns, RefPatterns);\n        const parse = {\n            debug(d) {\n                if (typeof (d) == 'boolean') {\n                    if (d) {\n                        return FormatterDebugger.DebugAll();\n                    }\n                    return null;\n                }\n                return FormatterDebugger.Load(d);\n            },\n            lintErrors(d, parser) {\n                const _lints = {};\n                for (let i in d) {\n                    let s = d[i];\n                    let lint = new FormatterLintError;\n                    lint.code = parseInt(i);\n                    if (typeof (s) == 'string') {\n                        lint.message = s;\n                    } else {\n                        const { message, fix, concept } = s;\n                        lint.fix = fix;\n                        lint.message = message;\n                        lint.concept = concept;\n                    }\n                    _lints[i] = lint;\n                }\n                return _lints;\n            },\n            patterns,\n            repository(d, parser) {\n                let _out = {};\n                let _o = null;\n                const { registry } = parser;\n                for (let i in d) {\n                    _o = new _pattern_class();\n                    JSonParser._LoadData(parser, _o, d[i], i, _o);\n                    parser.initialize(_o);\n                    _out[i] = _o;\n                }\n                parser.repositoryKey = null;\n                return _out;\n            },\n            debug(d) {\n                if (typeof (d) == 'boolean') {\n                    return d;\n                }\n                return !(!d);\n            },\n            settings(d, parser) {\n                if (d == null) {\n                    return null;\n                }\n                let m = JSonParser._LoadData(parser, new FormatterSetting, d);\n                return m;\n            },\n            tokens(d, parser) {\n                if (Array.isArray(d)) {\n                    return d;\n                }\n                return null;\n            }\n        };\n        let fc = parse[fieldname];\n        if (fc) {\n            return fc(data, parser, refKey);\n        }\n        return data;\n    }\n    /**\n     * create and load the formatting marker \n     * @param {string} name \n     * @param {undefined|string|InjectedClass} pattern_class_name \n     * @returns {null|Formatters}\n     */\n    static Load(name, pattern_class_name) {\n        const data = require(\"../formatters/\" + name + \".btm-syntax.json\");\n        if (data) {\n            return Formatters.CreateFrom(data, pattern_class_name)\n        }\n        return null;\n    }\n    /**\n     * create module from btm-format\n     * @param {*} data btn-format data \n     * @param {undefined|string|InjectedClass} pattern_class_name \n     * @returns {null|Formatters}\n     */\n    static CreateFrom(data, pattern_class_name) {\n        const _names = {};\n        let _registryExpression = null;\n        NativeRegExp.Save();\n        const formatter = Utils.JSonParseData(Formatters, data, {\n            initialize(m) {\n                if (((m instanceof Patterns) || (m instanceof CaptureInfo)) && (m.name)) {\n                    this.registerName(m.name);\n                }\n            },\n            registerName(n) {\n                if (n.length <= 0) return;\n                _names[n] = 1;\n            }\n        }, pattern_class_name);\n        Object.defineProperty(formatter, 'registerNames', { get() { return _names; } });\n        formatter._funcRegistryExpression = function () {\n            if (_registryExpression != null) {\n                return _registryExpression;\n            }\n            let registry = {};\n            let _entry = [];\n            for (let i in _names) {\n                if (i == 'global') {\n                    throw new Error('global is reserved');\n                }\n                i.split(' ').forEach(m => {\n\n                    Utils.DefineProp(m, undefined, registry);\n                    let n = m.split('.')[0];\n                    if (_entry.indexOf(n) == -1) {\n                        _entry.push(n);\n                    }\n                });\n            }\n            _registryExpression = { namespaces: _entry, registry };\n            return _registryExpression;\n        };\n        if (!formatter.settings) {\n            formatter.settings = new FormatterSetting();\n        }\n\n        Object.defineProperty(formatter, 'formatting', { get() { return formatter.settings.getCodingStyleFormatting(); } });\n        Object.defineProperty(formatter, 'registryClassName', { get() { return pattern_class_name; } });\n        NativeRegExp.Restore();\n        return formatter;\n    }\n    static CreateDefaultOption() {\n        return new FormatterSetting;\n    }\n    #createListener() {\n        const { listener } = this;\n        let _o = null;\n        if (listener) {\n            if (typeof (listener) == 'function')\n                // + | invoke function listener creator\n                _o = listener.apply(this);\n            else\n                _o = listener;\n        }\n        return _o || new FormatterListener();\n    }\n    /**\n     * init marker definition\n     * @param {*} option \n     * @returns \n     */\n    #initDefinition(option) {\n        const _rg = option || this.settings || Formatters.CreateDefaultOption();\n\n        let _listener = this.#createListener();\n\n        let _formatterBuffer = new FormatterBuffer;\n        _formatterBuffer.id = '_global_';\n        const m_constants_def = {\n            PrevLineFeedConstant: new PrevLineFeedConstantPattern,\n            PrevConstant: new PrevConstantPattern,\n            GlobalConstant: new GlobalConstantPattern,\n            StreamLineConstant: new StreamLineConstantPattern,\n            StreamBufferConstant: new StreamBufferConstantPattern,\n            TrimmedPrevLineFeedConstant: new TrimmedPrevLineFeedConstant,\n            refConstantClass: RefConstantPattern\n        };\n        let objClass = new FormatterOptions(this, _formatterBuffer, _listener, m_constants_def, _rg);\n        this._storeObjClass(objClass);\n        return objClass;\n    }\n    /**\n     * transform data to \n     * @param {string|string[]} data \n     * @param {string} target\n     * @param {*} option \n     */\n    transformTo(data, target, option) {\n        throw new Error('transform not implement');\n    }\n    _initDebug() {\n        let { debug } = this;\n        if ((!debug === null) || (debug == undefined) || (debug instanceof FormatterDebugger))\n            return;\n        if (typeof (debug) == 'boolean') {\n            debug = debug ? FormatterDebugger.DebugAll() : null;\n        } else if (debug && !(debug instanceof FormatterDebugger)) {\n            debug = FormatterDebugger.Load(debug);\n        } else\n            debug = null;\n        this.debug = debug;\n    }\n    /**\n     * format the data\n     * @param {string|string[]} data \n     * @param {null|undefined|{name:string, constantName:string, depth:number, complete: null|()=>* = null}} option format option \n     * @returns \n     */\n    format(data, option=null) {\n        this._initDebug();\n        NativeRegExp.Save();\n        \n\n        if (!Array.isArray(data)) {\n            if (typeof (data) == 'string') {\n                data = data.split(\"\\n\");\n            }\n            else throw new Error('argument not valid');\n        }\n        if (typeof (this.scopeName) == 'undefined') {\n            throw new Error('scopeName is not defined');\n        }\n        let { objClass, info} = this;\n        /**\n         * @type {FormatterOptions}\n         */\n        //let objClass = this.objClass;\n        if (!objClass) {\n            objClass = this.#initDefinition(option);\n        } else {\n            if (info.isSubFormatting == 0) {\n                objClass.reset();\n            }\n        }\n        // setup source option\n        objClass.sourceOption = option;\n\n\n        let _matcherInfo = null;\n        let _formatter = this;\n        let _trimStart = true;\n        // let pos = 0;\n        const { debug, lineFeed } = objClass;\n        const { tabStop, useIndent } = this.settings;\n\n        if (!this.info?.isSubFormatting) {\n            objClass.blockStarted = false;\n        }\n        if (this.info?.isSubFormatting) {\n            _trimStart = false;\n        }\n\n        const _trimEndOutput = (_output, option) => {\n            if (option.lastSegment?.info?.trimmed) {\n                const g = option.lastSegment.toString();\n                // + | trim last segment  \n                while (_output.length > 0 && (_output.endsWith(g))) {\n                    _output = _output.substring(0, _output.length - g.length - 1).trimEnd();\n                }\n            }\n            return _output;\n        };\n        // option = objClass;\n        // + | ------------------------------------------------------------\n        // + | START : FORMATTER LOGIC\n        // + | ------------------------------------------------------------\n        const _output_fc = () => {\n            const { formatting } = _formatter;\n\n            function _update_start_line_flag(_start_line_flag, option) {\n                const { pos } = option;\n                if (!_start_line_flag && option.skipMarkerFlag && (option.range.start < pos)) {\n                    let _l = option.line.substring(option.range.start, pos);\n                    if (_l.trim().length > 0)\n                        option.appendToBuffer(_l, option.constantPattern());\n                    option.storeRange(pos);\n                    option.skipMarkerFlag = false;\n                }\n            }\n            const _is_sub_formatting = _formatter.info.isSubFormatting > 0;\n            const { lineMatcher, lineSegments } = objClass;\n            let _nextLineOffset = 0;\n\n            data.forEach((line) => {\n                // + | update next line offset\n                objClass.lineOffset = _nextLineOffset;\n                _nextLineOffset += line.length + 1; \n                // + | start \n                let _start_line_flag = false; // flag to handle end streaming content\n                lineSegments.clear(); // reset line segments\n                if (this.skip_r) {\n                    return;\n                }\n                /**\n                 * @type {FormatterOptions} \n                 */\n                const option = objClass;\n                debug?.feature('read-line') && Debug.log('read:[' + objClass.lineCount + \"]:::\" + line);\n                objClass.resetRange();\n                lineMatcher.sourceLine = line;\n                objClass.continue = false;\n                objClass.lineCount++;\n                objClass.markerDepth = 0;\n                objClass.startLine = true;\n                if (_matcherInfo) {\n                    if (!_matcherInfo.marker.allowMultiline) {\n                        throw new Error(`marker '${_matcherInfo.name}' do not allow multi line.`);\n                    }\n                    objClass.continue = _matcherInfo.marker.newLineContinueState;\n                    objClass.lineJoin = false;\n                    _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n\n                } else {\n                    let _nextLine = (_trimStart && !useIndent ? objClass.line.trimStart() : objClass.line);\n                    if (objClass.nextGlueValue) {\n                        _nextLine = objClass.nextGlueValue + _nextLine;\n                        objClass.nextGlueValue = null;\n                    }\n                    // + | update offset line \n                    let _nextPosOffset = objClass.line.length - _nextLine.length;\n                    //_nextLineOffset+= _nextPosOffset;\n                    objClass.lineOffset += _nextPosOffset;\n                    // update the source line\n                    lineMatcher.sourceLine = _nextLine;\n                    _trimStart = true;\n                }\n                if (line.length <= 0) {\n                    return;\n                }\n                let ln = objClass.length;\n                let pos = objClass.pos;\n                _formatter._updateLineFeed(objClass, (pos == 0) && !objClass.lineFeedFlag);\n                objClass.loopStart();\n                let _lastPost = pos;\n                while (pos < ln) {\n                    objClass.continue = false;\n                    _start_line_flag = true;\n                    objClass.markerDepth = 0;\n                    _lastPost = pos;\n                    if (_matcherInfo) {\n                        objClass.continue = true;\n                        objClass.storeRange(objClass.pos);\n                        _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                    } else {\n                        _matcherInfo = Utils.GetPatternMatcher(this.patterns, objClass);\n                        if (_matcherInfo) {\n                            this._updateLineFeed(objClass, objClass.startLine);\n                            objClass.storeRange(pos, _matcherInfo.index);\n                            _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                            _update_start_line_flag(false, objClass);\n                        } else {\n                            objClass.markerDepth = 0;\n                            let p = objClass.line.substring(objClass.pos);\n                            if (!_is_sub_formatting)\n                                p = p.trimEnd();\n                            if (objClass.lineFeedFlag) {\n                                p = _trimStart && !useIndent ? p.trimStart() : p;\n                            }\n                            if (p.length > 0) {\n                                this._updateLineFeed(objClass, objClass.startLine);\n                                objClass.appendToBuffer(p, objClass.constantPattern());\n                            }\n                            objClass.pos = ln;\n                        }\n                    }\n                    pos = objClass.pos;\n                    ln = objClass.length;\n                    ((option) => {\n                        const { loopInfo } = option;\n                        if (_lastPost == pos) {\n                            // + | possibility of infine loop detection\n                            if (loopInfo.matcher != _matcherInfo) {\n                                loopInfo.matcher = _matcherInfo;\n                            }\n                            loopInfo.position = pos;\n                            if (loopInfo.count > 1) {\n                               throw new Error('infine loop detected : ' + JSON.stringify(loopInfo));\n                               //console.log(\"apply ... \", {ln, pos,  count: loopInfo.count });\n                            }\n                            loopInfo.count++\n                        } else {\n                            loopInfo.count = 0;\n                        }\n                    })(objClass);\n                    if (this.skip_r) {\n                        return;\n                    }\n                    _update_start_line_flag(_start_line_flag, objClass);\n                }\n                _update_start_line_flag(_start_line_flag, objClass);\n\n                objClass.lineJoin = true;\n                if (_matcherInfo) {\n                    if (ln >= pos) {\n                        if (1 || !objClass.skipEndOfLine) {\n\n                            objClass.EOL = true;\n                            if (_matcherInfo.isCaptureToEndLine(objClass)) {\n                                objClass.lineMatcher.setPosition(pos, pos);\n                            }\n                            _matcherInfo = _formatter._handleCheckCloseMarker(_matcherInfo, objClass);\n                            objClass.EOL = false;\n                        } else {\n\n                            objClass.skipEndOfLine = false;\n                        }\n                    } else {\n                        this._updateMarkerFormatting(_matcherInfo, objClass);\n                    }\n                }\n                formatting.updateEndLineUpdateMode(_matcherInfo, option);\n            });\n            if (this.skip_r) {\n                this.skip_r = false;\n                return null;\n            }\n            ((option) => {\n                // + | close matcher \n                if (_matcherInfo) {\n                    if (!this.info.isSubFormatting) {\n                        debug && Debug.log('...EOF...' + _matcherInfo.toString());\n                        option.EOF = true;\n                        option.lineMatcher.reset();\n                        // option.lineMatcher.offset = 61;\n                        //option.lineMatcher.setPosition(option.length);\n                        while (_matcherInfo) {\n                            //\n                            // + | close matcher - handle \n                            //\n                            _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                            option.lineMatcher.reset();\n                        }\n                        option.EOF = false;\n                    } else {\n                        if (_matcherInfo.parent)\n                            throw new Error('missing close definition');\n                    }\n                }\n            })(objClass);\n\n            debug?.feature('end') && (() => {\n                Debug.log('...end...');\n                console.log({\n                    depth: objClass.depth\n                });\n            })();\n            if ((objClass.markerInfo.length > 0) && (this.info.isSubFormatting == 0)) {\n                const _formatting = this.formatting;\n                // missing close marker info \n                while (objClass.markerInfo.length > 0) {\n                    let _old = objClass.shiftMarker();\n                    this._handleLastExpectedBlock(_old, objClass, _formatting);\n                }\n\n            } else {\n                objClass.markerInfo.length = 0;\n            }\n            objClass.store();\n            let _output = \"\";\n\n            if (!this.info?.isSubFormatting && (objClass.tokenList.length > 0)) {\n                throw new Error('token list have childs');\n            }\n            if (!this.info?.isSubFormatting && this.listener) {\n                // + | call end listener \n                const { listener } = this.objClass;\n                const { endContent, endOutput, treatOutput } = listener;\n                if (treatOutput) {\n                    _output = listener.treatOutput({ output: objClass.output, lineFeed, tabStop, option: this.objClass });\n                } else {\n                    _output = objClass.output.join(lineFeed).trimEnd();\n                    _output = _trimEndOutput(_output, objClass);\n\n                }\n                if (endOutput) {\n                    _output += listener.endOutput({ lineFeed });\n                }\n                if (endContent) {\n                    _output += listener.endContent();\n                }\n            } else {\n                _output = objClass.output.join(lineFeed);\n                if (!this.info?.isSubFormatting) {\n                    _output = _output.trimEnd();\n                    _output = _trimEndOutput(_output, objClass);\n                }\n            }\n            // + | clear buffer list  \n            this.objClass.formatterBuffer.clearAll();\n            return _output;\n        };\n        let _output = null;\n        try {\n            _output = _output_fc();\n            if ((this.info.isSubFormatting == 0) && (typeof (option?.complete) == 'function')) {\n                option.complete({ formatter: this });\n            }\n        } catch (e) {\n            if (this.error) {\n                if (!Array.isArray(this.error)) {\n                    this.error = [this.error];\n                }\n                this.error.push(e.message);\n            }\n            else {\n                this.error = e.message;\n            }\n            debug && console.error('Error : ' + e.message);\n        }\n        NativeRegExp.Restore();\n        return _output;\n    }\n    _updateLineFeed(option, startLine = false) {\n        if (option.skipUpdateStartLine) {\n            option.skipUpdateStartLine = !1;\n            return;\n        }\n        option.startLine = startLine;\n        if (option.lineFeedFlag) {\n            if (!option.formatterBuffer.isEmpty) {\n                option.store();\n                option.lineFeedFlag = !1;\n            }\n            option.startLine = true;\n        }\n    }\n    /**\n     * check for closing do not update markerInfo - specification \n     * @param {*} patternInfo \n     * @param {FormatterOptions} option \n     */\n    _handleCheckCloseMarker(patternInfo, option) {\n        const { debug } = option;\n        debug && Debug.log(\"---::check close marker::---\" + patternInfo.toString());\n        let _p = null;\n        let _matcher = null;\n        let _line = option.line.substring(option.pos);\n        // for check get and check if _old is avaiable \n        // let _old = (markerInfo.length > 0) && (markerInfo[0].marker == patternInfo) ? markerInfo[0] : null;\n        ({ _p, _matcher } = this.detectPatternInfo(_line, patternInfo, option));\n        if (_p && (_matcher == null)) {\n            return this._handleMarker(patternInfo, option);\n        }\n        if (_p && _matcher) {\n            if (_matcher.group.index == _p.index) {\n                // + | priority to pattern info\n                // + | ---------------------\n                let _tpret = this._handleMarker(patternInfo, option);\n                // + | same group end -\n                return _tpret;\n            }\n        }\n        if (_matcher) {\n            // + | a matcher that target end on line\n            if (_matcher.isStreamCapture) {\n                // + | start new stream capture \n                const cp = this._startStreamingPattern(_matcher, '', null, option, null, null, '', true);\n                return cp;\n            }\n            return this._handleMarker(_matcher, option);\n        }\n        return patternInfo;\n    }\n    _handleSameGroupMatch(_matcher, option) {\n        this._checkStartBlockDefinition(_matcher, option);\n        let _ref = this._handleMarker(_matcher, option);\n        return _ref;\n    }\n    /**\n     * update marker formatting mode\n     * @param {*} _marker \n     * @param {*} option \n     * @param {*} force \n     */\n    _updateMarkerFormatting(_marker, option, force = false) {\n        // | update formatting \n        const { formatting } = this;\n        if (_marker.formattingMode) {\n            formatting.formatBufferMarker(this, _marker, option, force);\n        } else {\n            this._updateNextMode(option, _marker, force);\n        }\n    }\n    updateBuffedValueAsToken(_buffer, _marker, option) {\n        option.formatterBuffer.clear();\n        option.appendToBuffer(_buffer, _marker);\n        option.store();\n        _buffer = option.flush(true);\n        option.formatterBuffer.appendToBuffer(_buffer, _marker);\n    }\n    /**\n     * check for last missing value - \n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _old \n     * @returns \n     */\n    _lastExpectedMatchResult(marker, option, _old) {\n        // + | check for last missing value\n        // const _formatting = this.formatting;\n        const { endMissingValue, group, isEndCaptureOnly } = marker;\n        let _p = [];\n        let regex = '';\n        if (!isEndCaptureOnly) {\n            if ((endMissingValue != undefined) && (endMissingValue !== null)) {\n\n                if (endMissingValue instanceof FormatterEndMissingExpression) {\n                    const engine = FormatterEndMissingEngine.Get(this.scopeName);\n                    // _value = _old?.data.dataSegment.join('') || group[0];\n                    let _cvalue = endMissingValue.load(group,\n                        (s) => Utils.ReplaceRegexGroup(Utils.RegExToString(s), group),\n                        engine, _old?.data, marker, option);\n                    if (_old) {\n                        // + update value - content value\n                        _old.content = _cvalue;\n                        _p = Utils.CreateEndMatch('');\n                        return _p;\n                    }\n                } else {\n                    regex = Utils.ReplaceRegexGroup(endMissingValue, group);\n                }\n            } else {\n                if (_old && (_old.marker.end.toString() != \"/$/d\"))\n                    regex = Utils.ReplaceRegexGroup(Utils.RegExToString(marker.end), group);\n            }\n            //remove escaped litteral\n            regex = regex ? regex.replace(/\\\\/g, \"\") : '';\n        }\n        _p.push(regex);\n        _p.indices = [[0, regex.length]];\n        _p.index = 0;\n        _p.input = '\\0';\n        return _p;\n    }\n    _handleLastExpectedBlock(_old, option, _formatting) {\n\n        const { marker } = _old;\n        const _group = marker.group;\n        if (marker.marker.throwErrorOnEndSyntax) {\n            throw new Error('invalid syntax');\n        }\n        if (marker.isEndCaptureOnly) {\n            return;\n        }\n        let regex = '';\n        const line = option.line;\n        let _append = line.substring(_group.index);\n\n        if (_old.marker.end.toString() != \"/$/d\")\n            regex = Utils.ReplaceRegexGroup(Utils.RegExToString(marker.end), _group, 'end');\n        regex = regex.replace(/\\\\/g, \"\"); //remove escaped litteral\n        _formatting.onLastExpectedBlockStart({ option, _old });\n        let _p = [];\n        let f = null;\n        _p.push(regex);\n        _p.indices = [[0, regex.length]];\n        _p.index = 0;\n        if (marker.isBlock) {\n            option.line = regex;\n            option.pos = 0;\n            let _buffer = option.buffer;\n            f = _formatting.onLastExpectedBlock({\n                mode: marker.mode,\n                buffer: _buffer,\n                option: option,\n                formatter: this\n            });\n\n            f = f == null ? _old.content + option.flush(true) : f;\n            return this._handleFoundEndPattern(f, regex, marker, _p, option, _old);\n        }\n\n        const _ln = _append.length;\n        _p.index = _ln;\n        _append += regex;\n        option.pos = _ln;\n        option.storeRange(_ln);\n        return this._handleFoundEndPattern('', _append, marker, _p, option, _old);\n    }\n\n    _isBlockAndStart(_marker, option) {\n        return _marker.isBlock && !option.continue;\n    }\n\n    /**\n     * \n     * @param {FormatterOptions} option \n     */\n    _startBlock(option) {\n        option.depth++;\n        const { output, tabStop, depth, formatterBuffer, listener } = option;\n        if (typeof (listener?.startNewBlock) == 'function') {\n            listener.startNewBlock({ buffer: '', formatterBuffer, output, tabStop, depth });\n        }\n        // + | \n        // + | begin start block \n        // + | \n        option.startBlock = true;\n    }\n    /**\n     * get new tokens array \n     * @returns \n     */\n    getTokens() {\n        return [this.scopeName];\n    }\n    /**\n     * get Marker captures depending on markerInfo\n     * @param {CaptureInfo|PatternMatchInfo} _markerInfo \n     * @param {*} end \n     * @returns \n     */\n    getMarkerCaptures(_markerInfo, end = false) {\n\n        if (_markerInfo instanceof CaptureInfo) {\n            return _markerInfo.captures;\n        }\n        const { marker } = _markerInfo;\n        if (!marker) {\n            return null;\n        }\n        const _type = marker.matchType;\n        if (_type == 0) {\n            const s = end ? marker.endCaptures : marker.beginCaptures;\n            return { ...marker.captures, ...s };\n        }\n        return { ...marker.captures };\n    }\n\n    /**\n     * register token name\n     * @param {PatternMatchInfo} marker \n     * @param {FormatterOptions} option \n     */\n    _registerTokenName(marker, option) {\n        const { name, isShiftenName, matchType } = marker;\n        const { tokenList } = option;\n        //+ | add token to global token list \n        if (name && (matchType == 0) && (!isShiftenName)) {\n            Utils.StoreTokens(name, tokenList);\n            marker.isShiftenName = true;\n        }\n    }\n    _updatePrevPatternPrevConstant(_marker, option) {\n        this._updatePatternPrevConstant(_marker, option);\n        option.storeRange(option.pos);\n    }\n    /**\n     * core handle marker handle marker \n     * @param {PatternMatchInfo} _marker \n     * @param {*} option \n     */\n    _handleMarker(_marker, option) {\n        if (!_marker) return;\n        if (!option.continue) {\n            this._updatePrevPatternPrevConstant(_marker, option);\n        }\n\n        const { matchType } = _marker.marker;\n        this._registerTokenName(_marker, option);\n        option.markerDepth++;\n        // + | each callback must return a marker or null \n        const handle = this._handleCallback(matchType, option) ||\n            ((m, option) => m.handleMarkerListener ? m.handleMarkerListener(option) : null)(_marker.marker, option);\n        if (!handle || (typeof (handle) != \"function\")) {\n            throw new Error(\"marker type handler is not a valid callback.\" + matchType);\n        }\n        let ret = handle.apply(this, [_marker, option]);\n        this._updateFormatModeFromTo(_marker, ret, option);\n        return ret;\n    }\n    /**\n     * replace with condition \n     * @param {PatternMatchInfo} _marker \n     * @param {*} value \n     * @param {*} group \n     * @param {*} option \n     * @param {*} _refObj \n     * @param {boolean} treat \n     * @returns \n     */\n    _operationReplaceWith(_marker, value, group, option, _refObj, treat = true) {\n        let _formatter = this;\n        const { replaceWith, replaceWithCondition } = _marker;\n        let g = group;\n        _refObj = _refObj || {};\n        if (!replaceWith) {\n            _refObj.replaced = false;\n            return value;\n        }\n        let _tab = replaceWith;\n\n        if (_tab instanceof ReplaceWithCondition) {\n            _tab = [_tab];\n        }\n        if (Array.isArray(_tab)) {\n            _tab = _tab.slice(0);\n\n            // + array of replace with conditions\n            while (_tab.length > 0) {\n                const q = _tab.shift();\n                const { expression, match, captures } = q;\n                if (!expression) {\n                    // + | skip missing expression\n                    continue;\n                }\n                if (match) {\n                    const _p = { replaced: true, g, _rpw: null };\n                    const tvalue = Utils.ReplaceWithCheck(expression, value, q, _p);\n                    if (_p.replaced) {\n                        const { _rpw } = _p;\n                        value = Utils.DoReplaceWith(tvalue, _formatter, _rpw, g, _marker, option, captures, treat);\n\n                        return value;\n                    }\n                }\n            }\n        }\n        else {\n            let _rpw = Utils.RegExToString(replaceWith);\n            const _cond = replaceWithCondition;\n            let match = _cond?.match;\n            const _captures = _cond?.captures;\n\n            if (match) {\n                let _op = _cond.operator || '=';\n                let _s = Utils.ReplaceRegexGroup(_cond.check, g);\n                if (/(!)?=/.test(_op)) {\n                    let r = match.test(_s);\n                    if (_op) {\n                        if (((_op == '=') && !r) || ((_op == '!=') && (r))) {\n                            _refObj.replaced = false;\n                            return value;\n                        }\n                    }\n                } else if (/(\\<\\>)=/.test(_op)) {\n                    let _ex = match.toString().replace(/\\\\\\//g, '');\n                    if (\n                        ((_op == \">=\") && (_s >= _ex)) ||\n                        ((_op == \"<=\") && (_s <= _ex))\n                    ) {\n                        if (_s >= _ex) {\n                            _refObj.replaced = false;\n                            return value;\n                        }\n                    }\n                }\n            }\n\n            value = Utils.DoReplaceWith(value, _formatter, _rpw, g, _marker, option, _captures, treat);\n            return value;\n        }\n        _refObj.replaced = false;\n        return value;\n    }\n    /**\n     * from type retrieve the handler type \n     * @param {*} type \n     * @returns \n     */\n    _handleCallback(type, option) {\n        // + handle callback\n        return {\n            \"0\": option.listener?.handleBeginEndMarker || this._handleBeginEndMarker,\n            \"1\": option.listener?.handleMatchMarker || this._handleMatchMarker,\n            \"2\": option.listener?.handleBeginWhile || this._handleBeginWhile,\n            \"3\": option.listener?.handleMatchTransform || this._handleMatchTransform,\n        }[type]\n    }\n    _handleMatchTransform(marker, option) {\n        const { parent } = marker;\n        let _cm_value = marker.group[0];\n        let op = [];\n        this._registerTokenName(marker, option);\n        _cm_value = this.treatMarkerValue(marker, _cm_value, op, option, marker.group, true);\n        if (_cm_value.length > 0) {\n            if (op.data) {\n                option.formatterBuffer.appendToBuffer({\n                    dataSegments: op.data.dataSegment,\n                    bufferSegments: op.data.bufferSegment\n                });\n            } else\n                option.appendToBuffer(op.data, marker);\n        }\n        option.matchTransform = marker;\n        return parent;\n\n    }\n    _onStartMarker(markerInfo, option, { type }) {\n        const { listener } = this;\n        if (listener?.onStartHandler)\n            listener.onStartHandler(markerInfo, option, { type,\n         formatter: this ,\n         isSubFormatting: this.info.isSubFormatting > 0});\n\n    }\n    /**\n     * on end handler\n     * @param {PatternMatchInfo} markerInfo \n     * @param {FormatterOptions} option \n     */\n    _onEndHandler(markerInfo, option) {\n        const { tokenList } = option;\n        const { listener } = this;\n\n        if (listener?.onEndHandler)\n            listener.onEndHandler(markerInfo, option,{\n        isSubFormatting: this.info.isSubFormatting > 0,\n        ...Formatters.EndListenerArguments(markerInfo, option)\n        }, this);\n\n        if (markerInfo.isShiftenContentName) {\n            this._shiftPatternContentName(markerInfo, option);\n        }\n        if ((markerInfo.isShiftenName) && (tokenList.length > 0)) {\n            Utils.UnshiftTokens(markerInfo.name, tokenList);\n            markerInfo.isShiftenName = false;\n        }\n        // reset option flag\n        if (option.isGlueValue) {\n            console.log(\"glue value\");\n        }\n    }\n    /**\n     * \n     * @param {*} _cm_value \n     * @param {*} _marker \n     * @param {*} option \n     * @param {FormatterMatchTreatment} _op \n     * @param {*} group \n     * @param {boolean} group match treatment\n     * @param {boolean} treat treatement\n     * @returns \n     */\n    _treatMatchValue(_cm_value, _marker, option, _op, group, treat = true) {\n        group = group || _marker.group;\n        const _ref_segment = treat ? {} : true;\n        _cm_value = this.treatMarkerValue(_marker, _cm_value, _op, option, this._getMatchGroup(group), _ref_segment);\n        if (treat) {\n            if (_op.treated) {\n                _op.data = _ref_segment.segments.dataSegment.join('');\n                _op.segments = _ref_segment.segments;\n                return _cm_value;\n            }\n            const _bck = _cm_value;\n            _cm_value = this._treatMatchResult(_cm_value, _op, _marker, option);\n            // + | update op.data  to store data to store after match treated\n            if ((_op.indexOf('replaceWith') != -1) || (_cm_value != _bck)) {\n                _op.data = _bck;\n            }\n        }\n        return _cm_value;\n    }\n    /**\n     * treat transform capture\n     * @param {*} _cm_value \n     * @param {*} _marker \n     * @param {*} _captures \n     * @returns \n     */\n    _treatTransform(_cm_value, _marker, _captures) {\n        const _tmatch = _marker.transformMatch || _marker.match;\n        _captures = _marker.transformCaptures || _captures;\n        if ((_cm_value.length > 0) && (_captures)) {\n\n            // + passing transformed to data\n            const _group = _tmatch ? _tmatch.exec(_cm_value) : null;\n            if (_group) {\n                // copy groups\n                _group.index = _marker.group.index;\n                _marker.group.length = 0;\n                _marker.group.indices = _group.indices;\n                _group.forEach(a => _marker.group.push(a));\n            } else {\n                if (_marker.matchType == 1)\n                    throw new Error(\"failed transform error match error. use transform capture to handle\")\n            }\n        }\n        return { _captures };\n    }\n    _treatMatchResult(_cm_value, _op, _marker, option) {\n        let _captures = _marker.captures;\n        if (_op.indexOf('transform') != -1) {\n            ({ _captures } = this._treatTransform(_cm_value, _marker, _captures));\n        }\n        if (_op.indexOf('replaceWith') == -1) {\n            if (_captures) {\n                _cm_value = option.treatBeginCaptures(_marker, _captures);\n            }\n        }\n        if (_marker.patterns?.length > 0) {\n            const new_value = Utils.TreatPatternValue(_cm_value, _marker.patterns, _marker.group, option);\n            _cm_value = new_value || _cm_value;\n        }\n        return _cm_value;\n    }\n\n    _getMatchGroup(group) {\n        const _formatter = this;\n        return (_formatter.info.isSubFormatting > 0) ?\n            _formatter.info.captureGroup : group;\n    }\n    _operateOnFramebuffer(_marker, option, _old) {\n        return HandleFormatting.apply(this, [_marker, option, _old]);\n    }\n    /**\n     * handle to end \n     */\n    _handleToEndPattern(_marker, line, option) {\n        const bck = { line: option.line, pos: option.pos };\n        let _ret = null;\n\n        if (_marker.isStreamCapture) {\n            // + | Update Stream Marker Info\n            this._updateMarkerOldContentOrSwapBuffer(_marker, null, '', _marker.endRegex, option);\n        }\n        option.setSourceLine(line);\n        option.TOEND = true;\n        _ret = this._handleMarker(_marker, option);\n        option.TOEND = false;\n        option.setSourceLine(bck.line, bck.pos + option.pos);\n        return _ret;\n    }\n    /**\n     * detected array operation\n     * @param {{replaceWith:string|RegExp, transform:string|string[]}} _marker \n     * @param {string} c value \n     * @param {string[]} op detected operatrion\n     * @param {*} option to handle start line transform \n     * @param {*} group to handle start line transform \n     * @param {?boolean} treat to handle start line transform \n     * @returns \n     */\n    treatMarkerValue(_marker, c, op, option, group, treat = true) {\n        if (_marker.replaceWith) {\n            // + | do replaceWith - replace \n            const _refObj = { replaced: true };\n            const _treat = treat === true ? {} : treat;\n            c = this._operationReplaceWith(_marker, c, group || _marker.group, option, _refObj, _treat);\n            if (_refObj.replaced) {\n                op.push('replaceWith');\n                op.data = _treat.segments;\n            }\n        }\n        if (_marker.transform && (op.indexOf('replaceWith') == -1)) {\n            // + | do transform\n            c = Utils.StringValueTransform(c, _marker.transform);\n            op.push('transform');\n        }\n        if (option && (option.startLine) && _marker.startLineTransform) {\n            c = Utils.StringValueTransform(c, _marker.startLineTransform);\n            op.push('startLineTransform');\n        }\n        return c;\n    }\n    treatEndMarkerValue(marker, option ){\n        const c = marker.value.source;\n        const group = [c];\n        const op = [];\n        if (marker.replaceWith){\n\n            let r = this.treatMarkerValue(marker, c, op, option, group, true);\n\n           // console.log(\"sample \", c, r);\n            // marker.value = {\n            //     'source':r,\n            //     'data':r\n            // };\n            option.formatterBuffer.clear(); \n            option.formatterBuffer.appendToBuffer(r);\n            \n        }\n    }\n    /**\n     * append constant\n     * @param {*} patternInfo \n     * @param {string} value \n     * @param {FormatterOptions} option \n     * @param {bool} append_child append to child \n     * @param {*} constant_type_marker type matcher\n     */\n    _appendConstant(patternInfo, value, option, append_child = true, constant_type_marker = null) {\n        let { debug, listener } = option;\n        let { formatting } = this;\n        debug?.feature('render/constant') && Debug.log('--::appendConstant::--[' + value + ']');\n        let _fempty = (value.trim().length == 0);\n        if (option.startBlock && _fempty) {\n            return;\n        }\n\n        let _def_type = option.constants.PrevLineFeedConstant;\n        value = formatting.treatConstantValue(value, patternInfo, option);\n        if (_fempty) {\n            // + | can be trimmed\n            _def_type = option.constants.TrimmedPrevLineFeedConstant;\n        }\n        let _inf = new PatternMatchInfo;\n        _inf.use({ marker: constant_type_marker || _def_type, line: option.line, index: -2, formatting });\n\n        formattingSetupPatternForBuffer(patternInfo, option);\n        const fc_update = () => {\n            formatting.updateBufferConstant(value, patternInfo.mode, _inf, option);\n        }\n        if (append_child) {\n            patternInfo.childs.push(_inf);\n        }\n        if (listener?.appendConstant) {\n            listener.appendConstant({ update: fc_update, patternInfo, data: value, option, _inf });\n        } else {\n            fc_update();\n        }\n        // + | \n        // + | missing update pattern mode from constant logic\n        // + |\n        patternInfo.mode = _inf.mode;\n    }\n\n    /**\n     * detect an start streaming pattern \n     * @param {*} patternInfo \n     * @param {*} _line \n     * @param {*} _endRegex \n     * @param {*} option \n     * @returns \n     */\n    _startStreamingPattern(patternInfo, _line, _endRegex, option, _error, _old, _buffer, end_line = false) {\n        const { debug } = option;\n        const { group } = patternInfo;\n        const { formatting } = this;\n        let _nextOffset = option.line.length;\n\n        debug?.feature('stream-start') && Debug.log(\"---::: START STREAMING :::--\" + patternInfo.toString());\n        // + switch depending on formatting mode\n        if (patternInfo.formattingMode == 4) {\n            // + | start formatting with streaming object \n            option.pos = patternInfo.index;\n            const _streaming = this._createStreamConstantPattern(patternInfo, '', _endRegex, option);\n            // this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);            \n            return _streaming;\n        }\n        // start streaming need to catch startLine before swapping buffer\n        let _startLine = option.startLine;\n        let _start_block = patternInfo.isBlock && !patternInfo.isBlockStarted && !patternInfo.blockStartInfo;\n        if (_start_block) {\n            this._checkStartBlockDefinition(patternInfo, option, true);\n        }\n\n        if (_old) {\n            const _oldMarker = _old.marker;\n            if ((_oldMarker != patternInfo) || (option.pos < group.index)) {\n                option.storeRange(option.pos, group.index);\n                this._updateStreamRangeModeToHolder(_oldMarker, option, _old);\n            }\n            option.markerInfo.unshift(_old);\n        } else {\n            _old = this._updateMarkerOldContentOrSwapBuffer(patternInfo, null, _buffer, _endRegex, option);\n        }\n        if (_start_block) {\n            formatting.oldStartStreamingBlock(_old);\n        }\n        option.startLine = _startLine;\n        if (end_line) {\n            if ((_line.trim().length > 0) || (_old.start)) {\n                option.appendToBuffer(_line, patternInfo);\n            }\n            option.pos = _nextOffset;\n        } else {\n            let _p, _matcher;\n            ({ _p, _matcher } = this.detectPatternInfo(_line, patternInfo, option));\n            if (_p && !_matcher) {\n\n                let select = Utils.GetNextCapture(_line, patternInfo.endRegex, option);\n                let _buffer = this._updateOldMarkerContent(_old, option);\n                option.formatterBuffer.appendToBuffer(_buffer);\n                let _endpos = option.pos + select.index + select.offset;\n                option.storeRange(option.pos, _endpos);\n                let _bool = option.shiftFromMarkerInfo(patternInfo, true);\n                option.restoreBuffer(_bool);\n                if (option.pos != _endpos) {\n                    this._updatePrevPatternPrevConstant(patternInfo, option);\n                } else {\n                    option.pos = _endpos + select.offset;\n                }\n                this._onEndHandler(patternInfo, option);\n                option.skipMarkerFlag = false;\n                return patternInfo.parent;\n            }\n            else {\n                // handle the next \n                if (_matcher) {\n                    let _constant_line = option.line.substring(option.pos, _matcher.group.index);\n\n                    if (_constant_line.length > 0) {\n                        this._appendConstant(patternInfo, _constant_line, option);\n                    }\n                    option.storeRange(option.pos);\n                    this._registerTokenName(patternInfo, option);\n                    let _ret = this._handleMarker(_matcher, option);\n                    return _ret;\n                }\n            }\n\n\n        }\n        return patternInfo;\n    }\n\n    //------------------------------------------\n    //#region handle pattern property \n    _handleInstructionSeperatorProperty(_marker, option, _e) {\n        const _cm_value = _e.value;\n        if (_marker.isInstructionSeparator) {\n            let b = this.settings.isInstructionSeperator(_cm_value.trim());\n            _e.isInstructionSeparator = b;\n        }\n    }\n    _handleMatchCaptureDefinition(_marker, option, _e, { _old, group, match }) {\n        let _cm_value = group[0];// _e.value;\n        const { parent } = _marker;\n        const _formatting = this.formatting;\n        let b = _e.isInstructionSeparator;\n        let _cond = _old && ((_cm_value.length == 0) || (_cm_value.trim().length == 0)\n            && (!_formatting.allowEmptySpace(_old.marker.mode, option))) &&\n            _marker.isMatchCaptureOnly;\n        if (_cond) {\n            _e.handle = true;\n            let _gcm_value = Utils.GetNextCapture(group.input, match, option);\n            _cm_value = _gcm_value[0];\n            if (_marker.isInstructionSeparator) {\n                b = this.settings.isInstructionSeperator(_cm_value.trim());\n            }\n\n            if (parent && (group.offset == 0)) {\n                // + | match capture only definition\n                if (_old && b) {\n                    _formatting.onEndInstruction(_marker, option);\n                }\n                // + | passing to handle parent group\n                if (parent.endGroup?.index == group.index) {\n                    let _g = this._handleToEndPattern(parent, _cm_value.trim(), option);\n                    if (b && !option.formatterBuffer.isEmpty) {\n                        option.store();\n                        if (_marker.isBlock) {\n                            // + | close block \n                            _g = this._closeBlockEntry(option, _marker, _g, _marker.closeParentData);\n                        }\n                    }\n                    return _g;\n                }\n                if (_marker.closeParent) {\n                    return this._closeMarker(_marker, parent, option, _marker.closeParentData);\n                }\n            }//\n            return parent;\n        }\n    }\n    appendJoinToBuffer(value, option) {\n        option.appendToBuffer(value, new JoinMarkerPattern());\n    }\n    /**\n     * store to buffer \n     * @param {string} buffer \n     * @param {string} data \n     * @param {PatternMatchInfo} marker \n     * @param {FormatterOptions} option \n     * @param {boolean} raise \n     */\n    _storeToBuffer(buffer, data, marker, option, raise = true) {\n        const s = { buffer, data };\n        const { debug, formatterBuffer } = option;\n        Utils.UpdateMarkedSegment(s, marker);\n        debug?.feature('match-value-handler') && (() => {\n            Debug.log('--:::store to buffer:::--');\n            console.log(s);\n        })();\n        formatterBuffer.appendToBuffer(s);\n        if (raise) {\n            this.onAppendToBuffer(marker, s, option);\n        }\n    }\n    _storeMatchValueHandler(_marker, option, _e, _extra) {\n        const { _op, _old, _skip_value } = _extra;\n        let _cm_value = _e.value;\n        let _data = _e.data;\n        const q = this;\n        // const { debug, formatterBuffer } = option;\n        const _formatting = this.formatting;\n        const b = _e.isInstructionSeparator || false;\n        const _is_join = option.joinWith && option.startLine;\n        const _store_to_buffer = (_cm_value, _data, option) => {\n            if (_data != undefined) {\n                q._storeToBuffer(_cm_value, _data, _marker, option, true);\n            } else {\n                option.appendToBuffer(_cm_value, _marker);\n            }\n        };\n\n        if (b || (!_marker.lineFeed) || (option.buffer.length > 0) || (_cm_value.length > 0)) {\n\n            if (_op.indexOf('replaceWith') == -1) {\n                if (_is_join) {\n                    // join entry with join value\n                    this.appendJoinToBuffer(option.joinWith, option);\n\n                }\n                _store_to_buffer(_cm_value, _data, option);\n\n            } else {\n                if ((option.glueValue == _cm_value)) {\n                    this._onEndHandler(_marker, option);\n                    return _marker.parent;\n                }\n                // + | check to add empty space before append.\n                if (!option.skipEmptyMatchValue || (_cm_value.trim().length > 0)) {\n                    if (_is_join) {\n                        // join entry with join value\n                        option.formatterBuffer.appendToBuffer(option.joinWith);\n                    }\n                    _store_to_buffer(_cm_value, _data, option);\n                    if (option.skipEmptyMatchValue) {\n                        option.skipEmptyMatchValue = false;\n                    }\n                }\n            }\n            if (_old && b) {\n                _formatting.onEndInstruction(_marker, option);\n            }\n            option.useGlue(_marker, _cm_value);\n            this._updateJoinWith(_marker, option);\n            _e.storeValue = true;\n            this._updateNextMode(option, _marker);\n        }\n    }\n    _updateJoinWith(_marker, option) {\n        if (_marker.joinWith) {\n            option.joinWith = _marker.joinWith;\n        } else {\n            option.joinWith = null;\n        }\n    }\n    //#endregion\n    //------------------------------------------\n\n\n    //-------------------------------------------\n    //#region MATCH AND BEGIN/END START HANDLER \n\n    _handleChainHandler(_marker, _chains_match, _e_args, option) {\n        while (_chains_match.length > 0) {\n            let _handle = _chains_match.shift();\n            let _fc = null;\n            let _target = null;\n            let _cparent = null;\n            let _extra_args = null;\n\n            if (Array.isArray(_handle)) {\n                _fc = _handle[1];\n                _target = _handle[0];\n                _extra_args = (2 in _handle) ? _handle[2] : null;\n            }\n            if (_fc) {\n                _cparent = _fc.apply(_target, [_marker, option, _e_args, _extra_args]);\n                if (_e_args.handle) {\n                    if (_e_args.udpateChild) {\n                        this._updateMarkerChild(_marker);\n                    }\n                    this._onEndHandler(_marker, option);\n                    return _cparent;\n                }\n            }\n        }\n    }\n    _updateOldEntryCapture(_old, _cm_value, option) {\n        if (_old && _old.captureEntry) {\n            _cm_value = _old.captureEntry + _cm_value;\n            _old.captureEntry = null;\n\n            option.saveBuffer();\n            option.appendToBuffer(_cm_value, _old.marker);\n\n            _cm_value = option.buffer;\n            option.formatterBuffer.clear();\n            option.restoreSavedBuffer();\n            _old.childs.push(new EntryCapturePattern(_cm_value));\n\n        }\n        return _cm_value;\n    }\n\n    /**\n     * onMatch handle affect only on content match\n     * @param {PatternMatchInfo} _marker \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    _handleMatchMarker(_marker, option) {\n        // + | - handle :match/match\n        option.debug?.feature('match/match') && Debug.log('--::: Handle match marker :::--' + _marker.toString());\n        option.state = 'match';\n        const { parent, group, match, closeParentData } = _marker;\n        const { formatting } = this;\n        option.lastMarker = _marker;\n        const _old = option.peekFirstMarkerInfo();// option.parentMatcherInfo;\n        let _cm_value = group[0];\n        let _next_position = group.index + group.offset;\n        let _checkParentInfo, _endCaptureCallback;\n        // TODO: skip entired line\n        const _handle_EOL = !option.EOL && (option.line.length == _next_position);\n\n        if (_handle_EOL) {\n            option.skipEndOfLine = true;\n        }\n\n        if (!_handle_EOL && (option.pos == _next_position) && (!_marker.closeParent)) {\n            // + | not move update marker formatting\n            if (_marker.formattingMode) {\n                this._updateMarkerFormatting(_marker, option, true);\n                option.lastEmptyMarkerPattern = _marker;\n                return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, _marker.parent);\n            }\n            if (option.EOL) {\n                return parent;\n            }\n            // + | handle stop - then skip to end line\n            let _ret = this._handleStopMarker(_marker, option);\n\n            // + | --------------------------------------------\n            // + | skip line \n            // + | by reading to end of line\n            // + |\n            option.pos = option.length;\n            let _constant_line = option.line.substring(_next_position, option.pos);\n            if (_constant_line.trim().length > 0) {\n                this._appendConstant(_marker, _constant_line, option);\n            }\n            // + |\n            // + | if stop en match empty value then - return null\n            // + | + macromate definitiont\n            if (_ret) {\n                _ret = this._justCloseMarker(_ret, option);\n                option.lineFeedFlag = true;\n            }\n            return _ret;\n        }\n        _cm_value = this._updateOldEntryCapture(_old, _cm_value, option);\n        // + | update cursor position\n        option.pos = _next_position;\n        const _op = FormatterMatchTreatment.Init(_cm_value);\n        // + | store update .data\n\n        // + | treat match value\n        _cm_value = this._treatMatchValue(_cm_value, _marker, option, _op);\n\n        // + skip empty value\n        const _fake_empty = _cm_value.trim().length == 0;\n        const _option_glue = option.glueValue;\n\n        let _skip_value = ((option.startLine && _fake_empty)) ||\n            (_option_glue && (_option_glue == _marker.isGlueValue)) ||\n            (_option_glue && (_option_glue == _cm_value)) ||\n            (_cm_value == '');\n\n        // + | -----------------------------------\n        // + | skip value on non empty glue values\n        // + |\n        if (!_skip_value && _marker.isGlueValue && _marker.skipGlueOnLineEnd && option.isEOL){\n            _skip_value =  true;\n        }\n\n        if (parent && !_skip_value && parent.isEndCaptureOnly) {\n            // passing to parent \n            let _p = parent.endGroup;\n            if (_p && (_next_position >= _p.index)) {\n                ({ _checkParentInfo, _endCaptureCallback } = this._handleCheckParentInfo(\n                    parent, _marker, _p, _old, option, '', '', group.index, \"match\"));\n            }\n        }\n        // + | inject argurment  \n        let _e_args = {\n            handle: false,\n            value: _cm_value,\n            state: 'match',\n            udpateChild: true,\n            _skip_value,\n            isInstructionSeparator: false,\n            data: _op.data\n        };\n        let _chains_match = [\n            [this, this._handleInstructionSeperatorProperty],\n            [this, this._handleCloseParentProperty, { closeParentData }],\n            [this, this._handleMatchCaptureDefinition, { _old, group, match }],\n            [this, function (_marker, option, _e) {\n                if (_e._skip_value) {\n                    _e.handle = true;\n                    _e.udpateChild = false;\n                    if (_marker.isBlock && _marker.parent) {\n                        // + | close block - consider as a block definition \n                        return this._closeBlockEntry(option, _marker, _marker.parent, closeParentData);\n                    }\n                    if (_marker.parent) {\n                        // +| update next mode with parent\n                        this._updateNextMode(option, _marker.parent);\n                    }\n                    return _marker.parent;\n                }\n            }],\n            [this, this._storeMatchValueHandler, { _op, _old }]\n        ];\n        let _ret = this._handleChainHandler(_marker, _chains_match, _e_args, option);\n        if (_e_args.handle) {\n            return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, _ret);\n        }\n        this._updateMarkerChild(_marker);\n        // + | marker is not a line feed directive or buffer is not empty - end instruction directive\n        if (!_e_args.storeValue) {\n            this._storeMatchValueHandler(_marker, option, _e_args, { _op, _old });\n        }\n        this._onEndHandler(_marker, option);\n\n        formatting.updateMatchNextFormatting(_marker, option, _old);\n\n        if (_marker.closeParent) {\n            return this._closeMarker(_marker, parent, option, _marker.closeParentData);\n        }\n        return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, parent);\n    }\n    /**\n     * just close marker to skip\n     * @param {*} _marker \n     * @param {*} option \n     * @returns \n     */\n    _justCloseMarker(_marker, option) {\n        let _ret = _marker;\n        // + | close all marking.\n        while (_ret) {\n            const _told = option.shiftFromMarkerInfo(_ret, true);\n            const _lbuffer = option.bufferState;\n            option.restoreBuffer(_told);\n            option.formatterBuffer.appendToBuffer(\n                {\n                    bufferSegments: _told.data.bufferSegment,\n                    dataSegments: _told.data.dataSegment,\n                }\n            );\n            option.formatterBuffer.appendToBuffer(\n                _lbuffer.data\n            );\n            this._onEndHandler(_ret, option);\n            _ret = _ret.parent;\n        }\n        return _ret;\n    }\n    _updateNextMode({ nextMode }, marker) {\n        nextMode = marker.mode;\n        arguments[0].nextMode = nextMode;\n    }\n    /**\n     * shift pattern content name\n     * @param {*} patternInfo \n     * @param {*} option \n     */\n    _shiftPatternContentName(patternInfo, option) {\n        const { tokenList } = option;\n        const name = patternInfo.contentName;\n        if (name && patternInfo.isShiftenContentName) {\n            if ((tokenList.length > 0)) {\n                Utils.UnshiftTokens(name, tokenList);\n                patternInfo.isShiftenContentName = false;\n            }\n            else {\n                throw Error('missing contentName');\n            }\n        }\n    }\n    /**\n     * unshift pattern content name \n     * @param {*} patternInfo \n     * @param {*} option \n     */\n    _unshiftPatternContentName(patternInfo, option) {\n        const { tokenList } = option;\n        const name = patternInfo.contentName;\n        if (name && !patternInfo.isShiftenContentName) {\n            Utils.StoreTokens(name, tokenList);\n            patternInfo.isShiftenContentName = true;\n        }\n    }\n\n    /**\n     * move entryBuffer to parent definition \n     * @param {*} marker\n     * @param {FormatterOptions} option\n     */\n    _updateBlockMarkerPropertyContent(marker, option) {\n        const _old = option.peekMarkerInfo;\n        const _entryBuffer = _old.entryBuffer;\n        let _content = _old.content;\n        let _marker = _old.marker;\n        let _new_v = _content.startsWith(_entryBuffer) ? _content.substring(_entryBuffer.length) : _content;\n\n        const { formatting } = this;\n        const { bufferSegment, dataSegment } = _old.data;\n        if (_entryBuffer.length > 0) {\n            let idx = bufferSegment.indexOf(_entryBuffer);\n            const data = dataSegment[idx];\n            // passing to entry buffer \n            _old.state.formatterBuffer.appendToBuffer({ buffer: _entryBuffer, data });\n            let _count = 0;\n            while (idx >= 0) {\n                dataSegment.shift();\n                bufferSegment.shift();\n                idx--;\n                _count++;\n            }\n            if (bufferSegment.marked) {\n                FormatterBuffer.ReduceBufferSegmentIndex(_count, bufferSegment);\n                FormatterBuffer.TreatMarkedSegments({ dataSegment, bufferSegment }, 'trimmed');\n            }\n        }\n\n        _old.useEntry = false;\n        _old.blockStarted = true;\n        _marker.isBlockStarted = true;\n        this._initUpdatedisBlockStartInformation(marker, option);\n        if (_new_v.length > 0) {\n            // + | prefix with line fied\n            option.saveBuffer();\n            option.appendExtraOutput();\n            // option.formatterBuffer.appendToBuffer({ buffer: _new_v, data: dataSegment.join('') });\n            option.formatterBuffer.appendToBuffer({ dataSegments: dataSegment, bufferSegments: bufferSegment });//  _new_v, data: dataSegment.join('') });\n            option.store();\n            const _buffer = option.flushAndData(true);\n            option.restoreSavedBuffer();\n            _new_v = _buffer.buffer;\n            // update data segment\n            FormatterBuffer.ClearSegments({ bufferSegment, dataSegment });\n            bufferSegment.push(_buffer.buffer);\n            dataSegment.push(_buffer.data);\n\n\n        }\n        _old.content = _new_v;\n        _old.useEntry = false;\n        _old.startBlock = 0;\n        formatting.startBlock(_old);\n    }\n\n    /**\n     * init block start \n     * @param {*} marker \n     * @param {*} param1 \n     */\n    _initBlockStarting(marker, { depth }) {\n        marker.isFormattingStartBlockElement = true;\n        marker.blockStartInfo = {\n            depth: depth\n        }\n    }\n    /**\n     * handle marker info \n     * @param {PatternMatchInfo} patternInfo \n     * @param {*} option \n     * @returns \n     */\n    _handleBeginEndMarker(patternInfo, option) {\n        option.state = 'begin/end'; const { formatting } = this;\n        const { debug, line, markerInfo } = option;\n        const { parent, lineFeed, group } = patternInfo;\n        debug?.feature('match/begin-end') && Debug.log('--::: begin/end - handle marker :::---#' + patternInfo.toString());\n\n        let _endRegex = null;\n        let _start = true;\n        let _line = '';\n        let _old = null;\n        let _buffer = null;\n        let _p, _matcher, _error;\n\n        // get _old marker to continue matching selection  \n\n        if ((markerInfo.length > 0) && (_old = option.shiftFromMarkerInfo(patternInfo, false))) {\n            _start = false; // update the marker to handle start definition\n            _buffer = this._updateOldMarkerContent(_old, option);\n        } else if (patternInfo.start) {\n            // + | if (transform treat  )\n            let _captures = null;\n            let _startOutput = { buffer: null, data: null };\n            if (patternInfo.transform) {\n                // treat match value before \n                let _cm_value = patternInfo.group[0];\n                let _op = [];\n                _startOutput.data = _cm_value;\n                _cm_value = this._treatMatchValue(_cm_value, patternInfo, option, _op, null, false);\n                if (_op.indexOf('transform') != -1) {\n                    _captures = patternInfo.transformCaptures || null;\n                    ({ _captures } = this._treatTransform(_cm_value, patternInfo, _captures));\n                }\n                // + | update start input \n                _startOutput.buffer = _cm_value;\n            }\n            // _captures = _captures || Utils.BeginCaptures(patternInfo);\n            // + | treat begin captures and update buffer\n            const _outdefine = {};\n            if (option.treatBeginCaptures(patternInfo, _captures, _outdefine) == undefined) {\n                const _fstartOutput = patternInfo.startOutput;\n                _startOutput.buffer = option.treatValueBeforeStoreToBuffer(patternInfo, _fstartOutput);\n                _startOutput.data = {\n                    dataSegment: [_fstartOutput],\n                    bufferSegment: [_startOutput.buffer]\n                };\n            } else {\n                _startOutput.buffer = patternInfo.startOutput;\n                _startOutput.data = _outdefine;\n            }\n            FormatterBuffer.InitBufferMarkedSegment(_startOutput.data.bufferSegment);\n            patternInfo.start = false;\n            if (patternInfo.isBlock) {\n                // +| on base start width K_R coding style \n                // this._checkStartBlockDefinition(patternInfo, option, false); \n                if (!patternInfo.isStreamCapture)\n                    this._initBlockStarting(patternInfo, option);\n            }\n            if (patternInfo.isBlockConditionalContainer) {\n                option.pushConditionalContainer(patternInfo);\n            }\n            this._updateParentProps(patternInfo, true, option);\n            if (parent) {\n                if (parent.isBlock && !parent.isBlockStarted && this._isChildBlock(patternInfo, option)) {\n                    // + | start block so that element \n                    if (markerInfo.length > 0) {\n                        this._updateBlockMarkerPropertyContent(patternInfo, option);\n                    }\n                }\n            } else {\n                if (lineFeed && (option.depth == 0)) {\n                    // auto change line feed \n                    if (!option.blockStarted) {\n                        option.blockStarted = true;\n                    }\n                }\n            }\n            const _mode = patternInfo.mode;\n            formatting.updateStartFormatting(_mode, option);\n            this._unshiftPatternContentName(patternInfo, option);\n            patternInfo.startOutput = _startOutput.buffer;\n            patternInfo.startData = _startOutput.data;\n            this._onStartMarker(patternInfo, option, { type: 'begin/end' });\n        } else {\n            throw new Error(\"missing logic for : \" + patternInfo);\n        }\n        _buffer = _start ? patternInfo.startOutput : _buffer;\n        _endRegex = patternInfo.endRegex;\n        _line = line.substring(option.pos);\n\n        if (!_start && option.TOEND) {\n            _p = patternInfo.endGroup || [''];\n            _p.index = 0;\n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n\n        if (option.EOF) {\n            // ---------------------------------------------------------------\n            // END FOUND\n            // ---------------------------------------------------------------\n            _p = this._lastExpectedMatchResult(patternInfo, option, _old);\n            _buffer = _old.content;\n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n\n        if (_line.length == 0) {\n\n            // + | check for end found - \n            ({ _p, _matcher, _error } = this.detectPatternInfo(_line, patternInfo, option));\n            const _eol = option.EOL;\n            if (_p && ((_matcher == null) || (_eol))) {\n                let _nextPos = Math.max(option.pos, _p.index);\n                // + | update the next position hosting\n                option.pos = _nextPos;\n                // \n                if (_p[0].length == 0) {\n                    let _close_data = patternInfo.closeParentData;\n                    if (_close_data) {\n                        const _op = [];\n                        _close_data = this._treatMatchValue(_close_data, patternInfo, option, _op, null, true);\n                        _buffer += _close_data;\n                        if (_old) {\n                            _old.data.bufferSegment.push(_close_data);\n                            _old.data.dataSegment.push(_close_data);\n                        }\n                    }\n                }\n                return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n            }\n            this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, patternInfo.endRegex, option);\n            return patternInfo;\n        }\n        // treat patterns\n        let _pos = option.pos;\n        if (_start) {\n            let _next_position = patternInfo.group.index + patternInfo.group.offset;\n            // + | on start before handle \n            _pos = _next_position;\n            option.pos = _next_position;\n        }\n        _line = line.substring(_pos);\n        // + | start pattern stream capture\n        if (patternInfo.isStreamCapture && _start) {\n            return this._startStreamingPattern(patternInfo, _line, _endRegex, option, null, null, _buffer, false);\n        }\n        // + | --------------------------------------------------------        \n        // + | DETECT: core match\n        // + | --------------------------------------------------------\n        ({ _p, _matcher, _error } = this.detectPatternInfo(_line, patternInfo, option)); \n\n        if (_error) {\n            throw new Error(_error);\n        }\n        if (_matcher == null) {\n            // no child matcher found\n            if (_p == null) {\n\n                if (patternInfo.isStreamCapture) {\n                    // + | detect buffer empty - buffer detection \n                    return this._startStreamingPattern(patternInfo, _line, _endRegex, option, _error, _old, _buffer, true);\n                }\n                this._checkStartBlockDefinition(patternInfo, option);\n                // no end - found \n                // _continue_with_marker = false;\n                // update cursor - start new marker and update - \n                this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n                if (_line.trim().length > 0) {\n                    this._appendConstant(patternInfo, _line, option);\n                }\n                option.pos = option.line.length;\n                if ((_buffer.length > 0) && this.info.isSubFormatting) {\n                    option.formatterBuffer.appendToBuffer(\n                        {\n                            bufferSegments: patternInfo.startData.bufferSegment,\n                            dataSegments: patternInfo.startData.dataSegment,\n                        }\n                    );\n                    _buffer = null;\n                }\n                return patternInfo;\n            } else {\n                // ---------------------------------------------------------------\n                // END FOUND\n                // ---------------------------------------------------------------\n                return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n            }\n        }\n        else {\n\n            // compared index and handle child\n            if ((_p == null) || (_matcher.group.index < _p.index)) {\n                this._checkStartBlockDefinition(patternInfo, option);\n\n                if (_matcher.isStreamCapture) {\n                    // + | detect buffer empty - buffer detection   \n                    // + | before startStream . \n                    // _old = \n                    this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n                    // start new stream for new \n                    return this._startStreamingPattern(_matcher, _line, _endRegex, option, _error, null, '', false);\n                }\n                // + | \n\n                // handle matcher \n                return this._handleItemFoundCallback().apply(this, [\n                    _matcher, patternInfo, _old, _buffer, _endRegex, option\n                ]);\n            }\n            // check if same \n            if (_matcher.group.index == _p.index) {\n                if (_matcher.isStartOnly) {\n                    // ---------------------------------------------------------------\n                    // END FOUND : priority to patternInfo\n                    // ---------------------------------------------------------------\n                    return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n                }\n                return Formatters.HandleSameGroup(this, patternInfo, _matcher, _p, _old, _buffer, _endRegex, option, null, _line);\n            }\n            // priority to current marker \n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n    }\n    _handleStopMarker(marker, option) {\n        const { parent } = marker;\n        let r = option.peekMarkerInfo;\n        // + | backup \n        let { pos, line, nextMode } = option;\n        let s = null;\n        if (r?.marker == marker)\n            this._closeMarkerByStop(marker, marker.endGroup, option);\n\n        if (parent) {\n            r = option.peekMarkerInfo;\n            if (r?.marker == parent) {\n                let _p = [''];\n                _p.index = 0;\n                _p.indices = [];\n                s = this._closeMarkerByStop(parent, _p, option, {\n                    _parentNextMode: nextMode\n                })\n            }\n        }\n        // + | restore \n        option.pos = pos;\n        option.line = line;\n        option.nextMode = nextMode;\n\n        return s;\n    }\n\n    // #endregion\n    //-------------------------------------------\n\n    /**\n     * detect logical pattern info\n     * @param {string} _line \n     * @param {PatternMatchInfo} patternInfo \n     * @param {FormatterOptions} option \n     * @param {PatternMatchInfo} parentMatcherInfo to handle parent result for pattern\n     * @param {bool} throwError re throw error in detection \n     * @returns \n     */\n    detectPatternInfo(_line, patternInfo, option, parentMatcherInfo, throwError = true) {\n        let _matcher = null;\n        let _p = null;\n        let _endRegex = patternInfo.endRegex;\n\n        let _error = null;\n        parentMatcherInfo = parentMatcherInfo || patternInfo;\n        const { patterns } = patternInfo;\n        const _call = (patterns && (patterns.length > 0));\n        const _call_update_regex = (_p, _endRegex) => {\n            _p.sourceRegex = _endRegex;\n            _p.type = '_end_';\n            _p.offset = _p[0].length;\n        };\n        try {\n            _matcher = _call ? Utils.GetPatternMatcher(patterns, option, parentMatcherInfo) : null;\n            // if (_call && !_matcher && option.lineMatcher){\n            //     _matcher = Utils.GetPatternMatcher(patterns, option, parentMatcherInfo, option.lineMatcher.subLine, option.lineMatcher.offset);\n            // }\n        }\n        catch (e) {\n            if (throwError) {\n                throw e;\n            }\n            _error = {\n                _line,\n                index: e.match.index - option.pos\n            }\n        }\n        // + | fix to end regex\n        if (_endRegex) {\n\n            //_p = _endRegex.exec(_line); \n            _p = option.lineMatcher.check(_endRegex);\n            if (_p) {\n                // _p.index += option.pos;\n                _call_update_regex(_p, _endRegex);\n            } else if (option.sourceLine != _line) {\n                const { lineMatcher } = option;\n                // + | possibility to detect a sub line */\n                let _ts = RegexUtils.RegexToStringRegex(_endRegex);\n                let c = RegexUtils.RemoveCaptureAndLeaveMovementCapture(_ts);\n                //\n                let treat = null;\n                if (c && c.length > 0) {\n                    // + | treat end priority to movement capture definition \n                    const _pline = (new RegExp(c, 'd')).exec(lineMatcher.subLine);\n                    treat = _pline;\n                }\n                const _pline = _endRegex.exec(lineMatcher.subLine);\n                if (_pline) {\n                    if (treat && (treat.index >= _pline.length)) {\n                        _p = treat;\n                    } else {\n                        _p = _pline;\n                    }\n                } else if (treat) {\n                    _p = _pline;\n                }\n                if (_p) {\n                    _p.index += lineMatcher.offset;\n                    _call_update_regex(_p, _endRegex);\n                }\n            } \n            patternInfo.endGroup = _p;\n        } \n        if (_p && patternInfo.checkMoveEndRegex(_p, option)){ \n            _p = null;\n        } \n        return { _p, _matcher, _error };\n    }\n    _updatePatternPrevConstant(_marker, option, _prev, offset, append_child = true) {\n        _prev = _prev || option.getLineRangeContent();\n        if (_prev.length > 0) {\n            offset = offset || 0;\n            if (!option.startLine || (_prev.trim().length > 0)) {\n                this._appendConstant(_marker, _prev, option, append_child);\n            }\n            option.pos += (offset || _prev.length);\n        }\n    }\n    /**\n     * determine that the pattern is a child block\n     * @param {*} patternInfo \n     * @returns bool\n     */\n    _isChildBlock(patternInfo, option) {\n        const { parent } = patternInfo;\n        let r = false;\n        const requestParentBlockCondition = parent?.requestParentBlockCondition;\n        if (requestParentBlockCondition) {\n            r = this._isEmptyRequestBlock({\n                childs: [patternInfo],\n                _marker: parent,\n                condition: requestParentBlockCondition\n            });\n        }\n        return r;\n    }\n    /**\n     * update buffer on end\n     * @param {*} _marker \n     * @param {*} option \n     * @param {*} param2 \n     * @private\n     * @returns \n     */\n    _updateBuffer(_marker, option, { _append, _buffer, _data, _trimOutput }) {\n        const q = this;\n        const { parent } = _marker;\n        const { formatterBuffer } = option;\n        let _skipOffset = 0;\n        if (_buffer.length > 0) {\n\n            if (_trimOutput) {\n                if (_data.bufferSegment.join('') != _buffer) {\n                    throw new Error('trim out buffer not match');\n                }\n                FormatterBuffer.TreatMarkedSegments(_data, 'trimmed');\n                _buffer = _data.bufferSegment.join('');\n            }\n\n            // + | direct append to buffer\n            formatterBuffer.storeToBuffer({ _buffer, _data }, option);\n            _buffer = '';\n        }\n        const _use_append = ((_marker.matchType==0)  && _append.length>0) || (_append.trim().length > 0);\n        if (_use_append) {\n            // + | append constant marker definition \n            if (_marker.isFormattingStartBlockElement && !_marker.newLine) {\n                _marker.newLine = true;\n            }\n            if (parent?.isAutoBlockElement) {\n                let r = option.buffer;\n                option.formatterBuffer.clear();\n                if (r.length > 0)\n                    option.output.push(r);\n                else\n                    option.appendExtraOutput();\n                q._appendConstant(_marker, _append, option);\n                option.store();\n                r = option.flush(true);\n                option.formatterBuffer.appendToBuffer(r);\n            }\n            else {\n                q._appendConstant(_marker, _append, option);\n                _skipOffset = _append.length;\n            }\n            _append = '';\n        }\n        option.nextMode = _marker.mode;\n        return { _append, _buffer, _skipOffset };\n    }\n    /**\n     * use to handle close parent\n     * @param {*} _marker \n     * @param {*} option \n     * @param {{handle:bool}} arg \n     */\n    _handleCloseParentProperty(_marker, option, arg = { handle: false }, _extra) {\n        const { debug } = option;\n        let _handle = false;\n        let _data = _extra?.closeParentData;\n        if (_data == undefined) {\n            return;\n        }\n        let _g = null;\n        debug && Debug.log('---:::CLOSE PARENT PROPERTY:::---' + _marker);\n        arg.udpateChild = this._requestUpdateChild(_marker, arg.state);\n        let _gparent = _marker.parent;\n        if (_gparent) {\n            if (_gparent.isBlock) {\n                _g = this._closeBlockEntry(option, _marker, _gparent, _data);\n            } else {\n                _g = this._closeMarkerAndUpdate(_marker, _gparent, option, _data);\n            }\n        }\n\n        _handle = true;\n\n        arg.handle = _handle;\n        return _g;\n    }\n    _requestUpdateChild(_marker, state) {\n        if (state == 'match') {\n            return (_marker.group[0].length > 0);\n        }\n        return true;\n    }\n    /**\n     * close block entry\n     * @param {FormatterOptions} option \n     * @param {PatternMatchInfo} _marker current marker \n     * @param {PatternMatchInfo} _parent parent\n     * @param {string} data data used to close  \n     * @param {boolean} store data used to close  \n     */\n    _closeBlockEntry(option, _marker, _parent, data = '', store = true) {\n        const { formatting } = this;\n        if (store && (option.depth > 0))\n            option.store();\n        option.depth = Math.max(--option.depth, 0);\n        if (_marker && _parent) {\n            return this._closeMarkerAndUpdate(_marker, _parent, option, data);\n        }\n    }\n    _closeMarkerAndUpdate(_marker, _parent, option, data) {\n        const { formatting } = this;\n        let _r = this._closeMarker(_marker, _parent, option, data);\n        formatting.updateEmptySkipMatchedValueFormatting(_r, option, { mode: _marker.mode, formattingMode: _parent.formattingMode });\n        return _r;\n    }\n    _closeMarker(_marker, _g, option, data = '') {\n        const { debug } = option;\n        debug && Debug.log(\":::CLOSEMARKER:::\" + _marker);\n        if (_marker?.isBlock) {\n            this.formatting.closeMarker(_marker);\n            _marker.isBlock = false;\n        }\n        if (_g) // move to parent \n        {\n            const { endGroup } = _g;\n            // if (endGroup==null){\n            //     // - continue thru parent\n            //     return _g;\n            // }\n            let _value = data;\n            let _type = null;\n            if (typeof (data) == 'object') {\n                _value = data.value;\n                _type = data.type;\n            }\n\n            if (endGroup && (endGroup[0] != _value)) {\n                let p = _g.endRegex.exec(_value) || ((d) => {\n                    d.indices = [[0, d[0].length]];\n                    d.index = 0;\n                    return d;\n                })([_value]);\n\n                p.index += option.pos;\n                _g.endGroup = p;\n            }\n            _g = this._handleToEndPattern(_g, _value, option);\n            let _buffer = option.buffer;\n            if (_type) {\n                _buffer = option.flush(true) + _buffer;\n                option.appendToBuffer(_buffer, new TypeMarkerInfoPattern(_type, { parser: this.registryClassName, data }));\n            } else {\n                option.store();\n            }\n        }\n        return _g;\n    }\n    /**\n     * \n     * @param {*} parent \n     * @param {*} _marker \n     * @param {*} _p \n     * @param {*} _old \n     * @param {*} option \n     * @param {*} _buffer \n     * @param {*} _line \n     * @param {number} _next_position \n     * @param {*} state \n     * @returns \n     */\n    _handleCheckParentInfo(parent, _marker, _p, _old, option, _buffer, _line, _next_position, state = 'begin/end') {\n\n        let _endCaptureCallback;\n        let _checkParentInfo;\n        const _isSkipTreatEnd = option.skipTreatEnd;\n        if (parent && !_isSkipTreatEnd && (parent.matchType == 0) &&\n            (parent.isEndCaptureOnly || _marker.isEndCaptureOnly)) {\n            // + | send to parent block\n            _checkParentInfo = {\n                _line,\n                _marker,\n                _old,\n                parent,\n                buffer: _buffer,\n                pos: _next_position,\n                line: option.line,\n                offset: option.offset,\n                endGroup: _p,\n                fromChild: (!parent.isEndCaptureOnly && _marker.isEndCaptureOnly),\n                state\n            };\n            _endCaptureCallback = this._closeNonCaptureBlock;\n        }\n        return { _endCaptureCallback, _checkParentInfo };\n    }\n\n    /**\n     * resolv data segments \n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _old \n     * @returns \n     */\n    _resolvFoundData(_marker, option, _old) {\n        if (option.EOF) {\n            if (_old) {\n                const c_data = _old.data;\n                if (c_data.bufferSegment.length > 0) {\n                    return c_data;\n                }\n            }\n            return _marker.startData;\n        }\n        return _old?.data || _marker.startData;\n    }\n    /**\n     * begin/end end found\n     * @param {string} _buffer current buffer presentation\n     * @param {*} _line entry line\n     * @param {*} _marker current marker\n     * @param {*} _p end match\n     * @param {FormatterOptions} option option \n     * @param {FormatterMarkerInfo} _old store information \n     * @returns \n     */\n    _handleFoundEndPattern(_buffer, _line, _marker, _p, option, _old) {\n        // calculate next position \n        const { debug } = option;\n        const { parent } = _marker;\n        let _next_position = _p.index + _p[0].length; // do not move cursor until condition meet\n        let _next_offset = undefined; //option.offset;\n        let _append = option.pos < _p.index ? option.line.substring(option.pos, _p.index) : '';\n        let _checkParentInfo = null;\n        let _endCaptureCallback = null;\n        const q = this;\n        const _formatting = q.formatting;\n        const _isSkipTreatEnd = option.skipTreatEnd;\n        const prependExtra = _old?.prependExtra;\n        let _b = null;\n        let _data = null;\n\n        debug?.feature('match/begin-end.end') && Debug.log(`--::: END::Begin/End handleFoundEndPattern :::--#${_marker}`);\n        option.lastMarker = _marker;\n\n        if (prependExtra) {\n            let r = _formatting.updatePreprendExtra(prependExtra, null, option);\n            _buffer += r.extra;\n            _old.prependExtra = null;\n        }\n        ({ _checkParentInfo, _endCaptureCallback } = this._handleCheckParentInfo(parent, _marker, _p, _old, option, _buffer, _line, _next_position));\n\n\n\n        let _saved = false;\n        if (_old == null) {\n            option.saveBuffer();\n            _saved = true;\n        }\n        this._shiftPatternContentName(_marker, option);\n\n        ({ _b, _data } = (() => {\n            const _empty = { _b: '', _data: '' };\n            return _isSkipTreatEnd ? _empty : (() => {\n                if (_p[0].length > 0) {\n                    let __b = option.treatEndCaptures(_marker, _p);\n                    if (__b == undefined) {\n                        __b = option.treatValueBeforeStoreToBuffer(_marker, _p[0]);\n                    }\n                    return { _b: __b, _data: _p[0] };\n                }\n            })() || _empty;\n        })());\n\n\n        option.skipTreatEnd = false;\n        let _close_block = false;\n        let _skipOffset = 0;\n\n\n        //const _debug_parent_is_capture_only = parent?.isEndCaptureOnly;\n\n        // + | update parent host - check update properties for end \n        this._updateMarkerChild(_marker, option);\n\n\n\n        // + | full fill pattern buffer \n        ({ _append, _buffer, _skipOffset } = _formatting.onEndUpdateBuffer({\n            marker: _marker,\n            option,\n            _buffer,\n            _data: this._resolvFoundData(_marker, option, _old),\n            _trimOutput: true,\n            update(info) {\n                return q._updateBuffer(_marker, option, { _append, _buffer, ...(info || {}) });\n            }\n        }\n        ));\n        if (_skipOffset) {\n            _next_offset = Math.min(_next_position, option.offset + _skipOffset + 1);\n        }\n\n        // + | node division  \n        if (_marker.isBlock && !_marker.blockStartInfo) {\n            // + | for some reason marker block is a block element but not got a blockStartInfo\n            this._closeBlockEntry(option, _marker, null, null, false);\n        }\n\n        if (_marker.isBlock && _marker.blockStartInfo) {\n            // + | just remove block before store \n            // + | reset block value;\n            _close_block = true;\n            //_marker.isBlockDefinition = null;\n            if (_marker.isFormattingStartBlockElement) {\n                ({ _b, _data } = _formatting.handleEndFormattingBeforeStore(q, _marker, option, _buffer,\n                    { _b, _data }));\n                const _refData = {};\n                _buffer = option.getBufferContent(true, _refData);\n                option.output.push(_buffer);\n                option.dataOutput.push(_refData.buffers.dataSegment.join(''));\n            } else {\n                _formatting.handleEndFormattingOnNonStartBlockElement(q, _marker, option);\n            }\n            _buffer = '';\n            // + | just reduce block depth\n            this._closeBlockEntry(option, _marker, null, null, false);\n        } else {\n\n            ({ _b } = _formatting.handleEndOnNonBlockElement(this, _marker, option,\n                { _b, _old, data: _p[0] }\n            ));\n        }\n        // + | append to buffer \n        if (_b.length > 0) {\n            option.formatterBuffer.appendToBuffer(_b);\n            _b = '';\n        }\n\n        // + | --------------------------------------------------------------------------------------\n        // + | update formatting and update mode depending on current marker.formattingMode or childs\n        // + | \n        this._updateMarkerFormatting(_marker, option);\n\n        if (_close_block) {\n            option.store();\n            _buffer = option.flushAndData(true);\n            option.formatterBuffer.appendToBuffer(_buffer);\n\n            // + | restore block old state\n            if (_old)\n                _marker.isBlock = _old.oldBlockStart;\n        }\n        if (_old != null) {\n\n            // + | restore buffering then update the buffer\n            if ((_old.marker == _marker)) {\n                // + | save buffer \n                _buffer = option.bufferState;\n\n\n                let _nextBuffer = null;\n                // - so st treat buffer \n                if (!_old.useEntry && _marker.isBlock) {\n                    // + | store                    \n                    // option.store(false);\n                    option.output.push(_buffer.buffer);\n                    _buffer = option.flush(true);\n                } else {\n                    if (_old.useEntry && parent && !parent.isBlock && _marker.updateParentProps?.isBlock && (_old.entryBuffer.length > 0)) {\n                        // + | possibility of parent child block - passing to parent \n                        ({ _buffer, _nextBuffer } = this._updatePreservedBlockBuffer(_buffer, _marker, _old, option));\n                    }\n                }\n                option.restoreBuffer(_old);\n                // + | > passing data\n                _formatting.updateEndBlockAfterRestoringBuffer(q, _marker, _buffer, _old, option);\n                _buffer = '';\n                if (_nextBuffer) {\n                    option.peekMarkerInfo.storePrependExtra(_nextBuffer);\n                }\n            }\n        }\n\n        // + | view child debug\n        // + | determine childs\n        debug?.feature('child-counter') && (_marker.childs.length > 0) && Debug.log(`--::: Counter ::-- #${_marker.name} have ${_marker.childs.length} childs`);\n\n        if (_marker?.parent?.newLine) {\n            _marker.parent.newLine = false;\n        }\n\n        if (_p[0].length == 0) {\n            _next_position = Math.max(option.pos, _next_position);\n        }\n        // + | update position\n        option.moveTo(_next_position, _next_offset);\n        // + | restore backup buffer\n        if (_saved) {\n            const _buffState = option.bufferState;\n            option.restoreSavedBuffer();\n            if (_buffState.buffer.length > 0) {\n                // + | \n                // + | passing current data to buffer definition so it can be encapsulate\n                // + | \n                option.appendToBuffer(_buffState, _marker, true, true);\n            }\n            if (!_close_block && (_marker.\n                isFormattingStartBlockElement || _marker.isBlock)) {\n                if (parent && (_marker.mode == 1)) {\n                    option.store();\n                }\n            } else if (_close_block) {\n                _formatting.updateNextSavedMode(_marker.mode, option);\n            }\n        }\n\n        if (!_marker.value && _old) {\n            // + | update marker value fallback \n            _marker.value = {\n                source: option.data,\n                value: option.buffer\n            }\n        }\n\n        // + | streat value berfore end \n        this.treatEndMarkerValue(_marker, option);\n\n\n        this._onEndHandler(_marker, option);\n        // + | reset glub value      \n        option.onBeginEndFound(_marker, _old);\n        // + |\n        // + | to update join\n        this._updateJoinWith(_marker, option);\n\n        //if (parent && (parent.childs.length ==1)){\n        // only for onchilds parents. check that element is empty \n        //}\n        if (parent && _marker.closeParent) {\n            let _data = _marker.closeParentData;\n            return this._closeMarker(_marker, parent, option, _data);\n        }\n        // + invoke check parent\n        return this._invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, parent);\n    }\n    /**\n     * \n     * @param {*} _checkParentInfo \n     * @param {*} _endCaptureCallback \n     * @param {*} option global option context\n     * @param {*} fallbackMarker fallback\n     * @returns \n     */\n    _invokeCheckParent(_checkParentInfo, _endCaptureCallback, option, fallbackMarker) {\n        if (_checkParentInfo && _endCaptureCallback) {\n            return _endCaptureCallback.apply(this, [_checkParentInfo, option]);\n        }\n        return fallbackMarker;\n    }\n    /**\n     * \n     * @param {*} _buffer \n     * @param {*} _marker \n     * @param {*} option \n     */\n    _updatePreservedBlockBuffer(_buffer, _marker, _old, option) {\n        const _parentInfo = option.peekMarkerInfo;\n        let _nextBuffer = null;\n        // const { parent } = _marker; \n        if (_buffer.indexOf(_old.entryBuffer) === 0) {\n            let _ln = _old.entryBuffer.length;\n            let _up = _buffer.substring(0, _ln);\n            _nextBuffer = _buffer.substring(_ln);\n\n            this._updateOldMarkerContent(_parentInfo, option, _up, '');\n            _buffer = '';\n        }\n        return { _buffer, _nextBuffer };\n\n    }\n    _closeMarkerByStop(marker, tp, option, { _line = '', nextMode }) {\n        let _old = null;\n        let _endFound = this._handleFoundEndPattern;\n        let _buffer = null;\n\n        tp = tp || [''];\n        if (marker.from && (option.markerInfo.length > 0)) {\n            _old = option.shiftFromMarkerInfo(marker.from, true);\n            _old = option.shiftFromMarkerInfo(marker, true);\n            _endFound = _old.endFound || _endFound;\n            marker = marker.from;\n        } else {\n            _old = option.shiftFromMarkerInfo(marker, true);\n        }\n\n\n        _buffer = _old ? this._updateOldMarkerContent(_old, option) : '';\n\n        // let _cline = _line.substring(tp.index);\n        // + | clear line input to update end buffer formatter\n        option.lineMatcher.save('');\n        tp.input = '';\n        tp.index = 0;\n        option.skipTreatEnd = true;\n        marker.endGroup = tp;\n        marker = _endFound.apply(this, [_buffer, _line, marker, tp, option, _old]);\n        option.skipTreatEnd = false;\n        option.lineMatcher.restore();\n        return marker;\n    }\n    /**\n     * update format mode\n     * @param {*} from \n     * @param {*} to \n     */\n    _updateFormatModeFromTo(from, to, option) {\n        const { formatting } = this;\n        if (to === null) {\n            // + update global mode formatting\n            formatting.updateGlobalFormatting(from, option);\n        } else {\n            // + | move next mode to top parent\n            to.mode = option.nextMode;\n            if (to !== from) {\n                option.lineFeedFlag = false;\n            }\n        }\n    }\n    /**\n     * end non capture block\n     * @param {{pos:number, line:string, buffer:string, _line: string, _old:*, endGroup}} info \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    _closeNonCaptureBlock(info, option) {\n        const { parent, endGroup, state } = info;\n        const { lineMatcher } = option;\n        let p = null;\n        const _line = info.line.substring(info.pos);\n        const _nextPosition = option.pos;\n        const _bckLine = option.line;\n        let _bckLineOffset = lineMatcher.offset;\n        let treat = false;\n        let fromChild = info.fromChild;\n        let tp = null;\n        let _end_non_capture = (marker, tp, nextMode) => {\n            marker.mode = nextMode;\n            let _ret_marker = this._closeMarkerByStop(marker, tp, option, { _line, nextMode });\n            this._updateFormatModeFromTo(marker, _ret_marker, option);\n            return _ret_marker;\n        };\n        let _offsetPosition = _nextPosition;\n        let _is_match = state == 'match';\n        if (_is_match) {\n            _offsetPosition = info.pos;\n        }\n        let _tcline = lineMatcher.subLine;\n        let _toffset = lineMatcher.offset;\n        let _loopCounter = 0;\n        // + | element do not  capture data \n        let _start = endGroup[0].length == 0;\n        // + | loop thru end captured data to close \n        let _supportCapture = false;\n        while (_start && info.parent && (fromChild || _supportCapture || info.parent.isEndCaptureOnly)) {\n            p = info.parent;\n            const { endRegex } = p;\n            _loopCounter++;\n\n            if (endRegex == null) {\n                // just loop on current p;\n                treat = true;\n                break;\n            }\n            if (tp = endRegex.exec(_tcline)) {\n                let l = (tp.index + _toffset);\n                let _ln = tp[0].length;\n                let _empty_capture = (_ln == 0);\n                if (((l == endGroup.index) && _empty_capture) || (_supportCapture && !_empty_capture && (endGroup.index == l + _ln))) {\n                    if (_supportCapture && !_empty_capture && (endGroup.index == l + _ln)) {\n                        tp.index += _toffset + _ln;\n                    } else\n                        tp.index += _toffset;\n                    p = _end_non_capture(p, tp, option.nextMode);\n                } else {\n\n                    // fix offset parent\n                    if ((l < endGroup.index) || !_empty_capture)\n                        _bckLineOffset = _offsetPosition;\n                    break;\n                }\n                treat = true;\n            } else {\n                tp = endRegex.exec(_line);\n                if (tp) {\n                    if ((tp.index + _offsetPosition) == endGroup.index) {\n                        // + | same index - update capture continue end\n                        tp.index += _offsetPosition;\n                        // + \n                        if (tp[0].length == 0) {\n                            // fromChild = p.isEndCaptureOnly;\n                            p = _end_non_capture(p, tp, option.nextMode);\n                        }\n                    } else {\n                        break;\n                    }\n                    treat = true;\n                } else {\n                    if (treat) {\n                        if (option.EOF) {\n                            p = _end_non_capture(p, null);\n                            info.parent = p;\n                            break;\n                        } else {\n                            break; // return p;\n                            throw new Error('end treatment - missmatch pattern: ' + p.toString());\n                        }\n                    }\n                    p = null;\n                }\n            }\n            info.parent = p;\n            fromChild = false;\n            _supportCapture = p ? ((p) => {\n                const { endRegex } = p;\n                return RegexUtils.HasMovementCapture(endRegex);\n            })(p) : false;\n        }\n\n        if (_is_match && (treat) && p) {\n            const _endRegex = p.endRegex;\n            if (_endRegex) {\n                tp = _endRegex.exec(_line);\n                if (tp && (tp[0].length == 0) && (tp.index + _offsetPosition == endGroup.index)) {\n                    tp.index += _offsetPosition;\n                    p = _end_non_capture(p, tp);\n                }\n            }\n        }\n        option.pos = _nextPosition;\n        option.line = _bckLine;\n        // if (!_start){\n        // + | update end lineMatcher offset to next research will start at position\n        if (treat) {\n            option.lineMatcher.offset = _nextPosition;\n            return p;\n        }\n        option.lineMatcher.offset = _bckLineOffset;\n        return parent;\n    }\n\n    /**\n     * check if this marker will be consider as an empty block if requested\n     * @param { {childs: [], _marker,condition}} option  \n     */\n    _isEmptyRequestBlock({ childs, _marker, condition }) {\n        if (childs.length == 0) {\n            return false;\n        }\n        const _tchilds = childs.slice(0);\n        if (condition) {\n            let r = true;\n            let q = null;\n            let expression = this._funcRegistryExpression();\n            const list = expression.namespaces.filter((o) => {\n                // ignore no valid name spacec\n                return o.indexOf('-') == -1;\n            }).join(',');\n            let fc = new Function(\"registry\", \"child\", \"marker\", `const {${list}} = registry; return ${condition};`);\n            while (_tchilds.length > 0) {\n                q = _tchilds.shift();\n\n                try {\n                    r = fc.apply({ child: q }, [\n                        expression.registry, q, _marker]);\n                }\n                catch (e) {\n                    console.error(\"error : \", e);\n                    return true;\n                }\n                if (r) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * update marker child \n     * @param {*} _marker \n     */\n    _updateMarkerChild(_marker, option) {\n        const { parent } = _marker;\n        if (!parent) return;\n\n        parent.childs.push({\n            name: _marker.name,\n            marker: _marker\n        });\n        this._updateParentProps(_marker, false, option);\n    }\n    /**\n     * \n     * @param {{name:string, marker:*}[]} childs \n     * @returns \n     */\n    static IsChildBlock(childs) {\n        let _block = false;\n        childs.forEach(c => {\n            _block = _block || (c.marker.isBlock);\n        });\n        return _block;\n    }\n    /**\n     * \n     * @param {*} _marker \n     * @param {*} _old \n     * @param {*} _buffer \n     * @param {*} _endRegex \n     * @param {*} option \n     * @returns \n     */\n    _updateMarkerOldContentOrSwapBuffer(_marker, _old, _buffer, _endRegex, option) {\n        if (_old) {\n            _old.content = _buffer;\n            if ((option.markerInfo.length < 0) || (option.markerInfo[0] !== _old))\n                option.unshiftMarker(_old);\n        } else {\n            if (!this.settings.useIndent) {\n                //_buffer = _buffer.trimStart();\n            }\n            _old = this._backupMarkerSwapBuffer(option, _marker, _buffer, _endRegex);\n            if (option.holdBufferState)\n                option.newOldBuffers.push(_old);\n        }\n        return _old;\n    }\n\n    /**\n     * restore buffer\n     * @param {*} option \n     * @param {*} data \n     */\n    _restoreBuffer(option, data) {\n        option.debug && Debug.log(':::--restore buffer--:::');\n        option.restoreBuffer(data);\n    }\n    /**\n     * initialize marker info object \n     * @param {FormatterOptions} option \n     * @param {PatternMatchInfo} _marker \n     * @param {string} entry \n     * @param {string|RegExp} _endRegex \n     */\n    _backupMarkerSwapBuffer(option, _marker, entry, _endRegex) {\n        option.debug?.feature('backup-swap-buffer') && Debug.log('--::: backup and swap buffer.[' + entry + ']');\n        let _u_content = null;\n        const _formatting = this.formatting;\n        if (_marker.isBlock && _marker.isCaptureOnly && !_marker.isStreamCapture) {\n            // buffer = content+buffer;\n            _u_content = entry;\n            entry = '';\n        }\n        if (option.appendToBufferListener) {\n            option.appendToBufferListener(entry, _marker, false, option);\n            entry = '';\n        }\n        const _inf = new FormatterMarkerInfo(this, _marker, entry, _endRegex, option);\n\n        // + | unshift marker \n        option.unshiftMarker(_inf);\n        // + | save option state\n        _inf.saveState(option, _marker.mode);\n        // + | create a new buffer \n        option.newBuffer(option.markerInfo.length);\n        // + | update option mode with current mode\n        option.nextMode = _inf.currentMode;\n        // + | remove start line flag\n        option.startLine = false;\n        // + | \n        option.skipEmptyMatchValue = false;\n        // + | reset line feed flag\n        if (_marker.parent)\n            option.lineFeedFlag = false;\n\n        _formatting.updateStartFormatting(option.nextMode, option);\n        if (_u_content) {\n            _inf.captureEntry = _u_content;\n            option.nextMode = _formatting.appendMode;\n        }\n        // update glue flags\n        // if (entry=='(')\n        option.useGlue(_marker, '');\n\n        return _inf;\n    }\n    /**\n     * update marker information - content and datathat is on the buffer\n     * @param {*} _old \n     * @param {bool} startLine \n     * @param {FormatterOptions } option \n     * @returns \n     */\n    _updateOldMarkerContent(_old, option, buffer, extra) {\n        let { content, marker, currentMode, autoStartLine, prependExtra } = _old;\n        let data = null;\n        const _formatting = this.formatting;\n        const _is_buffer = (buffer == undefined) && (extra == undefined);\n        const _ref_data = {};\n        let _buffer_data = null;\n        if (_is_buffer) {\n            _buffer_data = option.formatterBuffer.joinSegments('');\n            buffer = option.buffer;\n            data = option.data;\n            extra = option.flush(true, _ref_data);\n        } else {\n            buffer = buffer || '';\n            extra = extra || '';\n        }\n        const isEntryContent = _old.useEntry && (content == _old.entryBuffer);\n        let _joinwith = null;\n        if (_old.captureEntry) {\n            buffer = this._updateOldEntryCapture(_old, buffer, option);\n            _joinwith = marker.joinWith;\n        }\n\n        const props = {\n            marker, buffer, extra, option,\n            content,\n            data,\n            segments: _old.data,\n            mode: currentMode,\n            autoStartLine,\n            startBlock: _old.startBlock,\n            isEntryContent,\n            prependExtra,\n            bufferData: _buffer_data // join segment with buffered data.\n        };\n        content = _formatting.updateOldMarkerContent(props);\n        //+| update current mode \n        if (_old.currentMode != props.mode) {\n            _old.currentMode = props.mode;\n        } else if (option.nextMode != _old.currentMode) {\n            _old.currentMode = option.nextMode;\n        }\n        // update content\n        _old.content = content;\n        _old.startBlock = 0;\n        _old.autoStartLine = props.autoStartLine;\n        // + | store update current joinWith\n        _old.joinWith = _joinwith;\n        _old.prependExtra = props.prependExtra;\n        _old.set();\n        return content;\n    }\n\n    _handleSameGroup2(_marker, _matcher, _p, _old, _buffer, option, _endRegex) {\n        const { formatting } = this;\n        this._checkStartBlockDefinition(_matcher, option);\n        if (_matcher.group[0].length == 0) {\n            // matcher is empty and must past to end group\n            // just invoke the matcher before send to parent \n            if ((option.markerInfo.length == 0) || (option.markerInfo[0] !== _marker)) {\n                this._updateMarkerOldContentOrSwapBuffer(_marker, _old, _buffer, _endRegex, option);\n            }\n            let _q = this._handleMarker(_matcher, option);\n            return _q;\n        }\n        // + | update parent markerin of before handle marker \n        if ((option.markerInfo.length == 0) || (option.markerInfo[0] !== _marker)) {\n            this._updateMarkerOldContentOrSwapBuffer(_marker, _old, _buffer, _endRegex, option);\n        }\n        return this._handleMarker(_matcher, option);\n    }\n    /**\n     * update parent property\n     * @param {PatternMatchInfo} _marker \n     * @param {bool} _start \n     * @param {FormatterOptions} option \n     */\n    _updateParentProps(_marker, _start, option) {\n        const { parent, updateParentProps, requestParentBlockCondition } = _marker;\n        if (parent && updateParentProps) {\n            const _list = [\"isBlock\", 'lineFeed'];\n            _list.forEach(a => {\n                if (!(a in parent.updatedProperties) && (a in updateParentProps)) {\n                    let s = updateParentProps[a];\n                    if (a == _list[0]) {\n                        if (s && (requestParentBlockCondition)) {\n                            s = this._isEmptyRequestBlock({\n                                childs: _marker.childs,\n                                _marker,\n                                condition: requestParentBlockCondition\n                            });\n                        }\n                    }\n                    if (parent[a] != s) {\n                        parent[a] = s;\n                        parent.updatedProperties[a] = a;\n                    }\n                }\n            });\n\n\n            if (!_start) {\n                this._initUpdatedisBlockStartInformation(_marker, option);\n            } else {\n                this._checkUpdatedStartBlockProperties(parent, option, true);\n            }\n        }\n    }\n    /**\n     * \n     * @param {PatterMatchErrorInfo} _marker \n     * @param {FormatterOptions} option \n     * @param {boolean} _startBlock \n     */\n    _checkUpdatedStartBlockProperties(_marker, option, _startBlock) {\n        const { updatedProperties, isBlockStarted, blockStartInfo } = _marker;\n        if ((\"isBlock\" in updatedProperties) && !isBlockStarted && !blockStartInfo) {\n            // + | update parent block information \n            // + | ------------------------------- \n            if (!_startBlock) {\n                _marker.isBlockStarted = true;\n            }\n            _marker.blockStartInfo = {\n                depth: option.depth\n            }\n            _startBlock && this._startBlock(option);\n        }\n    }\n    _initUpdatedisBlockStartInformation(_marker, option) {\n        const { parent } = _marker;\n        // block already started\n        if (parent && (\"isBlock\" in parent.updatedProperties) && (_marker.isBlockStarted)) {\n            this._checkUpdatedStartBlockProperties(parent, option, false);\n        }\n\n    }\n    /**\n     * \n     * @param {*} patternInfo \n     * @param {*} _line \n     * @param {*} option \n     * @returns \n     */\n    detectConstantPattern(patternInfo, _line, option) {\n        const _endRegex = patternInfo.endRegex;\n        let _nPatternInfo = this._createStreamConstantPattern(patternInfo, _line, _endRegex, option);\n        option.pos = option.line.length;\n        this._updateMarkerOldContentOrSwapBuffer(_nPatternInfo, null, '', _endRegex, option);\n        return _nPatternInfo;\n    }\n    /**\n     * create the stream buffer object\n     * @returns \n     */\n    _createStreamBuffer() {\n        return new FormatterStreamBuffer();\n    }\n    /**\n     * create a stream constant pattern\n     * @param {*} patternInfo \n     * @param {*} _line \n     * @param {*} _endRegex \n     * @param {*} option \n     * @returns \n     */\n    _createStreamConstantPattern(patternInfo, _line, _endRegex, option) {\n        // patterns : patternInfo.hostPatterns\n        let _stream_buffer = this._createStreamBuffer();\n        _stream_buffer.from = patternInfo;\n        _stream_buffer.initialMode = option.nextMode;\n        // copy marker info \n        _stream_buffer.sourceMarkerInfo = option.markerInfo.slice(0);\n        _stream_buffer.sourceTokenList = option.tokenList.slice(0);\n        if (_line && _line.length > 0)\n            _stream_buffer.appendToBuffer(_line);\n\n\n        let _nPatternInfo = new PatternMatchInfo();\n        let _idx = patternInfo.indexOf;\n        _nPatternInfo.use({\n            marker: _stream_buffer,\n            endRegex: patternInfo.endRegex, //  ,\n            group: patternInfo.group,\n            line: option.line, // source line\n            parent: patternInfo?.parent,\n            patterns: patternInfo.hostPatterns,\n            index: _idx,\n            formatting: this.formatting\n        });\n        _stream_buffer.startPosition = option.pos;\n        _stream_buffer.start(option);\n        return _nPatternInfo;\n    }\n    /**\n     * check and start block definition\n     * @param {*} patternInfo \n     * @param {*} option \n     * @param {boolean} init \n     */\n    _checkStartBlockDefinition(patternInfo, option, init = false) {\n        const _formatting = this.formatting;\n        // start a new block\n        if (patternInfo.isBlock && !patternInfo.isBlockStarted) {\n            init && this._initBlockStarting(patternInfo, option);\n            _formatting.startBlockDefinition(this, patternInfo, option);\n        }\n    }\n    /**\n     * \n     * @param {*} patternInfo \n     * @param {*} option \n     * @param {*} _old \n     */\n    _updateStreamRangeModeToHolder(patternInfo, option, _old) {\n        if (option.range.start != option.range.end) {\n            this._updatePatternPrevConstant(patternInfo, option, null, null, true);\n            this._updateOldMarkerContent(_old, option);\n            option.storeRange(option.pos);\n        }\n    }\n    /**\n     * get item found callback\n     * @returns \n     */\n    _handleItemFoundCallback() {\n        return function (_matcher, patternInfo, _old, _buffer, _endRegex, option) {\n            const { debug } = option;\n            let { nextMode } = option;\n            if (_old == null) {\n                this._registerTokenName(patternInfo, option);\n            }\n            // handle matcher   \n\n            let _newOld = this._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n            nextMode = _newOld.currentMode;\n\n            // update previous matcher info\n            option.storeRange(option.pos, _matcher.group.index);\n            if (option.range.start != option.range.end) {\n                this._updatePatternPrevConstant(patternInfo, option, null, null, true);\n                _newOld.currentMode = nextMode;\n                this._updateOldMarkerContent(_newOld, option);\n                option.storeRange(option.pos);\n            }\n            this._checkStartBlockDefinition(patternInfo, option);\n            this._checkStartBlockDefinition(_matcher, option);\n            debug?.feature('found-items') && Debug.log(\"--::: found item #\" + _matcher.toString());\n            let _ret = this._handleMarker(_matcher, option);\n            return _ret;\n        };\n    }\n    /**\n     * \n     * @param {{_p, _matcher, patternInfo, option, endFound(), itemFound(), \n     * handleConstant(patternInfo, _line:string, option):}} param \n     */\n    handleMatchLogic({\n        _p, _matcher, _buffer, _old, patternInfo, option, _line,\n        endFound,\n        itemFound, handleConstant\n    }) {\n        let _continue_with_marker = false;\n        const _endRegex = patternInfo.endRegex;\n        const q = this;\n        endFound = endFound || q._handleFoundEndPattern;\n        handleConstant = handleConstant || q.detectConstantPattern;\n        itemFound = itemFound || q._handleItemFoundCallback();\n        if (_matcher == null) {\n            // no child matcher found\n            if (_p == null) {\n                // no end - found \n                _continue_with_marker = true;\n                // update cursor \n                q._appendConstant(patternInfo, _line, option);\n                option.pos = option.line.length;\n            } else {\n                // ---------------------------------------------------------------\n                // + | invoke END FOUND\n                // ---------------------------------------------------------------\n                return endFound.apply(q,\n                    [_buffer, _line, patternInfo, _p, option, _old]);\n            }\n        }\n        else {\n\n            // compared index and handle child\n            if ((_p == null) || (_matcher.group.index < _p.index)) {\n                // handle matcher  \n                return itemFound.apply(q, [_matcher, patternInfo, _old, _buffer, _endRegex, option]);\n            }\n            // check if same \n            if (_matcher.group.index == _p.index) {\n                return Formatters.HandleSameGroup(q, patternInfo, _matcher, _p, _old, _buffer, _endRegex, option, endFound);\n            }\n            // priority to current marker \n            return endFound.apply(q, [_buffer, _line, patternInfo, _p, option, _old]);\n            // throw new Error(\"Detected after not handle\");\n        }\n        if (_continue_with_marker) {\n            q._updateMarkerOldContentOrSwapBuffer(patternInfo, _old, _buffer, _endRegex, option);\n            return patternInfo;\n        }\n\n        // + | default append \n        listener.append(group[0], patternInfo);\n        // + | move forward\n        option.moveTo(_next_position);\n        return patternInfo.parent;\n    }\n    static HandleSameGroup(q, patternInfo, _matcher, _p, _old, _buffer, _endRegex, option, endFound, _line) {\n\n        const { debug } = option;\n        // const { endMatchLogic } = q.settings;\n        debug?.feature('handle-same-group') && (() => {\n            Debug.log('-:::handle same group:::-');\n        })();\n        // + | priority end group\n        let _ret = null;\n        _line = _line || option.line.substring(option.pos);\n        let startLine = patternInfo.isStreamCapture ? option.startLine : undefined;\n        // debug && Debug.log(\"Before logic just call end found. \");             \n        if (endFound) {\n            _ret = endFound.apply(q, [_buffer, _line, patternInfo, _p, option, _old]);\n        } else {\n            _ret = q._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n        }\n        if (startLine) {\n            option.startLine = startLine;\n            if (startLine) {\n                option.skipUpdateStartLine = true;\n            }\n        }\n        return _ret;\n    }\n    isSpecialMarker(marker) {\n        return marker instanceof SpecialMeaningPatternBase\n    }\n    /**\n     * append buffer and new line end buffer list\n     * @param {string} sb \n     * @param {PatternMatchInfo} marker \n     * @param {FormatterOptions} option \n     */\n    appendBufferAndLine(sb, marker, option) {\n        option.appendToBuffer(sb, marker);\n        option.store();\n        option.appendExtraOutput();\n    }\n}\n\nclass SpecialMeaningPatternBase extends Patterns {\n    get isSpecial() { return true; }\n}\n\nclass BlockPatternBase extends SpecialMeaningPatternBase {\n    get isBlock() { return true; }\n}\nclass EmptyBlockPattern extends BlockPatternBase {\n    name = 'system.empty.block';\n    get isEmptyBlock() { return true; }\n}\nclass BlockDefinitionPattern extends BlockPatternBase {\n    get isBlockDefinition() { return true };\n    name = 'system.block.definition';\n}\n\n/**\n * use to debug constant list \n */\nclass SystemConstantPattern extends SpecialMeaningPatternBase {\n    tokenID = 'constant';\n    transform = [function (v) {\n        if (v.trim().length == 0) return ''; return v;\n    }, 'joinSpace']\n    markedInfo() {\n        return Utils.GetMarkedInfo(this);\n    }\n}\n// previous contains before add to buffer \nclass PrevLineFeedConstantPattern extends SystemConstantPattern {\n    name = 'system.prev.line.feed.constant';\n\n    /**\n     * check if shift id constant\n     * @returns {bool}\n     */\n    shiftIdConstant() {\n        return false;\n    }\n}\n\nclass TrimmedPrevLineFeedConstant extends PrevLineFeedConstantPattern {\n    constructor() {\n        super();\n        this.markedSegment = {\n            trimmed: true\n        }\n    }\n}\n\nconst SYSTEM_MATCH_TYPE = 0x100;\n\nclass GlobalConstantPattern extends SystemConstantPattern {\n    name = 'system.global.line.constant';\n\n}\nclass StreamLineConstantPattern extends SystemConstantPattern {\n    name = 'system.stream.line.constant';\n}\nclass StreamBufferConstantPattern extends SystemConstantPattern {\n    name = 'system.stream.buffer.constant';\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 8;\n    }\n}\n\nclass PrevConstantPattern extends SystemConstantPattern {\n    name = 'system.prev.line.constant';\n}\nclass NameOnlyConstantPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 3;\n    }\n}\n\nclass RefConstantPattern extends SystemConstantPattern {\n    constructor(n) {\n        super();\n        this.name = n;\n    }\n}\nclass JoinMarkerPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 6;\n    }\n}\n\nclass EntryCapturePattern extends SpecialMeaningPatternBase {\n    name = 'entry.capture.pattern';\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 7;\n    }\n    constructor(value) {\n        super();\n        Object.defineProperty(this, 'value', { get() { return value; } })\n    }\n}\nclass TypeMarkerInfoPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return SYSTEM_MATCH_TYPE + 5;\n    }\n    constructor(type, { parser, data }) {\n        super();\n        if (typeof (type) == 'string') {\n            type = type.replace('.', '-');\n            this.tokenID = data?.tokenID || type;\n            this.name = data?.name || type;\n        }\n        if (data) {\n            // get extra key definition and append to parent\n            const keys = Object.keys(data);\n            const _mkeys = Object.keys(this);\n\n            ['type', 'value'].forEach(i => {\n                const idx = keys.indexOf(i);\n                if (idx !== -1)\n                    delete (keys[idx]);\n            });\n\n            const _diff = keys.filter((a) => _mkeys.indexOf(a) === -1);\n            const q = this;\n            _diff.forEach((o) => {\n                Object.defineProperty(q, o, { get() { return data[o]; } });\n            });\n        }\n    }\n}\n\nUtils.Classes = {\n    ...Utils.Classes,\n    Formatters\n};\n\nexports.Formatters = Formatters;\nexports.Utils = Utils;\nexports.Patterns = Patterns;\nexports.JSonParser = JSonParser;\nexports.SpecialMeaningPatternBase = SpecialMeaningPatternBase;\n\nconst { FormatterStreamBuffer } = require('./FormatterStreamBuffer');\nconst { FormatterLintError } = require('./FormatterLintError');\nconst { PatterMatchErrorInfo } = require('./PatterMatchErrorInfo');\nconst { ReplaceWithCondition } = require('./ReplaceWithCondition');\nconst { FormatterMatchTreatment } = require('./FormatterMatchTreatment');\n\n\n\nUtils.Classes.FormatterStreamBuffer = FormatterStreamBuffer;\n\n// Utils.DefineProperties(Utils.Classes, exports);","\"use strict\";\nconst K_R = 'KAndR'\nconst PSR_2 = 'PSR-2';\nconst PSR_21 = 'PSR-21';\nconst PSR_12 = 'PSR-12';\nconst ALLMAN = 'Allman';\nclass FormattingCodeStyles{\n    static get K_R(){return K_R; } \n    static get PSR_2(){return PSR_2; } \n    static get PSR_21(){return PSR_21; } \n    static get PSR_12(){return PSR_12; } \n    static get ALLMAN(){return ALLMAN; } \n\n    /**\n     * \n     * @param {*} data \n     */\n    static Support(data){\n        // \n        return FormattingCodeStyles.GetSupportedValues().indexOf(data) != -1;\n    }\n    static GetSupportedValues(){\n        return [\n            K_R,PSR_2, PSR_21, PSR_12, ALLMAN\n        ]\n    }\n}\nexports.FormattingCodeStyles = FormattingCodeStyles;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nexports.FormattingBase = void (0);\nconst { Debug } = require(\"../Debug\");\nconst { FormatterSegmentJoin } = require(\"../FormatterSegmentJoin\");\nconst { FormatterBuffer } = require(\"../FormatterBuffer\");\n\n\nconst CODE_STYLE_FORMATTERS = {};\n/**\n * operation to manipulate the formatter buffer on condition.\n */\nclass FormattingBase {\n    trimConstant;\n\n    startBlock({ currentMode }, _marker, _option) {\n        currentMode = FM_START_LINE;\n        arguments[0].currentMode = currentMode;\n    }\n    oldStartStreamingBlock({currentMode}){\n        currentMode = FM_START_LINE; \n        //arguments[0].currentMode = 100+currentMode;\n    }\n    /**\n     * update buffer prev content constant\n     * @param {*} data \n     * @param {*} mode \n     * @param {*} _marker \n     * @param {*} option \n     */\n    updateBufferConstant(data, mode, _marker, option) {\n        const { formatterBuffer } = option;\n        switch (mode) {\n            case FM_START_LINE:\n            case FM_END_BLOCK:\n                data = data.trimStart();\n                let _buffer = option.buffer;\n                if (_buffer.length > 0) {\n                    option.output.push(_buffer); // append line \n                    formatterBuffer.clear();\n                }\n                option.appendToBuffer(data, _marker);\n                mode = FM_APPEND;\n                break;\n            case FM_APPEND:\n                option.appendToBuffer(data, _marker);\n                break;\n            case FM_START_BLOCK:\n                // +| depending on the formatting mode start new block\n                data = data.trimStart();\n                if (data.length > 0) {\n                    option.appendToBuffer(data, _marker);\n                    mode = FM_APPEND;\n                }\n                break;\n            case FM_END_INSTRUCTION: // update buffer after end instruction\n                data = data.trimStart();\n                if (data.length > 0) {\n                    option.lineFeedFlag && option.appendExtraOutput();\n                    option.appendToBuffer(data, _marker);\n                    if (option.output.length > 0) {\n                        option.store();\n                        formatterBuffer.appendToBuffer(option.flush(true));\n                    }\n                    mode = FM_APPEND;\n                }\n                break;\n            case FM_START_LINE_APPEND:\n                data = data.trimStart();\n                if (data.length > 0) {\n                    option.appendToBuffer(data, _marker);\n                    option.store();\n                    mode = FM_APPEND;\n                }\n                break;\n            default:\n                throw new Error('update Buffer not handled : ' + mode);\n        }\n        _marker.mode = mode;\n    }\n    /**\n     * update marker global option\n     * @param {*} param0 \n     */\n    updataMarkerGlobalOption({ mode, lineFeedFlag, startLine }, option) {\n        const e = arguments[0];\n        switch (mode) {\n            case FM_START_LINE_NEXT_LINE:\n            case FM_END_BLOCK:\n            case FM_START_LINE:\n            case FM_END_INSTRUCTION:\n            case FM_APPEND_BLOCK:\n                startLine = true;\n                lineFeedFlag = true;\n                break;\n            default:\n                break;\n        }\n\n        e.lineFeedFlag = lineFeedFlag;\n        e.startLine = startLine;\n        if (option) {\n            option.startLine = startLine;\n            option.lineFeedFlag = lineFeedFlag;\n            option.nextMode = mode;\n        }\n    }\n    /**\n     * \n     * @param {number} mode \n     * @param {*} option \n     */\n    updateGlobalFormatting({ mode, formattingMode }, { lineFeedFlag, line, pos, length }) {\n        // after mode update global mode options\n        const option = arguments[1];\n\n        if (formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) {\n            if (mode == FM_START_LINE) {\n                mode = FM_APPEND;\n                lineFeedFlag = (pos >= length) || (line.trimEnd().length == pos);\n            }\n        }\n        switch (mode) {\n            case FM_START_LINE:\n            case FM_START_BLOCK:\n            case FM_END_BLOCK:\n                lineFeedFlag = true;\n                break;\n        }\n        option.lineFeedFlag = lineFeedFlag;\n    }\n    /**\n     * treat contant value before append to buffer\n     * @param {*} value \n     * @param {*} marker \n     */\n    treatConstantValue(value, marker, option) {\n        if (this.trimConstant) {\n            value = value.trimEnd();\n        }\n        return value;\n    }\n    /**\n     * retrieve append mode\n     */\n    get appendMode() {\n        return FM_APPEND;\n    }\n    updateStartFormatting(mode, option) {\n        switch (mode) {\n            case FM_START_LINE:\n            case FM_START_BLOCK:\n                option.startLine = true;\n                break;\n        }\n\n    }\n    updateEmptySkipMatchedValueFormatting(parent, option, { formattingMode }) {\n        if (parent) {\n            parent.mode = FM_START_LINE;\n        } else {\n            let _gformatting = FM_APPEND;\n            if (formattingMode == PatternFormattingMode.PFM_LINE_FEED) {\n                _gformatting = FM_START_LINE;\n            }\n            this.updateGlobalFormatting({ mode: _gformatting, formattingMode }, option);\n        }\n    }\n    /**\n     * update mode on close marker \n     * @param {*} marker \n     */\n    closeMarker(marker) {\n        if ((marker.isBlock) && (marker.mode == FM_APPEND)) {\n            marker.mode = FM_START_LINE;\n        }\n    }\n    updateMergeEndBlock({ content, marker, option, extra, buffer, _hasBuffer, _hasExtra }) {\n        let value = '';\n        let mode = marker.mode;\n        if (_hasBuffer) {\n            value += buffer;\n            mode = FM_START_LINE;\n        }\n        content = content.trimEnd();\n        return { value, content, mode };\n    }\n    /**\n     * \n     * @param {*} marker \n     * @param {FormatterOptions} option \n     */\n    updateEndLineUpdateMode(marker, option) {\n        if (marker) {\n            const _old = option.markerInfo[0];\n            const { formattingMode, mode } = marker;\n            let _buffer_is_empty = option.formatterBuffer.isEmpty;\n            if ((formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) && (mode == FM_APPEND)) {\n                option.nextMode = FM_START_LINE;\n                marker.mode = FM_START_LINE;\n                // + | change the current mode to start line request\n                if ((_old.currentMode == FM_APPEND) && (_buffer_is_empty)) {\n                    _old.currentMode = FM_START_LINE;\n                }\n            }\n        }\n    }\n    updatePreprendExtra(prependExtra, extra, option) {\n        option.saveBuffer();\n        let r = '';\n        (!Array.isArray(prependExtra) ? [prependExtra] : prependExtra).\n            forEach(i => {\n                option.formatterBuffer.appendToBuffer(i);\n                option.store();\n            });\n        if (extra !== null)\n            option.output.push(extra);\n        r = option.flush(true);\n        option.restoreSavedBuffer();\n        extra = r;\n        return { extra };\n    }\n    /**\n     * update buffer segment data\n     * @param {*} formatterBuffer \n     * @param {*} bufferData \n     */\n    _updateFormatterBufferSegments(formatterBuffer, bufferData) {\n        const { bufferSegment, dataSegment } = bufferData;\n        formatterBuffer.appendToBuffer({\n            bufferSegments: bufferSegment,\n            dataSegments: dataSegment\n        });\n    }\n    // + | -------------------------------------------------------------\n    // + | depending on marker mode update old marker content new value\n    // + | update from buffer content. \n    // + | -------------------------------------------------------------    \n    updateOldMarkerContent({ content, marker, extra, buffer, data, segments, option, mode, isEntryContent,\n        autoStartLine, prependExtra, bufferData }) {\n        let _ld = '';\n        const { debug, joinWith, formatterBuffer } = option;\n        mode = mode == undefined ? FM_APPEND : mode;\n        const _props = arguments[0];\n        let _hasExtra = (extra.length > 0);\n        let _hasBuffer = (buffer.length > 0);\n        if (!_hasExtra && !_hasBuffer) {\n            return content;\n        }\n        if (prependExtra) {\n            // + | ----------------------------------------------------------\n            // + | prepend extra data \n            // + | ----------------------------------------------------------\n            ({ extra } = this.updatePreprendExtra(prependExtra, extra, option));\n            prependExtra = null;\n        }\n\n        const _undef = typeof (marker.mode) == 'undefined';\n        let _append_next_mode = _undef ? FM_APPEND : marker.mode;\n\n        debug?.feature('update-old-buffer') && (function () {\n            Debug.log(\"--::: update old buffer :::--\");\n            console.log({ content, buffer, extra, mode, data });\n        })();\n\n        const _updateLd = () => {\n            const _ref_data = {};\n            const _buffer = option.flush(true, _ref_data);\n            _ld += _buffer;\n            _updateSegment({ buffer: _buffer, data: _ref_data.data });\n        };\n        const _updateSegment = ({ buffer, data }) => {\n            segments.bufferSegment.push(buffer);\n            segments.dataSegment.push(data);\n        };\n        // + | update what for buffer data\n        const _updateBufferedData = ({ dataSegment, bufferSegment }) => {\n            FormatterSegmentJoin.UpdateSegmentData(segments, { dataSegment, bufferSegment });\n        };\n        let _treat_buffer_data = false;\n\n        const _treat_buffer_data_fc = (op='trimmed')=>{\n            if (_treat_buffer_data)return;\n            FormatterBuffer.TreatMarkedSegments(bufferData, op);\n            buffer = bufferData.bufferSegment.join('');\n            _treat_buffer_data = true;\n        };\n\n        //+ || handle trimmed container\n        if ((marker.formattingOptions?.trimmedContainer || /\\(|\\[|\\{/.test(content)) && (marker.childs.length < 2)){\n            _treat_buffer_data_fc();\n        }\n\n\n\n\n        const _flushData = {};\n        switch (mode) {\n            case FM_START_LINE:\n                _treat_buffer_data_fc(); \n                if (joinWith) {\n                    _ld = buffer;\n                } else {\n                    _ld = this._treatOldMarkerContent(option, true, extra, buffer, _hasBuffer, _hasExtra);\n                }\n                if (_ld.length <= 0) {\n                    _append_next_mode = FM_START_LINE;\n                } else\n                    _flushData.dataOutput = _ld;\n                break;\n            case FM_END_BLOCK:\n                // after end block\n                // start line \n                option.appendExtraOutput();\n                let value = '';\n                ({ value, mode, content } = this.updateMergeEndBlock({ content, marker, extra, buffer, option, _hasBuffer, _hasExtra }));\n                option.formatterBuffer.appendToBuffer(value);\n                option.store();\n                _ld = option.flush(true, _flushData);\n                break;\n            case FM_START_BLOCK: // every block start with extra output\n                option.appendExtraOutput();\n                if (_hasExtra)\n                    option.output.push(extra);\n                if (_hasBuffer) {\n                    formatterBuffer.appendToBuffer(buffer);\n                    option.store();\n                }\n                _ld = option.flush(true, _flushData);\n                if (_append_next_mode == FM_END_BLOCK) {\n                    _append_next_mode = FM_START_LINE;\n                }\n                break;\n            case FM_END_INSTRUCTION: // after end instruction \n                if (_hasExtra) {\n                    option.output.push(extra);\n                    _ld = option.flush(true);\n                    _hasExtra = false;\n                }\n                if (_hasBuffer) {\n                    if (!_hasExtra) {\n                        option.appendExtraOutput();\n                    }\n                    option.formatterBuffer.appendToBuffer(buffer.trimStart());\n                    option.store();\n                    _ld += option.flush(true);\n                }\n                break;\n            case FM_APPEND_TO_NEXT:\n                if (_hasExtra) {\n                    option.appendExtraOutput();\n                    option.output.push(extra);\n                    _ld = option.flush(true);\n                }\n                if (buffer.length > 0) {\n                    if (!/\\\\s+$/.test(content)) {\n                        content += Utils.TreatValue(option.formatterBuffer, ' ', marker, option);\n                    }\n                    _ld += buffer;\n                }\n                break;\n\n            case FM_END_LINE:\n                // + | end line technique\n                option.appendExtraOutput();\n                if (_hasExtra) {\n                    option.output.push(extra);\n                    _updateLd();\n                }\n                if (_hasBuffer) {\n                    // trim end before store \n                    FormatterBuffer.TreatMarkedSegments(bufferData, 'trimmed');\n                    this._updateFormatterBufferSegments(formatterBuffer, bufferData);\n\n                }\n                option.store();\n                _ld = option.flush(true, _flushData);\n                if (option.nextMode == mode) {\n                    _append_next_mode = mode;\n                }\n                break;\n            case FM_APPEND:\n                if (_hasExtra) {\n                    option.appendExtraOutput();\n                    option.output.push(extra);\n                    _updateLd();\n                }\n                if (buffer.length > 0) {\n                    _ld += buffer;\n                    _updateBufferedData(bufferData);\n                }\n                break;\n            case FM_START_LINE_NEXT_LINE:\n                option.appendExtraOutput();\n                if (_hasBuffer) {\n                    formatterBuffer.appendToBuffer(buffer);\n                    option.store();\n                }\n                _ld = option.flush(true);\n                mode = FM_START_LINE_APPEND;\n                break;\n            case FM_START_LINE_APPEND:\n                _ld = this._treatOldMarkerContent(option, true, extra, buffer, _hasBuffer, _hasExtra);\n                _append_next_mode = FM_APPEND;\n                break;\n            case FM_APPEND_BLOCK:\n                ({ content, _ld } = this.onAppendBlock(content, extra, buffer, _hasBuffer, _hasExtra, isEntryContent, _flushData, segments));\n                if (!('dataOutput' in _flushData)) {\n                    _flushData['dataOutput'] = bufferData.dataSegment.join('');\n                }\n                break;\n\n            default:\n                throw new Error('mode not handle : ' + mode);\n        }\n        if ('dataOutput' in _flushData) {\n            _updateBufferedData({ dataSegment: [_flushData.dataOutput], bufferSegment: [_ld] });\n        }\n\n        marker.mode = _append_next_mode;\n        this._updateGlobalMarkerOptionDefinition(marker, option);\n        _props.mode = marker.mode;\n        _props.autoStartLine = autoStartLine;\n        _props.prependExtra = prependExtra;\n        return content + _ld;\n    }\n    /**\n     * append block\n     * @param {*} content \n     * @param {*} extra \n     * @param {*} buffer \n     * @param {*} _hasBuffer \n     * @param {*} _hasExtra \n     * @returns \n     */\n    onAppendBlock(content, extra, buffer, _hasBuffer, _hasExtra, isEntryContent, _flushData) {\n        let _ld = '';\n        if (extra.length > 0) {\n            _ld += extra;\n        }\n        if (buffer.length > 0) {\n            _ld += buffer;\n        }\n        return { content, _ld };\n    }\n    /**\n     * update defition \n     * @param {*} marker \n     * @param {*} option \n     */\n    _updateGlobalMarkerOptionDefinition(marker, option) {\n        const { mode, formattingMode } = marker;\n        const { lineFeedFlag, startLine } = option;\n        this.updataMarkerGlobalOption({ mode, formattingMode, lineFeedFlag, startLine }, option);\n    }\n    _treatOldMarkerContent(option, extraOutput, extra, buffer, _hasBuffer, _hasExtra) {\n        const { formatterBuffer } = option;\n        //extraOutput && !_hasExtra && option.appendExtraOutput();\n        extraOutput && option.appendExtraOutput();\n        if (_hasExtra) {\n            option.output.push(extra);\n        }\n        if (_hasBuffer) {\n            formatterBuffer.appendToBuffer(buffer);\n            option.store();\n        }\n        let _ld = option.flush(true);\n        return _ld.trim().length > 0 ? _ld : '';\n    }\n    /**\n     * is line feed\n     * @param {number} formattingMode \n     * @returns {boolean}\n     */\n    isLineFeed(formattingMode) {\n        return (formattingMode == PatternFormattingMode.PFM_LINE_FEED) ||\n            (formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED);\n    }\n    /**\n     * check if change to next append mode\n     * @param {*} mode \n     * @returns \n     */\n    canChangeNextFormatting(mode) {\n        switch (mode) {\n            case FM_END_INSTRUCTION:\n            case FM_END_BLOCK:\n                return true;\n\n        }\n        return false;\n    }\n    /**\n     * \n     * @param {*} formatter \n     * @param {PatternMatchInfo} marker \n     * @param {*} option \n     */\n    onAppendToBuffer(formatter, marker, value, option) {\n        let { mode } = marker;\n        const { debug } = option;\n        if (option.markerInfo.length > 0) {\n            const _old = option.markerInfo[0];\n            debug?.feature('on-append-to-buffer') && (()=>{\n                Debug.log(\"---::: onAppend to buffer - value :::---\");\n                console.log( value );\n            })()\n            // + | change current mode according to formatting rule\n            if (marker.formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) {\n\n                if (this.canChangeNextFormatting(_old.currentMode)) {\n                    if (option.startLine && (option.line.trimStart().indexOf(value) == 0)) {\n                        _old.currentMode = FM_START_LINE;\n                    } else\n                        _old.currentMode = FM_APPEND_TO_NEXT;\n                }\n\n            }\n        }\n        if (marker.lineFeed) {\n            mode = FM_START_LINE;\n        }\n        marker.mode = mode;\n\n\n    }\n    handleEndFound(formatter, marker, option, _buffer, _b) {\n        return marker.parent;\n    }\n    static Factory(name) {\n        if (name in CODE_STYLE_FORMATTERS) {\n            return CODE_STYLE_FORMATTERS[name];\n        }\n        let s = null;\n        let cname = name + 'Formatting';\n        const Library2 = Library;\n        let fc = new Function('lib', `const {${cname}} = lib; return ${cname};`);\n        let g = fc.apply(globalThis, [Library2]);\n        if (g) {\n            s = new g();\n            CODE_STYLE_FORMATTERS[name] = s;\n            return s;\n        }\n        throw new Error('missing code style formatters');\n    }\n\n    /**\n     * handle end end block buffer\n     * @param {*} _marker \n     * @param {*} _buffer \n     * @param {*} option \n     * @param {*} _old \n     * @returns \n     */\n    handleEndBlockBuffer(_marker, _buffer, option, _old) {\n        let _sbuffer = '';\n        if (option.depth > 0) {\n            if (!_old.blockStarted && (_old.content.length == 0)) {\n                option.store();\n                _sbuffer = option.flush(true);\n            }\n            else {\n                if (_old.entryBuffer.length == _old.content.trim().length) {\n                    option.store();\n                }\n                _sbuffer = option.flush(true) + _buffer;\n            }\n        } else {\n            option.store();\n            _sbuffer = option.flush(true);\n        }\n        return { _sbuffer };\n    }\n    /**\n     * on closing element passing mode to parent or ask for new line\n     * @param {*} formatter \n     * @param {*} marker_info \n     * @param {*} option \n     */\n    handleEndOnNonBlockElement(formatter, marker_info, option, { _b, _old }) {\n        // + | append with line feed if requested\n        const { parent, mode, lineFeed, formattingMode } = marker_info;\n        let _lf = (formattingMode == PatternFormattingMode.PFM_LINE_FEED) || (lineFeed);\n        let _build_lf = false;\n        if (parent) {\n            if (_lf) {\n                parent.mode = FM_START_LINE;\n            }\n            else {\n                // + passing current mode to parent\n                parent.mode = mode;\n            }\n        } else {\n            // build line on line feed or after ind line mode\n            _build_lf = (marker_info.mode == FM_END_LINE);\n            if (_lf) {\n                marker_info.mode = FM_START_LINE;\n            } else {\n                // + | depending on mode.\n                this._updateGlobalMarkerOptionDefinition(marker_info, option);\n            }\n        }\n        if (formattingMode == PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED) {\n\n            if (this.onHandleSingleLineBuffer(option) &&\n                (_b.length > 0)) {\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.formatterBuffer.appendToBuffer(_b);\n                option.store();\n                let _buffer = option.flush(true);\n                option.restoreSavedBuffer();\n                option.formatterBuffer.appendToBuffer(_buffer);\n                _b = '';\n            }\n        } else {\n            _build_lf = _build_lf || (_old?.currentMode == FM_START_LINE);\n            if (_build_lf) {\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.formatterBuffer.appendToBuffer(_b);\n                option.store();\n                let _buffer = option.flush(true);\n                option.restoreSavedBuffer();\n                option.formatterBuffer.appendToBuffer(_buffer);\n                _b = '';\n            }\n        }\n        return { _b };\n    }\n    onHandleSingleLineBuffer({ buffer, startLine }) {\n        return startLine || buffer.split(\"\\n\").length > 1;\n    }\n    /**\n     * join stream buffer\n     * @param {*} mode \n     * @param {*} buffer \n     * @param {*} append \n     * @returns \n     */\n    joinStreamBuffer(mode, buffer, append) {\n        return buffer + append;\n    }\n    /**\n     * operation to handle end block after restoring buffer\n     * @param {Formatters} formatter \n     * @param {*} _marker parent marker info \n     * @param {string|{buffer:string, data:string}} _buffer \n     * @param {FormatterOptions} option \n     */\n    updateEndBlockAfterRestoringBuffer(formatter, _marker, _buffer, _old, option) {\n        const { parent, isBlock } = _marker;\n        let _mark_buffer = false;\n        if (parent) {\n            const { mode, childs, isAutoBlockElement } = parent;\n            if (isAutoBlockElement) {\n                if ((childs.length > 1)) {\n                    if (mode == FM_START_LINE) {\n\n                        option.saveBuffer();\n                        let _frm = option.formatterBuffer;\n                        _frm.appendToBuffer(_buffer);\n                        option.store();\n                        _buffer = option.flush(true);\n                        option.restoreSavedBuffer();\n                        option.output.push(_buffer);\n                        _buffer = '';\n                    }\n                } else if (isBlock && !option.formatterBuffer.isEmpty) {\n                    let c = option.buffer;\n                    c = option.flush(true) + c;\n                    option.output.push(c + _buffer);\n                    _buffer = option.flush(true);\n                    parent.mode = FM_END_BLOCK;\n                }\n            } else {\n                _mark_buffer = true;\n            }\n        }\n\n        if (_buffer?.output?.length > 0) {\n            option.output.push(..._buffer.output);\n        }\n        if (_buffer?.dataOutput?.length > 0) {\n            option.dataOutput.push(..._buffer.dataOutput);\n        }\n\n\n        const _next_old = (option.markerInfo.length > 0) ? option.markerInfo[0] : null;\n        if (!_mark_buffer)\n            option.formatterBuffer.appendToBuffer(_buffer);\n        else {\n            if (_next_old && _next_old.joinWith) {\n                formatter.appendJoinToBuffer(_next_old.joinWith, option);\n                _next_old.joinWith = null;\n            }\n            if (typeof (_buffer) == 'string') {\n                option.appendToBuffer(_buffer, _marker);\n            } else {\n                option.formatterBuffer.appendToBuffer(_buffer);\n            }\n        }\n        if (isBlock && _next_old) {\n            // + | update marker definition depending of the formatter\n            if (_next_old.currentMode == FM_APPEND) {\n                // change mode to append item\n                _next_old.currentMode = FM_APPEND_BLOCK;\n                option.nextMode = _next_old.marker.mode\n                    = FM_START_LINE;\n            }\n        }\n    }\n    /**\n     * depending on next matching mode updete line feed\n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _old old markerInfo\n     */\n    updateMatchNextFormatting(marker, option, _old) {\n        _old = _old || option.peekMarkerInfo;\n        let { content, currentMode } = _old || {};\n        const _parentMarker = _old?.marker;\n        const { formattingMode } = marker;\n        let { lineFeedFlag, nextMode, formatter } = option;\n        switch (formattingMode) {\n            case PatternFormattingMode.PFM_LINE_FEED:\n                lineFeedFlag = true;\n                nextMode = FM_START_LINE;\n                break;\n            case PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED:\n                // + | append to extra line comment if possible \n                if ((content?.length > 0) && (option.lineSegments.length > 1) && (currentMode !== FM_END_LINE) && (currentMode == FM_START_LINE)) {\n                    lineFeedFlag = false;\n                    currentMode = FM_APPEND;\n                    _old.currentMode = FM_APPEND;\n                    _old.marker.mode = option.nextMode = FM_END_LINE;\n                    const _prepend = marker.formattingPrependExtra;\n                    let _prepend_value = _prepend == undefined ? \" \" : _prepend;\n                    if (_prepend_value) {\n                        let s = FormatterBufferUtils.TreatValue(formatter, _prepend_value, marker, option);\n                        option.formatterBuffer.prepend(s);\n                    }\n                    formatter._updateOldMarkerContent(_old, option);\n                    lineFeedFlag = true;\n                    nextMode = _old.marker.mode;\n                } else {\n                    let _emode = FM_END_LINE;\n                    if (_parentMarker?.isBlock && (content?.length==0)){\n                        _old.currentMode = FM_START_BLOCK;\n                    }\n                    lineFeedFlag = true;\n                    nextMode = _emode;\n                }\n                break;\n            default:\n                break;\n        }\n        option.lineFeedFlag = lineFeedFlag;\n        option.nextMode = nextMode;\n    }\n    updateNextSavedMode(mode, option) {\n        switch (mode) {\n            case FM_START_BLOCK:\n                mode = FM_END_BLOCK;\n                break;\n        }\n        option.nextMode = mode;\n        option.startLine = this.isStartLine(mode);\n    }\n    isStartLine(mode) {\n        return mode == FM_END_BLOCK;\n    }\n    /**\n     * on end update buffer\n     */\n    onEndUpdateBuffer({ marker, option, update, _buffer, _data, _trimOutput = false }) {\n        return update({ marker, _buffer, _data, _trimOutput }, option);\n    }\n    /**\n     * \n     * @param {*} old \n     * @param {*} option \n     */\n    updateBlockMarkerPropertyMode(old, option) {\n        old.currentMode = FM_APPEND_BLOCK;\n    }\n    /**\n    * treat and start block definition \n    * @param {Formatters} formatter \n    * @param {PatternMatchInfo} patternInfo \n    * @param {FormatterOptions} option \n    */\n    startBlockDefinition(formatter, patternInfo, option) {\n        patternInfo.isBlockStarted = true;\n        formatter._startBlock(option);\n        if (!option.isCurrentFormatterBufferIsRootBuffer) {\n            let _cf = option.flush(true);\n            if (_cf.length > 0) {\n                throw new Error('start block contains definition: ' + _cf);\n            }\n        }\n        patternInfo.mode = FM_START_BLOCK;\n        const { parent } = patternInfo;\n        if (parent) {\n            parent.mode = FM_APPEND;\n        }\n    }\n\n    /**\n     * element is block by auto child setup\n     * @param {} formatter \n     * @param {*} marker_info \n     * @param {*} option \n     */\n    handleEndFormattingOnNonStartBlockElement(formatter, marker_info, option) {\n        const { mode } = marker_info;\n        switch (mode) {\n            case FM_START_LINE:\n                // append line \n                let _buffer = option.buffer;\n                option.appendExtraOutput();\n                let _sbuffer = option.flush(true);\n                if (_buffer.length > 0) {\n                    option.output.push(_buffer); // append line \n                }\n                option.formatterBuffer.appendToBuffer(_sbuffer);\n                marker_info.mode = FM_APPEND;\n                break;\n        }\n    }\n    handleBufferingNextToSbuffer(marker, option) {\n        const { mode } = marker;\n        let _sbuffer = option.buffer;\n        // clear buffer \n        _sbuffer += option.flush(true);\n        return _sbuffer;\n    }\n    onEndInstruction(marker, option) {\n        // instruction        \n        marker.mode = FM_END_INSTRUCTION;\n        this._updateGlobalMarkerOptionDefinition(marker, option);\n    }\n    formatJoinFirstEntry(entryBuffer, buffer) {\n        return [entryBuffer, buffer].join(\"\\n\");\n    }\n    formatHandleExtraOutput(marker, _extra, option) {\n        let { mode } = marker;\n        let r = _extra;\n        switch (mode) {\n            case FM_END_INSTRUCTION:\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.output.push(r);\n                r = option.flush(true);\n                option.restoreSavedBuffer();\n                mode = FM_APPEND;\n                break;\n        }\n        marker.mode = mode;\n        return r;\n    }\n}\n\n//+ |  on end append technique\n\n\n\nexports.FormattingBase = FormattingBase\n/**\n * code style formatters\n */\nconst { KAndRFormatting } = require('./KAndRFormatting');\nconst { FM_APPEND, FM_START_LINE, FM_START_BLOCK, FM_END_BLOCK, FM_START_LINE_NEXT_LINE, FM_APPEND_BLOCK,\n    FM_END_INSTRUCTION, FM_START_LINE_APPEND, FM_APPEND_TO_NEXT, FM_END_LINE\n    , PatternFormattingMode,\n    FormattingMode } = require('./FormattingMode');\nconst { FormatterOptions } = require('../FormatterOptions');\nconst { Formatters, Utils } = require('../Formatters');\nconst { PatternMatchInfo } = require('../PatternMatchInfo');\nconst { FormatterBufferUtils } = require(\"../FormatterBufferUtils\");\n\n\nconst Library = {\n    KAndRFormatting\n};","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst FM_START = 0;\nconst FM_APPEND = 1;\nconst FM_APPEND_BLOCK = 9;\nconst FM_START_BLOCK = 5;\nconst FM_END_INSTRUCTION = 3;\nconst FM_END_BLOCK = 6;\nconst FM_START_LINE = 2;\nconst FM_START_LINE_NEXT_LINE = 7; \nconst FM_START_LINE_APPEND = 8; // start line then append \nconst FM_APPEND_TO_NEXT = 10;\nconst FM_END_LINE = 11; // mark current mode as end of line . used for single line comment\n\nexports.FM_APPEND = FM_APPEND;\nexports.FM_START_LINE = FM_START_LINE; \nexports.FM_START_BLOCK = FM_START_BLOCK;\nexports.FM_END_BLOCK = FM_END_BLOCK; \nexports.FM_START_LINE_NEXT_LINE = FM_START_LINE_NEXT_LINE; \nexports.FM_END_INSTRUCTION = FM_END_INSTRUCTION; \nexports.FM_START_LINE_APPEND = FM_START_LINE_APPEND; \nexports.FM_APPEND_BLOCK = FM_APPEND_BLOCK; \nexports.FM_APPEND_TO_NEXT = FM_APPEND_TO_NEXT; \nexports.FM_END_LINE = FM_END_LINE; \n\n/**\n * configured formatting mode \n */\n// format as single line feed\nconst PFM_LINE_FEED = 1;\n// require join for single pattern\nconst PFM_LINE_JOIN_END = 2; \n// join line formatting mode \nconst PFM_LINE_JOIN = 3;\n\n// enable streaming buffer\nconst PFM_STREAMING = 4;\n\nconst PFM_APPEND_THEN_LINE_FEED = 5;\n\nconst PFM_LINE_FEED_IF_IS_UPDATED_BLOCK = 6;\n\n\nexports.PatternFormattingMode = {\n    get PFM_LINE_FEED(){\n        return PFM_LINE_FEED;\n    },\n    get PFM_LINE_JOIN_END(){\n        return PFM_LINE_JOIN_END;\n    },\n    get PFM_LINE_JOIN(){\n        return PFM_LINE_JOIN;\n    },\n    get PFM_STREAMING(){\n        return PFM_STREAMING;\n    },\n    get PFM_APPEND_THEN_LINE_FEED(){\n        return PFM_APPEND_THEN_LINE_FEED;\n    },\n    get PFM_LINE_FEED_IF_IS_UPDATED_BLOCK(){\n        return PFM_LINE_FEED_IF_IS_UPDATED_BLOCK;\n    }\n};\n\n\nexports.FormattingMode = {\n    FM_APPEND,\n    FM_START_BLOCK,\n    FM_END_INSTRUCTION,\n    FM_END_BLOCK,\n    FM_START_LINE,\n    FM_START_LINE_NEXT_LINE ,\n    FM_APPEND_BLOCK,\n};\n\n\nexports.HandleFormatting = function(_marker, option, _old) {\n        let _mode = _marker.mode;\n        let _sbuffer = '';\n        let _buffer = option.buffer;\n\n        let _formatting = this.formatting;\n        switch (_mode) {\n            case FM_START:\n                option.store();\n                option.appendExtraOutput();\n                _sbuffer = option.flush(true);\n                _mode = FM_START_LINE;\n                break;\n            case FM_START_LINE:\n                // store then go to append\n                let _append = true;\n                if (_buffer.trim().length == 0) {\n                    option.formatterBuffer.clear();\n                    _buffer = '';\n                    _append =false;\n                } else {\n                    option.store(); \n                }\n                _sbuffer = option.flush(true);\n                if (_append && (_sbuffer.length > 0)) {\n                    _mode = FM_APPEND;\n                }\n                break;\n            case FM_APPEND:\n                // + | append to buffer \n                _sbuffer = option.buffer;\n                _sbuffer = option.flush(true) + _sbuffer;\n                break;\n            case FM_END_INSTRUCTION: \n                // + | append-flush-next-start-new-line\n                _sbuffer = option.flush(true)+_buffer;  \n                _mode = FM_START_LINE;\n                break;\n            case 4:\n                // store what is on the buffer append nuew file\n                option.store();\n                option.appendExtraOutput();\n                _sbuffer = option.flush(true);\n                _mode = FM_START_LINE;\n\n                break;\n            case FM_START_BLOCK: // start block - append line before append\n                if (_buffer.length>0){ \n                    option.store();   \n                    _sbuffer = option.flush(true);\n                    _mode = FM_APPEND;\n                }\n                break; \n            case FM_END_BLOCK:\n                ({_sbuffer} = _formatting.handleEndBlockBuffer(_marker, _buffer, option, _old)); \n                _mode = FM_START_LINE;\n                break;\n            case FM_START_LINE_NEXT_LINE:\n                option.store();\n                _sbuffer = option.flush(true);\n                if (_sbuffer.length > 0) {\n                    _mode = FM_START_LINE;\n                }else\n                    _mode = FM_APPEND;\n                break;\n        }\n        _marker.mode = _mode;\n        return _sbuffer;\n};\n \n/**\n * \n * @param {*} patternInfo \n */\nfunction formattingSetupPatternForBuffer(patternInfo, option){\n \n} \nexports.formattingSetupPatternForBuffer = formattingSetupPatternForBuffer;\n\n\nconst AC_PARENT = 'parent';\nconst AC_NEXT = 'next';\nclass StreamActions{\n    static get PARENT(){\n        return AC_PARENT;\n    }\n    static get NEXT(){\n        return AC_NEXT;\n    }\n}\n\n\nexports.StreamActions = StreamActions;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterOptions } = require('../FormatterOptions');\nconst { PatternMatchInfo } = require('../PatternMatchInfo');\nconst { FormattingBase } = require('./FormattingBase')\nconst { FM_APPEND, FM_START_LINE, FM_START_BLOCK, FM_END_BLOCK,\n    FM_START_LINE_NEXT_LINE, FM_END_INSTRUCTION,\n    FM_START_LINE_APPEND,\n    PatternFormattingMode } = require('./FormattingMode');\n\nconst { Utils } = require('../Utils');\n\n\n\n\nconst ALLOW_WHITE_SPACE = [FM_APPEND, FM_START_LINE];\n\nclass KAndRFormatting extends FormattingBase {\n    mergeEndBlock = true;\n\n    /**\n     * join stream buffer\n     * @param {number} mode \n     * @param {string} buffer \n     * @param {string} append \n     * @returns \n     */\n    joinStreamBuffer(mode, buffer, append) {\n        switch (mode) {\n            case FM_START_BLOCK:\n                buffer = buffer.trimEnd() + append;\n                return buffer;\n\n        }\n        return super.joinStreamBuffer(mode, buffer, append);\n    }\n\n    updateMergeEndBlock({ content, marker, option, extra, buffer, _hasBuffer, _hasExtra }) {\n        if (this.mergeEndBlock) {\n            return super.updateMergeEndBlock(arguments[0]);\n        }\n        let value = '';\n        let mode = marker.mode;\n        if (_hasBuffer) {\n            value += buffer;\n            mode = FM_START_LINE;\n        }\n        content = content.trimEnd();\n        option.output.push(content);\n        option.appendExtraOutput();\n        content = option.flush(true);\n        return { value, content, mode };\n    }\n    /**\n     * check allow empty space \n     * @param {number} mode \n     * @param {FormatterOptions} option \n     * @return {bool}\n     */\n    allowEmptySpace(mode, option) {\n        if (option.formatterBuffer.length > 0) {\n            return true;\n        }\n        return ALLOW_WHITE_SPACE.indexOf(mode) != -1;\n    }\n    /**\n     * \n     * @param {*} formatter \n     * @param {*} marker \n     * @param {*} option \n     * @param {*} _buffer \n     * @param {*} _refData \n     * @returns \n     */\n    handleEndFormattingBeforeStore(formatter, marker, option, _buffer, _refData) {\n        let { _b, _data } = _refData;\n        let sb = '';\n        let sd = '';\n        let _bbuffer = option.buffer;\n        let _bdata = option.data;\n        // let _state_saved = option.bufferState;\n        const { formatterBuffer, lineFeedFlag } = option;\n        let _clean = false;\n\n        if (this.mergeEndBlock) {\n            // + | remove last empty items.\n            _bbuffer = _bbuffer.trimEnd();\n        }\n        if (marker.childs.length == 0) {\n            sb = _bbuffer;\n            sd = _bdata;\n            if (lineFeedFlag) {\n                option.lineFeedFlag = false;\n                option.saveBuffer();\n                option.appendExtraOutput();\n                option.output.push(_b.trimStart());\n                sb += option.flush(true);\n                option.restoreSavedBuffer();\n            } else {\n                sb += _b;\n                sd += _data;\n            }\n            formatterBuffer.clear();\n            formatterBuffer.appendToBuffer({buffer:sb, data:sd});\n            formatterBuffer.clearOutput();\n            _clean = true;\n        } else {\n            option.formatterBuffer.clear();\n            option.formatterBuffer.appendToBuffer(_bbuffer);\n\n            if (this.mergeEndBlock) {\n                if ((marker.mode == FM_END_BLOCK) && (marker.childs.length == 1)) {\n                    // + | merge close tag\n                    option.formatterBuffer.appendToBuffer(_b.trimEnd());\n                    _clean = true;\n                }\n            } else {\n                if ((marker.mode == FM_END_BLOCK) && (marker.childs.length == 1)) {\n                    // + | merge close tag\n                    option.storeToOutput({ clear: true });\n                    option.formatterBuffer.appendToBuffer(_b.trimEnd());\n                    option.storeAndUpdateBuffer();\n                   _clean = true;\n                }\n            }\n        }\n        let _c_mode = (marker.childs == 0)\n            ? FM_APPEND : FM_END_BLOCK;\n        if (_clean){\n            _b = '';\n            sd = '';\n        }\n        // + | update marker mode to pass to parent\n        // marker.mode = _c_mode;\n        option.nextMode = _c_mode;\n        option.startLine = this.isStartLine(_c_mode);\n        if (_b && (marker.formattingMode == PatternFormattingMode.PFM_LINE_JOIN_END)) {\n            option.formatterBuffer.appendToBuffer(_b.trimEnd()); \n            _clean = true;\n        }\n        if (_clean){\n            _b = '';\n            sd = '';\n        }\n        \n        _refData._b = _b;\n        _refData._data = sd;\n        return _refData;\n    }\n    /**\n     * \n     * @param {*} content \n     * @param {*} extra \n     * @param {*} buffer \n     * @param {*} _hasBuffer \n     * @param {*} _hasExtra \n     * @param {*} isEntryContent \n     * @param {*} _flushData reference data to export\n     * @param {*} segments segment that represent the current content\n     * @returns \n     */\n    onAppendBlock(content, extra, buffer, _hasBuffer, _hasExtra, isEntryContent, _flushData, segments) {\n        const { FormatterBuffer } = Utils.Classes;\n        let _ld = '';\n        if (extra.length > 0) {\n            _ld += extra;\n        }\n        if (buffer.length > 0) {\n            _ld += buffer;\n        }\n        const _trimEnd = function(){\n            if (segments){\n\n                FormatterBuffer.TreatMarkedSegments(segments, 'trimmed'); \n                content = segments.bufferSegment.join('');\n\n            }\n            return content.trimEnd();\n            \n        };\n\n\n        content = !isEntryContent ? _trimEnd() : content;\n        if (!this.mergeEndBlock) {\n            option.appendExtraOutput();\n            option.formatterBuffer.appendToBuffer(_ld.trimStart());\n            option.store();\n            _ld = option.flush(true, _flushData);\n        }\n        return { content, _ld };\n    }\n    handleEndFound(formatter, marker, option, _buffer, _b) {\n        let sb = '';\n        if (marker.childs.length == 0) {\n            sb = _buffer.trimEnd() + _b.trimStart();\n            option.appendToBuffer(sb, marker);\n        }\n\n        return marker.parent;\n    }\n\n    formatJoinFirstEntry(entryBuffer, buffer) {\n        return [entryBuffer, buffer].join('');\n    }\n    /**\n     * format buffer marker\n     * @param {*} formatter \n     * @param {*} _marker \n     * @param {*} option \n     * @param {boolean} force force update \n     */\n    formatBufferMarker(formatter, _marker, option, force=false) {\n        let _buffer = option.buffer;\n        const { parent, startOutput } = _marker;\n        const { formattingMode, isBlock, isUpdatedBlock } = _marker;\n        let update_line_feed = ()=>{\n            if (parent) {\n                _marker.mode = FM_START_LINE;\n                this._updateGlobalMarkerOptionDefinition(_marker, option);\n            } else {\n                // + | update current buffer to handle\n                formatter.updateBuffedValueAsToken(_buffer, _marker, option);\n                if (option.depth == 0) {\n                    option.skipEmptyMatchValue = true;\n                }\n            }\n        };\n\n        switch (formattingMode) {\n            case PatternFormattingMode.PFM_LINE_FEED:\n                // + | formatting request last fied \n                if (force ||((_marker.childs.length > 0) || (startOutput.trim().length>0))) {  \n                   update_line_feed();\n                }\n                break;\n            case PatternFormattingMode.PFM_LINE_FEED_IF_IS_UPDATED_BLOCK:\n                if (force || ((_marker.childs.length>0) && (isBlock || isUpdatedBlock))){\n                    update_line_feed();\n                }\n                break;\n            case PatternFormattingMode.PFM_LINE_JOIN_END:\n            case PatternFormattingMode.PFM_APPEND_THEN_LINE_FEED:\n            case PatternFormattingMode.PFM_LINE_JOIN_END:\n            // join line formatting mode \n            case PatternFormattingMode.PFM_LINE_JOIN:\n            // enable streaming buffer\n            case PatternFormattingMode.PFM_STREAMING:\n                break;\n            default:\n                throw new Error('not implement formatting mode '+formattingMode);\n        }\n    }\n\n    /**\n     * on last handling mode\n     * @param {*} param0 \n     * @returns \n     */\n    onLastExpectedBlock({ mode, option, buffer }) {\n        let f = null;\n        switch (mode) {\n            case FM_END_BLOCK:\n                if (buffer.length > 0) {\n                    f = option.flush(true) + buffer;\n                }\n                break;\n            default:\n                option.store();\n                break;\n        }\n        return f;\n    }\n    onLastExpectedBlockStart({ _old, option }) {\n        if (this.mergeEndBlock) {\n            return;\n        }\n        if (!_old.blockStarted && (option.output.length > 0)) {\n            option.output.push(option.buffer);\n            let _buffer = option.flush(true);\n            option.formatterBuffer.appendToBuffer(_buffer);\n            option.storeAndUpdateBuffer();\n        }\n    }\n}\n\nexports.KAndRFormatting = KAndRFormatting;\nexports.FormattingBase = FormattingBase","Object.defineProperty(exports, '__esModule', {value:true});\n\n/**\n * json parser info\n */\nclass JSonParser{\n    source;\n    data; \n    registry;\n    repositoryKey;\n    throwOnError;\n    /**\n     * store pattern class name\n     */\n    patternClassName;\n    /**\n     * store capture info class name\n     */\n    captureInfoClassName;\n\n    get current(){\n        return this.m_current;\n    }\n\n    constructor(){\n        this.m_current = null;\n        this.throwOnError = true;\n    }\n\n    /**\n     * initialize object to registry\n     * @param {*} _o \n     */\n    initialize(_o){\n        if (this.registry){\n            this.registry.initialize(_o);\n        }\n    }\n\n    parse(){\n        obj = new this.source();\n        this.m_current = this.data;\n        JSonParser._LoadData(this, obj, this.data);\n        return obj;\n    }\n    /**\n     * load data with reference object \n     * @param {*} parser \n     * @param {*} obj \n     * @param {*} data \n     * @param {*} refKey \n     * @param {*} _refObj \n     * @returns \n     */\n    static _LoadData(parser, obj, data, refKey, _refObj){\n        const _throwOnError = parser.throwOnError;\n        const keyData = ()=>{\n            if (obj.json_keys){\n                return obj.json_keys();\n            }\n            return Object.keys(obj);\n        };\n        let validation = obj.json_validate;\n        let json_parsing = obj.json_parse;\n        keyData().forEach((i)=>{\n            let _r = data[i];\n            if (typeof(_r)=='undefined'){\n                return;\n            } \n            if ((validation)&& !validation.apply(obj, [i, _r, _throwOnError])){\n                return;\n            }\n            if (json_parsing){\n                _r = json_parsing.apply(obj, [parser, i, _r, refKey, _refObj]);\n            }\n            obj[i] = _r;\n        });\n        return obj;\n    }\n}\n\nexports.JSonParser = JSonParser;","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', { value: true });\nconst globalRegExp = RegExp;\nconst NATIVE_EXEC = (() => {\n    const _fn = globalRegExp.prototype.exec;\n    if (_fn.toString().indexOf('[native code]') !== -1)\n        return _fn;\n    throw new Error('missing native RegExp.exec');\n})();\nconst NATIVE_TEST = (() => {\n    const _fn = globalRegExp.prototype.test;\n    if (_fn.toString().indexOf('[native code]') !== -1)\n        return _fn;\n    throw new Error('missing native RegExp.test');\n})();\n/**\n * implement native RegExp because some extension override required function\n */\nclass NativeRegExp {\n    static #sm_states = [];\n    static Save() {\n        NativeRegExp.#sm_states.unshift({\n            exec: globalRegExp.prototype.exec,\n            test: globalRegExp.prototype.test\n        });\n        globalRegExp.prototype.exec = NATIVE_EXEC;\n        globalRegExp.prototype.test = NATIVE_TEST;\n    }\n    static Restore(){\n        const _g = NativeRegExp.#sm_states.shift();\n        if (_g){\n            globalRegExp.prototype.exec = _g.exec;\n            globalRegExp.prototype.test = _g.test;\n        }\n    }\n}\n\nNativeRegExp.prototype.exec = NATIVE_EXEC;\nNativeRegExp.prototype.test = NATIVE_TEST;\n\nexports.NativeRegExp = NativeRegExp;","\"use stricts;\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n\n/**\n * use to define error message object \n */\nclass PatterMatchErrorInfo{\n    /**\n     * error message\n     * @var {?string}\n     */\n    message\n    /**\n     * error code \n     * @var {?number}\n     */\n    code;\n}\n\nexports.PatterMatchErrorInfo = PatterMatchErrorInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\n\nclass PatternFormattingOptions{\n    /**\n     * patterns is trim block container - check on start and end\n     * @var {?bool}\n     */\n    trimContainer;\n}\nexports.PatternFormattingOptions = PatternFormattingOptions; ","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { RegexUtils } = require('./RegexUtils');\nconst { Utils } = require('./Utils');\n\n/**\n * type checking requirement\n * @param {*} v \n * @param {*} types \n * @returns \n */\nfunction is(v, types) {\n    const t = typeof (v);\n    return (types.indexOf(v) != -1) || (types.indexOf(t) != -1);\n}\n\n/**\n * export pattern match info\n */\nclass PatternMatchInfo {\n\n    /**\n     * indicate new created pattern info\n     * @var {bool}\n     */\n    start = true;\n\n    /**\n     * formatting start block element\n     */\n    isFormattingStartBlockElement = false;\n\n    /**\n     * formatting listener to handle start and end block element\n     */\n    formattingBlockListener;\n    /**\n     * \n     */\n    range = {\n        startLine: 0, // on start line \n        start: 0, // position start\n        end: 0 // position end\n    }\n    /**\n    * store marker info childs\n    */\n    childs = [];\n\n    /**\n     * store value\n     * @var {null|{value:string, source:string }}\n     */\n    value;\n\n    /**\n     * define block start information\n     */\n    blockStartInfo;\n\n    /**\n     * formatter new line flag\n     */\n    newLine = false;\n\n    /**\n     * get or store the end group\n     */\n    endGroup = null;\n\n    /**\n    * @var {?boolean}\n    */\n    isShiftenName = false;\n\n\n    /**\n     * flag: shiftenContentName\n     * @var {?boolean}\n     */\n    isShiftenContentName = false;\n\n    /**\n     * store start data\n     */\n    startData;\n\n    get isMarkedSegments() {\n        return (this.isTrimmedSegment === true) || (this.markedSegment != null);\n    }\n    /**\n     * is capture to end line \n     * @param {*} line \n     * @returns \n     */\n    isCaptureToEndLine({lineMatcher, lastMarker}){\n        const { childs } = this;\n        let lastChild = childs.length>0 ? childs[childs.length-1].marker : null;\n        lastMarker = lastChild || lastMarker;\n        if (lastMarker){\n            const { subLine } = lineMatcher;\n            const { end, matchType, match } = lastMarker;\n            if (matchType==1){\n                // + | match end regex\n                return RegexUtils.CheckRequestEndLine(match) && match.exec(subLine);\n            }\n            else if (matchType==0){\n                // + begin/end\n                return RegexUtils.CheckRequestEndLine(end) &&  end.exec(subLine);\n            }\n        }\n        return false;\n    }\n    markedInfo() {\n        //const { Utils } = require('./Utils');\n        return Utils.GetMarkedInfo(this); \n    }\n    constructor() {\n        var m_parent;\n        var m_marker;\n        var m_endRegex;\n        var m_group;\n        var m_line;\n        var m_isBlock = false;\n        var m_lineFeed = false;\n        var m_startOutput = null;\n        var m_endOutput = null;\n        var m_updatedProperties = {};\n        var m_isBlockStared = false;\n        var m_bufferMode = 1; // how to operate on buffer \n        var m_patterns = null;\n        var m_fromGroup = null; // store pattern group - to dected token id\n        var m_index = -1;\n        var m_state = null; // store use state\n        /**\n        * get or set the buffer mode. 0 - add a line before add go to 1 just append to buffer, 2 add a line after\n        */\n        Object.defineProperty(this, 'mode', {\n            get() { return m_bufferMode; },\n            set(v) {\n                if (v != m_bufferMode) {\n                    m_bufferMode = v; \n                }\n            }\n        });\n\n        /**\n         * get or set the parent info matcher\n         */\n        Object.defineProperty(this, 'isBlockStarted', {\n            get() {\n                return (this.isBlock) ? m_isBlockStared : false;\n            }, set(v) {\n                if (typeof (v) != 'boolean') {\n                    throw new Error('not a valid value');\n                }\n                if (this.isBlock) {\n                    m_isBlockStared = v;\n                }\n            }\n        });\n\n        Object.defineProperty(this, 'parent', { get() { return m_parent; } });\n        Object.defineProperty(this, 'updatedProperties', { get() { return m_updatedProperties; } });\n        Object.defineProperty(this, 'isBlock', {\n            get() { return m_isBlock; }, set(value) {\n\n                if (value === null) {\n                    throw new Error('can  not store null value');\n                }\n                m_isBlock = value;\n            }\n        });\n        Object.defineProperty(this, 'lineFeed', {\n            get() {\n                return m_lineFeed;\n            }\n        });\n        Object.defineProperty(this, 'marker', { get() { return m_marker; } });\n        Object.defineProperty(this, 'endRegex', { get() { return m_endRegex; } });\n        // group info\n        Object.defineProperty(this, 'group', { get() { return m_group; } });\n        Object.defineProperty(this, 'state', { get() { return m_state; } });\n\n        Object.defineProperty(this, 'line', { get() { return m_line; } });\n        Object.defineProperty(this, 'startOutput', {\n            get() {\n                // + | return group[0] on start definition\n                if ((m_startOutput == null) || (m_startOutput == undefined))\n                    return m_group[0];\n                return m_startOutput;\n            },\n            set(v) {\n                m_startOutput = v;\n            }\n        });\n        Object.defineProperty(this, 'endOutput', {\n            get() { return m_endOutput; }, set(v) {\n                m_endOutput = v;\n            }\n        });\n        Object.defineProperty(this, 'isBlockConditionalContainer', {\n            get() {\n                const { marker } = this;\n                return marker.isBlockConditionalContainer || (() => {\n                    return marker.formattingMode && marker.requestParentBlockCondition;\n\n                })();\n            }, set(v) {\n                if (is(v, ['boolean', undefined, 'undefined'])) {\n                    this.pattern.isBlockConditionalContainer = v;\n                }\n            }\n        });\n\n        Object.defineProperty(this, 'indexOf', {\n            get() {\n                return m_index;\n            }\n        });\n        Object.defineProperty(this, 'hostPatterns', {\n            get() {\n                return m_patterns;\n            }\n        });\n        Object.defineProperty(this, 'fromGroup', {\n            get() {\n                return m_fromGroup;\n            }\n        });\n\n        /**\n         * \n         * @param {*} marker \n         */\n        this.use = function ({ marker, endRegex, group, line, parent, patterns, formatting, fromGroup, index = -1 , state}) {\n            m_marker = marker;\n            m_endRegex = endRegex;\n            m_group = group;\n            m_state = state;\n            m_line = line;\n            m_parent = parent;\n            // setup configurable properties\n            m_isBlock = marker.isBlock;\n            m_lineFeed = marker.lineFeed || formatting.isLineFeed(marker.formattingMode);\n            m_patterns = patterns;\n            m_fromGroup = fromGroup;\n            m_index = index;\n\n\n            (function (q, pattern) {\n                const _keys = Object.keys(q);\n                const _keys_t = Object.keys(pattern);\n                ['isBlock', 'lineFeed', 'streamAction', 'isBlockConditionalContainer'].forEach(s => {\n                    delete _keys_t[_keys_t.indexOf(s)];\n                });\n                _keys_t.forEach(i => {\n\n                    if (_keys.indexOf(i) != -1) {\n                        console.log(\"property alreay defined [\" + i + \"]\");\n                        return;\n                    }\n                    let _i = Object.getOwnPropertyDescriptor(pattern, i);\n                    if (!_i || (_i.get) || _i.writable) {\n                        // q[i] = pattern[i];\n                        Object.defineProperty(q, i, { get() { return pattern[i]; } })\n                    }\n                });\n            })(this, m_marker);\n        };\n    }\n    /**\n     * @var {boolean}\n     */\n    get isUpdatedBlock() {\n        const { updatedProperties } = this;\n        return updatedProperties && ('isBlock' in updatedProperties);\n    }\n    get isMatchCaptureOnly() {\n        return this.marker?.isMatchCaptureOnly;\n    }\n    //\n    get isEndCaptureOnly() {\n        return this.marker?.isEndCaptureOnly;\n    }\n    get isWhileCaptureOnly() {\n        return this.marker?.isWhileCaptureOnly;\n    }\n    get isBeginCaptureOnly() {\n        return this.marker?.isBeginCaptureOnly;\n    }\n    get isCaptureOnly() {\n        return this.marker?.isCaptureOnly;\n    }\n    /**\n     * get if this empty block is start only use definition \n     */\n    get isStartOnly() {\n        return this.marker?.isStartOnly;\n    }\n\n    get closeParentData() {\n        let m = this.marker?.closeParent;\n        let _type = typeof (m);\n        if (_type == 'string') {\n            return m;\n        }\n        if (_type == 'boolean') {\n            return !m ? undefined : '';\n        }\n        return m;\n    }\n    /**\n     * get if this match info is a stream capture\n     */\n    get isStreamCapture() {\n        if (this.marker?.isStartOnly) {\n            return false;\n        }\n        return this.isCaptureOnly && (this.group[0].length == 0);\n    }\n    /**\n     * check this is a block but non configured;\n     */\n    get isAutoBlockElement() {\n        return this.isBlock && !this.isFormattingStartBlockElement;\n    }\n\n    get index() {\n        return this.group?.index;\n    }\n    get offset() {\n        return this.group?.offset;\n    }\n    get name() {\n        return this.marker?.name;\n    }\n    get captures() {\n        return this.marker?.captures;\n    }\n    get endCaptures() {\n        return this.marker?.endCaptures;\n    }\n    get beginCaptures() {\n        return this.marker?.beginCaptures;\n    }\n    get replaceWith() {\n        return this.marker?.replaceWith;\n    }\n    get replaceWithCondition() {\n        return this.marker?.replaceWithCondition;\n    }\n    get streamAction() {\n        const { streamAction } = this.marker;\n        return streamAction || 'next';\n    }\n    /**\n     * expose parker match type\n     */\n    get matchType() {\n        return this.marker.matchType;\n    }\n\n    /**\n     * check is pattern only definition.\n     * @var {bool}\n     */\n    get isPatternsOnly() {\n\n        return false;\n    }\n    /**\n     * debug this marker. internal used\n     */\n    get debug() {\n        return this.marker?.debug;\n    }\n    /**\n     * \n     * @returns \n     */\n    toString() {\n        return \"[PatternMatchInfo: \" + this.marker?.toString() + \"]\";\n    }\n\n    /**\n     * match type with glue type \n     */\n    get skipGlueOnLineEnd(){\n        const b = this.isGlueValue;\n        if (typeof(b) == 'object'){\n            let { skipGlueOnLineEnd } = b || {skipGlueOnLineEnd:false};\n            return skipGlueOnLineEnd; \n        }\n        return this.skipGlueOnLineEnd;\n\n    }\n\n    /**\n     * \n     * @param {*} end \n     * @param {*} param1 \n     * @returns \n     */\n    checkMoveEndRegex(end, {lineCount}){\n        return (this.group.index == end.index) && \n           (this.state.lineCount == lineCount);\n    }\n}\n\nexports.PatternMatchInfo = PatternMatchInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { JSonParser } = require('./JSonParser');\nconst { ReplaceWithCondition } = require('./ReplaceWithCondition');\nconst { Utils } = require('./Utils');\nconst { RegexUtils } = require('./RegexUtils');\nconst { BlockInfo } = require('./BlockInfo');\nconst { PatterMatchErrorInfo } = require('./PatterMatchErrorInfo');\nconst { RegexEngine } = require('./RegexEngine');\nconst { PatternFormattingOptions } = require('./PatternFormattingOptions');\n\n\nconst PatternParsing = { init: false };\nconst PTN_BEGIN_END = 0;\nconst PTN_MATCH = 1;\nconst PTN_BEGIN_WHILE = 2;\nconst PTN_MATCH_TRANSFORM = 3;\n\n\n\n/**\n * @typedef IFormatterReplaceWithCondition\n * @type\n * @property {string} expression,\n * \n */\n\n/**\n * \n */\nclass Patterns {\n    /**\n     * @var {undefined|?PatternFormattingOption} \n     */\n    formattingOptions;\n    /**\n     * @var {undefined|null|string|{message:string, code: number}} lint error \n     */\n    lintError;\n    /**\n     * \n     */\n    match;\n\n    /**\n     * match transform for injection\n     * @var {} \n     */\n    matchTransform;\n    /**\n     * start capture \n     */\n    begin;\n    /**\n     * end match\n     */\n    end;\n\n    /**\n     * pattern cardinality in list. \n     * @var {number} \n     */\n    cardinality;\n\n    /**\n     * use for begin/while . to implement\n     * @var {string|Regex}\n     */\n    while;\n\n    /**\n     * while captures definitions\n     */\n    whileCaptures;\n    /**\n     * setup the value on end missing\n     * @var {string|undefined|{expression:string, captures: undefined|captureInfo}}\n     */\n    endMissingValue;\n\n    /**\n     * the name of this pattern\n     */\n    name;\n\n    /**\n     * capture set content name\n     */\n    contentName;\n    /**\n     * describe this pattern\n     */\n    comment;\n    /**\n   * @var {?string} use for token matching\n   */\n    tokenID;\n    /**\n     * @var {?array} list of patterns\n     */\n    patterns;\n    /**\n     * indicate that this must be used as lineFeed\n     * @var {?bool}\n     */\n    lineFeed;\n    /**\n     * indicate that this must be consider as a block element\n    * @var {?bool|BlockInfo}\n    */\n    isBlock;\n\n    /**\n     * indicate that this pattern is a block conditional start\n     * @var {undefined|?boolean}\n     */\n    isBlockConditionalContainer;\n\n    /**\n     * indicate that condition of trimmed segment on depth update\n     */\n    isTrimmedSegment;\n\n    /**\n     * how to marked segment from definition\n     */\n    markedSegment;\n\n    /**\n     * get or set condition expression to set if this element is a block.\n     * @var {?string}\n     */\n    emptyBlockCondition;\n\n    /**\n     * get or set condition expression to evaluate if this element change the parent block property.\n     * @var {?string}\n     */\n    requestParentBlockCondition;\n\n\n    /**\n     * mark this match as instruction separator. by default will be use as lineFeed. by default the contains will be checked\n     * in match only alogrithm\n     */\n    isInstructionSeparator;\n\n    //  /**\n    //  * @var {?{start: string, end: string}} \n    //  */\n    // block;\n    /**\n     * @var {?bool}\n     */\n    allowMultiline;\n    /**\n     * @var {?bool}\n     */\n    preserveLineFeed;\n\n    /**\n     * depend on token force trim end white space for buffer\n     */\n    nextTrimWhiteSpace = false;\n\n    /**\n     * similar likje end expression will replace the match apend value before adding it to buffer\n     * @var {string|undefined|ReplaceWithCondition|ReplaceWithCondition[]}\n     */\n    replaceWith;\n\n    /**\n     * replace with condition object \n     * @var {object} \n     */\n    replaceWithCondition;\n\n    /**\n     * apply transform on start line\n     * @var {null|string|string[]}\n     */\n    startLineTransform;\n\n    /**\n     * used for begin capture\n     */\n    beginCaptures;\n\n    /**\n     * used for end captures\n     */\n    endCaptures;\n\n    /**\n     * apply to both begin and end captures definition\n     */\n    captures;\n\n    /**\n     * get updated parent props, {isBlock:?bool, lineFeed:?bool}\n     */\n    updateParentProps;\n\n    /**\n     * list of tranform operation\n     * @var {string|string[]}\n     */\n    transform;\n\n    /**\n     * match to apply after tranform definition\n     * @var {null|undefined|RegExp|string}\n     */\n    transformMatch;\n\n    /**\n     * transform captures\n     * @var  {null|undefined|captures}\n     */\n    transformCaptures;\n\n    /**\n     * formatting mode after begin of (begin/end) selection\n     * @var {?number}\n     */\n    beginFormattingMode;\n\n    /**\n     * formatting mode - after rendering the element\n     */\n    formattingMode = 0;\n\n\n    /**\n     * prepend value - on formattingMode = 5\n     * @var {string|undefined} - default value is space litteral if undefined\n     */\n    formattingPrependExtra;\n\n    /**\n     * a glue value - to merge on \n     */\n    isGlueValue;\n\n    /**\n     * same value with\n     * @var {?string} join \n     */\n    joinWith;\n\n    /**\n     * throw error on matching\n     * @var {null|bool|string|PatterMatchErrorInfo}\n     */\n    throwError;\n\n    /**\n     * stream action type.\n     * value use only on streaming default is 'next'\n     * @var {?string|'parent'|'next'}\n     */\n    streamAction;\n\n    /**\n     * stream formatter\n     * @var {{format(buffer: string):string}|(buffer:string):string}\n     */\n    streamFormatter;\n\n    /**\n     * captures to attach on stream or use captures as a fallback\n     */\n    streamCaptures;\n\n\n    /**\n     * indicate that this pattern must be only apply on start line\n     * @var {boolean}\n     */\n    startLine = false;\n\n    /**\n     * @var {number}\n     */\n    applyEndPatternLast;\n\n    /**\n     * @var {boolean} debug this field\n     */\n    debug;\n\n\n    /**\n     * name used in debug mode\n     * @var {?string}\n     */\n    debugName;\n\n    /**\n     * force close parent with litteral\n     * @var {null|undefined|true|string} close parent with litteral\n     */\n    closeParent;\n\n\n    /**\n     * skip matching on condition(s)\n     * @var {null|undefined|string|string[]}\n     */\n    skip;\n\n    /**\n     * formatting next glue value\n     */\n    nextGlueValue;\n\n\n    /**\n     * skip value on line end.\n     */\n    skipGlueOnLineEnd;\n\n    /**\n     * .ctr\n     */\n    constructor() {\n        this.patterns = [];\n        this.isBlock = false;\n        this.allowMultiline = true;\n        this.preserveLineFeed = false;\n        this.cardinality = 0;\n        var m_parent = null;\n        var m_startOnly = false;\n\n        Object.defineProperty(this, 'parent', {\n            get() { return m_parent; }, set(v) {\n                if ((v == null) || (v instanceof Patterns))\n                    m_parent = v;\n                else\n                    throw Error('parent value not valid');\n            }\n        });\n        Object.defineProperty(this, 'isStartOnly', {\n            get() {\n                return m_startOnly;\n            }, set(v) {\n                m_startOnly = v;\n            }\n        });\n    }\n    static IsSkipped(skip) {\n        return RegexUtils.IsSkipped(skip);\n    }\n    json_parse(parser, fieldname, data, refKey, refObj) {\n\n        // if (!PatternParsing.init) {\n        //     PatternParsing.parser = (() => {\n\n\n        const { Patterns, RefPatterns, CaptureInfo } = Utils.Classes;\n        const q = this;\n        const patterns = Utils.ArrayPatternsFromParser(parser, Patterns, RefPatterns);\n        const transform = Utils.TransformPropertyCallback();\n        const _regex_parser = RegexUtils.RegexParser(q);\n        const _capture_parser = Utils.JSONInitCaptureField(q);\n        const _replace_with = (n, parser, fieldname, refObj) => {\n            if (typeof (n) == 'string') {\n                //n = n.replaceAll(\"\\\\\\\\\",\"\\\\\");\n\n                const _reg = _regex_parser.apply(q, [n, parser, fieldname, refObj]);\n                return _reg;\n            }\n            if (typeof (n) == 'object') {\n                let m = new ReplaceWithCondition;\n                JSonParser._LoadData(parser, m, n, refObj);\n                return m;\n            }\n            if (Array.isArray(n)) {\n                let d = [];\n                n.forEach(n => {\n                    let m = new ReplaceWithCondition;\n                    JSonParser._LoadData(parser, m, n, refObj);\n                    d.push(m);\n                });\n                return d;\n            }\n            return null;\n        };\n\n        const parse = {\n            endMissingValue(n, parser) {\n                if (typeof (n) == 'object') {\n                    const { FormatterEndMissingExpression } = Utils.Classes;\n                    const { expression } = n;\n                    let { captures } = n;\n                    if (captures) {\n                        captures = _capture_parser(captures, parser);\n                    }\n                    return new FormatterEndMissingExpression(expression, captures);\n                }\n                return n;\n            },\n            closeParent(n, parser) {\n                const _type = typeof (n);\n                const { FormatterCloseParentInfo } = Utils.Classes;\n                const _gcl = parser.closeParentInfoClassName || FormatterCloseParentInfo;\n                if (_type == 'object') {\n\n                    let m = new _gcl;\n                    JSonParser._LoadData(parser, m, n);\n                    return m;\n                }\n                if (_type == 'boolean') {\n                    return n;\n                }\n                if (_type == 'string') {\n                    return n;\n                }\n                throw new Error('invalid closeParentType');\n            },\n            patterns(n, parser, refKey, refObj) {\n                let d = patterns.apply(q, [n, parser, refKey, refObj]);\n                d.forEach((s) => {\n                    s.parent = q;\n                });\n                return d;\n            }, // update with parent\n            begin: _regex_parser,\n            end: function (n, parser, refKey, refObj) {\n                if (typeof (n) == 'string') {\n                    // skip end matching \n                    if (n.length == 0) {\n                        return RegexUtils.SKIP_REGEX;\n                    }\n                }\n                return _regex_parser(n, parser, refKey, refObj);\n            },\n            while: _regex_parser,\n            match: _regex_parser,\n            matchTransform: _regex_parser,\n            replaceWith: _replace_with,\n            transformMatch: _regex_parser,\n            lintError: function (n, parser) {\n                const _t = typeof (n);\n                let _rt = { message: null, code: null };\n                if (_t == 'string') {\n                    _rt.message = _t;\n                } else if (n) {\n                    const { code, message, $ref } = n;\n                    const { lintErrors } = parser.data;\n                    if ($ref && lintErrors) {\n                        if ($ref in lintErrors) {\n                            const { code, message } = { code: $ref, message: lintErrors[$ref] };\n                            _rt.message = message;\n                            _rt.code = code;\n                            return _rt;\n                        }\n\n                    }\n                    _rt.message = message;\n                    _rt.code = code;\n                }\n                return _rt;\n            },\n            replaceWithCondition(n, parser) {\n                let m = new ReplaceWithCondition;\n                JSonParser._LoadData(parser, m, n, refObj);\n                return m;\n            },\n            beginCaptures: _capture_parser,\n            endCaptures: _capture_parser,\n            captures: _capture_parser,\n            streamCaptures: _capture_parser,\n            transformCaptures: _capture_parser,\n            transform,\n            formattingOptions(d, parser){\n                if (typeof(d)=='object'){\n                const l = new PatternFormattingOptions;\n                JSonParser._LoadData(parser, l, d);\n                return d;\n                }\n            },\n            lineFeed(d, parser) {\n                return typeof (d) == 'boolean' ? d : false;\n            },\n            isBlock(d, parser) {\n                let _t = typeof (d);\n                if (_t == 'object') {\n                    let m = new BlockInfo;\n                    JSonParser._LoadData(parser, m, d);\n                    return m;\n                }\n                return _t == 'boolean' ? d : false;\n            },\n            throwError(d, parser) {\n                if (typeof (d) == \"string\") {\n                    let l = new PatterMatchErrorInfo;\n                    l.message = d;\n                    return l;\n                }\n                return objOrBool(d, parser, PatterMatchErrorInfo);\n            }\n        };\n        //         return parse;\n        //     })();\n        //     PatternParsing.init = true;\n        // }\n        // const q = this;\n        // const parse = PatternParsing.parser;\n\n        let fc = parse[fieldname];\n        if (fc) {\n            return fc.apply(q, [data, parser, refKey, refObj]);\n        }\n        return data;\n    }\n    json_validate(field_name, d, throw_on_error) {\n        const validator = {\n            patterns(d) {\n                return Array.isArray(d);\n            },\n            replaceWithCondition(d) {\n                return typeof (d) == 'object';\n            }\n        };\n        let f = validator[field_name];\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    get matchType() {\n        const { begin, end, match, matchTransform } = this;\n        const _while = this.while;\n        if (begin) {\n            if (end)\n                return PTN_BEGIN_END;\n            else if (_while) {\n                return PTN_BEGIN_WHILE;\n            }\n        } else if (match) {\n            return PTN_MATCH;\n        } else if (matchTransform) {\n            return PTN_MATCH_TRANSFORM;\n        }\n        return -1;\n    }\n    /**\n     * get if end is capture only regex\n     */\n    get isEndCaptureOnly() {\n        let s = this.end;\n        if (s) {\n            return RegexUtils.IsCapturedOnlyRegex(s.toString());\n        }\n        return false;\n    }\n    /**\n     * get if begin capture only\n     */\n    get isBeginCaptureOnly() {\n        let s = this.begin;\n        if (s) {\n            return RegexUtils.IsCapturedOnlyRegex(s);\n        }\n        return false;\n    }\n    /**\n     * get if block is capture only\n     * @return {boolean}\n     */\n    get isCaptureOnly() {\n        let { begin, end } = this;\n        if (begin && end) {\n            return this.isBeginCaptureOnly && this.isEndCaptureOnly;\n        }\n        return false;\n    }\n    /**\n     * is match capture only\n     */\n    get isMatchCaptureOnly() {\n        let s = this.match;\n        if (s) {\n            return RegexUtils.IsCapturedOnlyRegex(s);\n        }\n        return !1;\n    }\n    /**\n     * new line continue state\n     */\n    get newLineContinueState() {\n        return true;\n    }\n    static Init(_o) {\n        if (_o.begin && !_o.end && !_o.while) {\n            // + | force begin/end\n            _o.end = RegexUtils.SKIP_REGEX;\n        }\n\n        if ((_o.matchType == -1) && (_o.patterns?.length > 0)) {\n            _o.patterns.forEach(s => {\n                _o._initRef(s);\n            });\n        }\n         \n    }\n    /**\n     * initialize reference\n     * @param {*} a \n     */\n    _initRef(a) {\n        if (!a.tokenID && this.tokenID) {\n            a.tokenID = this.tokenID;\n        }\n    }\n    getEntryRegex() {\n        const { begin, match, matchTransform } = this;\n        //const _while = this.while;\n        switch (this.matchType) {\n            case PTN_BEGIN_END:\n            case PTN_BEGIN_WHILE:\n                return begin;\n            case PTN_MATCH:\n                return match;\n            case PTN_MATCH_TRANSFORM: return matchTransform;\n        }\n    }\n    /**\n     * depending on the regex value - or type\n     * @param {string} l string to check\n     * @param {*} option \n     * @param {*} parentMatcherInfo parent matcher\n     * @param {*} regex \n     * @returns \n     */\n    check(l, option, parentMatcherInfo, regex) {\n        let p = null;\n        const { patterns } = this;\n        regex = regex || this.getEntryRegex();\n        if (regex) {\n            p = regex.exec(l);\n        } else {\n            // + | use for pattern only definition list\n            if (patterns) {\n                const cp = Utils.GetMatchInfo(patterns, l, option, parentMatcherInfo);\n                if (cp) {\n                    return { p: cp._match, s: cp._a, from: this, patterns: patterns, index: cp.index, regex: cp.regex };\n                }\n                return false;\n            }\n            throw new Error(\"cannot check : \" + l);\n        }\n        return { p, s: this, index: -1, regex };\n    }\n\n    get matchRegex() {\n        const rgs = {\n            \"0\": this.begin,\n            \"1\": this.match,\n            \"2\": this.while,\n            \"3\": this.matchTransform\n        };\n        return rgs[this.matchType]; //  this.matchType == 0 ? this.begin : this.match;\n    }\n    /**\n     * calculate end regex\n     * @param {*} p \n     * @returns \n     */\n    endRegex(p) {\n        const { end } = this;\n        if (!end || ((this.end instanceof RegexEngine) && end.isEmpty)\n            || Patterns.IsSkipped(end)) {\n            return null;\n        }\n\n\n\n        if (this.matchType == 0) {\n            let s = this.end.toString();\n            let idx = s.lastIndexOf('/');\n            let flag = '';\n            if (idx < (s.length - 1)) {\n                //remove options\n                flag = s.substring(idx + 1);\n                s = s.substring(0, idx + 1);\n            }\n            return Utils.GetRegexFrom(s, p, flag, 'end');\n        }\n        return null;\n    }\n    endWhile(p) {\n        if (this.matchType == 2) {\n            let s = this.while.toString();\n            let idx = s.lastIndexOf('/');\n            let flag = '';\n            if (idx < (s.length - 1)) {\n                //remove options\n                flag = s.substring(idx + 1);\n                s = s.substring(0, idx + 1);\n            }\n            return Utils.GetRegexFrom(s, p, flag, 'while');\n        }\n        return null;\n    }\n\n    toString() {\n        let { name, begin, end, match, debugName, matchType } = this;\n        const _while = this.while;\n        name = (debugName ? \"[\" + debugName + \"]\" : null) || name;\n        function getMatchInfo() {\n            switch (matchType) {\n                case PTN_BEGIN_END:\n                    return { \"begin\": begin?.toString(), \"end\": end?.toString() };\n                case PTN_MATCH:\n                    return { 'match': match?.toString() };\n                case PTN_BEGIN_WHILE:\n                    return { 'begin': begin?.toString(), \"while\": _while?.toString() };\n                case PTN_MATCH_TRANSFORM:\n                    return { \"matchTransfrom\": _while?.toString() };\n            }\n        }\n        if (!name) {\n            name = JSON.stringify({\n                type: matchType,\n                //...getMatchInfo()\n            });\n        }\n        return `Patterns[#${name}]`;\n    }\n\n}\n\n\nconst objOrBool = (d, parser, class_type) => {\n    let _t = typeof (d);\n    if (_t == 'object') {\n        let m = new class_type;\n        JSonParser._LoadData(parser, m, d);\n        return m;\n    }\n    return _t == 'boolean' ? d : false;\n}\n\n\nexports.Patterns = Patterns;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { Patterns } = require(\"./Patterns\");\n\nclass RefPatterns extends Patterns {\n    \n    /**\n     * reference pattern\n     * @param {Patterns} pattern \n     */\n    constructor(pattern){\n        super();\n        if (!pattern || !(pattern instanceof Patterns)){\n            throw new Error('pattern not a Pattern instance');\n        }\n        // + | init property ref keys \n        (function(q, pattern){\n            const _keys = Object.keys(q);\n            _keys.forEach(i => {\n                // let t = typeof (q[i]);\n                // if (/function|object/.test(t))\n                //     return;\n                let _i = Object.getOwnPropertyDescriptor(q, i);\n                if (!_i || (_i.get) || _i.writable) {\n                    // q[i] = pattern[i];\n                    Object.defineProperty(q, i, {get(){ return pattern[i]; }})\n                } \n            });\n        })(this, pattern);\n \n        Object.defineProperty(this, 'pattern', { get(){return pattern; }}); \n    }\n    check(l, option, parentMatcherInfo){\n        return this.pattern.check(l, option, parentMatcherInfo);\n    } \n    /**\n     * \n     * @returns \n     */\n    getEntryRegex(){\n        return this.pattern.getEntryRegex();\n    }\n    toString(){\n        let n = this.pattern.name;\n        if (!n){\n            if (this.patterns.matchType == -1){\n                n = 'groups'\n            };\n        }\n        return `RefPatterns[#${n}]`;\n    }   \n    endRegex(p){\n        return this.pattern.endRegex(p);\n    } \n}\nexports.RefPatterns = RefPatterns;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { RegexUtils } = require(\"./RegexUtils\")\n\n\n\n\nclass RegexEngine{\n    info;\n\n    constructor(def, empty){ \n        const _reg = def;\n        var _type;\n        Object.defineProperty(this, '_regex', {get(){return _reg;}});\n        Object.defineProperty(this, '_type', {get(){return _type;}});\n        Object.defineProperty(this, 'isEmpty', {get(){return empty;}});\n\n        this._store =(e)=>{\n            _reg.push(e);\n        };\n        this._clear =()=>{ _reg.length = 0; };\n        this._changeType = (f)=>{\n            _type = f;\n        };\n    }\n    toString(){\n        if (this._regex.length==1){\n            return this._regex[0].toString();\n        }\n        return this.info.s;\n    }\n    static Load(expression, empty){\n        if (!expression){\n            return null;\n        }\n        if (empty){\n            return new RegexEngine([expression], empty);\n        }\n        let _flag = null;\n        if (typeof(expression)!='string'){\n            expression = expression.toString();\n            let ind = expression.lastIndexOf(\"/\");\n            let option = expression.substring(ind+1);\n            expression = expression.substring(0, ind+1).slice(1,-1);\n            if (option){\n                let moption = [];\n                if (option.indexOf('i')!=-1) moption.push('i');\n                if (option.indexOf('m')!=-1) moption.push('m');\n                if (option.indexOf('d')!=-1) _flag = 'd';\n                // - //\n                if (moption.length>0){\n                    expression = \"(?\"+moption.join(\"\")+\")\"+expression;\n                }\n            }\n            //expression = expression.slice(1,-1);\n        }\n        let inf = RegexUtils.RegexInfo(expression);\n        let _s = inf.s;\n        //treat \n        let _offset = 0;\n        let _p = null;\n        let _start = 0;\n        let _def = [];\n        let _match = /\\(\\?[i]:/d;\n        let _ss = null;\n        let _is_extended = inf.option.indexOf('x')!=-1;\n        inf.option = inf.option.replace(\"x\",'');\n        if (_flag){\n            inf.option+= _flag;\n        }\n        // + | -------------------------------------------------\n        // + | JS: load extended data \n        // + |--------------------------------------------------\n        if (_is_extended){\n            let lit = inf.s.split(\"\\n\");\n            let _gt = [];\n            lit.forEach(i=>{\n                i = i.trimStart();\n                if (/^#/.test(i)) return;\n                i = i.replace(/^\\| /, \"|\");\n                _gt.push(i);\n                //\n            })\n            _s = _gt.join('');\n            inf.s = _s;  \n        }\n\n\n        while (_p = _match.exec(_s)){\n            // remove section flags - then \n            _offset = _p.index;\n            let _pre_exec = _s.substring(0, _offset);\n            if (!_start){\n                _def.push(new RegExp(_pre_exec, inf.option));\n            } \n            let _ms = _s.substring(_offset);\n            _s = _ss = _ms.replace(_match, \"(?:\");\n            _ss = RegexUtils.ReadBrank(_ss, 0, 0);\n            if (_match.test(_ss)){\n                // contains sub activated flags\n                throw new Error(\"contains sub activate flag - not allowed\")\n            }\n            _def.push(new RegExp(_ss, \"i\")); \n            _offset = _ss.length;\n            _s = _s.substring(_offset);\n        } \n        if (_s.length>0){\n            _def.push(new RegExp(_s, _def.length>0?'': inf.option));  \n        }\n\n        if (_def.length>0){\n            let _engine = new RegexEngine(_def, false);  \n            _engine.info = inf; \n            return _engine;\n        }\n        return null;\n    }\n    test(l){\n        return this.exec(l) !==null;\n    }\n    exec(l){\n        if (this.isEmpty){\n            return null;\n        }\n        let _cond = true;\n        let _q = this._regex.slice();\n        let _ret = null;\n        let _gret = null;\n        let _index = 0;\n        while(_cond && (_q.length>0)){\n            let m = _q.shift();\n            _ret = m.exec(l);\n            if (_ret){\n                if (_gret==null){\n                    // initial source\n                    _gret = _ret;\n                }else{\n                    // update gret\n                    // update group \n                    _gret[0] += _ret[0];\n                    _index+= _ret[0].length;\n                    l = l.substring(_index);\n                }\n            }else{\n                _cond = false;\n                _gret = null;\n            }\n        }\n        return _gret;\n    }   \n}\n\nexports.RegexEngine = RegexEngine;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst START_HERE = \"(??)\";\nconst CAPTURE_MOVEMENT =/\\(\\?((<)?!|(\\<)?=)./;\nconst SKIP_REGEX = {\n    exec(){\n        return null;\n    },\n    test(){\n        return null;\n    },\n    toString(){\n        return '';\n    }\n};\n/**\n * regex utility class \n */\nclass RegexUtils {\n    /**\n     * is skipped end regex\n     * @param {regex} skip \n     * @returns \n     */\n    static IsSkipped(skip){\n        return skip === SKIP_REGEX;\n    }\n    /**\n     * to remove [not-]ahead-backyard: matching\n     */\n    static get CAPTURE_NOT_AHEAD_BACKYARD() {\n        // not-ahead-backyard : (<)?!\n        // ahead: (=)\n        // backyard: <=\n        return /\\(\\?([imx]|(<)?!|(\\<)?=)./;\n    }\n    static get CAPTURE_MOVEMENT() {\n        return CAPTURE_MOVEMENT;\n    }\n    /**\n     * \n     */\n    static get CAPTURE_LEAVE_AHEAD_BACKYARD() {\n        // not-ahead-backyard : (<)?!\n        // ahead: (=)\n        // backyard: <=\n        return /\\((\\?(:|[imx])|(?!\\?))./; \n    }\n\n    /**\n     * check if has selection movement capture\n     * @param {*} regex \n     * @returns \n     */\n    static HasMovementCapture(regex){\n        let rc = RegexUtils.CAPTURE_NOT_AHEAD_BACKYARD;\n        let _ret =  rc.test(regex);\n        return _ret;\n    }\n    /**\n     * check if regex contains backyard movement capture\n     * @param {*} regex \n     * @returns \n     */\n    static HasBackyardMovementCapture(regex){\n        const rc = /(\\(\\?<(!|=))./;\n        return rc.test(regex);\n    }\n  \n    /**\n     * regex parsing\n     * @param {{isReadonly:boolean}} q \n     * @returns {(str:string)=>string}\n     */\n    static RegexParser(q){\n        const { Utils } = require(\"./Utils\");\n        const { RegexEngine } = require(\"./RegexEngine\");\n        return (s) => {\n            if (s == '(??)') {\n                q.isStartOnly = true;\n                s = '';\n            }\n            let is_empty = false;\n            if (s == '') {\n                is_empty = true;\n            }\n            let g = Utils.RegexParse(s, 'd');\n            g = RegexEngine.Load(g, is_empty);\n            return g;\n        }; \n    }\n\n    /**\n     * remove regex not-ahead-backyard - group\n     * @param {string} str \n     * @returns {?string}\n     */\n    static RemoveNotAheadBackyardGroup(str) {\n        let s = RegexUtils.RemoveCapture(str, RegexUtils.CAPTURE_NOT_AHEAD_BACKYARD);\n        if (s) {\n            return RegexUtils._TreatCaptureGroup(s);\n        }\n        return s;\n    }\n    /**\n     * removce capture on regex\n     * @param {string} str \n     * @returns \n     */\n    static RemoveCaptureAndLeaveMovementCapture(str) {\n        let s = RegexUtils.RemoveCapture(str, RegexUtils.CAPTURE_LEAVE_AHEAD_BACKYARD);\n        if (s) {\n            return RegexUtils._TreatCaptureGroup(s);\n        }\n        return s;\n    }\n    static _TreatCaptureGroup(s) {\n        if ((s[0]==\"/\") && (s[s.length-1]==\"/\")){\n            s = s.slice(1,-1);\n        }\n        return s.split('|').filter(o => o.length > 0).join('|')\n    }\n    /**\n     * regex to string regex\n     * @param {RegExp} s \n     * @returns \n     */\n    static RegexToStringRegex(s){\n        s = s.toString();\n        return s.substring(0, s.lastIndexOf('/')+1).slice(1,-1);\n    }\n    /**\n    * get regex info on start line\n    * @param {string} s regex string expression\n    */\n    static RegexInfo(s) {\n        let option = '';\n        if (s == \"(??)\") {\n            return {\n                s: \"^.^\",\n                option,\n                beginOnly: true\n            };\n        }\n\n        let _option = /^\\(\\?(?<active>[imx]+)(-(?<disable>[ixm]+))?\\)/;\n        let _potion = null;\n        if (_potion = _option.exec(s)) {\n            let sp = '';\n            if (_potion.groups) {\n                sp = _potion.groups.active ?? '';\n                if (_potion.groups.disable) {\n                    _potion.groups.disable.split().forEach(i => {\n                        sp = sp.replace(i, '');\n                    });\n                }\n            }\n            s = s.replace(_option, '');\n            option = sp;\n        }\n        return {\n            s,\n            option\n        };\n    }\n    /**\n     * check request start line\n     * @param {*} reg \n     * @returns \n     */\n    static CheckRequestStartLine(reg) {\n        // + | TO CHECK that regex request for start line \n        // - ^ must not be escaped \\^\n        // - ^ must not be a non validated group [^] \n        return /([^\\\\\\\\[]|^)\\^/.test(reg.toString());\n    }\n    /**\n     * check regex request on end line\n     * @param {*} reg \n     * @returns {boolean}\n     */\n    static CheckRequestEndLine(reg) {\n        // + | TO CHECK that regex request for start line \n        // - ^ must not be escaped \\$\n        // - ^ must not be a non validated group [$] \n        return /([^\\\\\\\\[]|$)\\$/.test(reg.toString());\n    }\n    /**\n    /**\n     * stringify and regex result\n     * @param {*} c \n     * @returns \n     */\n    static Stringify(c) {\n        return c.toString().slice(1, -1).replace(\"\\\\/\", \"/\")\n    }\n /**\n  * remove capture group\n  * @param {string} str regex data \n  * @param {*} regex regex that represent the capture\n  * @returns \n  */\n    static RemoveCapture(str, regex) {\n\n        if (typeof (str) != 'string') {\n            throw new Error('invalid parameter.');\n        }\n\n        let l = str;\n        let p = 0;\n        let ch = '';\n        regex = regex || /\\(\\?(:|(\\<)?=)./;\n        function rm_brank(l, index, start = '(', end = ')') {\n            let i = 1;\n            let ln = l.length;\n            const start_index = index;\n            let escaped = false;\n            while ((i < ln) && (i > 0) && (index < ln)) {\n\n                ch = l[index + 1];\n                if (ch == start) {\n                    if (!escaped) {\n                        i++;\n                    }\n                } else if (ch == end) {\n                    if (!escaped)\n                        i--;\n                }\n                escaped = ch == \"\\\\\";\n                index++;\n            }\n            //+ | fix: remove repeating brank symbol\n            if ((index + 1 < ln) && (/[\\\\?\\\\*]/.test(l[index + 1]))) {\n                index++;\n            }\n            return l.substring(0, start_index) + l.substring(index + 1);\n        }\n        let capture = false;\n        let _prev = '';\n        while (p = regex.exec(l)) {\n            if (p.index>0){\n                let _escape = l[p.index-1]==\"\\\\\";\n                if (_escape){\n                    _prev += l.substring(0, p.index+1);\n                    l = l.substring(p.index+1);\n                    continue;\n                }\n            }\n            l = rm_brank(l, p.index);\n            capture = true;\n        }\n        if (_prev.length>0){\n            if (capture){\n                l = _prev+l;\n            }\n        }\n        return capture ? l : str;\n    }\n\n    static ReadBrank(str, position, count = 1, start = '(', end = ')') {\n        const ln = str.length;\n        let ch = null;\n        let _stpos = position;\n        while (position < ln) {\n            ch = str[position];\n            if (ch == start) {\n                count++;\n            } else if (ch == end) {\n                count--;\n                if (count == 0) {\n                    position++;\n                    break;\n                }\n            }\n            position++;\n        }\n        return str.substring(_stpos, position);\n    }\n\n    /**\n     * check if is captured only regex expression\n     * @param {string|RegExp} regex \n     * @returns {bool}\n     */\n    static IsCapturedOnlyRegex(regex) {\n        let f = false;\n        let s = regex.toString();\n        s = s.substring(0, s.lastIndexOf('/') + 1).slice(1, -1);\n        s = RegexUtils.RemoveCapture(s, /\\(\\?((<)?!|(\\<)?=)./);\n        if (s == null) {\n            return false;\n        }\n        s = s.split('|').join('').trim();\n\n        f = s.length == 0;\n        return f;\n    }\n    /**\n     * unset capture definition \n     * @param {*} m \n     */\n    static UnsetCapture(m) {\n        const _regex = /\\(\\?(:|<|=)/;\n        let p = null;\n        let s = '';\n        let ch = null;\n        while (p = _regex.exec(m)) {\n            s = m.substring(0, p.index);\n            // + | remove branket dans leave content \n            let i = 1;\n            let g = m.substring(p.index + p[0].length);\n            let ln = g.length;\n            let pos = 0;\n            while (pos < ln) {\n                ch = g[pos];\n                if (ch == ')') {\n                    i--;\n                    if (i == 0) {\n                        if ((pos + 1 < ln) && /\\?|\\*/.test(g[pos + 1])) {\n                            pos++;\n                        }\n                        let end = g.substring(0, pos) + g.substring(pos + 1);\n                        s += end;\n                        break;\n                    }\n                }\n                else if (ch == '(') {\n                    i++;\n                }\n                pos++;\n            }\n            m = s;\n        }\n        return m;\n    }\n}\n\nRegexUtils.SKIP_REGEX = SKIP_REGEX;\n\nexports.RegexUtils = RegexUtils;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n \nconst { Utils } = require(\"./Utils\");\n\n\nclass ReplaceWithCondition{\n    /**\n     * expression to check\n     * @var {undefined|*}\n     */\n    expression;\n    check;\n    operator = '=';\n    match;\n    captures;\n\n    constructor(){ \n    }\n\n    json_parse(parser, fieldname, data, refKey){\n        const _regex_parser = (s)=>{\n            return Utils.RegexParse(s); \n        };\n        const _capture_parser = Utils.JSONInitCaptureField(this);\n        return Utils.JSonParse(this, {\n            expression: _regex_parser,\n            match: _regex_parser,\n            captures : _capture_parser\n        }, parser, fieldname, data, refKey);\n    }\n    json_validate(field_name, d, throw_on_error){\n        let string_test = (v)=> typeof(v)=='string';\n        return Utils.JSonValidate(this, {\n            check:string_test,\n            operator:string_test,\n            operator:string_test,\n        },field_name, d, throw_on_error); \n    }\n\n}\n\nexports.ReplaceWithCondition = ReplaceWithCondition;","\"use strict\";\nObject.defineProperty(exports, \"__ESModule\", { value: true });\n\nconst _REGISTRY = {};\n/**\n * base transform engine\n */\nclass TransformEngine\n{\n    /**\n     * register transform engine\n     * @param {*} id \n     * @param {*} func_or_class_name \n     */\n    static Register(id, func_or_class_name){\n        _REGISTRY[id] = func_or_class_name;\n    }\n    static CleareRegistry(){\n        Object.keys(_REGISTRY).forEach((o)=>{\n            delete(_REGISTRY[o]);\n        });\n\n    }\n    /**\n     * create a transform engine \n     * @param {*} id \n     * @returns \n     */\n    static Create(id){\n        const def = _REGISTRY[id];\n        if (def){\n            return new def();\n        }\n        return null;\n    }\n}\n\nexports.TransformEngine = TransformEngine;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { JSonParser } = require(\"./JSonParser\");\nconst { RegexUtils } = require(\"./RegexUtils\");\n\n/**\n * utility classe\n */\nclass Utils {\n    static TestScope;\n\n    /**\n     * utility trim buffer segment\n     * @param {*} bufferSegment \n     */\n    static TrimBufferSegment(bufferSegment, dataSegment) {\n        if (dataSegment.length != bufferSegment.length){\n            throw new Error('invalid trim operation. length must match');\n        }\n        const _tlist = bufferSegment.marked.slice(0);\n        let _dir = 0;\n        let _idx = 0;\n        let _count = 0;\n        let q = bufferSegment;\n        let _ln = bufferSegment.length;\n\n        while (_tlist.length > 0) {\n            _idx = _dir == 0 ? _tlist.shift() : _tlist.pop();\n            let _top = bufferSegment.marked.op[_idx] || null;\n            let _trim = _dir == 0 ? _idx == _count : _idx == _count;\n            if (_top && _trim && _top.trimmed) {\n                //let _ts = q[_idx];\n                delete (q[_idx]);\n                delete (dataSegment[_idx]);\n                delete (bufferSegment.marked[bufferSegment.marked.indexOf(_idx)]);\n                delete (bufferSegment.marked.op[_idx]);\n\n            }\n            if (_dir == 1) {\n                if (!_trim) {\n                    break;\n                }\n                _count--;\n            } else {\n                if (!_trim) {\n                    _dir = 1;\n                    _count = _ln - 1;\n                    _tlist.unshift(_idx);\n                    continue;\n                }\n                _count++;\n            }\n        }\n\n        if (dataSegment.length != bufferSegment.length){\n            throw new Error('invalid trim operation');\n        }\n    }\n    /**\n     * get marked segment setting\n     * @param {*} marker \n     * @returns \n     */\n    static GetMarkedInfo(marker){\n        let _info = null;\n        const { isMarkedSegments, isTrimmedSegment, markedSegment } = marker;\n        if (isMarkedSegments) {\n            if (typeof (markedSegment) == 'object') {\n                _info = {\n                    trimmed: isTrimmedSegment,\n                    ...markedSegment\n                }\n            }else{\n                _info = {isTrimmed: isTrimmedSegment};\n            }\n            return _info;\n        }\n        return false;\n    }\n    static ReorderBufferSegment(bufferSegment) {\n        const { FormatterBuffer } = Utils.Classes;\n        // order \n        const _op = bufferSegment.marked.op;\n        const _marked = bufferSegment.marked;\n        let _ni = 0;\n        let _buff = [];\n        _buff.marked = FormatterBuffer.InitMarkedSegment();\n        // update buffer marker order \n        for (let ri = 0; ri < bufferSegment.length; ri++) {\n            if (bufferSegment[ri] != undefined) {\n                // delete \n                _buff.push(bufferSegment[ri]);\n                if (ri in _op) {\n                    _buff.marked.push(_ni);\n                    _buff.marked.op[_ni] = _op[ri];\n                } else if (_marked.indexOf(ri) != -1) {\n                    _buff.marked.push(_ni);\n                }\n                _ni++;\n            }\n        }\n\n        bufferSegment.length = 0;\n        bufferSegment.push(..._buff);\n        bufferSegment.marked = _buff.marked;\n\n    }\n\n    /**\n     * \n     * @param {*} _d \n     * @param {*} _idx \n     * @param {*} op operation to do \n     */\n    static UpdateSegmentMarkerOperation(_d, _idx, op) {\n        if (Array.isArray(_d)==false){\n            throw new Error(\"required array\");\n        }\n      \n        // if (!op) {\n        //     console.log(\"----not op-----\", _d);\n        //     return;\n        // }\n        _d.op[_idx] = op;\n    }\n    static UpdateMarkedSegment(s, _marker) {\n        if (_marker.isMarkedSegments) {\n            s.marked = _marker.markedInfo();\n        }\n    }\n\n    /**\n     * Get default begin captures\n     * @param {*} marker \n     * @returns \n     */\n    static BeginCaptures(marker) {\n        return { ...marker.captures, ...marker.beginCaptures };\n    }\n    static EndCaptures(marker) {\n        return { ...marker.captures, ...marker.endCaptures };\n    }\n\n    static JSON_REGEX_PARSER() {\n        return (s) => {\n            if (s == '(??)') {\n                q.isStartOnly = true;\n                s = '';\n            }\n            let is_empty = false;\n            if (s == '') {\n                is_empty = true;\n            }\n            let g = Utils.RegexParse(s, 'd');\n            g = RegexEngine.Load(g, is_empty);\n            return g;\n        };\n    }\n\n    /**\n     * create end match\n     * @param {*} value \n     * @returns \n     */\n    static CreateEndMatch(value, input) {\n        const _p = [value];\n        _p.index = 0;\n        _p.indices = [[0, value.length]];\n        _p.input = input || \"\\0\";\n        return _p;\n    }\n\n    static ReplaceWithCheck(replaceWith, value, { match, captures, operator, check }, _refObj) {\n        let _rpw = Utils.RegExToString(replaceWith);\n        const { g } = _refObj;\n        _refObj._rpw = _rpw;\n        if (match) {\n            let _op = operator || '=';\n            let _s = Utils.ReplaceRegexGroup(check, g);\n            if (/(!)?=/.test(_op)) {\n                let r = match.test(_s);\n                if (_op) {\n                    if (((_op == '=') && !r) || ((_op == '!=') && (r))) {\n                        _refObj.replaced = false;\n                        return value;\n                    }\n                }\n            } else if (/(\\<\\>)=/.test(_op)) {\n                let _ex = match.toString().replace(/\\\\\\//g, '');\n                if (\n                    ((_op == \">=\") && (_s >= _ex)) ||\n                    ((_op == \"<=\") && (_s <= _ex))\n                ) {\n                    if (_s >= _ex) {\n                        _refObj.replaced = false;\n                        return value;\n                    }\n                }\n            }\n        }\n        else {\n            _refObj.replaced = false;\n        }\n        return value;\n    }\n\n    /**\n     * render data\n     * @param {string} value \n     * @param {PatternMatchInfo} marker \n     * @param {null|CaptureInfo[]} captures \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static RenderToBuffer(value, marker, captures, option) {\n        let _cm_value = value;\n        let _cm_data = value;\n\n        // if (captures){\n        //     _cm_value = Utils.TreatCapture(marker, captures, _cm_value, option.tokenChains, option)\n        // }\n\n        option.saveBuffer();\n        option.appendToBuffer(_cm_value, marker, option);\n        option.store();\n        let refdata = { data: null };\n        _cm_value = option.flush(true, refdata);\n        _cm_data = refdata.data;\n        option.restoreSavedBuffer();\n\n        return {\n            \"buffer\": _cm_value,\n            \"data\": _cm_data\n        };\n\n    }\n    /**\n     * define properties\n     * @param {*} target \n     * @param {*} def \n     */\n    static DefineProperties(target, def) {\n        for (let i in def) {\n            target[i] = def[i];\n        }\n    }\n    /**\n    * define and inject property \n    * @param {string} n namespace\n    * @param {undefined|*} v \n    * @param {*} globalname \n    * @returns \n    */\n    static FunctionDefineArg(n, v, globalname) {\n        let c = 0;\n        let result = 0;\n        let s = '';\n        if (globalname) {\n            s = '((w,p,q,n)=>{n=w; while((p.length>1) && (q = p.shift())){ n[q] = n[q] || {}; n = n[q];} n[p[0]] = v})(' + globalname + \", \\\"\" + n + \"\\\".split('.'), v) || \";\n        }\n        n.split('.').forEach((i) => {\n            if (!result) {\n                result = i + '=((v)=>{ return ' + s + '{'\n            } else {\n                if (c) {\n                    result += \"{\"\n                }\n                result += i + \":\";\n                c++;\n            }\n        });\n        v = typeof (v) == 'undefined' ? 'undefined' : (typeof (v) == 'object' ? JSON.stringify(v) : v) || '\"' + n + '\"';\n        result += v + '}'.repeat(c) + \"})(\" + v + \")\";\n\n        return result;\n    }\n    /**\n     * define property \n     * @param {string} n \n     * @param {undefined|*} v \n     * @param {object} global object definition \n     * @returns \n     */\n    static DefineProp(n, v, window) {\n        return ((q, v, window) => {\n            let r = null; let m = null; let _last = null; let _o = null;\n            v = (typeof (v) != \"undefined\" ? v : n);\n            if (q.length == 0) return v;\n            q.forEach(i => {\n                if (r == null) {\n                    // first object definition\n                    r = m = (window ? window[i] : null) || {};\n                    if (window) {\n                        window[i] = r;\n                    }\n                }\n                if (_last) {\n                    _o = m;\n                    if (typeof (m[i]) == 'string') {\n                        m[i] = {};\n                    }\n                    m[i] = m[i] || {};\n                    m = m[i];\n                }\n                _last = i;\n            });\n\n            if (_o)\n                _o[_last] = v;\n            else {\n                if (window) {\n                    window[q[0]] = v;\n                }\n            }\n            return r;\n        })(n.split('.'), v, window);\n    }\n    /**\n     * store tokens\n     * @param {*} name \n     * @param {*} tokens \n     */\n    static StoreTokens(name, tokens) {\n        tokens.unshift(...name.split(' ').reverse());\n    }\n    /**\n     * unshift tokens\n     * @param {*} name \n     * @param {*} tokens \n     */\n    static UnshiftTokens(name, tokens) {\n        const r = name.split(' ').reverse();\n        while (r.length > 0) {\n            const q = r.shift();\n            if (tokens[0] == q) {\n                tokens.shift();\n            } else {\n                throw new Error('missing tokens definition ' + q);\n            }\n        }\n    }\n\n    static ArrayPatternsFromParser(parser, Patterns, RefPatterns) {\n\n        const _pattern_class = parser.patternClassName || Patterns;\n        return Utils.ArrayParser(_pattern_class, RefPatterns);\n    }\n    /**\n     * \n     * @param {*} class_name \n     * @param {*} data \n     * @param {*} registry \n     * @param {null|undefined|{patternClassName: undefined|class, captureInfoClassName:undefined|class, closeParentInfoClassName: undefined|class}} registry \n     * @returns \n     */\n    static JSonParseData(class_name, data, registry, pattern_class_name) {\n        let parser = new JSonParser;\n        parser.source = class_name;\n        parser.data = data;\n        parser.includes = {};\n        // + | init parser definitions\n        if (typeof (pattern_class_name) == 'object') {\n            const { patternClassName, captureInfoClassName, closeParentInfoClassName } = pattern_class_name;\n            parser.patternClassName = patternClassName;\n            parser.captureInfoClassName = captureInfoClassName;\n            parser.closeParentInfoClassName = closeParentInfoClassName;\n        } else {\n            parser.patternClassName = pattern_class_name;\n        }\n        if (registry) {\n            parser.registry = registry;\n        }\n        return Utils.LoadData(parser, new class_name(), data, null); //.parse();\n    }\n    static LoadData(parser, obj, data, refKey) {\n        return JSonParser._LoadData(parser, obj, data, refKey);\n    }\n    /**\n     * array parser callback\n     * @param {*} class_name \n     * @returns \n     */\n    static ArrayParser(class_name, refkey_class_name) {\n        if (!refkey_class_name || typeof (refkey_class_name) == 'undefined') {\n            throw new Error('missing refkey_class_name');\n        }\n        /**\n         * \n         */\n        return function (d, parser, refKey, refObj) {\n            let _out = [];\n            let q = refObj || this;\n            const { Formatters } = Utils.Classes;\n            d.forEach((a) => {\n                const { include } = a;\n                const _extends = a.extends;\n                let _o = null, _key = null, _def = null;\n                if (include) {\n                    if (include[0] == '#') {\n                        // + | LOAD INCLUDE PROPERTY . #include\n                        _key = include.substring(1);\n                        if (_key in parser.includes) {\n                            _o = new refkey_class_name(parser.includes[_key]);\n                        }\n                        else {\n                            if (refKey && (refKey == _key) && refObj) {\n                                _o = new refkey_class_name(q);\n                            } else {\n                                _def = parser.data.repository[_key];\n                                if (_def) {\n                                    _o = new class_name();\n                                    parser.includes[_key] = _o;\n                                    JSonParser._LoadData(parser, _o, _def, _key, refObj || _o);\n                                    parser.initialize(_o);\n                                    class_name.Init(_o);\n                                }\n                            }\n                        }\n                    } else {\n                        // TODO: load engine source formatter - or not\n                        // _o = new FormatterResourceLoadingPattern(include);\n                        const { EngineFormatter } = Formatters;\n                        if (EngineFormatter) {\n                            return EngineFormatter.resolve(include);\n                        }\n\n                    }\n                }\n                else if (_extends) {\n                    throw new Error(\"extends not support yet\");\n                }\n                else {\n                    _o = new class_name();\n                    JSonParser._LoadData(parser, _o, a, refKey, refObj || _o);\n                    parser.initialize(_o);\n\n                }\n                if (_o) {\n                    _out.push(_o);\n                }\n            });\n            return _out;\n        }\n    }\n    /**\n     * check skip pattern\n     * @param {*} skip \n     * @param {*} marker \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static CheckSkip(skip, marker, option) {\n\n        if (typeof (skip) == 'string') {\n            skip = [skip];\n        }\n        const _flags = {\n            startLine: option.startLine,\n            startBlock: option.startBlock,\n            conditionBlockStart: option.isConditionalBlockStart()\n        }\n        while (skip.length > 0) {\n            let q = skip.shift();\n            if (q in _flags) {\n                if (_flags[q]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * \n     * @param {*} s \n     * @param {FormatterOptions} option \n     * @returns \n     */\n    static _SkipLine(s, option) {\n        let _skip = false;\n        if (s.startLine) {\n            if (!option.startLine) {\n                _skip = true;\n            }\n        }\n        if (!_skip && s.skip) {\n            _skip = Utils.CheckSkip(s.skip, s, option);\n        }\n        if (!_skip && option.matchTransform && s.matchTransform) {\n            _skip = true;\n        }\n        if (!_skip && (option.lastEmptyMarkerPattern?.marker == s)) {\n            _skip = true;\n            option.lastEmptyMarkerPattern = null;\n        }\n        return _skip;\n    }\n    /**\n     * get match info\n     * @var {array} patterns\n     * @var {string} l string\n     * @var {*} options\n     * @var {*} parentMatcherInfo parent pattern for get result\n     * @var {boolean|{_a,_match: null|number|RegExpResult,_from:undefined, patterns}}\n     */\n    static GetMatchInfo(patterns, l, option, parentMatcherInfo) {\n        // const { FormatterOptions } = Utils.Classes;\n        let _a = null;\n        let _from = null;\n        let _match = 0;\n        let _index = -1;\n        let _patterns = patterns;\n        let _position = -1; // selected pattern position        \n        const { lineMatcher, debug } = option;\n        lineMatcher.startLine = option.startLine;\n        const _tloop = [{ patterns: patterns, from: null, ref: parentMatcherInfo, count: 0 , slice:0}];\n        const ll = l;\n        while (_tloop.length > 0) {\n            const _m_patterns = _tloop.shift();\n            let _count = 0;\n            let _mpatterns = _m_patterns.patterns.slice(_m_patterns.slice);\n            while (_mpatterns.length > 0) {\n                let s = _mpatterns.shift();\n                //_m_patterns.patterns.forEach((s) => {\n                let p = null;\n                let from = null;\n                let item_index = null;\n                let skip = Utils._SkipLine(s, option);\n\n                if (!skip) {\n                    let { patterns } = s;\n                    const _regex = s.getEntryRegex();\n                    let _d = null;\n                    if (_regex) {\n                        p = lineMatcher.check(_regex, option);\n                        _d = {\n                            p, s: s, index: -1, regex: _regex, from: _m_patterns.from,\n                            patterns: _m_patterns.patterns,\n                            ref: _m_patterns.ref\n                        };\n                    }\n                    else {\n                        if (patterns) {\n                             _tloop.push({ patterns: patterns, from: s, ref: parentMatcherInfo, \n                                count: _count ,\n                                slice: 0});\n                            if (_mpatterns.length > 0) {\n                                _tloop.push({ patterns: _m_patterns.patterns, from: _m_patterns.from, ref: parentMatcherInfo, \n                                    count: _count, \n                                   slice : _m_patterns.patterns.length - _mpatterns.length});\n                                _mpatterns.length = 0;\n                            }\n                            continue;\n                        }\n                    }\n                    if (_d) {\n                        ({ p, s, from, patterns } = _d);\n                        item_index = _d.index == -1 ? _count : _d.index;\n                    }\n                    if (p && ((_index == -1) || (_index > p.index))) {\n                        _index = p.index;\n                        _a = s;\n                        _match = p;\n                        _from = from;\n                        _patterns = patterns || _patterns;\n                        _position = item_index || _count;\n                    }\n                }\n                _count++;\n                // });\n            }\n        } \n        if (_match === 0) {\n            return false;\n        }\n        return { _a, _match, _from, patterns: _patterns, index: _position };\n    }\n    /**\n     * \n     * @param {*} patterns \n     * @param {*} option \n     * @param {*} parentMatcherInfo \n     * @returns \n     */\n    static GetPatternMatcher(patterns, option, parentMatcherInfo = null/*, _line = null, _sub_line_offset = null*/) {\n        const { line, debug, depth, lineCount, lineMatcher, startLine } = option;\n        const { FormatterPatternException } = Utils.Classes;\n        let _a = null;\n        let _match = 0;\n        let _from = -1;\n        let l = lineMatcher.nextLine;\n        const { RefPatterns } = Utils.Classes;\n        let index;\n        ({ _a, _match, _from, patterns, index } = Utils.GetMatchInfo(patterns, l, option, parentMatcherInfo));\n        if (_match) {\n            if (_match.index > option.length) {\n                _a = null;\n                _match = null;\n            }\n        }\n        if (_a) {\n\n            debug?.feature('matcher-begin') && console.log('matcher-begin: ', {\n                '__name': _a.toString(),\n                name: _a.name,\n                line,\n                pos: _match.index,\n                depth,\n                hasParent: _a.parent != null,\n                isBlock: _a.isBlock,\n                comment: _a.comment,\n                isRef: _a instanceof RefPatterns,\n                value: _match[0],\n                detectOn: l,\n                offset: lineMatcher.offset,\n                regex: _a.matchRegex,\n                type: _a.matchType == 0 ? \"begin/end\" : \"match\",\n                isFromGroupRef: _from != null,\n                parent: _a.parent?.toString(),\n                from: _from?.toString(),\n                startLine\n            });\n            if (_a.throwError) {\n                let e = _a.throwError;\n                let msg = typeof (e) == 'object' ? e.message : 'invalid match';\n                msg = msg.replace(\"%value%\", \"'\" + _match[0] + \"'\");\n                throw new FormatterPatternException(msg, _a, _match, lineCount);\n            }\n            // + | add property to offset \n            _match.offset = _match[0].length;\n            // + | treat begin captures must be at corresponding data  \n            let _info = new PatternMatchInfo;\n            Utils.InitPatternMatchInfo(_info, _a, _match, parentMatcherInfo, _from, line, patterns, index, option.formatter.formatting,\n                {\n                    lineCount: option.lineCount\n                }\n            );\n            return _info;\n        }\n        return _a;\n    }\n    /**\n     * \n     * @param {*} _info \n     * @param {*} _a \n     * @param {*} _match \n     * @param {*} parentMatcherInfo \n     * @param {*} _from \n     * @param {*} line \n     * @param {*} patterns \n     * @param {*} index \n     * @param {*} formatting \n     * @param {{lineCount: number}} state state info\n     */\n    static InitPatternMatchInfo(_info, _a, _match, parentMatcherInfo, _from, line, patterns, index = -1, formatting=null, state = null) {\n        _info.use({\n            marker: _a,\n            endRegex: _a.endRegex(_match),\n            line,\n            group: _match,\n            parent: parentMatcherInfo,\n            patterns,\n            fromGroup: _from,\n            index,\n            formatting,\n            state\n        });\n    }\n    /**\n     * \n     * @param {string} l \n     * @param {*} patterns \n     * @param {*} option \n     * @param {*} parentMatcherInfo \n     * @returns \n     */\n    static GetPatternMatcherInfoFromLine(line, patterns, option, parentMatcherInfo) {\n        const { debug, depth, lineCount, formatter } = option;\n        const { RefPatterns, FormatterPatternException } = Utils.Classes;\n        let _a = null;\n        let _match = 0;\n        let pos = 0;\n        let _from = null;\n        let index = -1;\n        const { formatting } = formatter;\n        ({ _a, _match, _from, patterns, index } = Utils.GetMatchInfo(patterns, line, option, parentMatcherInfo));\n\n        if (_a) {\n            // _match.index += pos;\n            if (debug) {\n                console.log('matcher-begin-1: ', {\n                    '__name': _a.toString(),\n                    name: _a.name, line, pos:\n                        _match.index, depth,\n                    hasParent: _a.parent != null,\n                    isBlock: _a.isBlock,\n                    isRef: _a instanceof RefPatterns,\n                    value: _match[0],\n                    regex: _a.matchRegex,\n                    index\n                });\n            }\n            if (_a.throwError) {\n                let e = _a.throwError;\n                const msg = typeof (e) == 'object' ? e.message : 'invalid match';\n                throw new FormatterPatternException(msg, _a, _match, lineCount);\n            }\n            // + | add property to offset \n            _match.offset = _match[0].length;\n            // +| treat begin captures must be at corresponding data info \n\n            let _info = new PatternMatchInfo;\n            Utils.InitPatternMatchInfo(_info, _a, _match, parentMatcherInfo, _from, line, patterns, index, formatting);\n            return _info;\n        }\n        return _a;\n    }\n    /**\n     * get regex from\n     * @param {string} s regex expression\n     * @param {*} p group match\n     * @returns \n     */\n    static GetRegexFrom(s, p, flag, op) {\n        if ((op == 'end') || (op == 'while')) {\n\n            s = s.replace(/\\\\([\\d]+)/g, (a, m) => {\n\n                return p[m];\n            });\n\n        }\n        else {\n\n            s = s.replace(/[^\\\\]?\\$([\\d]+)/g, (a, m) => {\n                if (a[0] == \"\\\\\") return a;\n                if (a[0] != '$')\n                    return a[0] + p[m];\n                return p[m];\n            });\n        }\n        s = /^\\/.+\\/$/.test(s) ? s.slice(1, -1) : s;\n        return new RegExp(s, flag || '');\n    }\n\n\n    static ReplaceRegexGroup(s, group, op) {\n        let gp = Utils.GetRegexFrom(s, group, null, op);\n        gp = gp.toString().substring(1).slice(0, -1).replace(/\\\\\\//g, \"/\");\n        s = s.replace(s, gp);\n        return s;\n    }\n    /**\n     * convert to string en remove the flags\n     * @param {*} regex \n     * @returns \n     */\n    static RegExToString(regex) {\n        let s = regex.toString();\n        s = s.substring(0, s.lastIndexOf('/') + 1);\n        return s;\n    }\n\n    /**\n     * get regex info on start line\n     * @param {string} s regex string expression\n     */\n    static RegexInfo(s) {\n        return RegexUtils.RegexInfo(s);\n    }\n    static RegexParseInfo(s, flag) {\n        let _info = Utils.RegexInfo(s);\n        if (flag && ((_info.option.length == 0) || (_info.option.indexOf(flag) == -1))) {\n            _info.option += flag;\n        }\n        return _info;\n    }\n\n\n    /**\n     * \n     * @param {*} s \n     * @param {*} flag \n     * @returns \n     */\n    static RegexParse(s, flag) {\n        if (typeof (s) == 'string') {\n            let _info = Utils.RegexParseInfo(s, flag);\n            return new RegExp(_info.s, _info.option);\n        } else if (typeof (s) == 'object') {\n            if (s instanceof RegExp) {\n\n                s = RegexUtils.RegexToStringRegex(s);\n                let _info = Utils.RegexParseInfo(s, flag);\n                let _ms = new RegExp(_info.s, _info.option);\n                return _ms;\n            }\n            const { option, regex } = s;\n            if (regex instanceof RegExp) {\n                regex = Utils.GetRegexFrom(regex.toString(), option);\n                return regex;\n            }\n            return new RegExp(regex, option);\n        }\n        return s;\n    }\n    static StringValueTransform(v, transform) {\n        const _func = {\n            captialize(s){\n                let tb = [];\n                s.split(\" \").forEach(a =>{\n                    tb.push(a.charAt(0).toUpperCase()+a.slice(1).toLowerCase());\n                });\n                return tb.join(\" \");\n            },\n            joinSpace(s) {\n                s = s.replace(/\\s+/g, ' ');\n                return s;\n            },\n            upperCase(v) {\n                return v.toUpperCase();\n            },\n            lowerCase(v) {\n                return v.toLowerCase();\n            },\n            trim(v) {\n                return v.trim();\n            },\n            /**\n             * \n             * @param {string} v \n             * @returns \n             */\n            rtrim(v) {\n                return v.trimEnd();\n            }\n            , /**\n            * \n            * @param {string} v \n            * @returns \n            */\n            ltrim(v) {\n                return v.trimStart();\n            }\n        };\n        transform.forEach((s) => {\n            // if (v.length == 0) {\n            //     return;\n            // }\n            let _p = null;\n            if (_p = /^:(?<symbol>=|\\^|#)(.)(?<number>\\d+)/.exec(s)) {\n                // + | replacement value with pattern\n                let n = parseInt(_p.groups['number']);\n                let _s = _p.groups['symbol'];\n                if (n > v.length) {\n                    let _g = _p[2];\n                    if (_s == '#') {\n                        v = v.toString().padEnd(n, _g);\n                    } else if (_s == '^') {\n                        v = v.toString().padStart(n, _g);\n                    }\n                    else if (_s == '=') {\n                        let c = Math.floor((n - v.length) / 2);\n                        v = v.toString().padEnd((c % 2) == 0 ? n - c : n - c + 1, _g);\n                        v = v.toString().padStart(n, _g);\n                    }\n                }\n                return v;\n            }\n\n            if (_p = /^\\[(?<expression>.+)\\]$/.exec(s)) {\n                let c = Utils.GetRegexFrom(_p.groups['expression'], [v]);\n                c = RegexUtils.Stringify(c);\n                v = v.replace(v, c);\n                return v;\n            }\n\n            v = typeof (s) == 'function' ? s(v) : _func[s](v);\n        });\n        return v;\n    }\n    /**\n     * \n     * @param {*} q \n     * @param {*} validator \n     * @param {*} field_name \n     * @param {*} d \n     * @param {*} throw_on_error \n     * @returns \n     */\n    static JSonValidate(q, validator, field_name, d, throw_on_error) {\n\n        let f = validator ? validator[field_name] : null;\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * \n     * @param {*} q \n     * @param {*} parse \n     * @param {*} parser \n     * @param {*} fieldname \n     * @param {*} data \n     * @param {*} refKey \n     * @returns \n     */\n    static JSonParse(q, parse, parser, fieldname, data, refKey) {\n        let fc = parse ? parse[fieldname] : null;\n        if (fc) {\n            return fc.apply(q, [data, parser, refKey]);\n        }\n        return data;\n    }\n    static TransformPropertyCallback() {\n        return function (n, parser) {\n            if (typeof (n) == 'string') {\n                let t = []\n                n.split(',').forEach((i) => {\n                    i.trim();\n                    if (i.length > 0)\n                        t.push(i);\n                });\n                return t;\n            }\n            if (Array.isArray(n)) {\n                return n;\n            }\n        };\n    }\n    /**\n * do replace with\n * @param {*} value \n * @param {*} _formatter \n * @param {string} replace_with \n * @param {*} group \n * @param {*} _marker markerInfo\n * @param {FormatterOptions} option markerInfo\n * @param {*} captures markerInfo\n * @param {refobject|boolean} treat treat marker with capture\n * @returns \n */\n    static DoReplaceWith(value, _formatter, replace_with, group, _marker, option, captures, treat = true) {\n        let g = group;\n        let _rp = replace_with; // \n        let m = '';\n        const { CaptureRenderer } = Utils.Classes;\n        const { listener } = option;\n        if (g) {\n            // ------------------------\n            // \n            //\n            m = Utils.ReplaceRegexGroup(_rp, g); // check for regex presentation\n            let check = m.replace(/(?<=(^|[^\\\\]))(\\(|\\))/g, ''); // remove capture brackets\n            // escape range \n            // ------------------------\n            // consider escape to check\n            //\n            let cp = new RegExp(m, 'd');\n            let _in = value.replace(value, check).replace(/\\\\\\\\/g, /\\\\0/);\n            // passing exec to formatt new value\n            let matches = cp.exec(_in);\n            const _tokens = option.tokenChains;\n            const _caps = captures || _formatter.getMarkerCaptures(_marker);\n            if (matches && _caps) {\n                g = CaptureRenderer.CreateFromGroup(matches, _tokens);\n                const _outdefine = {};\n                let out = g.render(listener, _caps, false, _tokens, option, _outdefine, treat);\n                if (typeof (treat) == 'object') {\n                    treat.segments = _outdefine;\n                }\n                return out;\n            }\n            check = check.replace(/\\\\(.)/g, '$1');\n            return check;\n\n        } else {\n            //treat:\n            _rp = _rp.substring(1).slice(0, -1)\n            if (_rp == '(?:)') {\n                _rp = '';// empty string\n            }\n            m = _rp.replace(/\\\\\\//g, \"/\");\n        }\n        value = value.replace(value, m);\n        return value;\n    }\n\n    /**\n     * Treat patterns values\n     * @param {string|{value:string, name:string}} value value to treat \n     * @param {*} patterns \n     * @param {*} group - parent group match to resolve\n     * @param {*} option - options\n     * @returns \n     */\n    static TreatPatternValue(value, patterns, group, option) {\n        const _formatter = option.formatter;\n        let _bckCapture = _formatter.info.captureGroup;\n        _formatter.info.captureGroup = group;\n        let name = null;\n        let _name = null;\n        let _value = null;\n        // extra name and value\n        if (typeof (value) == 'object') {\n            ({ value, name } = value);\n        } else {\n            _value = value;\n        }\n        _name = name;\n        _value = value;\n\n        const q = option;\n        if (_formatter.settings.useCurrentFormatterInstance) {\n            option.pushState();\n            // backup setting\n            let _bck = {\n                patterns: _formatter.patterns,\n                buffer: q.buffer,\n                output: q.output,\n                formatterBuffer: q.formatterBuffer,\n                lineCount: q.lineCount,\n                markerInfo: q.markerInfo.slice(0),\n                line: q.line,\n                pos: q.pos,\n                depth: q.depth,\n                tokenList: q.tokenList.slice(0),\n                markerDepth: q.markerDepth,\n                blockStarted: q.blockStarted,\n                appendToBufferListener: q.appendToBufferListener,\n                lastEmptyMarkerPattern: option.lastEmptyMarkerPattern\n            };\n            // clean setting\n\n            q.appendToBufferListener = null;\n            q.lineCount = 0;\n            q.depth = 0;\n            q.markerInfo.length = 0;\n            option.lineMatcher.save();\n            option.lineSegments.save();\n            option.lastEmptyMarkerPattern = null;\n            q.newBuffer('_subformat_buffer_');\n            _formatter.info.isSubFormatting++;\n            _formatter.patterns = patterns;\n\n            value = _formatter.format(_value, { name: _name });\n            _formatter.info.isSubFormatting--;\n            _formatter.patterns = _bck.patterns;\n            // + | restore setting\n            q.lineCount = _bck.lineCount;\n            option.lineMatcher.restore();\n            option.lineSegments.restore();\n            q.line = _bck.line;\n            q.depth = _bck.depth;\n\n            q.appendToBufferListener = _bck.appendToBufferListener;\n            q.restoreBuffer({ state: { formatterBuffer: _bck.formatterBuffer } });\n            _bck.markerInfo.forEach(a => q.markerInfo.push(a));\n            option.popState();\n            option.lastEmptyMarkerPattern = _bck.lastEmptyMarkerPattern;\n\n        } else {\n            // passing value to pattern \n            let n_formatter = Formatters.CreateFrom({ patterns: d.patterns });\n            value = n_formatter.format(value);\n        }\n        _formatter.info.captureGroup = _bckCapture;\n        return value;\n    }\n\n    /**\n     * \n     * @param {*} marker \n     * @param {*} _cap \n     * @param {*} group \n     * @param {*} tokenChains \n     * @param {*} option \n     * @returns {string|undefined}\n     */\n    static TreatCapture(marker, _cap, group, tokenChains, option) {\n        const { listener } = option;\n        const { CaptureRenderer } = Utils.Classes;\n        let _s = null;\n        if (Array.isArray(group) == false) {\n            if (group === null)\n                group = '';\n            const indices = [];\n            indices.push([0, group.length]);\n            group = [group];\n            group.indices = indices;\n        }\n        _s = CaptureRenderer.CreateFromGroup(group, marker.name);\n        if (_s) {\n            let _g = _s.render(listener, _cap, false, tokenChains, option);\n            return _g;\n        }\n    }\n    /**\n     * get next capture data\n     * @param {string} line \n     * @param {string} endRegex \n     * @param {*} option \n     * @returns \n     */\n    static GetNextCapture(line, endRegex, option) {\n        const { RegexUtils } = Utils.Classes;\n        let m = endRegex.toString();\n        m = m.substring(0, m.lastIndexOf('/') + 1).slice(1, -1);\n        m = RegexUtils.UnsetCapture(m);\n        let reg = new RegExp(m);\n        let _ret = reg.exec(line);\n        if (_ret) {\n            _ret.offset = _ret[0].length;\n        }\n        return _ret;\n    }\n\n    static JSONInitCaptureField(q) {\n        return (s, parser) => {\n            const _info_class = parser.captureInfoClassName || Utils.Classes.CaptureInfo;\n            let d = {};\n            for (let i in s) {\n                let m = new _info_class(q);\n                JSonParser._LoadData(parser, m, s[i]);\n                d[i] = m;\n                parser.initialize(m);\n            }\n            return d;\n        }\n    }\n    /**\n * \n * @param {*} patterns \n * @param {*} idx \n * @param {*} action \n * @returns \n */\n    static GetPatternsList(patterns, idx, action) {\n        switch (action) {\n            case 'next':\n                return patterns.slice(idx + 1);\n            case 'parent':\n                break;\n            case 'all':\n                return patterns.slice(0);\n            case 'exclude':\n                let r = patterns.slice(0);\n                delete (r[idx]);\n                return r;\n        }\n        return [];\n    }\n}\n\n\n\nexports.Utils = Utils;\n\n// + | extra const usage \nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");","\"use strict\";\nObject.defineProperty(exports, '__ESModule', {value:true});\n\nconst vscode = require('vscode');\nconst { CssTransformer } = require('../lib/Css/CssTransformer')\nconst commands = {\n    \"css.transform.toJSON\": async () => { \n        const { document } = vscode.window.activeTextEditor;\n        if (!document){\n            return;\n        }\n        let {scheme} = document.uri;\n        if (scheme != 'file'){\n            return;\n        }\n        // determine if the document match the language\n        let _match = vscode.languages.match({language:'css'}, document);\n\n        // console.log(_match);\n       if (_match==0){\n         throw new Error('document is not a valid css document')\n       }\n        // let _fname = await vscode.window.showInputBox({\n        //     placeHolder: 'file Name'\n        // })\n        const src = document.getText()\n\n        const json = CssTransformer.ToJSON(src);\n        \n        console.log(`transform css to json`);\n        vscode.workspace.openTextDocument({\n            \"language\":\"json\",\n            \"content\":json,\n        }).then((a)=>{\n            vscode.window.showTextDocument(a);\n        });\n    }\n}\n\nexports.commands = commands;","const { Formatters } = require(\"../../src/lib/Formatters\");\n\n\nconst _list = {\n    bcss: {\n        /**\n         * \n         * @param {string} src \n         * @returns {{colorList:object, rootList: Object }}\n         */\n        GetProvideList(src) {\n            const c_detect = {\n                scopeName: 'detect.color',\n                repository: {\n                    \"glue-white-space\": {\n                        \"match\": \"\\\\s+\",\n                        \"replaceWith\": \" \",\n                        \"isGlueValue\": \" \",\n                        \"tokenID\": \"wp\"\n                    },\n                    \"read-property\": {\n                        \"begin\": \"(-)*\\\\b[a-z][a-z0-9\\\\-]*\\\\b\",\n                        \"end\": \"(?=\\\\s|:|;)\",\n                        \"tokenID\": \"property\"\n                    },\n                    \"value-content\": {\n                        \"begin\": \"[^\\\\s]\",\n                        \"end\": \"(?=;|\\\\})\",\n                        \"tokenID\": \"value\",\n                        \"patterns\": [\n                            {\n                                \"include\": \"#glue-white-space\"\n                            }, {\n                                \"match\": \"(?i)[a-z0-9]+\",\n                            },\n                            {\n                                \"match\": \"//(.)+$\",\n                                \"replaceWith\": \"\"\n                            },\n                            {\n                                \"begin\": \"/\\\\*\",\n                                \"end\": \"\\\\*/\",\n                                \"replaceWith\": \"\"\n                            }\n                        ]\n                    },\n                    \"read-value\": {\n                        \"begin\": \"(:)\",\n                        \"end\": \"(?=;|\\\\})\",\n                        \"tokenID\": \"source-def\",\n                        \"patterns\": [\n                            {\n                                \"include\": \"#value-content\"\n                            }\n                        ]\n                    },\n                    \"root-property-detection\": {\n                        \"patterns\": [\n                            {\n                                \"include\": \"#read-property\"\n                            },\n                            {\n                                \"include\": \"#glue-white-space-\"\n                            },\n                            {\n                                \"include\": \"#read-value\"\n                            }\n                        ]\n                    },\n                    \"color-property-detection\": {\n                        \"patterns\": [{\n                            \"include\": \"#read-property\"\n                        },\n                        {\n                            \"include\": \"#read-value\"\n                        }]\n                    },\n                    \"root-property-handle\": {\n                        begin: \"@root\",\n                        end: \"(?<=\\\\})\",\n                        tokenID: 'root-directive',\n                        patterns: [\n                            {\n                                begin: \"\\\\{\",\n                                end: \"\\\\}\",\n                                name: \"block-definition.detect.bcss\",\n                                patterns: [\n                                    {\n                                        \"include\": \"#root-property-detection\"\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                },\n                patterns: [\n                    {\n                        begin: \"@color\",\n                        end: \"(?<=\\\\})\",\n                        name: 'color-def',\n                        tokenID: 'color-directive',\n                        patterns: [\n                            {\n                                begin: \"\\\\{\",\n                                end: \"\\\\}\",\n                                name: \"block-definition.detect.bcss\",\n                                patterns: [\n                                    {\n                                        \"include\": \"#color-property-detection\"\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        include: \"#root-property-handle\"\n                    }\n                ]\n            }\n            let c_formatter = Formatters.CreateFrom(c_detect);\n            const _colorList = {};\n            const _rootList = {};\n            const _isDirectiveToken = (v) => {\n                return /-directive$/.test(v)\n            };\n\n            c_formatter.listener = {\n                /**\n                 * @type {null|string}\n                 */\n                _p: null,\n                _colorList,\n                _rootList,\n                /**\n                 * @type {?number}\n                 */\n                _mode: 0,\n                /**\n                 * \n                 * @param {*} marker \n                 * @param {*} option \n                 */\n                onEndHandler(marker, option, { isSubFormatting, tokenID, value, offset, sourceOffset }) {\n                    const { debug } = option;\n                    //console.log(\"end handler .... \", value, tokenID);\n\n                    const _list = ((m, q) => {\n                        return {\n                            'color': q._colorList,\n                            'root': q._rootList,\n                        }[m]\n                    })(this._mode, this);\n\n                    switch (tokenID) {\n                        case 'property':\n                            this._p = value.value.trim();\n                            break;\n                        case 'value':\n                            const { _p } = this;\n                            this._p = null;\n                            if ((this._mode == 'root') && (!/^--/.test(_p))) {\n                                break;\n                            }\n                            _list[_p] = value.value.trim();\n                            break;\n                        default:\n                            if (!isSubFormatting && _isDirectiveToken(tokenID)) {\n                                this._mode = 0;\n                            }\n                            break;\n                    }\n                },\n                onStartHandler(marker, option, { isSubFormatting }) {\n                    const { tokenID } = marker;\n                    if (!isSubFormatting && /-directive$/.test(tokenID)) {\n                        let g = tokenID.substring(0, tokenID.length - 10);\n                        this._mode = g;\n                    }\n\n                },\n\n                renderToken(value, ...args) {\n                    return value;\n                }\n            }\n         \n            let _result = c_formatter?.format(src);\n            return {\n                colorList: _colorList,\n                rootList: _rootList\n            };\n        }\n    }\n};\n\nmodule.exports = {\n    ..._list\n}","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\nconst { utils } = require('./utils');\nexports.utils = utils;\nexports.__namespace = __dirname; ","\"use strict\";\n\nconst { Formatters } = require(\"../formatter\");\n\nconst webcolor = {\n\t\"aliceblue\": \"#EFF7FF\",\n\t\"antiquewhite\": \"#F9EAD6\",\n\t\"aqua\": \"#0FF\",\n\t\"aquamarine\": \"#7FFFD3\",\n\t\"azure\": \"#EFFFFF\",\n\t\"beige\": \"#F4F4DB\",\n\t\"bisque\": \"#FFE2C4\",\n\t\"black\": \"#000\",\n\t\"blanchedalmond\": \"#FFEACC\",\n\t\"blue\": \"#00F\",\n\t\"blueviolet\": \"#892BE2\",\n\t\"brown\": \"#A52828\",\n\t\"burlywood\": \"#DDB787\",\n\t\"cadetblue\": \"#5E9EA0\",\n\t\"chartreuse\": \"#7FFF00\",\n\t\"chocolate\": \"#D1681E\",\n\t\"coral\": \"#FF7F4F\",\n\t\"cornflowerblue\": \"#6393ED\",\n\t\"cornsilk\": \"#FFF7DB\",\n\t\"crimson\": \"#DB143D\",\n\t\"cyan\": \"#0FF\",\n\t\"darkblue\": \"#00008C\",\n\t\"darkcyan\": \"#008C8C\",\n\t\"darkgoldenrod\": \"#B7870A\",\n\t\"darkgray\": \"#A8A8A8\",\n\t\"darkgreen\": \"#006300\",\n\t\"darkgrey\": \"#A8A8A8\",\n\t\"darkkhaki\": \"#BCB76B\",\n\t\"darkmagenta\": \"#8C008C\",\n\t\"darkolivegreen\": \"#546B2D\",\n\t\"darkorange\": \"#FF8C00\",\n\t\"darkorchid\": \"#93C\",\n\t\"darkred\": \"#8C0000\",\n\t\"darksalmon\": \"#E8967A\",\n\t\"darkseagreen\": \"#8EBC8E\",\n\t\"darkslateblue\": \"#473D8C\",\n\t\"darkslategray\": \"#2D4F4F\",\n\t\"darkslategrey\": \"#2D4F4F\",\n\t\"darkturquoise\": \"#00CED1\",\n\t\"darkviolet\": \"#9300D3\",\n\t\"deeppink\": \"#FF1493\",\n\t\"deepskyblue\": \"#00BFFF\",\n\t\"dimgray\": \"#686868\",\n\t\"dimgrey\": \"#686868\",\n\t\"dodgerblue\": \"#1E8EFF\",\n\t\"firebrick\": \"#B22121\",\n\t\"floralwhite\": \"#FFF9EF\",\n\t\"forestgreen\": \"#218C21\",\n\t\"fuchsia\": \"#F0F\",\n\t\"gainsboro\": \"#DBDBDB\",\n\t\"ghostwhite\": \"#F7F7FF\",\n\t\"gold\": \"#FFD600\",\n\t\"goldenrod\": \"#D8A521\",\n\t\"gray\": \"#7F7F7F\",\n\t\"green\": \"#007F00\",\n\t\"greenyellow\": \"#ADFF2D\",\n\t\"grey\": \"#7F7F7F\",\n\t\"honeydew\": \"#EFFFEF\",\n\t\"hotpink\": \"#FF68B5\",\n\t\"indianblue\": \"#00D9FF\",\n\t\"indianred\": \"#CC5B5B\",\n\t\"indigo\": \"#490082\",\n\t\"ivory\": \"#FFFFEF\",\n\t\"khaki\": \"#EFE58C\",\n\t\"lavender\": \"#E5E5F9\",\n\t\"lavenderblush\": \"#FFEFF4\",\n\t\"lawngreen\": \"#7CFC00\",\n\t\"lemonchiffon\": \"#FFF9CC\",\n\t\"lightblue\": \"#ADD8E5\",\n\t\"lightcoral\": \"#EF7F7F\",\n\t\"lightcyan\": \"#E0FFFF\",\n\t\"lightgoldenrodyellow\": \"#F9F9D1\",\n\t\"lightgray\": \"#D3D3D3\",\n\t\"lightgreen\": \"#8EED8E\",\n\t\"lightgrey\": \"#D3D3D3\",\n\t\"lightpink\": \"#FFB5C1\",\n\t\"lightsalmon\": \"#FFA07A\",\n\t\"lightseagreen\": \"#21B2AA\",\n\t\"lightskyblue\": \"#87CEF9\",\n\t\"lightslategray\": \"#778799\",\n\t\"lightslategrey\": \"#778799\",\n\t\"lightsteelblue\": \"#AFC4DD\",\n\t\"lightyellow\": \"#FFFFE0\",\n\t\"lime\": \"#0F0\",\n\t\"limegreen\": \"#3C3\",\n\t\"linen\": \"#F9EFE5\",\n\t\"magenta\": \"#F0F\",\n\t\"maroon\": \"#7F0000\",\n\t\"mediumaquamarine\": \"#6CA\",\n\t\"mediumblue\": \"#00C\",\n\t\"mediumorchid\": \"#BA54D3\",\n\t\"mediumpurple\": \"#9370D8\",\n\t\"mediumseagreen\": \"#3DB270\",\n\t\"mediumslateblue\": \"#7A68ED\",\n\t\"mediumspringgreen\": \"#00F999\",\n\t\"mediumturquoise\": \"#47D1CC\",\n\t\"mediumvioletred\": \"#C61484\",\n\t\"midnightblue\": \"#191970\",\n\t\"mintcream\": \"#F4FFF9\",\n\t\"mistyrose\": \"#FFE2E0\",\n\t\"moccasin\": \"#FFE2B5\",\n\t\"navajowhite\": \"#FFDDAD\",\n\t\"navy\": \"#00007F\",\n\t\"oldlace\": \"#FCF4E5\",\n\t\"olive\": \"#7F7F00\",\n\t\"olivedrab\": \"#6B8E23\",\n\t\"orange\": \"#FFA500\",\n\t\"orangered\": \"#ff4500\",\n\t\"orchid\": \"#D870D6\",\n\t\"palegoldenrod\": \"#EDE8AA\",\n\t\"palegreen\": \"#99F999\",\n\t\"paleturquoise\": \"#AFEDED\",\n\t\"palevioletred\": \"#D87093\",\n\t\"papayawhip\": \"#FFEFD6\",\n\t\"peachpuff\": \"#FFD8BA\",\n\t\"peru\": \"#CC843F\",\n\t\"pink\": \"#FFBFCC\",\n\t\"plum\": \"#DDA0DD\",\n\t\"powderblue\": \"#AFE0E5\",\n\t\"purple\": \"#7F007F\",\n\t\"red\": \"#F00\",\n\t\"rosybrown\": \"#BC8E8E\",\n\t\"royalblue\": \"#3F68E0\",\n\t\"saddlebrown\": \"#8C4411\",\n\t\"salmon\": \"#F97F72\",\n\t\"sandybrown\": \"#F4A360\",\n\t\"seagreen\": \"#2D8C56\",\n\t\"seashell\": \"#FFF4ED\",\n\t\"sienna\": \"#A0512D\",\n\t\"silver\": \"#BFBFBF\",\n\t\"skyblue\": \"#87CEEA\",\n\t\"slateblue\": \"#6B59CC\",\n\t\"slategray\": \"#707F8E\",\n\t\"slategrey\": \"#707F8E\",\n\t\"snow\": \"#FFF9F9\",\n\t\"springgreen\": \"#00FF7F\",\n\t\"steelblue\": \"#4482B5\",\n\t\"tan\": \"#D1B58C\",\n\t\"teal\": \"#007F7F\",\n\t\"thistle\": \"#D8BFD8\",\n\t\"tomato\": \"#FF6347\",\n\t\"transparent\": \"transparent\",\n\t\"turquoise\": \"#3FE0D1\",\n\t\"violet\": \"#ED82ED\",\n\t\"wheat\": \"#F4DDB2\",\n\t\"white\": \"#FFF\",\n\t\"whitesmoke\": \"#F4F4F4\",\n\t\"yellow\": \"#FF0\",\n\t\"yellowgreen\": \"#9C3\"\n};\nconst _reverse_color_keys = ((c) => {\n\t//reverse keys\n\tlet _o = {};\n\tfor (let i in c) {\n\t\tlet k = c[i];\n\t\t_o[k] = i;\n\t}\n\treturn _o;\n})(webcolor);\n\n\nconst _is_reducable_hex_color = (hexColor) => {\n\treturn /^\\b(?:([0-9a-f])\\1){3,4}\\b/i.test(hexColor);\n}\nconst _is_web_color =\n\t/**\n\t * \n\t * @param {vscode.Color} color \n\t * @param {{name:string}} ref name \n\t * @returns \n\t */\n\t(color, ref) => {\n\n\t\tlet _key = _hex_color(color).toUpperCase();\n\t\tif (ref) {\n\t\t\tref.hexColor = _key;\n\t\t}\n\t\tconst _bkey = [];\n\t\tif (_is_reducable_hex_color(_key.substring(1))) {\n\t\t\tlet n_key = \"#\" + _key.substring(1, 2) +\n\t\t\t\t_key.substring(3, 4) +\n\t\t\t\t_key.substring(5, 6);\n\t\t\t_bkey.push(n_key.toUpperCase());\n\t\t}\n\t\t_bkey.push(_key);\n\t\twhile (_bkey.length > 0) {\n\t\t\t_key = _bkey.shift();\n\t\t\tif (_key in _reverse_color_keys) {\n\t\t\t\tif (ref) {\n\t\t\t\t\tref.name = _reverse_color_keys[_key];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n/**\n * \n * @param {vscode.Color} color \n */\nfunction _hex_color(color) {\n\tlet _a = color.alpha != 1 ? parseInt(_clamp(Math.round(color.alpha * 255.0), 255)).toString(16).padStart(2, '0') : \"\";\n\treturn \"#\" + (color.red * 255.0).toString(16).padStart(2, '0') +\n\t\t(color.green * 255.0).toString(16).padStart(2, '0') +\n\t\t(color.blue * 255.0).toString(16).padStart(2, '0') + _a;\n}\nfunction _clamp(v, max) {\n\treturn Math.min(max, Math.max(0, v));\n}\n\nfunction _round_colorf(cl , p=100.0){\n\treturn Math.round(cl * p) / p;\n}\n\n\nclass utils {\n\tstatic LoadProvideDocumentColor(name, vscode) {\n\t\tconst _formatter = Formatters.Load(name);\n\t\tif (!_formatter) {\n\t\t\tthrow new Error('missing formatter ');\n\t\t}\n\t\treturn {\n\t\t\tprovideDocumentColors(document, token) {\n\t\t\t\tconst _text = document.getText();\n\n\t\t\t\tconst _colors_lists = utils.ExtractColors(_formatter, _text);\n\t\t\t\tconst _colors = [];\n\t\t\t\tif (_colors_lists) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_colors_lists.forEach(i => {\n\t\t\t\t\t\t\tlet x = document.positionAt(i.sourceOffset * 1.0);\n\t\t\t\t\t\t\tlet y = document.positionAt(i.sourceOffset + i.value.length);\n\t\t\t\t\t\t\tconst _range = new vscode.Range(x, y);\n\t\t\t\t\t\t\tconst _color = utils.GetColor(i.type == 'webcolor' ? utils.ReverseColor(i.value) : i.value, vscode);\n\t\t\t\t\t\t\tconst _clinfo = new vscode.ColorInformation(_range, _color);\n\t\t\t\t\t\t\t_colors.push(_clinfo);\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tconsole.debug(\"error \", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn _colors;\n\t\t\t}\n\t\t};\n\t}\n\tstatic GetProviderPresentation(id, vscode) {\n\t\treturn {\n\t\t\t/**\n\t\t\t\t * \n\t\t\t\t * @param {vscode.Color} color \n\t\t\t\t * @param {{document: vscode.TextDocument}, range: vscode.Range} context \n\t\t\t\t * @param {vscode.CancellationToken} token \n\t\t\t\t * @returns {vscode.ColorPresentation[]}\n\t\t\t\t */\n\t\t\tprovideColorPresentations(color, context, token) {\n\t\t\t\t// list of presntation color\n\t\t\t\tconst _p = [];\n\t\t\t\tconst cl = { R: 0, G: 0, B: 0, r: 0, g: 0, b: 0, A: 1, a: 1 };\n\t\t\t\tconst _name = { name: '', hexColor: null };\n\t\t\t\tconst _webcl = _is_web_color(color, _name);\n\t\t\t\tif (_webcl) {\n\t\t\t\t\t_p.push(new vscode.ColorPresentation(_name.name));\n\t\t\t\t}\n\t\t\t\t_p.push(new vscode.ColorPresentation(_name.hexColor));\n\t\t\t\tcl.R = (color.red * 255.0);\n\t\t\t\tcl.G = (color.green * 255.0);\n\t\t\t\tcl.B = (color.blue * 255.0);\n\t\t\t\tcl.A = (color.alpha * 100.0);\n\t\t\t\tcl.a = color.alpha;\n\t\t\t\tif (color.alpha == 1)\n\t\t\t\t\t_p.push(new vscode.ColorPresentation(`rgb(${cl.R}, ${cl.G}, ${cl.B})`));\n\t\t\t\t_p.push(new vscode.ColorPresentation(`rgba(${cl.R}, ${cl.G}, ${cl.B}, ${cl.a})`));\n\t\t\t\t_p.push(new vscode.ColorPresentation(`/* {${_round_colorf(color.red)}, ${_round_colorf(color.green)}, ${_round_colorf(color.blue)}, ${_round_colorf(color.alpha)}} */`));\n\t\t\t\treturn _p;\n\t\t\t}\n\t\t};\n\t}\n\tstatic ReverseColor(color) {\n\t\treturn webcolor[color] || \"#000\";\n\t}\n\t/**\n\t * get color utility\n\t * @param {string} hexColor \n\t * @param {*} vscode vscode lib\n\t * @returns \n\t */\n\tstatic GetColor(hexColor, vscode) {\n\t\tlet _red = 0, _green = 0, _blue = 0;\n\t\tlet _alpha = 1;\n\t\tconst _v = hexColor.substring(1);\n\t\tconst _type = hexColor.length - 1;\n\t\tswitch (_type) {\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\t_red = parseInt(_v.substring(0, 1).repeat(2), 16) / 255.0;\n\t\t\t\t_green = parseInt(_v.substring(1, 2).repeat(2), 16) / 255.0;\n\t\t\t\t_blue = parseInt(_v.substring(2, 3).repeat(2), 16) / 255.0;\n\t\t\t\tif (_type == 4) {\n\t\t\t\t\t_alpha = (parseInt(_v.substring(3, 4).repeat(2), 16) / 255.0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t_red = parseInt(_v.substring(0, 2), 16) / 255.0;\n\t\t\t\t_green = parseInt(_v.substring(2, 4), 16) / 255.0;\n\t\t\t\t_blue = parseInt(_v.substring(4, 6), 16) / 255.0;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn new vscode.Color(_red, _green, _blue, _alpha);\n\n\t}\n\n\t/**\n\t * \n\t * @param {*} formatter \n\t * @param {*} src \n\t * @returns \n\t */\n\tstatic ExtractColors(formatter, src) {\n\t\tconst _color_lists = [];\n\t\tconst _listener = {\n\t\t\t/**\n\t\t\t * \n\t\t\t * @param {*} marker \n\t\t\t * @param {*} option \n\t\t\t * @param {*} isSubFormatting \n\t\t\t * @returns \n\t\t\t */\n\t\t\tonEndHandler(marker, option, isSubFormatting = false) {\n\t\t\t\tif (isSubFormatting) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst { tokenID, value, offset, sourceOffset } = Formatters.EndListenerArguments(marker, option);\n\t\t\t\tconst { debug } = option;\n\t\t\t\tswitch (tokenID) {\n\t\t\t\t\tcase 'webcolor':\n\t\t\t\t\tcase 'hexcolor':\n\t\t\t\t\t\tconst _inf = { 'type': tokenID, 'value': value.source, sourceOffset, offset };\n\t\t\t\t\t\t_color_lists.push(_inf);\n\t\t\t\t\t\tdebug && console.log(_inf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tformatter.listener = _listener;\n\t\tformatter.format(src);\n\t\treturn _color_lists;\n\t}\n}\n\nexports.utils = utils;","\"use stricts\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { FormatterCloseParentInfo } = require(\"../lib/FormatterCloseParentInfo\");\nconst _utils = require(\"../lib/Utils\")\n \n\nconst { Patterns, CaptureInfo, Debug } = _utils.Utils.Classes;\n\nfunction InitLine(target, max_line_count) {\n    let _maxLine = (max_line_count + '').length;\n    let _style = 'display:inline-block; text-align:right; margin-right:4px; min-width: ' + _maxLine + 'em;';\n    let _lineCount = 0;\n    target.querySelectorAll('div.line').forEach(i => {\n        let n = document.createElement('div');\n        n.innerHTML = _lineCount + 1;\n        n.style = _style;\n        i.insertBefore(n, i.firstChild);\n        _lineCount++;\n    });\n}\n\nconst classDefinition = {\n    'comment':'comment',\n    'reserved-word':'rs-w',\n};\nfunction getClass(tokenID){\n    if (tokenID in classDefinition){\n        return classDefinition[tokenID];\n    }\n    return tokenID.toLowerCase();\n}\n\nclass ExtraFormatterCloseParentInfo extends FormatterCloseParentInfo{\n    className;\n    tokenID\n    getClass(){\n        return getClass(this.tokenID);\n    }\n}\nclass ExtraPattern extends Patterns{\n    className;\n    _initRef(a){\n        super._initRef(a);\n        if (!a.className && this.className){\n            a.className = this.className;\n        }\n    }\n}\nclass ExtraCapture extends CaptureInfo{\n    className\n    constructor(q){\n        super(q); \n    }\n}\nconst webStyleClass = {\n    patternClassName: ExtraPattern,\n    captureInfoClassName: ExtraCapture,\n    closeParentInfoClassName: ExtraFormatterCloseParentInfo\n};\n\n/**\n * webFormattingListener - \n * @param {*} _def \n * @returns \n */\nfunction webFormattingListener(_def) {\n    _def._maxLineCount = 0;\n    // + | define global map\n    _def.globalClassMap = {\n        'comment':1,\n        'constant':1,\n        'line':1,\n        'number':1,\n        'operator':1,\n        'reserver-word':1,\n        'string':1,\n        'symbol':1\n    };\n    return function () {\n        let blocks = [];\n        let sbuffer = false;\n        let _lineCount = 0;\n        let _self = this;\n        let _r_def = {\n            endOutput({lineFeed}){\n                return '';\n            },\n            endContent(){\n                return \"\";\n            },\n            appendConstant({_inf, update, data, patternInfo}){\n                if (data.trim().length == 0){\n                    if (patternInfo.isBlock && (patternInfo.childs.length==0))\n                    return;\n                } \n                update(); \n            }, \n            renderToken(v, tokens, tokenID, engine, debug, marker) {                \n                debug && Debug.log('renderToken', {value:v, tokenID, tokens: tokens.slice(0)})\n                if (v.length==0){\n                    return '';\n                }\n                let lt = tokens.shift();\n                let n = null;\n                let _clname = '';\n                let _map = {};\n                if (tokenID) {\n                    _map[tokenID] = 1;\n                    _def.globalClassMap[tokenID] = 1;\n                }\n                if (marker?.className){\n                    marker.className.split(' ').forEach(a=>{\n                       if(a.trim().length==0)return;\n                        _map[a]=1;\n                        if (!(a in _def.globalClassMap))\n                            _def.globalClassMap[a] = 2;\n                    });\n                }\n                if (/^symbol\\./.test(lt)) {\n                    v = v.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\n                    _map['s']=1;\n                    _map['symbol']=1; \n                }\n                if (/^constant\\.color/.test(lt)){\n                    v = \"<div class=\\\"inline-color\\\" style=\\\"display:inline-block; margin: 0 4px; background-color:\"+v+\"; width:8px; height:8px;\\\"></div>\"+v;\n                }\n                _clname = Object.keys(_map).join(' ');\n                if (_clname.length==0){\n                    return v;\n                }\n                    if (typeof(document) != 'undefined'){\n                    n = document.createElement('span');\n                    n.className = _clname;\n                    n.innerHTML = v;\n                    \n                    return n.outerHTML;\n                    } else {\n                        if (_clname.length>0){\n                            _clname = \" class=\\\"\"+_clname+\"\\\"\";\n                        }\n                        let sb = '<span'+_clname+'>'+v+'</span>';\n                        return sb;\n                    }  \n            },\n            newLine(){\n                console.log('bind:newLine');\n            },\n            appendExtraOutput({output}){ \n                // + | just push and extra value to join on render\n                output.push('');\n            },\n            treatOutput({output, lineFeed, tabStop}){\n                const l = [];\n\n                output.forEach((m)=>{\n                    m.split(\"\\n\").forEach(_l=>{\n                        //if (_l.length==0) return; // \n                        _l = \"<div class=\\\"line\\\">\"+_l;\n                        _l+= \"</div>\";\n                        l.push(_l);\n                        _def._maxLineCount++;\n                    });\n                });\n                return l.join(lineFeed).trimEnd();\n            },\n            output({ buffer, output, lineFeed, flush, _ctx }){    \n                let l = '';\n                //if (output.length>0)\n                    l =  output.join(lineFeed);\n\n                return l;\n            },\n            /**\n             * store what is in the buffer to output\n             * @param {*} param0 \n             */\n            store({ output, buffer, depth, tabStop, formatterBuffer }) {\n                \n                const store_buffer = function(buffer){\n                    if (buffer.length==0){\n                        return;\n                    }\n                    if (depth > 0) {\n                        buffer = '<span>' + (\"&nbsp;\".repeat(4)).repeat(depth) + '</span>' + buffer;\n                    } else { \n                        buffer = buffer; \n                    } \n                    output.push(buffer);\n                }\n                const r = [buffer]; \n                r.forEach(store_buffer); \n            },\n            startNewBlock(a) {\n                // start new block\n            }\n        };\n        Object.defineProperty(_def, 'bufferList', {get(){\n            return _buffers;\n        }});\n        return _r_def;\n    }\n}\nexports.webStyleClass = webStyleClass;\nexports.InitLine = InitLine;\nexports.webFormattingListener = webFormattingListener;","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3497);\n"],"names":["object","stringifiable","forOf","module","exports","text","style","result","char","getFn","d","assign","forEach","map","primitiveSet","setPrototypeOf","memoize","memoizeMethods","sgr","supportsColor","mods","join","Array","prototype","defineProperty","Object","max","Math","min","variantModes","xtermMatch","process","platform","memoized","scope","mod","_cliColorData","proto","create","Function","gs","this","xterm","code","isNaN","_fg","bgXterm","_bg","getEndRe","RegExp","primitive","self","start","end","msg","call","arguments","conf","hasAnsi","hasCSI","key","replace","isColorSupported","defineProperties","xtermSupported","generate","from","iterable","isValue","repeat","getStrippedLength","push","inputRows","options","colsMeta","colsOptions","columns","rows","row","rowRows","cellStr","columnIndex","cellRows","split","length","cellRow","rowRowIndex","apply","str","index","strLength","col","width","item","pad","align","colOptions","sep","screen","screenLeft","screenRight","line","lineLeft","lineRight","strip","windowSize","erase","move","beep","slice","throbber","reset","art","includes","forOwn","onlyKey","forEachRight","uniq","CSI","bold","_bold","italic","_italic","underline","_underline","blink","_blink","inverse","_inverse","strike","_strike","reduce","obj","color","toUpperCase","openers","closers","modPair","openStyle","openedMods","closeStyle","splice","prepend","currentMods","complete","closerCodes","reverse","extractCode","csi","Number","state","enableColor","disableColor","autoDetectSupport","env","NO_COLOR","colors","match","i","abs","r","parseInt","g","b","data","diff","Infinity","every","innerMatch","currentIndex","ndiff","currentDiff","channel","up","down","right","left","trunc","floor","getMove","control","num","x","y","to","lines","n","dir","top","bottom","lineBegin","lineEnd","reAnsi","Token","token","tokenize","exec","head","prehead","tail","concat","seq","len","begin","sliced","chunk","preOpeners","inOpeners","inClosers","nextChunk","isChunkInSlice","relBegin","relEnd","sliceSeq","ThrobberIterator","compose","callable","validTimeout","running","next","chars","write","interval","format","iterator","undefined","setInterval","restart","stop","clearInterval","stdout","height","define","ensureValue","ensurePlainFunction","copy","normalizeOptions","bind","hasOwnProperty","name","desc","dgs","value","writable","get","overwriteDefinition","resolveContext","props","isPlainFunction","normalizeOpts","contains","dscr","c","e","w","configurable","enumerable","set","getOwnPropertyDescriptor","getPrototypeOf","cacheDesc","cacheName","resolvable","flat","Boolean","ownDesc","base","TypeError","numberIsNaN","toPosInt","indexOf","objHasOwnProperty","searchElement","fromIndex","val","cb","thisArg","isFirst","filter","arr","iteratorSymbol","isArguments","isFunction","validValue","isString","isArray","arrayLike","Context","j","getIterator","mapFn","done","charCodeAt","currentLength","isObject","captureStackTrace","Error","message","err","ext","aFrom","callFn","arg","fn","fnIgnored","fns","first","args","argIgnored","mixin","cache","test","arg1","arg2","ignore","toString","src","target","objToString","id","isFunctionStringTag","isArrayLike","is","sign","NaN","isFinite","toInteger","keys","objPropertyIsEnumerable","propertyIsEnumerable","method","defVal","list","compareFn","sort","foo","bar","trzy","dest","error","propertyNames","propertyName","ensure","shim","nullObject","polyProps","level","getOwnPropertyNames","function","_undefined","targetObj","getOwnPropertySymbols","source","sourceObject","symbol","opts1","plainObject","validate","status","objIsPrototypeOf","isPrototypeOf","nullDesc","tmpObj1","tmpObj2","__proto__","isNullBase","nullPolyfill","isCallable","String","searchString","count","RangeError","safeToString","reNewLine","string","JSON","stringify","ArrayIterator","Symbol","Iterator","kind","constructor","_resolve","__kind__","__list__","toStringTag","some","mode","doBreak","broken","StringIterator","clear","autoBind","context","__context__","__nextIndex__","on","_onAdd","_onDelete","_onClear","_next","__redo__","shift","_unBind","_createResult","off","redo","__length__","isIterable","global","validTypes","toPrimitive","objPrototype","created","ie11BugWorkaround","postfix","NativeSymbol","SymbolPolyfill","hasInstance","isConcatSpreadable","search","species","unscopables","validateSymbol","registry","for","keyFor","HiddenSymbol","isNativeSafe","generateName","setupStandardSymbols","setupSymbolRegistry","description","__description__","__name__","valueOf","isSymbol","once","emit","methods","descriptors","descriptor","type","listener","__eeOnceListener__","__ee__","listeners","candidate","l","o","naiveFallback","window","__global__","globalThis","isPromise","then","limit","del","size","queue","hit","oldIndex","nuIndex","delete","objectMap","defineLength","nextTick","tbi","currentCallback","currentContext","currentArgs","waiting","original","last","origCb","has","oldCache","extensions","dispose","async","promise","resultArray","timeout","noop","maxAge","timeouts","preFetchAge","preFetchTimeouts","setTimeout","unref","clearTimeout","preFetch","toPosInteger","lruQueue","ensureString","toShortString","supportedModes","promises","isFailed","onSuccess","onFailure","resolvedMode","nextTickFailure","finally","refCounter","deleteRef","getRefCount","resolveLength","plain","normalizer","customError","ee","resolveResolve","resolveNormalize","memLength","extDel","extGet","extHas","getListeners","setListeners","deleteListeners","resolve","resolvers","profileName","updateEnv","__memoized__","_get","_has","lazy","getNormalizer","optsLength","fnLength","isAsync","userNormalizer","resolveArgs","toArray","lastId","argsMap","path","pop","configure","force","extFn","__profiler__","ensureCallable","byObserver","Observer","currentQueue","node","document","createTextNode","callback","observe","characterData","queueMicrotask","MutationObserver","WebKitMutationObserver","setImmediate","maxTimeout","isPrototype","stringCoerce","errorMessage","inputOptions","valueInsertIndex","valueToken","firstToken","secondToken","firstInsertIndex","secondInsertIndex","nameInsertIndex","resolveErrorMessage","defaultMessage","isOptional","errorCode","error2","possibleTypes","resolveException","classRe","functionToString","objectToString","valueToString","vscode","cli","TransformEngine","utils","Formatters","completion","Register","sm_FORMATTERS","_formatter","GetFormatter","Load","console","log","formatAllDocument","_text","getText","_range","Range","lineAt","range","lineCount","_res","TextEdit","red","activate","languageFormatter","Map","a","p","languages","registerDocumentFormattingEditProvider","provideDocumentFormattingEdits","subscriptions","commands","_commands","_key","_fc","registerCommand","_clprofiles","LoadProvideDocumentColor","provideDocumentColors","_colors_lists","ExtractColors","_colors","positionAt","sourceOffset","_color","GetColor","ReverseColor","_clinfo","ColorInformation","ex","debug","_provider","provideColorPresentations","GetProviderPresentation","registerColorProvider","scheme","language","registerCompletionItemProvider","provideCompletionItems","position","_provide_items","_item","CompletionItem","commitCharacters","documentation","MarkdownString","insertText","CompletionItemKind","Module","GetProvideList","bcss","colorList","rootList","li","_m","Property","deactivate","Utils","Patterns","CaptureInfo","Classes","Version","Web","webpackContext","req","webpackContextResolve","__webpack_require__","BlockInfo","tokenID","patterns","transform","comment","replaceWith","nextTrimWhiteSpace","captures","throwError","parent","json_parse","parser","fieldname","refKey","refObj","q","RefPatterns","ArrayPatternsFromParser","_regex_parser","s","RegexParse","parse","replaceWithCondition","m","ReplaceWithCondition","JSonParser","_LoadData","TransformPropertyCallback","JSONInitCaptureField","matchTransform","fc","FormatterMatchTreatment","FormatterOptions","FormatterSyntaxException","CaptureRenderer","matches","roots","subcaptures","CreateFromGroup","_info","_t","indices","lp","_startIndex","rootgroup","_troot","_offset","chain_root","begin_root","idx","v","def_info","info_contains","childs","_minfo","get_matche_token_info","_o","render","tokens","option","outdefine","treat","engine","_input","_begin","_output","formatter","treat_root","root","refData","rf","rd","subchilds","output","sub","_end","childrens","unshift","croot","cap","nv","offset","_out","substring","dt","_treat_pattern","_op","Init","e_obj","CheckError","StoreTokens","treatMarkerValue","StringValueTransform","_bckTokens","tokenList","TreatPatternValue","renderToken","treat_constant","_keys","_Capkeys","_root_only","_ref_data","input","bufferSegment","dataSegment","rt","_error","CssAtLayerDefinition","styles","toJSON","CssAtRuleProperty","syntax","inherits","initialValue","CssCounterStyle","system","symbols","negative","prefix","suffix","fallback","speakAs","additiveSymbols","CssFontFaceStyle","ascentOverride","descentOverride","fontDisplay","fontFamily","fontStretch","fontStyle","fontWeight","fontFeatureSettings","fontVariationSettings","lineGapOverride","sizeAdjust","unicodeRange","CssImports","_list","url","toRender","store","layer","supports","queries","CssStyle","CssLayerStyle","properties","AppendDef","css","def","CssStyleRenderer","CssStyleDefinitions","charset","frames","colorProfile","imports","container","counterStyle","fontFace","fontFeatureValues","fontPaletteValues","namespace","page","property","startingStyle","m_media","ref","medias","lt","_glueStyle","res","renderMedias","initMedia","profileNames","_multi_def","_glueStyles","filter_sub","_set_join","f","pretty","minify","objKeys","_f","_k","toLowerCase","RenderRule","_n","_refObj","space","_filter_sub","_render_colorprofile","_render_container","_render_property","_render_scope","_render_layer","_render_layer_child","_get_inner_layer","_copy","_childs","_s","k","_render_counterstyles","cp","_v","_render_fontface","_render_in_def","_render_fontfeaturevalues","_render_def","_render_fontpalettevalues","_render_imports","cd","_render_namespace","_render_pages","_render_startingstyle","_render_supports","trim","_render_viewtransition","renderer","glueStyles","FormatterListener","json_data","CreateFrom","_baseFormatterListener","methodSuffixName","CssStyles","SelectorDefinition","definitions","mergeDefinitions","styleStore","initDefinition","_init_style","getStylesDefinition","update","_regex","_loadSeparator","_mergeFromDefinition","_mergeDefinition","_mergeDefinitionComplete","_tab","_tdef","pdef","_index","_get_definition","getMediasDefinition","rule","tab","CssSelectorStyles","CssTransformer","ToJSON","_css_definition","_selectorDefinition","_debug","callBacks","_updateMediaDefinition","_updatePropertyDefinition","_get_frames","frame","_listener","medias_definition","media_states","ref_mode","_auto","_frame_info","onStartHandler","marker","_mode","_mfc","_handleColorprofile","_handle","handle","_initSelectorDefinition","_resetSelectorDefinition","_handleKeyframes","_handleKeyentry","_name","_handleMedia","_condition","condition","_src","_handleCharset_value","_onStartContainer","objDef","inf","_ref","_onStartAtRuleProperty","_handleAtRuleProperty","_onStartScope","selector","_closeAutoHandle","_handleScope","_h","_obj","_value","_id","get_scope_id","_def","_popMode","_handleLayer","_store_style","names","_p","_pdef","_onStartLayer","_parent","_ndef","_handleContainer","_container_name","get_container_id","onEndHandler","isSubFormatting","tokenChains","buffer","_onStartCounterStyle","_handleCounterStyle","counterStyles","_onStartFontFace","_handleFontFace","_onStartFontFeatureValues","ident","_handleFontFeatureValues","_onStartFontPaletteValues","_handleFontPaletteValues","_onStartImport","_handleImport","_onStartNamespace","_handleNamespace","_onStartPage","pages","_handlePage","_inf","_onStartStartingStyle","current","_handleStartingStyle","_onStartSupports","storage","_handleSupports","_g","_onStartViewTransition","viewTransition","_handleViewTransition","_initListener","_format","Debug","static","IsEnabled","LogLevel","Enable","enable","bhtml","isAutoCloseTag","autoCloseTagValue","_lastData","_lastBuffer","_load_data","_cp","_captures","endCaptures","_is_closed","_close_tag","_is_auto_closed","CreateEndMatch","tp","treatEndCaptures","RenderToBuffer","_isChildBlock","saveBuffer","appendExtraOutput","_rbuffer","flush","restoreSavedBuffer","IsChildBlock","engines","Joiner","FormatterBuffer","m_output","m_bufferSegments","m_dataSegments","m_dataOutput","marked","InitMarkedSegment","isEmpty","bufferSegments","InitBufferMarkedSegment","CopyMarkedSegment","op","InitOpMarkedSegment","dataSegments","getContent","getData","joinSegments","JoinSegments","_bufferS","_dataS","_OP","_call","t","_marked","_idx","UpdateSegmentMarkerOperation","appendToBuffer","appendToData","_joinWith","storeToBuffer","lastDefineStates","_buffer","_data","ClearSegments","ReduceBufferSegmentIndex","TS","_new_idx","FormatterSegmentJoin","updateData","clearOutput","dataOutput","clearAll","trimEnd","segment","trimStart","lastSegment","lastDataSegment","lastSegmentInfo","GetBufferMarkedOperation","FormatterSegmentInfo","replaceLastSegment","newValue","TreatMarkedSegments","bufferData","TrimBufferSegment","ReorderBufferSegment","elt","FormatterBufferUtils","TreatValue","FormatterCloseParentInfo","FormatterDebugger","all","feature","DebugAll","DEBUG_ALL","top_keys","ENGINES","REF","FormatterEndMissingEngine","Get","scopeName","FormatterEndMissingExpression","expression","load","group","_e","_ret","_args","FormatterErrors","RegexUtils","FormatterLineMatcher","MATCHER_STATES","save","new_value","sourceLine","restore","startLine","subLine","nextLine","_np","setPosition","check","regex","_has_movement","HasBackyardMovementCapture","_has_startLine","CheckRequestStartLine","_mark","new_s","FormatterLineSegment","super","m_states","mps","isCapturing","FormatterLintError","m_lastToken","setLastMarker","appendLine","line_feed","_cbuffer","startNewBlock","formatterBuffer","tabStop","depth","endOutput","lineFeed","endContent","startBlock","FormatterToken","lastToken","FormatterMarkerInfo","oldBlockStart","blockStarted","useEntry","captureEntry","joinWith","prependExtra","storePrependExtra","updateDataSegments","ic","_new_id","_marker","entry","_endRegex","isBlock","m_currentMode","_marker_info","_content","_isNew","oldValue","saveState","currentBufferContent","treatment","PatternMatchInfo","lineOffset","continue","lineJoin","skipTreatEnd","skipTreatWhile","markerDepth","loopInfo","lastMarker","sourceOption","EOF","EOL","TOEND","lineFeedFlag","stream","newOldBuffers","holdBufferState","glueValue","skipEmptyMatchValue","skipUpdateStartLine","skipMarkerFlag","nextMode","skipEndOfLine","startReading","matchTransformFlag","lastEmptyMarkerPattern","nextGlueValue","lineSegments","pushConditionalContainer","conditionalContainer","isBlockConditionalContainer","popConditionalContainer","isConditionalBlockStart","topConditionalBlockContainer","_formatterBuffer","m_constants_def","_rg","c_lineMatcher","c_conditionalContainer","info","m_isCapturing","m_depth","_blockStarted","_bufferState","_markerInfo","_states","m_appendToBufferListener","_outputBufferInfo","updateLine","updateRange","m_saveCount","m_formatterListener","empty","is_emptyObj","_renderCaptures","_bck","resetRange","storeRange","isRootFormatterBuffer","formatter_buffer","pos","_tokens","getTokens","getLineRangeContent","unshiftMarker","shiftMarker","pushState","_state","_i","popState","updateBufferValue","joinBuffer","noSpaceJoin","raise","_def_value","treatValueBeforeStoreToBuffer","markedInfo","_storeBuffer","onAppendToBuffer","useGlue","_cm_value","isGlueValue","isSpecialMarker","shiftIdConstant","_shiftMarkerInfo","isShiftenName","fromGroup","getTokenID","treatBeginCaptures","patternInfo","_outdefine","_cap","BeginCaptures","startOutput","markerInfo","endMatch","fc_handle_end","endOuput","treatCaptures","markers","prop","pushError","NameOnlyConstantPattern","moveTo","newPosition","newOffset","lineMatcher","restoreBuffer","newBuffer","_ctx","refdata","buffers","settings","treatAndFormat","sourcePattern","_cpos","streamFormatter","_gbuffer","loopStart","matcher","transformMarker","_resetFlags","cleanNewOldBuffers","tq","bf","setSourceLine","onBeginEndFound","_old","onBeginWhileFound","shiftAndRestoreFrom","shiftFromMarkerInfo","_rdata","startLineReading","storeAndUpdateBuffer","getBufferContent","_cm","peekFirstMarkerInfo","storeToOutput","useDepth","peekMarkerInfo","AppendExtraLiveOutput","flushAndData","_refData","bufferSegmentState","bufferState","constantPattern","_c","constantName","constants","refConstantClass","GlobalConstant","FormatterPatternException","pattern","isMarked","UpdateSegmentData","segments","joiner","_length","_d","element","_ts","FormattingCodeStyles","FormattingBase","FormatterSetting","blockOnSingleLine","codingStyle","K_R","useIndent","instructionSeparator","useCurrentFormatterInstance","transformEngine","endMatchLogic","Support","CreateEngine","getCodingStyleFormatting","Factory","isInstructionSeperator","ch","SpecialMeaningPatternBase","FormattingMode","FormatterStreamBuffer","initialMode","startPosition","started","closed","endFoundListener","sourceMarkerInfo","sourceTokenList","matchType","m_saved","saved","formatting","joinStreamBuffer","newLineContinueState","throwErrorOnEndSyntax","isEndCaptureOnly","isWhileCaptureOnly","isBeginCaptureOnly","endRegex","stopAndExitStream","_restoreState","_line","ret","bck","_onEndHandler","moveToNextPattern","handleMarkerListener","_restored","_topStreamRemoved","_restoreSavedBuffer","_nbuffer","appendToBufferListener","_restoreBackupState","parentMode","FM_APPEND","_matcher","detectPatternInfo","endFound","HandleStreamEndFound","_stream_old","_updateMarkerOldContentOrSwapBuffer","handleMatchLogic","handleConstant","skipFormat","next_position","_tline","hostPatterns","streamAction","_patterns","GetPatternsList","GetPatternMatcherInfoFromLine","_rindex","_append","StreamLineConstant","_nextCapture","_next_position","GetNextCapture","_sline","_gline","GetBufferedLine","StreamBufferConstant","_src_line","_group","streamCaptures","TreatCapture","At","isRendered","NativeRegExp","HandleFormatting","formattingSetupPatternForBuffer","sm_globalEngine","sm_engine_formatter","lintErrors","repository","injectionSelector","foldingStartMarker","foldingStopMarker","fileTypes","uuid","firstLineMatch","EngineFormatter","GlobalEngine","EndListenerArguments","objClass","m_listener","m_objClass","m_info","captureGroup","m_errors","_storeObjClass","_skip","blockStart","m_option","json_keys","json_validate","field_name","throw_on_error","validator","_pattern_class","patternClassName","_lints","lint","fix","concept","initialize","repositoryKey","pattern_class_name","_names","_registryExpression","Save","JSonParseData","registerName","_funcRegistryExpression","_entry","DefineProp","namespaces","Restore","CreateDefaultOption","PrevLineFeedConstant","PrevLineFeedConstantPattern","PrevConstant","PrevConstantPattern","GlobalConstantPattern","StreamLineConstantPattern","StreamBufferConstantPattern","TrimmedPrevLineFeedConstant","RefConstantPattern","transformTo","_initDebug","_matcherInfo","_trimStart","_trimEndOutput","trimmed","endsWith","_output_fc","_update_start_line_flag","_start_line_flag","_l","_is_sub_formatting","_nextLineOffset","skip_r","allowMultiline","_handleMarker","_nextLine","_nextPosOffset","ln","_updateLineFeed","_lastPost","GetPatternMatcher","isCaptureToEndLine","_handleCheckCloseMarker","_updateMarkerFormatting","updateEndLineUpdateMode","_formatting","_handleLastExpectedBlock","treatOutput","isStreamCapture","_startStreamingPattern","_handleSameGroupMatch","_checkStartBlockDefinition","formattingMode","formatBufferMarker","_updateNextMode","updateBuffedValueAsToken","_lastExpectedMatchResult","endMissingValue","_cvalue","ReplaceRegexGroup","RegExToString","content","onLastExpectedBlockStart","onLastExpectedBlock","_handleFoundEndPattern","_ln","_isBlockAndStart","_startBlock","getMarkerCaptures","beginCaptures","_registerTokenName","_updatePrevPatternPrevConstant","_updatePatternPrevConstant","_handleCallback","_updateFormatModeFromTo","_operationReplaceWith","replaced","_rpw","_cond","operator","_ex","DoReplaceWith","tvalue","ReplaceWithCheck","handleBeginEndMarker","_handleBeginEndMarker","handleMatchMarker","_handleMatchMarker","handleBeginWhile","_handleBeginWhile","handleMatchTransform","_handleMatchTransform","_onStartMarker","isShiftenContentName","_shiftPatternContentName","UnshiftTokens","_treatMatchValue","_ref_segment","_getMatchGroup","treated","_treatMatchResult","_treatTransform","_tmatch","transformMatch","transformCaptures","_operateOnFramebuffer","_handleToEndPattern","_treat","startLineTransform","treatEndMarkerValue","_appendConstant","append_child","constant_type_marker","_fempty","_def_type","treatConstantValue","use","fc_update","updateBufferConstant","appendConstant","end_line","_nextOffset","_createStreamConstantPattern","_startLine","_start_block","isBlockStarted","blockStartInfo","_oldMarker","_updateStreamRangeModeToHolder","oldStartStreamingBlock","select","_updateOldMarkerContent","_endpos","_bool","_constant_line","_handleInstructionSeperatorProperty","isInstructionSeparator","_handleMatchCaptureDefinition","allowEmptySpace","isMatchCaptureOnly","onEndInstruction","endGroup","_closeBlockEntry","closeParentData","closeParent","_closeMarker","appendJoinToBuffer","JoinMarkerPattern","_storeToBuffer","UpdateMarkedSegment","_storeMatchValueHandler","_extra","_skip_value","_is_join","_store_to_buffer","_updateJoinWith","storeValue","_handleChainHandler","_chains_match","_e_args","_target","_cparent","_extra_args","udpateChild","_updateMarkerChild","_updateOldEntryCapture","EntryCapturePattern","_checkParentInfo","_endCaptureCallback","_handle_EOL","_invokeCheckParent","_handleStopMarker","_justCloseMarker","_fake_empty","_option_glue","skipGlueOnLineEnd","isEOL","_handleCheckParentInfo","_handleCloseParentProperty","updateMatchNextFormatting","_told","_lbuffer","contentName","_unshiftPatternContentName","_updateBlockMarkerPropertyContent","_entryBuffer","entryBuffer","_new_v","startsWith","_count","_initUpdatedisBlockStartInformation","_initBlockStarting","isFormattingStartBlockElement","_start","_startOutput","_fstartOutput","_updateParentProps","updateStartFormatting","startData","_eol","_nextPos","_close_data","_pos","_handleItemFoundCallback","isStartOnly","HandleSameGroup","_closeMarkerByStop","_parentNextMode","parentMatcherInfo","_call_update_regex","sourceRegex","RegexToStringRegex","RemoveCaptureAndLeaveMovementCapture","_pline","checkMoveEndRegex","_prev","requestParentBlockCondition","_isEmptyRequestBlock","_updateBuffer","_trimOutput","_skipOffset","newLine","isAutoBlockElement","_requestUpdateChild","_gparent","_closeMarkerAndUpdate","_r","updateEmptySkipMatchedValueFormatting","closeMarker","_type","TypeMarkerInfoPattern","registryClassName","_isSkipTreatEnd","fromChild","_closeNonCaptureBlock","_resolvFoundData","c_data","_next_offset","_b","updatePreprendExtra","extra","_saved","_empty","__b","_close_block","onEndUpdateBuffer","handleEndFormattingBeforeStore","handleEndFormattingOnNonStartBlockElement","handleEndOnNonBlockElement","_nextBuffer","updateParentProps","_updatePreservedBlockBuffer","updateEndBlockAfterRestoringBuffer","_buffState","updateNextSavedMode","fallbackMarker","_parentInfo","_up","_endFound","updateGlobalFormatting","_nextPosition","_bckLine","_bckLineOffset","_end_non_capture","_ret_marker","_offsetPosition","_is_match","_tcline","_toffset","_supportCapture","_empty_capture","HasMovementCapture","_tchilds","child","_block","_backupMarkerSwapBuffer","_restoreBuffer","_u_content","isCaptureOnly","currentMode","appendMode","autoStartLine","_buffer_data","isEntryContent","_joinwith","updateOldMarkerContent","_handleSameGroup2","updatedProperties","_checkUpdatedStartBlockProperties","detectConstantPattern","_nPatternInfo","_createStreamBuffer","_stream_buffer","init","startBlockDefinition","_newOld","itemFound","_continue_with_marker","append","appendBufferAndLine","sb","isSpecial","SystemConstantPattern","GetMarkedInfo","markedSegment","SYSTEM_MATCH_TYPE","_mkeys","_diff","PatterMatchErrorInfo","PSR_2","PSR_21","PSR_12","ALLMAN","GetSupportedValues","CODE_STYLE_FORMATTERS","trimConstant","_option","FM_START_LINE","FM_END_BLOCK","FM_START_BLOCK","FM_END_INSTRUCTION","FM_START_LINE_APPEND","updataMarkerGlobalOption","FM_START_LINE_NEXT_LINE","FM_APPEND_BLOCK","PatternFormattingMode","PFM_APPEND_THEN_LINE_FEED","_gformatting","PFM_LINE_FEED","updateMergeEndBlock","_hasBuffer","_hasExtra","_buffer_is_empty","_updateFormatterBufferSegments","_ld","_props","_append_next_mode","_updateLd","_updateSegment","_updateBufferedData","_treat_buffer_data","_treat_buffer_data_fc","formattingOptions","trimmedContainer","_flushData","_treatOldMarkerContent","FM_APPEND_TO_NEXT","FM_END_LINE","onAppendBlock","_updateGlobalMarkerOptionDefinition","extraOutput","isLineFeed","canChangeNextFormatting","handleEndFound","cname","Library2","Library","handleEndBlockBuffer","_sbuffer","marker_info","_lf","_build_lf","onHandleSingleLineBuffer","_mark_buffer","_next_old","_parentMarker","_prepend","formattingPrependExtra","_prepend_value","_emode","isStartLine","updateBlockMarkerPropertyMode","old","isCurrentFormatterBufferIsRootBuffer","_cf","handleBufferingNextToSbuffer","formatJoinFirstEntry","formatHandleExtraOutput","KAndRFormatting","PFM_LINE_JOIN_END","PFM_LINE_JOIN","PFM_STREAMING","PFM_LINE_FEED_IF_IS_UPDATED_BLOCK","StreamActions","PARENT","NEXT","ALLOW_WHITE_SPACE","mergeEndBlock","sd","_bbuffer","_bdata","_clean","_c_mode","isUpdatedBlock","update_line_feed","throwOnError","captureInfoClassName","m_current","_throwOnError","validation","json_parsing","globalRegExp","NATIVE_EXEC","_fn","NATIVE_TEST","PatternFormattingOptions","trimContainer","formattingBlockListener","isMarkedSegments","isTrimmedSegment","CheckRequestEndLine","m_parent","m_marker","m_endRegex","m_group","m_line","m_isBlock","m_lineFeed","m_startOutput","m_endOutput","m_updatedProperties","m_isBlockStared","m_bufferMode","m_patterns","m_fromGroup","m_index","m_state","types","_keys_t","isPatternsOnly","RegexEngine","lintError","cardinality","while","whileCaptures","emptyBlockCondition","preserveLineFeed","beginFormattingMode","applyEndPatternLast","debugName","skip","m_startOnly","IsSkipped","RegexParser","_capture_parser","_gcl","closeParentInfoClassName","SKIP_REGEX","_rt","$ref","objOrBool","_while","IsCapturedOnlyRegex","_initRef","getEntryRegex","GetMatchInfo","_match","_a","matchRegex","lastIndexOf","flag","GetRegexFrom","endWhile","class_type","_reg","_store","_clear","_changeType","_flag","ind","moption","RegexInfo","_ss","_is_extended","lit","_gt","_pre_exec","_ms","ReadBrank","_engine","_q","_gret","CAPTURE_MOVEMENT","CAPTURE_NOT_AHEAD_BACKYARD","CAPTURE_LEAVE_AHEAD_BACKYARD","is_empty","RemoveNotAheadBackyardGroup","RemoveCapture","_TreatCaptureGroup","beginOnly","_potion","sp","groups","active","disable","reg","Stringify","rm_brank","start_index","escaped","capture","_stpos","UnsetCapture","JSonParse","string_test","JSonValidate","_REGISTRY","func_or_class_name","CleareRegistry","Create","_tlist","_dir","_top","_trim","isTrimmed","_ni","_buff","ri","EndCaptures","JSON_REGEX_PARSER","_cm_data","DefineProperties","FunctionDefineArg","globalname","_last","ArrayParser","class_name","LoadData","refkey_class_name","include","_extends","extends","CheckSkip","_flags","conditionBlockStart","_SkipLine","_from","_position","_tloop","_m_patterns","_mpatterns","item_index","hasParent","isRef","detectOn","isFromGroupRef","InitPatternMatchInfo","gp","RegexParseInfo","_func","captialize","tb","charAt","joinSpace","upperCase","lowerCase","rtrim","ltrim","padEnd","padStart","replace_with","_rp","_in","_caps","out","_bckCapture","_info_class","action","activeTextEditor","uri","json","workspace","openTextDocument","showTextDocument","c_formatter","_colorList","_rootList","__namespace","webcolor","_reverse_color_keys","_round_colorf","cl","round","R","G","B","A","hexColor","alpha","green","blue","_hex_color","_bkey","n_key","_is_web_color","ColorPresentation","_red","_green","_blue","_alpha","Color","_color_lists","_utils","classDefinition","webStyleClass","className","getClass","InitLine","max_line_count","_style","_lineCount","querySelectorAll","createElement","innerHTML","insertBefore","firstChild","webFormattingListener","_maxLineCount","globalClassMap","_r_def","_clname","_map","outerHTML","_buffers","require","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","__webpack_exports__"],"sourceRoot":""}