{"version":3,"file":"bformatter.js","mappings":"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","sources":["webpack://balafon-formatters/./src/lib/Debug.js","webpack://balafon-formatters/./src/lib/FormatterListener.js","webpack://balafon-formatters/./src/lib/FormatterSetting.js","webpack://balafon-formatters/./src/lib/Formatters.js","webpack://balafon-formatters/./src/lib/JSonParser.js","webpack://balafon-formatters/./src/lib/PatternMatchInfo.js","webpack://balafon-formatters/./src/lib/Patterns.js","webpack://balafon-formatters/./src/lib/RefPatterns.js","webpack://balafon-formatters/./src/lib/ReplaceWithCondition.js","webpack://balafon-formatters/./src/lib/Utils.js","webpack://balafon-formatters/webpack/bootstrap","webpack://balafon-formatters/./src/main.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst LOG_NAME = '[igk-formatters]'\nclass Debug{\n    static LogLevel = 3;\n    static #Enabled = false;\n    \n    static get IsEnabled(){\n        return Debug.#Enabled;\n    }\n    static log(msg, level){\n        if (level){\n            if (level < Debug.LogLevel){\n                return;\n            }\n        }\n        if (typeof(msg)=='object'){\n            msg = JSON.stringify(msg, (k, v)=>{\n                if (k.length==0){\n                    return v;\n                }\n                if (typeof(v)=='object'){\n                    return {};//'[object]';\n                }\n                if (typeof(v)=='array'){\n                    return [];//'[array]';\n                }\n                return v;\n            });\n        }\n        let args = [];\n        if (arguments){\n            for(let i = 1; i < arguments.length; i++){\n                args.push(arguments[i]);\n            }\n        }\n        console.log(`${LOG_NAME} - ${msg}`, ...args);\n    }\n    /**\n     * enable debug globally\n     * @param {?bool} enable \n     */\n    static Enable(enable){\n        Debug.#Enabled = enable;\n    }\n}\n\nexports.Debug = Debug;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\nconst { Debug } = require(\"./Debug\");\nconst { Patterns } = require(\"./Patterns\");\nconst { Utils } = require(\"./Utils\");\nclass FormatterListener { \n    objClass = null;\n    \n    /**\n     * object to treat be data before adding it to buffer \n     */\n    treatBuffer;\n\n    constructor() {\n        var m_lastToken;\n        /**\n         * get last evaluated marker\n         */\n        Object.defineProperty(this, 'lastMarker', { get() { return m_lastToken } });\n\n        this.setLastMarker = function (token) {\n            m_lastToken = token;\n        };\n    }\n    /**\n     * call to add a new block\n     */\n    startNewBlock(marker){ \n        const o = this.objClass;\n        if (!o) return;\n        let d = o.depth\n        o.output.length = 0;\n        o.output.push('');\n        o.output.push(o.tabStop.repeat(d));\n    }\n    /**\n     * treat buffer before send and matching\n     * @param {*} _marker \n     * @param {*} p \n     * @param {*} endRegex \n     * @param {*} buffer \n     * @returns \n     */\n    treatEndBufferCapture(_marker, p, endRegex, buffer){\n        const { endCaptures } = _marker;\n        if (endCaptures){\n            for(let i in endCaptures){\n                let _def = _marker.endCaptures[i];\n                if ((i==0) && _def.nextTrimWhiteSpace){\n                    buffer = buffer.trimEnd();\n                } \n            }\n        }\n        return buffer;\n    }\n\n    treatEndCapture(_marker, p, endRegex){\n        const { endCaptures } = _marker;\n        if (endCaptures){\n            for(let i in endCaptures){\n                let _def = _marker.endCaptures[i]; \n                if (_def.nextTrimWhiteSpace){\n                    this.objClass.buffer = this.objClass.buffer.trimEnd();\n                }\n            }\n        }\n        return p;\n    }\n    treatBeginCapture(_marker, p){\n        // To Treat capture\n    }\n    /**\n     * treat value before append\n     * @param {} _marker \n     * @param {*} s \n     * @returns \n     */\n    treatValue(_marker, s, endCapture=false) {\n        let _last = this.lastMarker;\n        if (_last){\n            if (_last.nextTrimWhiteSpace){\n\n                this.objClass.buffer = this.objClass.buffer.trimEnd();\n            }\n        }\n        // if (_marker.captures){\n\n        // }\n        if (endCapture && _marker.endCaptures){\n            for(let i in _marker.endCaptures){\n                let _def = _marker.endCaptures[i];\n                if ((i==0) && _def.nextTrimWhiteSpace){\n                    this.objClass.buffer = this.objClass.buffer.trimEnd();\n                }\n            }\n        } \n        if (_marker.replaceWith && _marker.match) {\n            let gp = Utils.GetRegexFrom(_marker.replaceWith.toString(), _marker.group);\n            gp = gp.toString().substring(1).slice(0, -1);\n            s = s.replace(_marker.match, gp);\n        }\n        if (_marker.tokenID) {\n            this.setLastMarker(_marker);\n        }\n        return s;\n    }\n    /**\n     * append or transform value to buffer. at end on string manipulation \n     * @param {string} s \n     * @param {Patterns} _marker \n     * @returns \n     */\n    append(s, _marker, endCapture=false) {\n        let _o = this.objClass;\n        if (!_o) return;\n        if (s.length == 0) return;\n\n        if (_marker) {\n            // let a = `<span class=\"tk s\">${s}</span>`;\n            _o.debug && Debug.log({ tokenID: _marker.tokenID, value: s , name: _marker.name});\n            s = this.treatValue(_marker, s, endCapture);\n        }\n\n        if (_marker && _marker.isBlockDefinition) {\n            if (!_o.blockOnSingleLine && (_o.buffer.length > 0)) {\n                this.store();\n            }\n        }\n\n\n        //+ | transform multi-space to single space\n        if (!_marker)\n            s = s.replace(/\\s+/g, ' ');\n        else if (_marker.lineFeed) {\n            _o.buffer = this.objClass.buffer.trimEnd();\n        }\n        // + | \n        _o.debug &&  Debug.log('append: ' + s);\n    \n        if (_o.buffer.length > 0) {\n            // join expression with single space\n            let _trx = new RegExp(\"^\\\\s+(.+)\\\\s+$\");\n            s = s.replace(_trx, ' ' + s.trim() + ' ');\n        }\n\n        if (_o.lineJoin) {\n            if (!_o.noSpaceJoin) {\n                _o.buffer = _o.buffer.trimEnd() + ' ';\n            }\n            _o.lineJoin = false;\n        } \n        _o.buffer += s;\n\n        if (_marker && _marker.lineFeed) {\n            this.store();\n        }\n    }\n    /**\n     * \n     * @param {string} s append pattern\n     * @param {Patterns} _marker marker pattern\n     */\n    appendAndStore(s, _marker, endCapture=false) {\n        this.append(s, _marker, endCapture);\n        this.store();\n    }\n    /**\n     * treat current buffer and store it to option \n     * buffer to ouput . \n     */\n    store({buffer, output, depth, tabStop, startBlock}) { \n        let s = buffer;\n        let d = depth;\n        s = s.trim();\n        if (s.length > 0){\n            if (startBlock){\n                output.unshift('');\n            }\n            let _tab = d > 0 ? tabStop.repeat(d) : '';\n            output.push(_tab + s);\n        } \n    }\n    output(clear, {output, lineFeed}) { \n        let _s = output.join(lineFeed);\n        if (clear) {\n            output = [];\n        }\n        return _s;\n    }\n    appendLine() {\n        const _o = this.objClass;\n        if (_o.output.length > 0) {\n            _o.output[_o.output.length - 1] += _o.lineFeed;\n        }\n    }\n\n\n    treat\n}\n\nexports.FormatterListener = FormatterListener;","\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {value:true});\n\nclass FormatterSetting{\n    tabStop = \"\\t\";\n    lineFeed = \"\\n\";\n    blockOnSingleLine = true;\n    noSpaceJoin= false;\n    depth =0;\n    line = 0;\n    /**\n     * by default use the current  formatter instance\n     */\n    useCurrentFormatterInstance = true;\n}\nexports.FormatterSetting = FormatterSetting;","\"use strict\";\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { Utils } = require(\"./Utils\");\nconst { Patterns } = require(\"./Patterns\");\nconst { RefPatterns } = require(\"./RefPatterns\");\nconst { JSonParser } = require(\"./JSonParser\");\nconst { Debug } = require(\"./Debug\");\nconst { FormatterListener } = require(\"./FormatterListener\");\nconst { FormatterSetting } = require(\"./FormatterSetting\");\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\n\n// + | --------------------------------------------------------\n// + | export pattern match information \n// + | --------------------------------------------------------\nUtils.Classes = {\n    RefPatterns,\n    Patterns,\n    PatternMatchInfo\n};\n\n\n/**\n * formatters entry point\n */\nclass Formatters {\n    patterns;\n    repository;\n    /**\n     * @var {?string}\n     */\n    scopeName;\n    /**\n    * @var {?bool}\n    */\n    debug; // allow debug\n    /**\n     * use to configure general setting\n     */\n    settings;\n\n    constructor() {\n        let m_listener;\n        let m_objClass;\n        let m_errors = [];\n        let m_info = {\n            isSubFormatting: 0,\n            captureGroup: null\n        };\n        this.debug = false;\n        this.patterns = [];\n        this.repository = {};\n\n        Object.defineProperty(this, 'listener', { get() { return m_listener; }, set(value) { m_listener = value } })\n        Object.defineProperty(this, 'errors', { get() { return m_errors; } })\n        /**\n         * get format info : use to update some current state\n         */\n        Object.defineProperty(this, 'info', { get() { return m_info; } })\n        Object.defineProperty(this, 'objClass', { get() { return m_objClass; } })\n\n\n\n\n\n        this.pushError = (e) => {\n            this.m_errors.push(\n                { 101: 'not in capture.' }[e]\n            );\n        }\n        this._storeObjClass = function (s) {\n            m_objClass = s;\n            delete this._storeObjClass;//  = null;\n        };\n\n    }\n\n    get lineFeed() {\n        return this.m_option.lineFeed;\n    }\n    set lineFeed(value) {\n        this.m_option = value;\n    }\n    json_keys() {\n        const n = 'repository';\n        let tab = Object.keys(this);\n        let idx = tab.indexOf(n);\n        delete (tab[idx]);\n        tab.unshift(n);\n        return tab;\n    }\n    /**\n     * validate current field name\n     * @param {*} field_name \n     * @param {*} d \n     * @returns bool\n     */\n    json_validate(field_name, d, throw_on_error) {\n        const validator = {\n            patterns(d) {\n                return Array.isArray(d);\n            },\n            repository(d) {\n                return typeof (d) == 'object';\n            },\n            debug(d) {\n                return typeof (d) == 'boolean' || /(yes|no|1|0)/.test(d);\n            },\n            settings(d) {\n                return (d == null) || typeof (d) == 'object';\n            },\n            scopeName(d) {\n                return (d == null) || typeof (d) == 'string';\n            }\n        };\n        let f = validator[field_name];\n        if (f && !f(d)) {\n            if (throw_on_error) {\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n    json_parse(parser, fieldname, data, refKey) {\n        const patterns = Utils.ArrayParser(Patterns, RefPatterns);\n        const parse = {\n            patterns,\n            repository(d, parser) {\n                let _out = {};\n                let _o = null;\n                const { registry } = parser;\n                for (let i in d) {\n                    _o = new Patterns();\n                    JSonParser._LoadData(parser, _o, d[i], i, _o);\n                    parser.initialize(_o);\n                    _out[i] = _o;\n                }\n                parser.repositoryKey = null;\n                return _out;\n            },\n            debug(d) {\n                if (typeof (d) == 'boolean') {\n                    return d;\n                }\n                return !(!d);\n            },\n            settings(d, parser) {\n                if (d == null) {\n                    return null;\n                }\n                let m = JSonParser._LoadData(parser, new FormatterSetting, d);\n                return m;\n            }\n        };\n        let fc = parse[fieldname];\n        if (fc) {\n            return fc(data, parser, refKey);\n        }\n        return data;\n    }\n    static CreateFrom(data) {\n        const _names = {};\n        let _registryExpression = null;\n        const formatter = Utils.JSonParseData(Formatters, data, {\n            initialize(m) {\n                if ((m instanceof Patterns) && (m.name)) {\n                    this.registerName(m.name);\n                }\n            },\n            registerName(n) {\n                if (n.length <= 0) return;\n                _names[n] = 1;\n            }\n        });\n        Object.defineProperty(formatter, 'registerNames', { get() { return _names; } });\n        formatter._funcRegistryExpression = function () {\n            if (_registryExpression != null) {\n                return _registryExpression;\n            }\n            let registry = {};\n            let _entry = [];\n            for (let i in _names) {\n                if (i == 'global') {\n                    throw new Error('global is reserved');\n                }\n                Utils.DefineProp(i, undefined, registry);\n                let n = i.split('.')[0];\n                if (_entry.indexOf(n) == -1) {\n                    _entry.push(n);\n                }\n            }\n            _registryExpression = { namespaces: _entry, registry };\n            return _registryExpression;\n        };\n        return formatter;\n    }\n    static CreateDefaultOption() {\n        return new FormatterSetting;\n    }\n    #createListener() {\n        const { listener } = this;\n        let _o = null;\n        if (listener) {\n            _o = listener();\n        }\n        return _o || new FormatterListener();\n    }\n    /**\n     * init marker definition\n     * @param {*} option \n     * @returns \n     */\n    #initDefinition(option) {\n        const _rg = option || this.settings || Formatters.CreateDefaultOption();\n        const { lineFeed, tabStop } = _rg;\n        const { debug } = this;\n        const _markerInfo = [];\n        const _states = [];\n        let depth = _rg.depth || 0; \n        let _formatter = this;  \n        let _info = this.#createListener(); \n        let m_pos = 0;\n        let _outputBufferInfo = {\n            line : 0,\n            start: 0,\n            end : 0,\n            /**\n             * update number information\n             * @param {number} lineCount number info\n             */\n            updateLine(lineCount){\n                this.line = lineCount;\n                this.start = this.end = 0;\n            },\n            /**\n             * update range\n             * @param {number} start \n             * @param {undefined|number} end \n             */\n            updateRange(start, end){\n                this.start = start;\n                this.end = typeof(end)=='undefined' ? start: end;\n            }\n        }\n        const m_constants_def = {\n            PrevLineFeedConstant: new PrevLineFeedConstantPattern,\n            PrevConstant: new PrevConstantPattern,\n            GlobalConstant: new GlobalConstantPattern,\n        };\n        let objClass = {\n            ..._rg,\n            line: '',\n            pos: 0,\n            lineCount: 0,\n            depth,\n            continue: false,\n            lineJoin: false,\n            lineFeedFlag: false,\n            buffer: '',\n            output: [], // output result\n            listener: _info,\n            debug: _formatter.debug,\n            lineFeed,\n            state: '', // current state mode \n            range: {\n                start: 0, // start position\n                end: 0    // number end position range\n            },\n            resetRange() {\n                this.storeRange(0, 0);\n            },\n            /**\n             * store range \n             * @param {number} start \n             * @param {number} end if optional \n             */\n            storeRange(start, end) {\n                this.range.start = start;\n                this.range.end = typeof (end) == 'undefined' ? start : end;\n            }\n        };\n\n        Object.defineProperty(objClass, 'outputBufferInfo', { get(){return _outputBufferInfo; }})\n        Object.defineProperty(objClass, 'length', { get: function () { return this.line.length; } })\n        Object.defineProperty(objClass, 'tabStop', { get: function () { return tabStop; } })\n        Object.defineProperty(objClass, 'lineFeed', { get: function () { return lineFeed; } })\n        Object.defineProperty(objClass, 'debug', { get: function () { return debug; } })\n        Object.defineProperty(objClass, 'markerInfo', { get: function () { return _markerInfo; } })\n        Object.defineProperty(objClass, 'constants', { get: function () { return m_constants_def; } })\n        Object.defineProperty(objClass, 'pos', {\n            get: function () { return m_pos; }, set(v) {\n                // console.log(\"set position\", v);\n                m_pos = v;\n            }\n        });\n\n        objClass.unshiftMarker = (o) => {\n            _markerInfo.unshift(o);\n        };\n        objClass.shiftMarker = () => {\n            return _markerInfo.shift();\n        };\n        objClass.empty = empty;\n\n        function empty(l) {\n            return (!l && l.length == 0)\n        }\n        function is_emptyObj(q) {\n            return Object.keys(q).length == 0\n        }\n        function pushState() {\n            let _keys = Object.keys(objClass);\n            let _state = {};\n            _keys.forEach(i => {\n                let t = typeof (objClass[i]);\n                if (/function|object/.test(t))\n                    return;\n                let _i = Object.getOwnPropertyDescriptor(objClass, i);\n                if (!_i || (_i.get && _i.set)) {\n                    _state[i] = objClass[i];\n                } \n            })\n            _states.unshift({ ..._state });\n        }\n        function popState() {\n            let s = _states.shift();\n            if (s) {\n                for (let i in s) {\n                    objClass[i] = s[i];\n                }\n            }\n        }\n        /**\n         * treat how to update the current buffer before add it to listener\n         * @param {string} s \n         * @param {*} value \n         * @param {*} _marker \n         * @returns new buffer value\n         */\n        objClass.updateBufferValue = function (s, value, _marker) {\n            // allow listener to treate buffer value\n            // + | tranform before update \n            if (empty(value)) {\n                return s;\n            }\n            if (_marker.replaceWith) {\n                let _g = _marker?.parent?.group;\n                if (this.state == 'begin/end') {\n                    _g = _marker.group;\n                }\n                value = _formatter._operationReplaceWith(_marker, value, _g);\n            }\n            // global treatment \n            if (_marker.transform) {\n                value = Utils.StringValueTransform(value, _marker.transform);\n            }\n            if (this.listener.treatBuffer) {\n                return this.listener.treatBuffer.append(s, value, _marker, this);\n            }\n            return this.joinBuffer(s, value);\n        };\n\n        objClass.joinBuffer = function (buffer, value) {\n            const { lineJoin, noSpaceJoin } = this;\n            let s = buffer;\n            if (lineJoin) {\n                let join = ' ';\n                if (noSpaceJoin) {\n                    join = '';\n                }\n                s = [s.trimEnd(), value.trimStart()].join(join);\n                this.lineJoin = false;\n            } else {\n                s += value;\n            }\n            return s;\n        }\n\n        /**\n         * append to buffer\n         * @param {string} value \n         * @param {*} _marker \n         */\n        objClass.appendToBuffer = function (value, _marker) {\n            this.debug && Debug.log(\"[append to buffer] \" + value);\n            let _buffer = this.buffer;\n            _buffer = this.updateBufferValue(_buffer, value, _marker)\n            this.buffer = _buffer;\n        }\n        /**\n         * treat begin captures\n         * @param {*} _marker \n         * @param {*} matches \n         * @returns \n         */\n        objClass.treatBeginCaptures = function (_marker, matches) {\n            let _cap = { ..._marker.captures, ..._marker.beginCaptures };\n            if (is_emptyObj(_cap)) {\n                return;\n            }\n            return this.treatCaptures(_cap, _marker, matches);\n        };\n        objClass.treatEndCaptures = function (_marker, endMatch) {\n            let _cap = { ..._marker.captures, ..._marker.endCaptures };\n            if (is_emptyObj(_cap)) {\n                return;\n            }\n            const { debug } = this;\n            // let transformed = _marker.endRegex(_marker.group); \n            // use replace with to change the value at specied capture \n            let list = [];\n            list.markers = {};\n            let prop = null;\n            let _bckCapture = _formatter.info.captureGroup;\n            _formatter.info.captureGroup = _marker.group;\n            for (let i in _cap) {\n                list.push(i);\n                let d = _cap[i];\n                if (!(i in endMatch)) {\n                    this.pushError(101);\n                    continue;\n                }\n                let value = endMatch[i];\n\n\n                if (d.replaceWith) {\n                    Formatters.DoReplaceWith(value, _formatter, d.replaceWith.toString(), _marker.group); // Formatters.GetMarkerGroup(_formatter, _marker))\n\n                }\n                if (d.nextTrimWhiteSpace) {\n                    // TODO: Trim next buffer space \n                }\n                if (d.transform) {\n                    value = Utils.StringValueTransform(value, d.transform);\n\n                }\n                if (d.name) {\n                    prop = new NameOnlyConstantPattern();\n                    prop.name = d.name; \n                    prop.isClosingBlock = d.isClosingBlock;\n                    list.markers[i] = {\n                        marker: prop,\n                        value: value,\n                        parent: _marker\n                    };\n                }\n                if (d.patterns) {\n                    debug && Debug.log('---::::treatEndCaptures::::--- contains patterns');\n                    if (_formatter.settings.useCurrentFormatterInstance) {\n                        pushState();\n                        // backup setting\n                        let _bck = {\n                            patterns: _formatter.patterns,\n                            buffer: this.buffer,\n                            output: this.output,\n                            lineCount : this.lineCount,\n                            markerInfo : this.markerInfo.slice(0),\n                            line : this.line,\n                            pos: this.pos\n                        };\n                        // clean setting\n                        this.output = [];\n                        this.buffer = [];\n                        this.lineCount = 0;\n                        _markerInfo.length = 0;\n                        _formatter.info.isSubFormatting++;\n                        _formatter.patterns = d.patterns;\n                        value = _formatter.format(value);\n                        _formatter.info.isSubFormatting--;\n                        _formatter.patterns = _bck.patterns;\n                        // restore setting\n                        this.output = _bck.output;\n                        this.buffer = _bck.buffer;\n                        this.lineCount = _bck.lineCount;\n                        this.line = _bck.line;\n                        this.pos = _bck.pos;\n                        _bck.markerInfo.forEach(a => _markerInfo.push(a));\n                        popState();\n\n                    } else {\n                        // passing value to pattern \n                        let n_formatter = Formatters.CreateFrom({ patterns: d.patterns });\n                        value = n_formatter.format(value);\n                    }\n                }\n\n                endMatch[i] = value;\n            }\n            _formatter.info.captureGroup = _bckCapture;\n            return list;\n        }\n        objClass.treatCaptures = function (_cap, _marker, endMatch) {\n            // let transformed = _marker.endRegex(_marker.group); \n            // use replaceWith to change the value at specied capture \n            let list = [];\n            list.markers = {};\n            let prop = null;\n            for (let i in _cap) {\n                list.push(i);\n                let d = _cap[i];\n                if (!(i in endMatch)) {\n                    this.pushError(101);\n                    continue;\n                }\n                let value = endMatch[i];\n\n                if (d.replaceWith) {\n                    let m = Utils.ReplaceRegexGroup(d.replaceWith.toString(), _marker.group);\n                    value = value.replace(value, m);\n                }\n                if (d.nextTrimWhiteSpace) {\n                    // TODO: Trim next buffer space \n                }\n                if (d.transform) {\n                    value = Utils.StringValueTransform(value, d.transform);\n\n                }\n                if (d.name) {\n                    prop = new NameOnlyConstantPattern();\n                    prop.name = d.name;\n                    list.markers[i] = {\n                        marker: prop,\n                        value: value\n                    };\n                }\n                endMatch[i] = value;\n            }\n            return list;\n        }\n\n        /**\n         * move to this location\n         * @param {number} newPosition \n         */\n        objClass.moveTo = function (newPosition) {\n            this.pos = newPosition;\n        }\n\n\n        objClass.store = function (startBlock = false) {\n            const { listener } = this;\n            if (listener) {\n                const _ctx = this;\n                const { buffer, output, depth } = _ctx;\n                listener.store.apply(null, [{ buffer, output, depth, tabStop, _ctx, startBlock }]);\n                this.buffer = '';\n            }\n        }\n\n        objClass.flush = function (clear) {\n\n            const _ctx = this;\n            const { buffer, output, listener } = _ctx;\n            let l = '';\n            if (listener) {\n                l = listener.output.apply(null, [clear, { buffer, output, lineFeed, _ctx }]);\n            } else {\n                l = this.output.join(lineFeed);\n            }\n            if (clear) {\n\n                this.buffer = '';\n                this.output = [];\n            }\n            return l;\n        }\n        this._storeObjClass(objClass);\n        return objClass;\n\n    }\n    format(data, option) {\n        if (!Array.isArray(data)) {\n            if (typeof (data) == 'string') {\n                data = [data];\n            }\n            else throw new Error('argument not valid');\n        }\n        let objClass = this.objClass;\n        if (!objClass) {\n            objClass = this.#initDefinition(option);\n        }\n        let _matcherInfo = null;\n        let _formatter = this;\n        // let pos = 0;\n        const { debug, lineFeed } = objClass;\n        // + | ------------------------------------------------------------\n        // + | START : FORMATTER LOGIC\n        // + | ------------------------------------------------------------\n        data.forEach((line) => {\n            const option = objClass;\n            objClass.debug && Debug.log('read:[' + objClass.lineCount + \"]::: \" + line);\n            objClass.resetRange();\n            objClass.line = line;\n            objClass.pos = 0;\n            objClass.continue = false;\n            objClass.lineCount++;\n\n\n            if (_matcherInfo) {\n                if (!_matcherInfo.marker.allowMultiline) {\n                    throw new Error(`marker '${_matcherInfo.name}' do not allow multi line definition.`);\n                }\n                objClass.continue = true;\n                objClass.lineJoin = false;\n                objClass.startLine = true;\n                _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass, _info);\n\n            } else {\n                objClass.line = objClass.line.trimStart();\n            }\n            if (line.length <= 0) {\n                return;\n            }\n            objClass.startLine = false;\n            let ln = objClass.length;\n            let pos = objClass.pos;\n            const { debug } = objClass;\n            while (pos < ln) {\n                objClass.continue = false;\n                if (_matcherInfo) {\n                    objClass.continue = true;\n                    objClass.storeRange(objClass.pos);\n                    _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                } else {\n                    _matcherInfo = Utils.GetPatternMatcher(this.patterns, objClass);\n                    if (_matcherInfo) {\n                        objClass.storeRange(pos, _matcherInfo.index);\n                        _matcherInfo = _formatter._handleMarker(_matcherInfo, objClass);\n                    } else {\n                        objClass.appendToBuffer(objClass.line.substring(objClass.pos), objClass.constants.GlobalConstant);\n                        objClass.pos = ln;\n                    }\n                }\n                pos = objClass.pos;\n            }\n            objClass.lineJoin = true;\n        });\n\n        debug && console.log('.....end.....');\n        if (objClass.markerInfo.length > 0) {\n            // missing close marker info\n            debug && console.log('.....contains marker info .....');\n            let q = null;\n            while (q = objClass.markerInfo.shift()) {\n                this._restoreBuffer(objClass, q);\n                if (q.marker.isBlock) {\n                    objClass.buffer += q.content;\n                    objClass.depth = Math.max(--objClass.depth, 0);;\n                    objClass.output.push(objClass.buffer);\n                    objClass.buffer = '';\n                    _info.appendAndStore(\n                        q.marker.blockEnd\n                    );\n                }\n\n            }\n        }\n        objClass.store();\n        const _output =  objClass.output.join(lineFeed);\n        // + | clear buffer list \n        this.objClass.buffer = '';\n        this.objClass.output = [];\n\n        return _output;\n    }\n    _isBlockAndStart(_marker, option) {\n        return _marker.isBlock && !option.continue;\n    }\n    _startNewBlock(_marker, option) {\n        if (option.buffer.trim().length != 0) {\n            throw new Error('buffer must be trimmed before start a new block');\n        }\n        option.buffer = option.buffer.trimEnd();\n        option.depth++;\n        option.listener.startNewBlock();\n    }\n    /**\n     * do replace with\n     * @param {*} value \n     * @param {*} _formatter \n     * @param {*} replace_with \n     * @param {*} group \n     * @returns \n     */\n    static DoReplaceWith(value, _formatter, replace_with, group) {\n        let g = group;\n        let _rp = replace_with; // \n        let m = '';\n        if (g) {\n            m = Utils.ReplaceRegexGroup(_rp, g); // \n        } else {\n\n            m = _rp.replace(/\\\\\\//g, \"/\");\n        }\n        value = value.replace(value, m);\n        return value; q\n    }\n\n    /**\n     * core handle marker handle marker \n     * @param {PatternMatchInfo} _marker \n     * @param {*} option \n     */\n    _handleMarker(_marker, option) {\n        if (!_marker) return;\n\n        if (!option.continue) {\n            let _prev = option.line.substring(option.range.start, option.range.end);\n            if (_prev.length > 0) {\n                option.appendToBuffer(_prev, option.constants.PrevLineFeedConstant);\n                option.pos += _prev.length;\n            }\n            option.storeRange(option.pos);\n        }\n        /**\n         * each callback must return a marker or null \n         * */\n        const handle = this._handleCallback(_marker.marker.matchType, option);\n        if (!handle || (typeof (handle) != \"function\")) {\n            throw new Error(\"marker type handler is not a valid callback\");\n        }\n        return handle.apply(this, [_marker, option]);\n    }\n /**\n  * replace with condition \n  * @param {PatternMatchInfo} _marker \n  * @param {*} value \n  * @param {*} group \n  * @returns \n  */\n    _operationReplaceWith(_marker, value, group) {\n        let _formatter = this;\n        if (_marker.replaceWith) {\n            let _rpw = _marker.replaceWith.toString();\n            const _cond = _marker.replaceWithCondition;\n            let match = _cond?.match;\n\n            let g = group;\n            if (!g && _formatter.info.isSubFormatting > 0) {\n                g = _formatter.info.captureGroup;\n            }\n            if (match) {\n                let _op = _cond.operator || '=';\n                let _s = Utils.ReplaceRegexGroup(_cond.check, g);\n                if (/(!)?=/.test(_op)) {\n                    let r = match.test(_s);\n                    if (_op) {\n                        if (((_op == '=') && !r) || ((_op == '!=') && (r))) {\n                            return value;\n                        }\n                    }\n                } else if (/(\\<\\>)=/.test(_op)) {\n                    let _ex = match.toString().replace(/\\\\\\//g, '');\n                    if (\n                        ((_op == \">=\") && (_s >= _ex)) ||\n                        ((_op == \"<=\") && (_s <= _ex))\n                    ) {\n                        if (_s >= _ex) return value;\n                    }\n                }\n\n            }\n            value = Formatters.DoReplaceWith(value, _formatter, _rpw, g);\n\n        }\n        return value;\n    }\n    /**\n     * from type retrieve the handler type \n     * @param {*} type \n     * @returns \n     */\n    _handleCallback(type, option) {\n        return {\n            \"0\": option.listener?.handleBeginEndMarker || this._handleBeginEndMarker2,\n            \"1\": option.listener?.handleMatchMarker || this._handleMatchMarker\n        }[type]\n    }\n    _handleMatchMarker(_marker, option) {\n        option.debug && Debug.log('--:: Handle match marker :--');\n        option.state = 'match';\n        let c = _marker.group[0];\n        // + | update cursor position\n        option.pos += c.length;\n        let _p_host = option.markerInfo.length > 0 ?\n            option.markerInfo[0] : null;\n        if (_p_host) {\n            this._updateMarkerChild(_p_host, _marker);\n        }\n        // + | marker is not a line feed directive or buffer is not empty\n        if ((!_marker.lineFeed) || (option.buffer.length > 0)) {\n            option.appendToBuffer(c, _marker);\n            if (_marker.lineFeed) {\n                option.lineFeedFlag = true;\n            }\n        }\n        return _marker.parent;\n    }\n    /**\n     * handle marker info \n     * @param {PatternMatchInfo} patternInfo \n     * @param {*} option \n     * @returns \n     */\n    _handleBeginEndMarker2(patternInfo, option) {\n        option.state = 'begin/end';\n        const { debug, listener, line, markerInfo, startLine } = option;\n        const { group } = patternInfo;\n        debug && Debug.log('-------------: handle marker 2 :----------------------');\n\n        let _endRegex = null;\n        let _start = true;\n        let _line = '';\n        let _matcher = null;\n        let _old = null;\n        let _buffer = '';\n        let _p = null; // end matcher \n        // get _old marker to continue matching selection  \n        if ((markerInfo.length > 0) && (markerInfo[0].marker == patternInfo) && (_old = markerInfo.shift())) {\n            _start = _old.start; // update the marker to handle start definition\n            _buffer = this._updateOldMarker(_old, patternInfo, startLine, option);\n        } else if (patternInfo.start){\n            // + | treat begin captures and update buffer\n            let _list =  option.treatBeginCaptures(patternInfo.marker, patternInfo.group);\n            patternInfo.start = false;\n        }\n\n\n        _endRegex = patternInfo.endRegex;// _endRegex || _marker.endRegex(_marker.group);\n        _buffer = _buffer || patternInfo.group[0];\n        let _next_position = patternInfo.group.index + patternInfo.group.offset;\n        // treat patterns\n        if (_start) {\n            // + | on start before handle \n            option.pos = _next_position;\n        }\n        _line = line.substring(option.pos);\n\n        let _continue_with_marker = false;\n        _matcher = (_line.length > 0) &&\n            (patternInfo.patterns && (patternInfo.patterns.length > 0)) ?\n            Utils.GetPatternMatcher(patternInfo.patterns, option, patternInfo) : null;\n        _p = _line.length > 0 ? _endRegex.exec(_line) : null;\n        if (_p) {\n            _p.index += option.pos;\n        }\n\n\n        if (_line.length == 0) {\n            this._updateMarkerInfoOld(patternInfo, _old, _buffer, _endRegex, option);\n            return patternInfo;\n        }\n        if (_matcher == null) {\n            // no child matcher found\n            if (_p == null) {\n                // no end - found \n                _continue_with_marker = true;\n                // update cursor \n                listener.append(_line);\n                option.pos = option.line.length;\n            } else {\n                // ---------------------------------------- -----------------------\n                // END FOUND\n                // ----------------------------------------------------------------\n                return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n            }\n        }\n        else {\n            // compared index and handle child\n            if ((_p == null) || (_matcher.group.index < _p.index)) {\n                // handle matcher  \n                this._updateMarkerInfoOld(patternInfo, _old, _buffer, _endRegex, option);\n                option.storeRange(option.pos, _matcher.group.index);\n                return this._handleMarker(_matcher, option);\n            }\n            // check if same \n            if (_matcher.group.index == _p.index) {\n                return this._handleSameGroup2(patternInfo, _matcher, _p, _old, _buffer, option, _endRegex);\n            }\n            // priority to current marker \n            return this._handleFoundEndPattern(_buffer, _line, patternInfo, _p, option, _old);\n            // throw new Error(\"Detected after not handle\");\n        }\n        if (_continue_with_marker) {\n            this._updateMarkerInfoOld(patternInfo, _old, _buffer, _endRegex, option);\n            return patternInfo;\n        }\n\n        // + | default append \n        listener.append(group[0], patternInfo);\n        // + | move forward\n        option.moveTo(_next_position);\n        return null;\n    }\n    _handleFoundEndPattern(_buffer, _line, _marker, _p, option, _old) {\n        const { debug } = option;\n\n        debug && Debug.log('--::handleFoundEndPattern::--')\n        if (debug) {\n\n            Debug.log('matcher-end: ', {\n                __name: _marker.toString(),\n                name: _marker.name,\n                line: option.line,\n                pos: _p.index,\n                depth: option.depth,\n                hasParent: _marker.parent != null,\n                isBlock: _marker.isBlock,\n                value: _p[0],\n                regex: _marker.endRegex\n            }); \n        }\n        let _close_block = false;\n        if (_marker.isBlock) {\n            // just remove block before store \n            option.depth = Math.max(--option.depth, 0);\n            // reset block value;\n            _marker.isBlock = _old.oldBlockStart\n            _close_block = true;\n        }\n\n        // calculate next position \n        const _next_position = _p.index + _p[0].length;\n        // ent treatment\n        let s = option.treatEndCaptures(_marker, _p);\n        let _b = _p[0];\n        let _append = option.line.substring(option.pos, _p.index);\n        let _sblock = _marker?.parent?.isBlock;\n        let _p_host = ((option.markerInfo.length > 0) ? option.markerInfo[0] : null);\n\n        // update parent host with childrend\n\n        if (_p_host) {\n            this._updateMarkerChild(_p_host, _marker);\n        }\n\n        // update parent props\n        this._updateParentProps(_marker); // move props to parent \n\n        // check request parentBlock for buffer\n        let _requestParentBlock = _old && !_sblock && _marker?.parent?.isBlock;\n\n        if (_requestParentBlock) {\n            // validate the block to \n            _marker.parent.isBlock = this._isEmptyRequestBlock({ _marker, _old, childs: _old.childs, condition: _marker.requestParentBlockCondition });\n        } else if (!_sblock && _marker?.parent?.isBlock) {\n            _marker.parent.isBlock = false;\n        }\n\n        if ((!s && (_append != _b) && (_append.trim().length > 0)) || (_requestParentBlock && _marker.parent.isBlock)) {\n            // fix that capture not added with data .\n            // if request to make parent block\n            if (_requestParentBlock) {\n                // this item change the parent block \n                if (_p_host) {\n                    // pass buffer content to parent\n                    // get startup buffer  \n                    if (_old.entryBuffer.length > 0) {\n                        _p_host.content = option.updateBufferValue(_p_host.content, _old.entryBuffer, _p_host.marker);\n                        // + | remove entry buffer \n                        _buffer = _buffer.replace(new RegExp('^' + _old.entryBuffer), '');\n                    }\n\n                    // start block definition \n                    _p_host.startBlock = 1;\n                    _p_host.oldBlockStart = _sblock;\n                } else {\n                    option.appendToBuffer(_buffer, _marker);\n                    option.store();\n                }\n                this._startNewBlock(_marker.parent, option);\n            }\n            if (!s && (_append != _b) && (_append.trim().length > 0)) {\n                _buffer = option.updateBufferValue(_buffer, _append, _marker);\n            }\n        }\n        else if (_requestParentBlock) {\n            _marker.parent.isBlock = _p_host.oldBlockStart;\n        }\n        option.appendToBuffer(_buffer, _marker);\n        _buffer = ''; \n        let _block_marker = _marker;\n        if (s) {\n            // + | update change marker definition group \n            if (0 in s.markers) {\n                let g = s.markers[0];\n                if (g.marker){\n                    _block_marker = g.marker;\n                }\n                // _marker = g.marker || _marker;\n            }\n        }\n        if (_close_block) {\n            option.store();\n        }\n\n        if (_b.length > 0) {\n            option.appendToBuffer(_b, _block_marker);\n        }\n        option.moveTo(_next_position);\n\n        if (_old && (_old.marker == _marker)) {\n            // + | update a restore folder \n            // + | restore and update buffer\n            const _cbuffer = option.buffer;\n            let _tbuffer = option.flush(true);\n            _tbuffer += _cbuffer;\n            this._restoreBuffer(option, _old);\n            if (_tbuffer.length > 0) {\n                option.buffer += _tbuffer;\n            }\n        }\n        if ((_old == null) && (option.markerInfo.length > 0)) {\n            // + | get the first marker parent update inner childs\n            let v_marker_info = option.markerInfo[0];\n            let v_parent = v_marker_info.parent;\n            if (v_parent) { \n                if (!v_parent?.isBlock && v_marker_info.marker.updateParentProps?.isBlock) {\n                    let v_request = true;\n                    if (v_marker_info.marker.requestParentBlockCondition) {\n                        // update or start condition block\n                        v_request = this._isEmptyRequestBlock({\n                            childs: v_marker_info.childs,\n                            _marker: v_marker_info.marker,\n                            _old: v_marker_info,\n                            condition: v_marker_info.marker.requestParentBlockCondition\n                        });\n                    }\n                    if (v_request) {\n                        v_marker_info.marker.parent.isBlock = true;\n                        v_marker_info.startBlock = 0;\n                        v_marker_info.autoStartChildBlock = true;\n                        _buffer = option.buffer; // backup buffer \n                        option.buffer = ''; // clear current buffer\n                        option.store();\n                        this._startNewBlock(v_marker_info.marker, option);\n                        option.appendToBuffer(_buffer, _marker);\n                        option.store(true);\n                    }\n                }else if (v_parent?.isBlock && v_marker_info.autoStartChildBlock){\n                    option.store(true);\n                }\n            } \n        } \n        return _marker.parent;\n    }\n    /**\n     * check if this marker will be consider as an empty block if requested\n     * @param {*} _marker \n     * @param {*} _old \n     */\n    _isEmptyRequestBlock({ childs, _marker, _old, condition }) {\n        if (_old && true) {//_marker.blockToParentCondition){\n\n            if (childs.length == 0) {\n                return false;\n            }\n            if (condition) {\n                let r = true;\n                let q = null;\n                let expression = this._funcRegistryExpression();\n                const list = expression.namespaces.join(',');\n                let fc = new Function(\"registry\", \"child\", \"marker\", `const {${list}} = registry;  return ${condition};`);\n                while (childs.length > 0) {\n                    q = childs.shift();\n\n                    try {\n                        r = fc.apply({ child: q }, [expression.registry, q, _marker]);\n                    }\n                    catch (e) {\n                        console.error(\"error : \", e);\n                        return true;\n                    }\n                    if (r) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * update marker child\n     * @param {} _p_host \n     * @param {*} _marker \n     */\n    _updateMarkerChild(_p_host, _marker) {\n        _p_host.childs.push({\n            name: _marker.name,\n            marker: _marker,\n            range: { start: 0, end: 0 }\n        });\n    }\n    _updateMarkerInfoOld(_marker, _old, _buffer, _endRegex, option) {\n        if (_old) {\n            _old.content = _buffer;\n            option.markerInfo.unshift(_old);\n        } else {\n            this._backupMarkerSwapBuffer(option, _marker, _buffer, _endRegex);\n        }\n    }\n\n    /**\n     * restore buffer\n     * @param {*} option \n     * @param {*} data \n     */\n    _restoreBuffer(option, data) {\n        option.debug && Debug.log('restore buffer');\n        option.buffer = data.state.buffer;\n        option.output = data.state.output;\n    }\n    _backupMarkerSwapBuffer(option, _marker, l, _endRegex) {\n        option.debug && Debug.log('backup and swap buffer.');\n        const _inf = {\n            marker: _marker,\n            start: false,\n            // content: l, // define content property\n            endRegex: _endRegex,\n            startBlock: _marker.isBlock ? 1 : 0, // start join mode 0|block = append new line before \n            autoStartChildBlock: false, // indicate that child is an autostarted child start bloc\n            oldBlockStart: _marker.isBlock, // backup the start source start  \n            childs: [],\n            state: {\n                buffer: option.buffer,\n                output: option.output\n            },\n            entryBuffer: l // used to handle first entry buffer for block definition\n        };\n        (function (entry) {\n            var _content = entry;\n            Object.defineProperty(_inf, 'content', {\n                get() {\n                    return _content;\n                },\n                set(v) {\n                    if (v != _content) {\n                        option.debug && Debug.log(\"store content :\" + v)\n                        _content = v;\n                    }\n                }\n            });\n        })(l);\n        option.unshiftMarker(_inf);\n        option.buffer = '';\n        option.output = [];\n    }\n    _updateOldMarker(_old, _marker, startLine, option) {\n        let _sbuffer = '';\n        let _lf = _old.startBlock == 1 ? option.lineFeed : '';\n        let _buffer = _old.content;\n        const _info = option.listener;\n        // console.log(\"_buffer content = \"+_buffer);\n\n        if (startLine) {\n            if (_marker.preserveLineFeed) {\n                _buffer += option.lineFeed;\n            }\n            if ((option.output.length > 0) || _old.startBlock) {\n                _info.store();\n                _buffer = _buffer.trimEnd();\n                option.output.unshift('');\n                _sbuffer = option.flush(true);\n                _lf = '';\n            }\n        } else {\n            // append current buffer to \n\n            if ((option.output.length > 0) || _old.startBlock) {\n                option.store(_old.startBlock);\n                _sbuffer = option.flush(true);\n                _lf = '';\n\n            } else {\n                _sbuffer = option.buffer;\n                option.flush(true);\n                option.buffer = '';\n            }\n\n        }\n        if (_sbuffer) {\n            _buffer += _lf + _sbuffer;\n        }\n        _old.startBlock = 0;\n        //  \n        //  + | update old buffer content\n        // this._restoreBuffer(option, _old);\n        _old.content = _buffer;\n        return _buffer;\n    }\n\n    _handleSameGroup2(_marker, _matcher, _p, _old, _buffer, option, _endRegex) {\n        if (_matcher.group[0].length == 0) {\n            // matcher is empty and must past to end group\n            if (_endRegex.test(_buffer)) {\n                return this._handleFoundEndPattern(_buffer, option.line, _marker, option, _old);\n            }\n        }\n\n        // + | update parent markerin of before handle marker \n        if ((option.markerInfo.length == 0) || (option.markerInfo[0] !== _marker)) {\n            this._updateMarkerInfoOld(_marker, _old, _buffer, _endRegex, option);\n        }\n        return this._handleMarker(_matcher, option);\n    }\n    // _handleEndBlock2(_marker, option) {\n\n    // }\n    /**\n     * update parent property\n     * @param {*} _matcher \n     */\n    _updateParentProps(_matcher, option) {\n        if (!_matcher.updateParentProps)\n            return;\n        const { isBlock, lineFeed } = _matcher.updateParentProps;\n        _matcher.parent.isBlock = isBlock || _matcher.parent.isBlock;\n        _matcher.parent.lineFeed = lineFeed || _matcher.parent.lineFeed;\n    }\n\n    _getMatchList() {\n        const _list = [];\n\n        return _list;\n    }\n    _renderMatchList(_list, option) {\n        const { listener } = option;\n\n        _list.forEach((o) => {\n            listener.append(o.value, o.marker);\n            if (o.marker.lineFeed) {\n                listener.store();\n            }\n        });\n    }\n}\n\nclass SpecialMeaningPatternBase extends Patterns {\n    get isSpecial() { return true; }\n}\n\nclass BlockPatternBase extends SpecialMeaningPatternBase {\n    get isBlock() { return true; }\n}\nclass EmptyBlockPattern extends BlockPatternBase {\n    name = 'system.empty.block';\n    get isEmptyBlock() { return true; }\n}\nclass BlockDefinitionPattern extends BlockPatternBase {\n    get isBlockDefinition() { return true };\n    name = 'system.block.definition';\n}\n\n/**\n * use to debug constant list \n */\nclass SystemConstantPattern extends SpecialMeaningPatternBase {\n    tokenID = 'constant';\n    transform = [function (v) {\n        if (v.trim().length == 0) return ''; return v;\n    }, 'joinSpace']\n}\n\nclass PrevLineFeedConstantPattern extends SystemConstantPattern {\n    name = 'system.prev.line.feed.constant'\n}\n\nclass GlobalConstantPattern extends SystemConstantPattern {\n    name = 'system.global.line.constant';\n\n}\n\nclass PrevConstantPattern extends SystemConstantPattern {\n    name = 'system.prev.line.constant';\n}\nclass NameOnlyConstantPattern extends SpecialMeaningPatternBase {\n    get matchType() {\n        return 3;\n    }\n}\n\nexports.Formatters = Formatters;\nexports.Utils = Utils;\nexports.Patterns = Patterns;\nexports.JSonParser = JSonParser;","Object.defineProperty(exports, '__esModule', {value:true});\n\n/**\n * json parser info\n */\nclass JSonParser{\n    source;\n    data; \n    registry;\n    repositoryKey;\n    throwOnError;\n\n    get current(){\n        return this.m_current;\n    }\n\n    constructor(){\n        this.m_current = null;\n        this.throwOnError = true;\n    }\n\n    initialize(_o){\n        if (this.registry){\n            this.registry.initialize(_o);\n        }\n    }\n\n    parse(){\n        obj = new this.source();\n        this.m_current = this.data;\n        JSonParser._LoadData(this, obj, this.data);\n        return obj;\n    }\n    /**\n     * load data with reference object \n     * @param {*} parser \n     * @param {*} obj \n     * @param {*} data \n     * @param {*} refKey \n     * @param {*} _refObj \n     * @returns \n     */\n    static _LoadData(parser, obj, data, refKey, _refObj){\n        const _throwOnError = parser.throwOnError;\n        const keyData = ()=>{\n            if (obj.json_keys){\n                return obj.json_keys();\n            }\n            return Object.keys(obj);\n        };\n        let validation = obj.json_validate;\n        let json_parsing = obj.json_parse;\n        keyData().forEach((i)=>{\n            let _r = data[i];\n            if (typeof(_r)=='undefined'){\n                return;\n            } \n            if ((validation)&& !validation.apply(obj, [i, _r, _throwOnError])){\n                return;\n            }\n            if (json_parsing){\n                _r = json_parsing.apply(obj, [parser, i, _r, refKey, _refObj]);\n            }\n            obj[i] = _r;\n        });\n        return obj;\n    }\n}\n\nexports.JSonParser = JSonParser;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n/**\n * export pattern match info\n */\nclass PatternMatchInfo{\n    /**\n     * @var {bool}\n     */\n    start = true; \n    /**\n     * current definition block\n     * @var {bool}\n     */\n    isBlock;\n    /**\n     * store start line\n     */\n    startLine = 0;\n    /**\n     * \n     */\n    range = {\n        start : 0,\n        end : 0\n    }\n\n    constructor(){\n        var m_parent;\n        var m_marker;\n        var m_endRegex;\n        var m_group;\n        var m_line;\n        var m_isBlock = false;\n        var m_lineFeed = false;\n\n        /**\n         * get or set the parent info matcher\n         */\n        Object.defineProperty(this, 'parent', {get(){return m_parent; }});\n        Object.defineProperty(this, 'isBlock', {get(){return m_isBlock; }, set(value){ m_isBlock = value; }});\n        Object.defineProperty(this, 'lineFeed', {get(){return m_lineFeed; }, set(value){ m_lineFeed = value; }});\n        Object.defineProperty(this, 'marker', {get(){return m_marker; }});\n        Object.defineProperty(this, 'endRegex', {get(){return m_endRegex; }});\n        Object.defineProperty(this, 'group', {get(){return m_group; }});\n        Object.defineProperty(this, 'line', {get(){return m_line; }});\n\n        /**\n         * \n         * @param {*} marker \n         */\n        this.use = function({marker, endRegex, group, line, parent}){\n            m_marker = marker;\n            m_isBlock = marker.isBlock;\n            m_endRegex = endRegex;\n            m_group = group;\n            m_line = line;\n            m_parent = parent;\n\n            (function(q, pattern){\n                const _keys = Object.keys(q);\n                const _keys_t = Object.keys(pattern);\n                ['isBlock','lineFeed'].forEach(s=>{\n                    delete _keys_t[_keys_t.indexOf(s)];\n                });\n                _keys_t.forEach(i => { \n                    \n                    if (_keys.indexOf(i)!=-1){\n                        console.log(\"property alreay defined [\"+i+\"]\");\n                        return;\n                    } \n\n\n\n                    let _i = Object.getOwnPropertyDescriptor(pattern, i);\n                    if (!_i || (_i.get) || _i.writable) {\n                        // q[i] = pattern[i];\n                        Object.defineProperty(q, i, {get(){ return pattern[i]; }})\n                    } \n                });\n            })(this, m_marker);\n        };\n    }\n\n    get index(){\n        return this.group?.index;\n    }\n    get offset(){\n        return this.group?.offset;\n    }\n    get name(){\n        return this.marker?.name;\n    } \n    get captures(){\n        return this.marker?.captures;\n    } \n    get endCaptures(){\n        return this.marker?.endCaptures;\n    } \n    get beginCaptures(){\n        return this.marker?.beginCaptures;\n    } \n    get replaceWith(){\n        return this.marker?.replaceWith;\n    }\n    get replaceWithCondition(){\n        return this.marker?.replaceWithCondition;\n    }\n    toString(){\n        return \"[PatternMatchInfo: \"+this.marker?.toString()+\"]\";\n    }\n\n}\n\nexports.PatternMatchInfo = PatternMatchInfo;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\nconst { JSonParser } = require('./JSonParser'); \nconst { ReplaceWithCondition } = require('./ReplaceWithCondition');\nconst { Utils } = require('./Utils');\nclass Patterns{\n    /**\n     * \n     */\n    match;\n    /**\n     * start capture \n     */\n    begin;\n    /**\n     * end match\n     */\n    end;\n    /**\n     * the name of this pattern\n     */\n    name;\n\n    /**\n     * capture set content name\n     */\n    contentName;\n    /**\n     * describe this pattern\n     */\n    comment;\n      /**\n     * @var {?string} use for token matching\n     */\n    tokenID;\n    /**\n     * @var {?array} list of patterns\n     */\n    patterns;\n    /**\n     * indicate that this must be used as lineFeed\n     * @var {?bool}\n     */\n    lineFeed;\n     /**\n      * indicate that this must be consider as a block element\n     * @var {?bool}\n     */\n    isBlock;\n\n    /**\n     * indicate that this must be consider as a closing block element\n     * @var {?bool}\n     */\n    isClosingBlock = false;\n\n    /**\n     * get or set condition expression to set if this element is a bloc.\n     * @var {?string}\n     */\n    emptyBlockCondition;\n\n    /**\n     * get or set condition expression to evaluate if this element change the parent block property.\n     * @var {?string}\n     */\n    requestParentBlockCondition;\n\n     /**\n     * @var {?{start: string, end: string}} \n     */\n    block;\n    /**\n     * @var {?bool}\n     */\n    allowMultiline;\n    /**\n     * @var {?bool}\n     */\n    preserveLineFeed;\n\n    /**\n     * depend on token force trim end white space for buffer\n     */\n    nextTrimWhiteSpace = false;\n\n    /**\n     * similar likje end expression will replace the match apend value before adding it to buffer\n     */\n    replaceWith;\n\n    /**\n     * replace with condition object \n     * @var {} \n     */\n    replaceWithCondition\n\n    beginCaptures;\n\n    /**\n     * used for end captures\n     */\n    endCaptures;\n\n    /**\n     * apply to both begin and end captures definition\n     */\n    captures;\n\n    /**\n     * get updated parent props, {isBlock:?bool, lineFeed:?bool}\n     */\n    updateParentProps;\n\n\n    /**\n     * use to mark section as a buffer transform - according to parent \n     * passing the transformed data to parent end \n     */\n    transformToken;\n\n    /**\n     * list of tranform operation\n     * @var {string|string[]}\n     */\n    transform;\n\n    constructor(){\n        this.patterns = [];\n        this.isBlock = false;\n        this.allowMultiline = true;\n        this.preserveLineFeed = false;\n        var m_parent = null;\n\n        Object.defineProperty(this, 'parent', {get(){return m_parent;}, set(v){\n            if ((v==null)||(v instanceof Patterns) )\n                m_parent = v;\n            else throw Error('parent value not valid');\n        }});\n    }\n    json_parse(parser, fieldname, data, refKey, refObj){ \n        const { Patterns, RefPatterns } = Utils.Classes;\n\n        const patterns = Utils.ArrayParser(Patterns, RefPatterns);\n        const _regex_parser = (s)=>{\n            return Utils.RegexParse(s, 'd'); \n        };\n        const _capture_parser = (s, parser)=>{\n\n            let d = {}; \n            for(let i in s){\n                let m = new Patterns; \n                JSonParser._LoadData(parser, m, s[i]);  \n                d[i] = m; \n                parser.initialize(m); \n            } \n            return d;\n\n        }\n        const q = this;\n\n        const parse = {\n            patterns(n,parser, refKey, refObj){\n                let d = patterns.apply(q, [n,parser, refKey, refObj]);\n                d.forEach((s)=>{\n                    s.parent = q;\n                });\n                return d;\n            }, // update with parent\n            begin: _regex_parser,\n            end: _regex_parser,\n            match: _regex_parser,\n            replaceWith: _regex_parser,\n            replaceWithCondition(n , parser, ){\n                let m = new ReplaceWithCondition; \n                JSonParser._LoadData(parser, m, n, refObj);  \n                return m;\n            },\n            beginCaptures :_capture_parser,\n            endCaptures :_capture_parser,\n            captures :_capture_parser,\n            transform(n,parser){\n                if (typeof(n)=='string'){\n                    let t = []\n                    n.split(',').forEach((i)=>{\n                        i.trim();\n                        if (i.length>0)\n                            t.push(i);\n                    });\n                    return t;\n                }\n                if (Array.isArray(n)){\n                    return n;\n                }\n            }\n        };\n        let fc = parse[fieldname];\n        if (fc){\n            return fc.apply(q, [data, parser, refKey, refObj]);\n        }\n        return data;\n    }\n    json_validate(field_name, d, throw_on_error){\n        const validator = {\n            patterns(d){\n                return Array.isArray(d);\n            },\n            replaceWithCondition(d){\n                return typeof(d)=='object';\n            }\n        };\n        let f = validator[field_name];\n        if (f && !f(d)){\n            if (throw_on_error){\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    get matchType(){\n        if (this.begin){\n            return 0;\n        } else if (this.match){\n            return 1;\n        }\n        return -1;\n    }\n    check(l){\n        let p = null;\n        if (this.begin){\n            p = this.begin.exec(l);\n        } else if (this.match){\n            p = this.match.exec(l);\n        } else {\n            throw new Error(\"cannot check : \"+l);\n        }\n        return p;\n    }\n    \n    get matchRegex(){\n        return this.matchType == 0? this.begin : this.match;\n    }\n    get index(){\n        return this.m_match?.index;\n    }\n    get group(){\n        return this.m_match;\n    } \n  \n     \n    /**\n     * calculate end regex\n     * @param {*} p \n     * @returns \n     */\n    endRegex(p){\n        if (this.matchType==0){\n\n            let s = this.end.toString();\n            return Utils.GetRegexFrom(s, p); \n        }\n        return null;\n    }\n    get blockStart(){\n        const t = this.matchType;\n        if (!this.isBlock || (t!=0)){\n            return '';\n        }\n        return this.block?.start || this.begin.toString().trim();\n    }\n    get blockEnd(){\n        const t = this.matchType;\n        if (!this.isBlock || (t!=0)){\n            return '';\n        }\n        return this.block?.end || this.end.toString().trim();\n    }\n    toString(){\n        return `Patterns[#${this.name}]`;\n    }\n}\n\n\n \nexports.Patterns = Patterns;","Object.defineProperty(exports, '__esModule', {value:true});\n\nconst { Patterns } = require(\"./Patterns\");\n\nclass RefPatterns extends Patterns {\n    \n    /**\n     * reference pattern\n     * @param {Patterns} pattern \n     */\n    constructor(pattern){\n        super();\n        if (!pattern || !(pattern instanceof Patterns)){\n            throw new Error('pattern not a Pattern instance');\n        }\n        // + | init property ref keys \n        (function(q, pattern){\n            const _keys = Object.keys(q);\n            _keys.forEach(i => {\n                // let t = typeof (q[i]);\n                // if (/function|object/.test(t))\n                //     return;\n                let _i = Object.getOwnPropertyDescriptor(q, i);\n                if (!_i || (_i.get) || _i.writable) {\n                    // q[i] = pattern[i];\n                    Object.defineProperty(q, i, {get(){ return pattern[i]; }})\n                } \n            });\n        })(this, pattern);\n \n        Object.defineProperty(this, 'pattern', { get(){return pattern; }}); \n    }\n    check(l){\n        return this.pattern.check(l);\n    } \n    toString(){\n        return `RefPatterns[#${this.pattern.name}]`;\n    }   \n    endRegex(p){\n        return this.pattern.endRegex(p);\n    } \n}\nexports.RefPatterns = RefPatterns;","\"use strict\";\nObject.defineProperty(exports, '__esModule', {value:true});\n\n \nconst { Utils } = require(\"./Utils\");\n\n\nclass ReplaceWithCondition{\n    check;\n    operator = '=';\n    match;\n\n    constructor(){ \n    }\n\n    json_parse(parser, fieldname, data, refKey){\n        const _regex_parser = (s)=>{\n            return Utils.RegexParse(s); \n        };\n        return Utils.JSonParse(this, {\n            match: _regex_parser\n        }, parser, fieldname, data, refKey);\n    }\n    json_validate(field_name, d, throw_on_error){\n        let string_test = (v)=> typeof(v)=='string';\n        return Utils.JSonValidate(this, {\n            check:string_test,\n            operator:string_test,\n            operator:string_test,\n        },field_name, d, throw_on_error); \n    }\n\n}\n\nexports.ReplaceWithCondition = ReplaceWithCondition;","Object.defineProperty(exports, '__esModule', { value: true });\n\nconst { JSonParser } = require(\"./JSonParser\");\nconst { PatternMatchInfo } = require(\"./PatternMatchInfo\");\n\nclass Utils {\n    /**\n    * define and inject property \n    * @param {string} n namespace\n    * @param {undefined|*} v \n    * @param {*} globalname \n    * @returns \n    */\n   static FunctionDefineArg(n, v, globalname){\n       let c = 0;\n       let result = 0;\n       let s = '';\n       if (globalname){\n           s = '((w,p,q,n)=>{n=w; while((p.length>1) && (q = p.shift())){ n[q] = n[q] || {}; n = n[q];} n[p[0]] = v})('+globalname+\", \\\"\"+n+\"\\\".split('.'), v) || \";\n       } \n       n.split('.').forEach((i)=>{\n       if (!result){\n           result = i+'=((v)=>{ return '+s+'{'\n       }else{\n           if (c){\n               result+=\"{\"\n           }\n           result+= i+\":\";\n           c++;\n       }\n   });\n   v = typeof(v)=='undefined'? 'undefined': (typeof(v)=='object'? JSON.stringify(v):v) || '\"'+n+'\"';\n   result += v+ '}'.repeat(c)+\"})(\"+v+\")\";\n   \n   return result;\n   }\n    /**\n     * define property \n     * @param {string} n \n     * @param {undefined|*} v \n     * @param {object} global object definition \n     * @returns \n     */\n    static DefineProp(n, v, window){\n        return ((q, v, window)=>{ let r = null; let m = null; let _last = null; let _o = null;\n            v = (typeof(v)!=\"undefined\" ? v : n);\n            if (q.length==0) return v;\n            q.forEach(i=>{\n                if (r==null){\n                    // first object definition\n                    r = m = (window? window[i] : null) || {} ;\n                    if (window){\n                        window[i] = r;\n                    }\n                }\n                if (_last){\n                    _o = m;\n                    if ( typeof(m[i]) == 'string'){\n                        m[i] = {};\n                    }\n                    m[i] = m[i] || {};\n                    m = m[i]; \n                }\n                _last = i; \n            });\n            \n            if(_o) \n                _o[_last] = v;\n            else{\n                if (window){\n                    window[q[0]] = v;\n                }\n            }\n            return r;\n        })(n.split('.'),v, window);\n    }\n\n    /**\n     * \n     * @param {*} class_name \n     * @param {*} data \n     * @param {*} registry \n     * @returns \n     */\n    static JSonParseData(class_name, data, registry) {\n        let parser = new JSonParser;\n        parser.source = class_name;\n        parser.data = data;\n        parser.includes = {};\n        if (registry){\n            parser.registry = registry;\n        }\n        return Utils.LoadData(parser, new class_name(), data, null); //.parse();\n    }\n    static LoadData(parser, obj, data, refKey) {\n        return JSonParser._LoadData(parser, obj, data, refKey);\n    }\n    /**\n     * array parser callback\n     * @param {*} class_name \n     * @returns \n     */\n    static ArrayParser(class_name, refkey_class_name) {\n        if (!refkey_class_name || typeof(refkey_class_name)=='undefined'){\n            throw new Error('missing refkey_class_name');\n        }\n        /**\n         * \n         */\n        return function (d, parser, refKey, refObj) {\n            let _out = [];\n            let q = refObj || this; \n            d.forEach((a) => {\n                const { include } = a;\n                const _extends = a.extends;\n                let _o = null, _key = null, _def = null;\n                if (include) {\n                    if (include[0] == '#') {\n                        _key = include.substring(1);\n                        // if (_key in parser.includes){\n                        //     _o = new refkey_class_name(parser.includes[_key]);\n                        // }\n                        // else \n                        if (refKey && (refKey == _key) && refObj) {\n                            _o = new refkey_class_name(q);\n                        } else {\n                            _def = parser.data.repository[_key];\n                            if (_def) {\n                                _o = new class_name();\n                                parser.includes[_key] = _o; \n                                JSonParser._LoadData(parser, _o, _def, _key, refObj || _o);\n                                parser.initialize(_o);\n                            }\n                        }\n                    }\n                }\n                else if (_extends) {\n                    throw new Error(\"extends not support yet\");\n                }\n                else {\n                    _o = new class_name();\n                    JSonParser._LoadData(parser, _o, a, refKey, refObj || _o);\n                    parser.initialize(_o);\n                    \n                }\n                if (_o) {\n                    _out.push(_o);\n                }\n\n            });\n            return _out;\n        }\n    }\n\n    static GetPatternMatcher(patterns, options, parentMatcherInfo=null) {\n        const { line, pos, debug, depth } = options;\n        let _a = null;\n        let _match = 0;\n        let _index = -1;\n        let l = line.substring(pos);\n        const { RefPatterns } = require('./RefPatterns');\n\n        patterns.forEach((s) => {\n            let _ts = s;\n            // if (s instanceof RefPatterns) {\n            //     _ts = s.pattern;\n            // }\n\n            let p = _ts.check(l);\n            if (p && ((_index == -1) || (_index > p.index))) {\n                _index = p.index;\n                _a = s;\n                _match = p;\n            }\n        });\n        if (_a){\n            _match.index += pos;\n            //_a.startMatch(line, _match);\n            if (debug) {\n                console.log('matcher-begin: ', {\n                    '__name':_a.toString(),\n                    name: _a.name, line, pos:\n                        _match.index, depth,\n                    hasParent: _a.parent != null,\n                    isBlock: _a.isBlock,\n                    isRef: _a instanceof RefPatterns,\n                    value: _match[0],\n                    regex: _a.matchRegex  \n                });\n            } \n            // + | add property to offset \n            _match.offset = _match[0].length;\n            // +| treat begin captures must be at corresponding data info\n            //options.treatBeginCaptures(_a, _match); \n            let _info = new PatternMatchInfo; \n            _info.use({marker:_a, endRegex: _a.endRegex(_match), \n                line, \n                group:_match, \n                parent: parentMatcherInfo});\n            // _info.startLine = options.outputBuffer.line;\n            // _info.startLine = options.outputBuffer.range;\n            // init _info matcher\n\n            return _info;\n        }\n        return _a;\n    }\n    /**\n     * get regex from\n     * @param {string} s regext expression\n     * @param {*} p group\n     * @returns \n     */\n    static GetRegexFrom(s, p) {\n\n        s = s.replace(/[^\\\\]?\\$([\\d]+)/, (a, m) => {\n            if (a[0] == \"\\\\\") return a;\n            if (a[0] != '$')\n                return a[0] + p[m];\n            return p[m];\n        });\n        s = /^\\/.+\\/$/.test(s) ? s.substring(1).slice(0, -1) : s;\n        return new RegExp(s);\n    }\n\n\n    static ReplaceRegexGroup(s, group) {\n        let gp = Utils.GetRegexFrom(s, group);\n        gp = gp.toString().substring(1).slice(0, -1).replace(/\\\\\\//g, \"/\");\n        s = s.replace(s, gp);\n        return s;\n    }\n\n    /**\n     * \n     * @param {string} s regex string expression\n     */\n    static RegexInfo(s) {\n        let _option = /^\\(\\?(?<active>[ixm]+)(-(?<disable>[ixm]+))?\\)/;\n        let option = '';\n        let _potion = null;\n        if (_potion = _option.exec(s)) {\n            let sp = '';\n            if (_potion.groups) {\n                sp = _potion.groups.active ?? '';\n                if (_potion.groups.disable) {\n                    _potion.groups.disable.split().forEach(i => {\n                        sp = sp.replace(i, '');\n                    });\n                }\n            }\n            s = s.replace(_option, '');\n            option = sp;\n        }\n        return {\n            s,\n            option\n        };\n    }\n\n    static RegexParse(s, flag) {\n        if (typeof (s) == 'string') {\n            let _info = Utils.RegexInfo(s);\n            if (flag){\n                _info.option = flag;\n            }\n            return new RegExp(_info.s, _info.option);\n        } else if (typeof (s) == 'object') {\n            if (s instanceof RegExp)\n                return s;\n            const { option, regex } = s;\n            if (regex instanceof RegExp) {\n                regex = Utils.GetRegexFrom(regex.toString(), option);\n                return regex;\n            }\n            return new RegExp(regex, option);\n\n        }\n        return s;\n    }\n    static StringValueTransform(v, transform) {\n        const _func = {\n            joinSpace(s){ \n                s = s.replace(/\\s+/g, ' ');\n                return s;\n            },\n            upperCase(v) {\n                return v.toUpperCase();\n            },\n            lowerCase(v) {\n                return v.toLowerCase();\n            },\n            trim(v) {\n                return v.trim();\n            },\n            /**\n             * \n             * @param {string} v \n             * @returns \n             */\n            rtrim(v) {\n                return v.trimStart();\n            }\n            , /**\n            * \n            * @param {string} v \n            * @returns \n            */\n            ltrim(v) {\n                return v.trimEnd();\n            }\n        };\n        transform.forEach((s) => {\n            if (v.length==0){\n                return;\n            }\n            let _p = null;\n            if ( _p = /^:(?<symbol>=|^|#)(.)(?<number>\\d+)/.exec(s)){\n                //replacement value with pattern\n                let n = parseInt(_p.groups['number']);\n                let _s = _p.groups['symbol'];\n                if (n > v.length ){\n                    let _g = _p[2];\n                    if (_s=='#'){\n                        v = v.toString().padEnd(n, _g);\n                    } else if(_s=='^'){\n                        v = v.toString().padStart(n, _g); \n                    }\n                    else if(_s=='='){\n                        let c = Math.floor((n - v.length) / 2);\n                       \n                        v = v.toString().padEnd((c % 2)==0? n-c: n-c+1, _g);\n                        v = v.toString().padStart(n, _g); \n                    }\n                }\n                return v;\n            }\n\n            v = typeof (s) == 'function' ? s(v) : _func[s](v);\n        });\n        return v;\n    }\n    /**\n     * \n     * @param {*} q \n     * @param {*} validator \n     * @param {*} field_name \n     * @param {*} d \n     * @param {*} throw_on_error \n     * @returns \n     */\n    static JSonValidate(q, validator, field_name, d, throw_on_error){\n\n        let f = validator ? validator[field_name] : null;\n        if (f && !f(d)){\n            if (throw_on_error){\n                throw new Error(`[${field_name}] is not valid`);\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * \n     * @param {*} q \n     * @param {*} parse \n     * @param {*} parser \n     * @param {*} fieldname \n     * @param {*} data \n     * @param {*} refKey \n     * @returns \n     */\n    static JSonParse(q, parse, parser, fieldname, data, refKey){\n        let fc = parse ? parse[fieldname] : null;\n        if (fc){\n            return fc.apply(q, [data, parser, refKey]);\n        }\n        return data;\n    }\n}\nexports.Utils = Utils;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nconst { Formatters, Utils } = require(\"./lib/Formatters\");\n// + | ---------------------------------------\n// + | check parent function evaluation \n// + | ---------------------------------------\n\n  \n \n\n// let a ;\n// let b = null; //{ a:9, b:8};\n// let q = {...a, ...b};\n// function is_emptyObj(q){\n//     return Object.keys(q).length == 0\n// }\n\n// console.log(is_emptyObj(q));\n\n\n// return;\n\n// ---------------------------------------\n// check url detectetion\n// ---------------------------------------\n// let s = \"(?i)(((ftp|http(s)|[a-z]+)?:(\\\\/{,2}))|(\\\\.(\\\\.\\\\/|\\\\/)?)|\\\\s*)[^\\\\s\\\\/\\\\)]+(\\\\/|(\\\\/[^\\\\s\\\\/\\\\)]+)*)(\\\\/)?\";\n// let s = \"(?<path>(?:\\\\.(\\\\.\\\\/)?[^\\\\s\\\\/\\\\)\\\\)]+)|[^\\\\s\\\\/\\\\)\\\\)]+(\\\\/|(\\\\/[^\\\\s\\\\/\\\\)/\\\\(]+)+))\";\n// scheme detection \n// let s = \"(?<scheme>(?:ftp|http(?:s)|[a-z]+)):(?:\\\\/\\\\/|\\\\/|)(?<path>(?:\\\\/|\\\\.\\\\.(?:\\\\/)?|\\\\.(?:\\\\/)?)[^\\\\/\\\\)\\\\(]+(?:\\\\/|\\/[^\\\\/\\\\)\\\\()\\\\;]+))(?:;(?<queryo>[^\\\\?\\\\#]+))?(?:\\\\?(?<query>[^\\\\#]+))?(?:(?<anchor>#.+))?\"; \n// let rg = Utils.RegexParse(s);\n// console.log(rg);\n\n// console.log(\"1\", rg.exec(\"info\")); // not a valid uri\n// console.log(\"2\", rg.exec(\".info\")); //  \n// console.log(\"2\", rg.exec(\"..info\")); //  \n// console.log(\"2\", rg.exec(\"../info\")); // \n// console.log(\"3\", rg.exec(\"info/\")); / \n// console.log(\"3\", rg.exec(\"http://info/\")); // not a valid uri\n// console.log(\"3\", rg.exec(\"//info/\")); // not a valid uri\n// console.log(\"3\", rg.exec(\"..info/\")); // not a valid uri\n// console.log(\"3\", rg.exec(\"http://info/;info=2?sample=8#present\")); // not a valid uri\n// console.log(rg.exec(\".info\"));\n// console.log(rg.exec(\"./info\"));\n// console.log(rg.exec(\"../info\"));\n\n\n// return;\n// ---------------------------------------\n// test regex parse from string\n// ---------------------------------------\n// let _potion = null;\n// s = \"(?i)(((ftp|http(s)|[a-z]+)?:(\\\\/{,2}))|(\\\\.)|\\\\s*)[^\\\\s\\\\/\\\\)]+(\\\\/[^\\\\s\\\\/\\\\)]+)*(\\\\/)?\";\n// let l = Utils.RegexParse(s);\n// console.log(l);\n\n\n\n\n\n\n// let _option = /^\\(\\?(?<active>[ixm]+)(-(?<disable>[ixm]+))?\\)/;\n// if (_potion = _option.exec(s)){\n//     let sp = '';\n//     if(_potion.groups){\n//         sp = _potion.groups.active ?? '';\n//         if (_potion.groups.disable){\n//             _potion.groups.disable.split().forEach(i=>{\n//                 sp = sp.replace(i,'');\n//             });\n//         }\n//     }\n//     s = s.replace(_option, '');\n\n//     console.log(\"active option ... \", _potion, sp, s);\n// }\n\n// return;\n\n/*\nconst data = {\n    settings:{\n        tabStop:\"\\t\",\n        blockOnSingleLine:true\n    },\n    patterns:[ \n         { include : \"#string\"},\n         { include : \"#string-multiline\" },\n         { include : \"#end-instruct\"},\n         { include : \"#block\" }\n    ], \n    repository:{\n        block: {\n            begin:/\\{/,\n            end:/\\}/,\n            name:\"block.definition\",\n            isBlock : true,\n            comment: \"block comment information\",\n            block:{\n                start:\"{\",\n                end:\"}\"\n            },\n            patterns:[\n                { include : \"#string-multiline\" },\n                { include : \"#string\" }, \n                { include : \"#end-instruct\"},\n                { include : \"#block\" }, \n            ]\n        }, \n        string:{\n            begin: /(\"|')/,\n            end: /\\$1/,\n            name:\"string.definition\",\n            allowMultiline:false,\n            patterns:[\n                {\n                    match:/\\\\./\n                }\n            ]\n        },\n        \"end-instruct\":{\n            match:/;/,\n            name:'end.instruction',\n            lineFeed: true\n        },\n        \"string-multiline\":{\n            begin: /(`)/,\n            end: /\\$1/,\n            name:\"string.multiline.definition\", \n            preserveLineFeed:true,\n            patterns:[\n                {\n                    match:/\\\\./\n                }\n            ]\n        },\n\n    }\n}\n\n// let u = Utils.JSonParseData(Formatters, data);\n\nlet formatter = Formatters.CreateFrom(data);\n\n\n// console.log(u);\n// console.log(formatter);\n// console.log(JSON.stringify(u));\nconst _data = {\n    data1:[\n        \"line1 for 'string data'  - after\",\n        \"line2 for \\\"local data\\\" - after\"\n    ],\n    data2:[\n        \"\\\"line1 x\",\n        \"\\\"- x present 12 - ds\"\n    ],\n    data3:[ // escape string \n        \"exemple pour \\\"line1 \\\\\\\" x\\\" for you\", \n    ],\n    data4:[ // escape string \n    \"un\", \n    \"deux\",\n    \"\",\n    \"\",\n    \"trois\"\n    ],\n    data5:[\n        \"one 'is' the 'best' after all.\"\n    ],\n    data6:[\n        \" a + `multiline - \",\n        \"   \",\n        \"   o\",\n        \"\",\n        \"string` + 'preserve' \", \n    ],\n    data6:[\n        //\" a + `multiline` + 'preserve' \",  \n        \" a + `multi\",\n        \"line` + 'preserve' \",  \n    ],\n    data7:[\n        \"info() \",\n        \"{\",\n        \"x = 'data.'; pour le dire de la vie \",\n        \"doWhile(){\",\n        \"y\",\n        \"z = 32;\",\n        \"}\",\n        \"}\"\n    ],\n    data8:[\n        \"x='data' + x ; P\"\n    ],\n    data9:[\n        \"{; x='uri' + x;P(){ y = 4}}\"\n    ],\n    multispace_transform:[\n        \"bonjour     tout le  monde\" //{; x='uri' + x;P(){ y = 4}}\"\n    ],\n    read_empty:{\n        data:[\n        \"{     }\"\n    ], expected:[\n        \"{}\"\n    ]\n    },\n    read_block:{\n        data:[\n        \"{ var x }\"\n    ], expected:[\n        \"{\",\n        \"\\tvar x\",\n        \"}\"\n    ]},\n    read_block_after_line:{\n        data:[\n        \"{ var x \",\n        \"}\"\n    ], expected:[\n        \"{\",\n        \"\\tvar x\",\n        \"}\"\n    ]\n    },\n    function_block:{\n        data:[\n        \"doSomething(){ var x \",\n        \"}\"\n    ], expected:[\n        \"doSomething(){\",\n        \"\\tvar x\",\n        \"}\"\n    ]\n    },\n    function_block_2:{\n        data:[\n        \"doSomething(){    var x \",\n        \"   var y\",\n        \"}\"\n    ], expected:[\n        \"doSomething(){\",\n        \"\\tvar x\",\n        \"\\tvar y\",\n        \"}\"\n    ]\n    },\n    segment:{\n        data:[\n        \"doSomething(){    var x =   32    ;}\",  \n    ], expected:[\n        \"doSomething(){\",\n        \"\\tvar x = 32;\", \n        \"}\"\n    ]\n    },\n    segment_2:{\n        data:[\n        \"doSomething(){    var x =   32    ; var y; var z=4;}\",  \n    ], expected:[\n        \"doSomething(){\",\n        \"\\tvar x = 32;\", \n        \"\\tvar y;\", \n        \"\\tvar z=4;\", \n        \"}\"\n    ]\n    },\n    subfunc_block:{\n        data:[\n            \"A(){    var x =   32    ; B{ var y } }\",  \n        ], expected:[\n            \"A(){\",\n            \"\\tvar x = 32;\", \n            \"\\tB{\",\n            \"\\t\\tvar y\",\n            \"\\t}\",  \n            \"}\"\n        ]\n    },\n    litteral:{\n        data:[\n            \"A(){   'litteral {} start' }\",  \n        ], expected:[\n            \"A(){\",\n            \"\\t'litteral {} start'\",  \n            \"}\"\n        ]\n    }\n}\nfunction expect(data, formatter){\n    let r = formatter.format(data.data);\n    let s = data.expected.join(\"\\n\"); \n    if (r == s){\n        return true;\n    }\n    console.log(\"result :\",r);\n    console.log(r);\n\n    let idx = 0; \n    r.split('\\n').forEach((l)=>{\n        let g = data.expected[idx];\n        if (l== g){\n            console.log(l);\n        }else{\n            console.log(\"--\"+l);\n            console.log(\"++\"+g);\n        }\n        idx++;\n    });\n    return false;\n\n}\nformatter.debug = false;\n[\n    'read_empty', \n    'read_block',\n    'read_block_after_line',\n    'function_block',\n    'function_block_2',\n    'segment',\n    'segment_2',\n    'subfunc_block',\n    'litteral'\n].forEach((f)=>{\n\n    // if (!expect(_data[f], formatter)){\n    //     throw new Error(\"format failed. [\"+f+\"]\");\n    // }\n});\n\n\n// let r = formatter.format(_data.multispace_transform); \n// console.log(\"result:\");\n// console.log(r);\n\n*/\n// let rgx =  /(?:lala)(pr(in))(base)(?=info)/;\n// let rgx =  /(?:info)/;\n// let e = rgx.exec('jump lalaprinbaseinfo');\n\n// capture : \n// (?:subexp) - capture in global capture result - not capture group\n// (?<=subexp) - look behind - not in global capture - not capture group\n// (?=subexp) - look ahead - not in global capture - not capture group\n// console.log(e);\nfunction removeCapture(str){\n    let l = str;\n    let p = 0;\n    function rm_brank(l, index, start='(', end=')'){\n        let i = 1;\n        let ln = l.length;\n        const start_index = index;\n        while((i < ln) && (i>0)){\n\n            ch = l[index+1];\n            if (ch==start){\n                i++;\n            } else if (ch ==end){\n                i--;\n            }\n            index++;\n        }\n        return l.substring(0, start_index)+l.substring(index+1);\n    }\n    let capture = false;\n    while( p = /\\(\\?(:|(\\<)?=)./.exec(l)){\n        l = rm_brank(l, p.index);\n        capture= true;\n    }\n    return capture ? l : null;\n}\n// let p = removeCapture(rgx.toString()); // .replace(/\\(\\?(:|=|>)./g, '');\n// if (p){\n//     \n// p = p.substring(1).slice(0,-1);\n// let _regp = new RegExp(p);\n// let _gp = _regp.exec(e[0]); \n// // let captureStart = e.index+_gp.index;\n// // let captureLength = _gp[0].length;\n// _gp.index += e.index;\n// _gp.input = e.input;\n// // let captureInfo = {\n// //     captureStart,\n// //     captureLength,\n// //     group: _gp\n// // };\n// console.log(_gp);\n// }\n// var entireLength = e.reduce(function (acc, match) {\n//     return acc + (match ? match.length : 0);\n// }, 0);\n// console.log(e);\n// console.log(\"length\");\n// console.log(entireLength);\n// return;\n\nconst json_data = require(\"../data/html.btm-format.json\");\nconst _formatter = Formatters.CreateFrom(json_data);\nlet lines = [];\n// _formatter.listener = ()=> ({\n//     treatBuffer:{\n//         /**\n//          * call before append to the buffer \n//          * @param {*} buffer \n//          * @param {*} value \n//          * @param {*} otion option setting \n//          * @param {*} _marker \n//          * @returns \n//          */\n//         append( buffer, value, _marker, option){\n//             // dependending on  _marker. add some value\n//             const {lineFeed, startLine, lineJoin, tabStop } = option;\n//             console.log(\"treate value : -------------------------------------\");\n\n//             // if (_marker && /^html\\./.test(_marker.name)){\n//             //     value = 'HTML:'+value;\n//             // } \n//             // value = value.replace(/[\\\\<\\\\>]/g, '');\n\n//             return option.joinBuffer(buffer, value); \n//         }\n//     },\n//     append(s){\n//         // append - just output to buffer data\n//         console.log('output : ', s);\n//         lines.push(s);\n        \n//     },\n//     store({output, buffer}){\n//         let option = this.objClass;;\n//         if (buffer.length>0){\n//             output.push(buffer);\n//         }  \n//     },\n//     output(){\n//         console.log(\"ask for output result .... \");\n\n//     }\n// });\n_formatter.debug = true; \nlet tests = [\n    { s: ['info'], e:'info'},\n    { s: ['\"string test info\" pour tout le   monde'], e:'\"string test info\" pour tout le monde'}, \n    { s: ['pour dire \"the main : bondje test info\"'], e:'pour dire \"the main : BONDJE test info\"'}, \n    { s: ['par   devant'], e:'par devant'}, \n    { s: ['par   devant'], e:'par devant'}, \n    { s: ['<div /><div />'], e:'<div></div><div></div>'}, \n    { s: ['<div/>    <div />     <input />'], e:'<div></div><div></div><input></input>'}, \n    { s: ['<div/>', '<div />', '<div />'], e:'<div></div><div></div><div></div>'}, \n    { s: ['<div id = \"data\"     />'], e:'<div id=\"data\"></div>'}, \n];\n\n\n\n{/* <!DOCTYPE html><?xml blabla ?>\n<data \n\nx   =  \n    \"Present\">\n    presentation\n</data   \n>\n<empty />\n<!-- comment \nfor sample \n-->*/}\n \n\n\n// runTest(tests, _formatter);\n\nconst testdata = require('./../tests/source.data.json');\n\nrunTest(testdata.tests, _formatter);\n\n\nfunction runTest(tests, _formatter){\n    let testCount = 0;\n\n    tests.forEach(o=>{\n        let s = _formatter.format(\n            o.s\n            );\n            let e = o.e;\n            if (Array.isArray(o.e)){\n                e = e.join(\"\\n\");\n            }\n\n            if (s==e){\n                testCount++;\n                return;\n        } \n\n        compareString(s, o.e);\n        throw new Error(\"failed : \"+testCount);\n    });\n}\n\nfunction compareString(r, o){\n    let idx = 0; \n    let data = typeof(o)=='string' ?  o.split(\"\\n\") : o;\n    console.log(' ++++ = expected');\n    console.log(' ---- = return');\n    console.log(\"\\n-result\");\n    console.log(r);\n    console.log(\"\\n-compare\");\n    r.split('\\n').forEach((l)=>{\n        let g = idx in data ? data[idx]: '';\n        if (l== g){\n            console.log(l);\n        }else{ \n            console.log(\"++++ |\"+((g+'').length.toString().padStart(10, ' '))+\" |\"+g);\n            console.log(\"---- |\"+((l+'').length.toString().padStart(10, ' '))+\" |\"+l); \n        }\n        idx++;\n    });\n    if (idx<data.length){\n        data.slice(idx).forEach(l=>{\n            console.log('++++ ' + l);\n        });\n    }\n}\n \n "],"names":["Object","defineProperty","exports","value","Debug","static","IsEnabled","log","msg","level","LogLevel","JSON","stringify","k","v","length","args","arguments","i","push","console","Enable","enable","Patterns","Utils","FormatterListener","objClass","treatBuffer","constructor","m_lastToken","this","get","setLastMarker","token","startNewBlock","marker","o","d","depth","output","tabStop","repeat","treatEndBufferCapture","_marker","p","endRegex","buffer","endCaptures","_def","nextTrimWhiteSpace","trimEnd","treatEndCapture","treatBeginCapture","treatValue","s","endCapture","_last","lastMarker","replaceWith","match","gp","GetRegexFrom","toString","group","substring","slice","replace","tokenID","append","_o","debug","name","isBlockDefinition","blockOnSingleLine","store","lineFeed","_trx","RegExp","trim","lineJoin","noSpaceJoin","appendAndStore","startBlock","unshift","_tab","clear","_s","join","appendLine","treat","FormatterSetting","line","useCurrentFormatterInstance","RefPatterns","JSonParser","PatternMatchInfo","Classes","Formatters","patterns","repository","scopeName","settings","m_listener","m_objClass","m_errors","m_info","isSubFormatting","captureGroup","set","pushError","e","_storeObjClass","m_option","json_keys","n","tab","keys","idx","indexOf","json_validate","field_name","throw_on_error","validator","Array","isArray","test","f","Error","json_parse","parser","fieldname","data","refKey","parse","ArrayParser","_out","registry","_LoadData","initialize","repositoryKey","fc","CreateFrom","_names","_registryExpression","formatter","JSonParseData","m","registerName","_funcRegistryExpression","_entry","DefineProp","undefined","split","namespaces","CreateDefaultOption","listener","option","_rg","_markerInfo","_states","_formatter","_info","m_pos","_outputBufferInfo","start","end","updateLine","lineCount","updateRange","m_constants_def","PrevLineFeedConstant","PrevLineFeedConstantPattern","PrevConstant","PrevConstantPattern","GlobalConstant","GlobalConstantPattern","pos","continue","lineFeedFlag","state","range","resetRange","storeRange","empty","l","is_emptyObj","q","pushState","_keys","_state","forEach","t","_i","getOwnPropertyDescriptor","popState","shift","unshiftMarker","shiftMarker","updateBufferValue","_g","parent","_operationReplaceWith","transform","StringValueTransform","joinBuffer","trimStart","appendToBuffer","_buffer","treatBeginCaptures","matches","_cap","captures","beginCaptures","treatCaptures","treatEndCaptures","endMatch","list","markers","prop","_bckCapture","info","DoReplaceWith","NameOnlyConstantPattern","isClosingBlock","_bck","markerInfo","format","a","ReplaceRegexGroup","moveTo","newPosition","_ctx","apply","flush","_matcherInfo","allowMultiline","startLine","_handleMarker","ln","GetPatternMatcher","index","constants","_restoreBuffer","isBlock","content","Math","max","blockEnd","_output","_isBlockAndStart","_startNewBlock","replace_with","g","_rp","_prev","handle","_handleCallback","matchType","_rpw","_cond","replaceWithCondition","_op","operator","check","r","_ex","type","handleBeginEndMarker","_handleBeginEndMarker2","handleMatchMarker","_handleMatchMarker","c","_p_host","_updateMarkerChild","patternInfo","_endRegex","_start","_line","_matcher","_old","_p","_updateOldMarker","_next_position","offset","_continue_with_marker","exec","_updateMarkerInfoOld","_handleSameGroup2","_handleFoundEndPattern","__name","hasParent","regex","_close_block","oldBlockStart","_b","_append","_sblock","_updateParentProps","_requestParentBlock","_isEmptyRequestBlock","childs","condition","requestParentBlockCondition","entryBuffer","_block_marker","_cbuffer","_tbuffer","v_marker_info","v_parent","updateParentProps","v_request","autoStartChildBlock","expression","Function","child","error","_backupMarkerSwapBuffer","_inf","_content","_sbuffer","_lf","preserveLineFeed","_getMatchList","_renderMatchList","_list","SpecialMeaningPatternBase","isSpecial","SystemConstantPattern","source","throwOnError","current","m_current","obj","_refObj","_throwOnError","validation","json_parsing","_r","m_parent","m_marker","m_endRegex","m_group","m_line","m_isBlock","m_lineFeed","use","pattern","_keys_t","writable","ReplaceWithCondition","begin","contentName","comment","emptyBlockCondition","block","transformToken","refObj","_regex_parser","RegexParse","_capture_parser","matchRegex","m_match","blockStart","super","JSonParse","string_test","JSonValidate","FunctionDefineArg","globalname","result","window","class_name","includes","LoadData","refkey_class_name","include","_extends","extends","_key","options","parentMatcherInfo","_a","_match","_index","isRef","RegexInfo","_option","_potion","sp","groups","active","disable","flag","_func","joinSpace","upperCase","toUpperCase","lowerCase","toLowerCase","rtrim","ltrim","parseInt","padEnd","padStart","floor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","json_data","tests","testCount","compareString","runTest"],"sourceRoot":""}